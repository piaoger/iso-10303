# ! [doc = r" This file is generated. Do not edit."] # ! [allow (dead_code)] use iso_10303 :: step :: * ; use std :: collections :: HashSet ; # [derive (Default , Debug)] pub struct Unimplemented { } impl From < Parameter > for Unimplemented { fn from (_parameter : Parameter) -> Self { Unimplemented { } } } type IfcStrippedOptional = bool ; type IfcAbsorbedDoseMeasure = Real ; type IfcAccelerationMeasure = Real ; type IfcAmountOfSubstanceMeasure = Real ; type IfcAngularVelocityMeasure = Real ; type IfcArcIndex = Vec < IfcPositiveInteger > ; type IfcAreaDensityMeasure = Real ; type IfcAreaMeasure = Real ; type IfcBinary = Unimplemented ; type IfcBoolean = bool ; type IfcBoxAlignment = IfcLabel ; type IfcCardinalPointReference = i64 ; type IfcComplexNumber = Vec < Real > ; type IfcCompoundPlaneAngleMeasure = Vec < i64 > ; type IfcContextDependentMeasure = Real ; type IfcCountMeasure = Real ; type IfcCurvatureMeasure = Real ; type IfcDate = String ; type IfcDateTime = String ; type IfcDayInMonthNumber = i64 ; type IfcDayInWeekNumber = i64 ; type IfcDescriptiveMeasure = String ; type IfcDimensionCount = i64 ; type IfcDoseEquivalentMeasure = Real ; type IfcDuration = String ; type IfcDynamicViscosityMeasure = Real ; type IfcElectricCapacitanceMeasure = Real ; type IfcElectricChargeMeasure = Real ; type IfcElectricConductanceMeasure = Real ; type IfcElectricCurrentMeasure = Real ; type IfcElectricResistanceMeasure = Real ; type IfcElectricVoltageMeasure = Real ; type IfcEnergyMeasure = Real ; type IfcFontStyle = String ; type IfcFontVariant = String ; type IfcFontWeight = String ; type IfcForceMeasure = Real ; type IfcFrequencyMeasure = Real ; type IfcGloballyUniqueId = String ; type IfcHeatFluxDensityMeasure = Real ; type IfcHeatingValueMeasure = Real ; type IfcIdentifier = String ; type IfcIlluminanceMeasure = Real ; type IfcInductanceMeasure = Real ; type IfcInteger = i64 ; type IfcIntegerCountRateMeasure = i64 ; type IfcIonConcentrationMeasure = Real ; type IfcIsothermalMoistureCapacityMeasure = Real ; type IfcKinematicViscosityMeasure = Real ; type IfcLabel = String ; type IfcLanguageId = IfcIdentifier ; type IfcLengthMeasure = Real ; type IfcLineIndex = Vec < IfcPositiveInteger > ; type IfcLinearForceMeasure = Real ; type IfcLinearMomentMeasure = Real ; type IfcLinearStiffnessMeasure = Real ; type IfcLinearVelocityMeasure = Real ; type IfcLogical = Option < bool > ; type IfcLuminousFluxMeasure = Real ; type IfcLuminousIntensityDistributionMeasure = Real ; type IfcLuminousIntensityMeasure = Real ; type IfcMagneticFluxDensityMeasure = Real ; type IfcMagneticFluxMeasure = Real ; type IfcMassDensityMeasure = Real ; type IfcMassFlowRateMeasure = Real ; type IfcMassMeasure = Real ; type IfcMassPerLengthMeasure = Real ; type IfcModulusOfElasticityMeasure = Real ; type IfcModulusOfLinearSubgradeReactionMeasure = Real ; type IfcModulusOfRotationalSubgradeReactionMeasure = Real ; type IfcModulusOfSubgradeReactionMeasure = Real ; type IfcMoistureDiffusivityMeasure = Real ; type IfcMolecularWeightMeasure = Real ; type IfcMomentOfInertiaMeasure = Real ; type IfcMonetaryMeasure = Real ; type IfcMonthInYearNumber = i64 ; type IfcNonNegativeLengthMeasure = IfcLengthMeasure ; type IfcNormalisedRatioMeasure = IfcRatioMeasure ; type IfcNumericMeasure = Real ; type IfcPhMeasure = Real ; type IfcParameterValue = Real ; type IfcPlanarForceMeasure = Real ; type IfcPlaneAngleMeasure = Real ; type IfcPositiveInteger = IfcInteger ; type IfcPositiveLengthMeasure = IfcLengthMeasure ; type IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure ; type IfcPositiveRatioMeasure = IfcRatioMeasure ; type IfcPowerMeasure = Real ; type IfcPresentableText = String ; type IfcPressureMeasure = Real ; type IfcPropertySetDefinitionSet = HashSet < EntityRef < IfcPropertySetDefinition > > ; type IfcRadioActivityMeasure = Real ; type IfcRatioMeasure = Real ; type IfcReal = Real ; type IfcRotationalFrequencyMeasure = Real ; type IfcRotationalMassMeasure = Real ; type IfcRotationalStiffnessMeasure = Real ; type IfcSectionModulusMeasure = Real ; type IfcSectionalAreaIntegralMeasure = Real ; type IfcShearModulusMeasure = Real ; type IfcSolidAngleMeasure = Real ; type IfcSoundPowerLevelMeasure = Real ; type IfcSoundPowerMeasure = Real ; type IfcSoundPressureLevelMeasure = Real ; type IfcSoundPressureMeasure = Real ; type IfcSpecificHeatCapacityMeasure = Real ; type IfcSpecularExponent = Real ; type IfcSpecularRoughness = Real ; type IfcTemperatureGradientMeasure = Real ; type IfcTemperatureRateOfChangeMeasure = Real ; type IfcText = String ; type IfcTextAlignment = String ; type IfcTextDecoration = String ; type IfcTextFontName = String ; type IfcTextTransformation = String ; type IfcThermalAdmittanceMeasure = Real ; type IfcThermalConductivityMeasure = Real ; type IfcThermalExpansionCoefficientMeasure = Real ; type IfcThermalResistanceMeasure = Real ; type IfcThermalTransmittanceMeasure = Real ; type IfcThermodynamicTemperatureMeasure = Real ; type IfcTime = String ; type IfcTimeMeasure = Real ; type IfcTimeStamp = i64 ; type IfcTorqueMeasure = Real ; type IfcUriReference = String ; type IfcVaporPermeabilityMeasure = Real ; type IfcVolumeMeasure = Real ; type IfcVolumetricFlowRateMeasure = Real ; type IfcWarpingConstantMeasure = Real ; type IfcWarpingMomentMeasure = Real ; # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcActionRequestTypeEnum { Email , Fax , Phone , Post , Verbal , Userdefined , Notdefined , } impl Default for IfcActionRequestTypeEnum { fn default () -> Self { IfcActionRequestTypeEnum :: Email } } impl From < String > for IfcActionRequestTypeEnum { fn from (value : String) -> Self { match value . as_str () { "EMAIL" => IfcActionRequestTypeEnum :: Email , "FAX" => IfcActionRequestTypeEnum :: Fax , "PHONE" => IfcActionRequestTypeEnum :: Phone , "POST" => IfcActionRequestTypeEnum :: Post , "VERBAL" => IfcActionRequestTypeEnum :: Verbal , "USERDEFINED" => IfcActionRequestTypeEnum :: Userdefined , "NOTDEFINED" => IfcActionRequestTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcActionRequestTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcActionRequestTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcActionRequestTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcActionSourceTypeEnum { DeadLoadG , CompletionG1 , LiveLoadQ , SnowS , WindW , PrestressingP , SettlementU , TemperatureT , EarthquakeE , Fire , Impulse , Impact , Transport , Erection , Propping , SystemImperfection , Shrinkage , Creep , LackOfFit , Buoyancy , Ice , Current , Wave , Rain , Brakes , Userdefined , Notdefined , } impl Default for IfcActionSourceTypeEnum { fn default () -> Self { IfcActionSourceTypeEnum :: DeadLoadG } } impl From < String > for IfcActionSourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DEAD_LOAD_G" => IfcActionSourceTypeEnum :: DeadLoadG , "COMPLETION_G1" => IfcActionSourceTypeEnum :: CompletionG1 , "LIVE_LOAD_Q" => IfcActionSourceTypeEnum :: LiveLoadQ , "SNOW_S" => IfcActionSourceTypeEnum :: SnowS , "WIND_W" => IfcActionSourceTypeEnum :: WindW , "PRESTRESSING_P" => IfcActionSourceTypeEnum :: PrestressingP , "SETTLEMENT_U" => IfcActionSourceTypeEnum :: SettlementU , "TEMPERATURE_T" => IfcActionSourceTypeEnum :: TemperatureT , "EARTHQUAKE_E" => IfcActionSourceTypeEnum :: EarthquakeE , "FIRE" => IfcActionSourceTypeEnum :: Fire , "IMPULSE" => IfcActionSourceTypeEnum :: Impulse , "IMPACT" => IfcActionSourceTypeEnum :: Impact , "TRANSPORT" => IfcActionSourceTypeEnum :: Transport , "ERECTION" => IfcActionSourceTypeEnum :: Erection , "PROPPING" => IfcActionSourceTypeEnum :: Propping , "SYSTEM_IMPERFECTION" => IfcActionSourceTypeEnum :: SystemImperfection , "SHRINKAGE" => IfcActionSourceTypeEnum :: Shrinkage , "CREEP" => IfcActionSourceTypeEnum :: Creep , "LACK_OF_FIT" => IfcActionSourceTypeEnum :: LackOfFit , "BUOYANCY" => IfcActionSourceTypeEnum :: Buoyancy , "ICE" => IfcActionSourceTypeEnum :: Ice , "CURRENT" => IfcActionSourceTypeEnum :: Current , "WAVE" => IfcActionSourceTypeEnum :: Wave , "RAIN" => IfcActionSourceTypeEnum :: Rain , "BRAKES" => IfcActionSourceTypeEnum :: Brakes , "USERDEFINED" => IfcActionSourceTypeEnum :: Userdefined , "NOTDEFINED" => IfcActionSourceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcActionSourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcActionSourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcActionSourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcActionTypeEnum { PermanentG , VariableQ , ExtraordinaryA , Userdefined , Notdefined , } impl Default for IfcActionTypeEnum { fn default () -> Self { IfcActionTypeEnum :: PermanentG } } impl From < String > for IfcActionTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PERMANENT_G" => IfcActionTypeEnum :: PermanentG , "VARIABLE_Q" => IfcActionTypeEnum :: VariableQ , "EXTRAORDINARY_A" => IfcActionTypeEnum :: ExtraordinaryA , "USERDEFINED" => IfcActionTypeEnum :: Userdefined , "NOTDEFINED" => IfcActionTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcActionTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcActionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcActionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcActuatorTypeEnum { Electricactuator , Handoperatedactuator , Hydraulicactuator , Pneumaticactuator , Thermostaticactuator , Userdefined , Notdefined , } impl Default for IfcActuatorTypeEnum { fn default () -> Self { IfcActuatorTypeEnum :: Electricactuator } } impl From < String > for IfcActuatorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ELECTRICACTUATOR" => IfcActuatorTypeEnum :: Electricactuator , "HANDOPERATEDACTUATOR" => IfcActuatorTypeEnum :: Handoperatedactuator , "HYDRAULICACTUATOR" => IfcActuatorTypeEnum :: Hydraulicactuator , "PNEUMATICACTUATOR" => IfcActuatorTypeEnum :: Pneumaticactuator , "THERMOSTATICACTUATOR" => IfcActuatorTypeEnum :: Thermostaticactuator , "USERDEFINED" => IfcActuatorTypeEnum :: Userdefined , "NOTDEFINED" => IfcActuatorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcActuatorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcActuatorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcActuatorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAddressTypeEnum { Office , Site , Home , Distributionpoint , Userdefined , } impl Default for IfcAddressTypeEnum { fn default () -> Self { IfcAddressTypeEnum :: Office } } impl From < String > for IfcAddressTypeEnum { fn from (value : String) -> Self { match value . as_str () { "OFFICE" => IfcAddressTypeEnum :: Office , "SITE" => IfcAddressTypeEnum :: Site , "HOME" => IfcAddressTypeEnum :: Home , "DISTRIBUTIONPOINT" => IfcAddressTypeEnum :: Distributionpoint , "USERDEFINED" => IfcAddressTypeEnum :: Userdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAddressTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAddressTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAddressTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAirTerminalBoxTypeEnum { Constantflow , Variableflowpressuredependant , Variableflowpressureindependant , Userdefined , Notdefined , } impl Default for IfcAirTerminalBoxTypeEnum { fn default () -> Self { IfcAirTerminalBoxTypeEnum :: Constantflow } } impl From < String > for IfcAirTerminalBoxTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONSTANTFLOW" => IfcAirTerminalBoxTypeEnum :: Constantflow , "VARIABLEFLOWPRESSUREDEPENDANT" => IfcAirTerminalBoxTypeEnum :: Variableflowpressuredependant , "VARIABLEFLOWPRESSUREINDEPENDANT" => IfcAirTerminalBoxTypeEnum :: Variableflowpressureindependant , "USERDEFINED" => IfcAirTerminalBoxTypeEnum :: Userdefined , "NOTDEFINED" => IfcAirTerminalBoxTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAirTerminalBoxTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAirTerminalBoxTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAirTerminalBoxTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAirTerminalTypeEnum { Diffuser , Grille , Louvre , Register , Userdefined , Notdefined , } impl Default for IfcAirTerminalTypeEnum { fn default () -> Self { IfcAirTerminalTypeEnum :: Diffuser } } impl From < String > for IfcAirTerminalTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DIFFUSER" => IfcAirTerminalTypeEnum :: Diffuser , "GRILLE" => IfcAirTerminalTypeEnum :: Grille , "LOUVRE" => IfcAirTerminalTypeEnum :: Louvre , "REGISTER" => IfcAirTerminalTypeEnum :: Register , "USERDEFINED" => IfcAirTerminalTypeEnum :: Userdefined , "NOTDEFINED" => IfcAirTerminalTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAirTerminalTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAirTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAirTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAirToAirHeatRecoveryTypeEnum { Fixedplatecounterflowexchanger , Fixedplatecrossflowexchanger , Fixedplateparallelflowexchanger , Rotarywheel , Runaroundcoilloop , Heatpipe , Twintowerenthalpyrecoveryloops , Thermosiphonsealedtubeheatexchangers , Thermosiphoncoiltypeheatexchangers , Userdefined , Notdefined , } impl Default for IfcAirToAirHeatRecoveryTypeEnum { fn default () -> Self { IfcAirToAirHeatRecoveryTypeEnum :: Fixedplatecounterflowexchanger } } impl From < String > for IfcAirToAirHeatRecoveryTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FIXEDPLATECOUNTERFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum :: Fixedplatecounterflowexchanger , "FIXEDPLATECROSSFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum :: Fixedplatecrossflowexchanger , "FIXEDPLATEPARALLELFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum :: Fixedplateparallelflowexchanger , "ROTARYWHEEL" => IfcAirToAirHeatRecoveryTypeEnum :: Rotarywheel , "RUNAROUNDCOILLOOP" => IfcAirToAirHeatRecoveryTypeEnum :: Runaroundcoilloop , "HEATPIPE" => IfcAirToAirHeatRecoveryTypeEnum :: Heatpipe , "TWINTOWERENTHALPYRECOVERYLOOPS" => IfcAirToAirHeatRecoveryTypeEnum :: Twintowerenthalpyrecoveryloops , "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS" => IfcAirToAirHeatRecoveryTypeEnum :: Thermosiphonsealedtubeheatexchangers , "THERMOSIPHONCOILTYPEHEATEXCHANGERS" => IfcAirToAirHeatRecoveryTypeEnum :: Thermosiphoncoiltypeheatexchangers , "USERDEFINED" => IfcAirToAirHeatRecoveryTypeEnum :: Userdefined , "NOTDEFINED" => IfcAirToAirHeatRecoveryTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAirToAirHeatRecoveryTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAirToAirHeatRecoveryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAirToAirHeatRecoveryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAlarmTypeEnum { Bell , Breakglassbutton , Light , Manualpullbox , Siren , Whistle , Userdefined , Notdefined , } impl Default for IfcAlarmTypeEnum { fn default () -> Self { IfcAlarmTypeEnum :: Bell } } impl From < String > for IfcAlarmTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BELL" => IfcAlarmTypeEnum :: Bell , "BREAKGLASSBUTTON" => IfcAlarmTypeEnum :: Breakglassbutton , "LIGHT" => IfcAlarmTypeEnum :: Light , "MANUALPULLBOX" => IfcAlarmTypeEnum :: Manualpullbox , "SIREN" => IfcAlarmTypeEnum :: Siren , "WHISTLE" => IfcAlarmTypeEnum :: Whistle , "USERDEFINED" => IfcAlarmTypeEnum :: Userdefined , "NOTDEFINED" => IfcAlarmTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAlarmTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAlarmTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAlarmTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAnalysisModelTypeEnum { InPlaneLoading2d , OutPlaneLoading2d , Loading3d , Userdefined , Notdefined , } impl Default for IfcAnalysisModelTypeEnum { fn default () -> Self { IfcAnalysisModelTypeEnum :: InPlaneLoading2d } } impl From < String > for IfcAnalysisModelTypeEnum { fn from (value : String) -> Self { match value . as_str () { "IN_PLANE_LOADING_2D" => IfcAnalysisModelTypeEnum :: InPlaneLoading2d , "OUT_PLANE_LOADING_2D" => IfcAnalysisModelTypeEnum :: OutPlaneLoading2d , "LOADING_3D" => IfcAnalysisModelTypeEnum :: Loading3d , "USERDEFINED" => IfcAnalysisModelTypeEnum :: Userdefined , "NOTDEFINED" => IfcAnalysisModelTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAnalysisModelTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAnalysisModelTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAnalysisModelTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAnalysisTheoryTypeEnum { FirstOrderTheory , SecondOrderTheory , ThirdOrderTheory , FullNonlinearTheory , Userdefined , Notdefined , } impl Default for IfcAnalysisTheoryTypeEnum { fn default () -> Self { IfcAnalysisTheoryTypeEnum :: FirstOrderTheory } } impl From < String > for IfcAnalysisTheoryTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FIRST_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum :: FirstOrderTheory , "SECOND_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum :: SecondOrderTheory , "THIRD_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum :: ThirdOrderTheory , "FULL_NONLINEAR_THEORY" => IfcAnalysisTheoryTypeEnum :: FullNonlinearTheory , "USERDEFINED" => IfcAnalysisTheoryTypeEnum :: Userdefined , "NOTDEFINED" => IfcAnalysisTheoryTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAnalysisTheoryTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAnalysisTheoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAnalysisTheoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcArithmeticOperatorEnum { Add , Divide , Multiply , Subtract , } impl Default for IfcArithmeticOperatorEnum { fn default () -> Self { IfcArithmeticOperatorEnum :: Add } } impl From < String > for IfcArithmeticOperatorEnum { fn from (value : String) -> Self { match value . as_str () { "ADD" => IfcArithmeticOperatorEnum :: Add , "DIVIDE" => IfcArithmeticOperatorEnum :: Divide , "MULTIPLY" => IfcArithmeticOperatorEnum :: Multiply , "SUBTRACT" => IfcArithmeticOperatorEnum :: Subtract , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcArithmeticOperatorEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcArithmeticOperatorEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcArithmeticOperatorEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAssemblyPlaceEnum { Site , Factory , Notdefined , } impl Default for IfcAssemblyPlaceEnum { fn default () -> Self { IfcAssemblyPlaceEnum :: Site } } impl From < String > for IfcAssemblyPlaceEnum { fn from (value : String) -> Self { match value . as_str () { "SITE" => IfcAssemblyPlaceEnum :: Site , "FACTORY" => IfcAssemblyPlaceEnum :: Factory , "NOTDEFINED" => IfcAssemblyPlaceEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAssemblyPlaceEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAssemblyPlaceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAssemblyPlaceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcAudioVisualApplianceTypeEnum { Amplifier , Camera , Display , Microphone , Player , Projector , Receiver , Speaker , Switcher , Telephone , Tuner , Userdefined , Notdefined , } impl Default for IfcAudioVisualApplianceTypeEnum { fn default () -> Self { IfcAudioVisualApplianceTypeEnum :: Amplifier } } impl From < String > for IfcAudioVisualApplianceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AMPLIFIER" => IfcAudioVisualApplianceTypeEnum :: Amplifier , "CAMERA" => IfcAudioVisualApplianceTypeEnum :: Camera , "DISPLAY" => IfcAudioVisualApplianceTypeEnum :: Display , "MICROPHONE" => IfcAudioVisualApplianceTypeEnum :: Microphone , "PLAYER" => IfcAudioVisualApplianceTypeEnum :: Player , "PROJECTOR" => IfcAudioVisualApplianceTypeEnum :: Projector , "RECEIVER" => IfcAudioVisualApplianceTypeEnum :: Receiver , "SPEAKER" => IfcAudioVisualApplianceTypeEnum :: Speaker , "SWITCHER" => IfcAudioVisualApplianceTypeEnum :: Switcher , "TELEPHONE" => IfcAudioVisualApplianceTypeEnum :: Telephone , "TUNER" => IfcAudioVisualApplianceTypeEnum :: Tuner , "USERDEFINED" => IfcAudioVisualApplianceTypeEnum :: Userdefined , "NOTDEFINED" => IfcAudioVisualApplianceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcAudioVisualApplianceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcAudioVisualApplianceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcAudioVisualApplianceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBSplineCurveForm { PolylineForm , CircularArc , EllipticArc , ParabolicArc , HyperbolicArc , Unspecified , } impl Default for IfcBSplineCurveForm { fn default () -> Self { IfcBSplineCurveForm :: PolylineForm } } impl From < String > for IfcBSplineCurveForm { fn from (value : String) -> Self { match value . as_str () { "POLYLINE_FORM" => IfcBSplineCurveForm :: PolylineForm , "CIRCULAR_ARC" => IfcBSplineCurveForm :: CircularArc , "ELLIPTIC_ARC" => IfcBSplineCurveForm :: EllipticArc , "PARABOLIC_ARC" => IfcBSplineCurveForm :: ParabolicArc , "HYPERBOLIC_ARC" => IfcBSplineCurveForm :: HyperbolicArc , "UNSPECIFIED" => IfcBSplineCurveForm :: Unspecified , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBSplineCurveForm { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBSplineCurveForm :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBSplineCurveForm :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBSplineSurfaceForm { PlaneSurf , CylindricalSurf , ConicalSurf , SphericalSurf , ToroidalSurf , SurfOfRevolution , RuledSurf , GeneralisedCone , QuadricSurf , SurfOfLinearExtrusion , Unspecified , } impl Default for IfcBSplineSurfaceForm { fn default () -> Self { IfcBSplineSurfaceForm :: PlaneSurf } } impl From < String > for IfcBSplineSurfaceForm { fn from (value : String) -> Self { match value . as_str () { "PLANE_SURF" => IfcBSplineSurfaceForm :: PlaneSurf , "CYLINDRICAL_SURF" => IfcBSplineSurfaceForm :: CylindricalSurf , "CONICAL_SURF" => IfcBSplineSurfaceForm :: ConicalSurf , "SPHERICAL_SURF" => IfcBSplineSurfaceForm :: SphericalSurf , "TOROIDAL_SURF" => IfcBSplineSurfaceForm :: ToroidalSurf , "SURF_OF_REVOLUTION" => IfcBSplineSurfaceForm :: SurfOfRevolution , "RULED_SURF" => IfcBSplineSurfaceForm :: RuledSurf , "GENERALISED_CONE" => IfcBSplineSurfaceForm :: GeneralisedCone , "QUADRIC_SURF" => IfcBSplineSurfaceForm :: QuadricSurf , "SURF_OF_LINEAR_EXTRUSION" => IfcBSplineSurfaceForm :: SurfOfLinearExtrusion , "UNSPECIFIED" => IfcBSplineSurfaceForm :: Unspecified , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBSplineSurfaceForm { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBSplineSurfaceForm :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBSplineSurfaceForm :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBeamTypeEnum { Beam , Joist , Hollowcore , Lintel , Spandrel , TBeam , Userdefined , Notdefined , } impl Default for IfcBeamTypeEnum { fn default () -> Self { IfcBeamTypeEnum :: Beam } } impl From < String > for IfcBeamTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BEAM" => IfcBeamTypeEnum :: Beam , "JOIST" => IfcBeamTypeEnum :: Joist , "HOLLOWCORE" => IfcBeamTypeEnum :: Hollowcore , "LINTEL" => IfcBeamTypeEnum :: Lintel , "SPANDREL" => IfcBeamTypeEnum :: Spandrel , "T_BEAM" => IfcBeamTypeEnum :: TBeam , "USERDEFINED" => IfcBeamTypeEnum :: Userdefined , "NOTDEFINED" => IfcBeamTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBeamTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBeamTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBeamTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBenchmarkEnum { Greaterthan , Greaterthanorequalto , Lessthan , Lessthanorequalto , Equalto , Notequalto , Includes , Notincludes , Includedin , Notincludedin , } impl Default for IfcBenchmarkEnum { fn default () -> Self { IfcBenchmarkEnum :: Greaterthan } } impl From < String > for IfcBenchmarkEnum { fn from (value : String) -> Self { match value . as_str () { "GREATERTHAN" => IfcBenchmarkEnum :: Greaterthan , "GREATERTHANOREQUALTO" => IfcBenchmarkEnum :: Greaterthanorequalto , "LESSTHAN" => IfcBenchmarkEnum :: Lessthan , "LESSTHANOREQUALTO" => IfcBenchmarkEnum :: Lessthanorequalto , "EQUALTO" => IfcBenchmarkEnum :: Equalto , "NOTEQUALTO" => IfcBenchmarkEnum :: Notequalto , "INCLUDES" => IfcBenchmarkEnum :: Includes , "NOTINCLUDES" => IfcBenchmarkEnum :: Notincludes , "INCLUDEDIN" => IfcBenchmarkEnum :: Includedin , "NOTINCLUDEDIN" => IfcBenchmarkEnum :: Notincludedin , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBenchmarkEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBenchmarkEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBenchmarkEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBoilerTypeEnum { Water , Steam , Userdefined , Notdefined , } impl Default for IfcBoilerTypeEnum { fn default () -> Self { IfcBoilerTypeEnum :: Water } } impl From < String > for IfcBoilerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "WATER" => IfcBoilerTypeEnum :: Water , "STEAM" => IfcBoilerTypeEnum :: Steam , "USERDEFINED" => IfcBoilerTypeEnum :: Userdefined , "NOTDEFINED" => IfcBoilerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBoilerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBoilerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBoilerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBooleanOperator { Union , Intersection , Difference , } impl Default for IfcBooleanOperator { fn default () -> Self { IfcBooleanOperator :: Union } } impl From < String > for IfcBooleanOperator { fn from (value : String) -> Self { match value . as_str () { "UNION" => IfcBooleanOperator :: Union , "INTERSECTION" => IfcBooleanOperator :: Intersection , "DIFFERENCE" => IfcBooleanOperator :: Difference , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBooleanOperator { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBooleanOperator :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBooleanOperator :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBuildingElementPartTypeEnum { Insulation , Precastpanel , Userdefined , Notdefined , } impl Default for IfcBuildingElementPartTypeEnum { fn default () -> Self { IfcBuildingElementPartTypeEnum :: Insulation } } impl From < String > for IfcBuildingElementPartTypeEnum { fn from (value : String) -> Self { match value . as_str () { "INSULATION" => IfcBuildingElementPartTypeEnum :: Insulation , "PRECASTPANEL" => IfcBuildingElementPartTypeEnum :: Precastpanel , "USERDEFINED" => IfcBuildingElementPartTypeEnum :: Userdefined , "NOTDEFINED" => IfcBuildingElementPartTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBuildingElementPartTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBuildingElementPartTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBuildingElementPartTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBuildingElementProxyTypeEnum { Complex , Element , Partial , Provisionforvoid , Provisionforspace , Userdefined , Notdefined , } impl Default for IfcBuildingElementProxyTypeEnum { fn default () -> Self { IfcBuildingElementProxyTypeEnum :: Complex } } impl From < String > for IfcBuildingElementProxyTypeEnum { fn from (value : String) -> Self { match value . as_str () { "COMPLEX" => IfcBuildingElementProxyTypeEnum :: Complex , "ELEMENT" => IfcBuildingElementProxyTypeEnum :: Element , "PARTIAL" => IfcBuildingElementProxyTypeEnum :: Partial , "PROVISIONFORVOID" => IfcBuildingElementProxyTypeEnum :: Provisionforvoid , "PROVISIONFORSPACE" => IfcBuildingElementProxyTypeEnum :: Provisionforspace , "USERDEFINED" => IfcBuildingElementProxyTypeEnum :: Userdefined , "NOTDEFINED" => IfcBuildingElementProxyTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBuildingElementProxyTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBuildingElementProxyTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBuildingElementProxyTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBuildingSystemTypeEnum { Fenestration , Foundation , Loadbearing , Outershell , Shading , Transport , Userdefined , Notdefined , } impl Default for IfcBuildingSystemTypeEnum { fn default () -> Self { IfcBuildingSystemTypeEnum :: Fenestration } } impl From < String > for IfcBuildingSystemTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FENESTRATION" => IfcBuildingSystemTypeEnum :: Fenestration , "FOUNDATION" => IfcBuildingSystemTypeEnum :: Foundation , "LOADBEARING" => IfcBuildingSystemTypeEnum :: Loadbearing , "OUTERSHELL" => IfcBuildingSystemTypeEnum :: Outershell , "SHADING" => IfcBuildingSystemTypeEnum :: Shading , "TRANSPORT" => IfcBuildingSystemTypeEnum :: Transport , "USERDEFINED" => IfcBuildingSystemTypeEnum :: Userdefined , "NOTDEFINED" => IfcBuildingSystemTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBuildingSystemTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBuildingSystemTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBuildingSystemTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcBurnerTypeEnum { Userdefined , Notdefined , } impl Default for IfcBurnerTypeEnum { fn default () -> Self { IfcBurnerTypeEnum :: Userdefined } } impl From < String > for IfcBurnerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcBurnerTypeEnum :: Userdefined , "NOTDEFINED" => IfcBurnerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcBurnerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcBurnerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcBurnerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCableCarrierFittingTypeEnum { Bend , Cross , Reducer , Tee , Userdefined , Notdefined , } impl Default for IfcCableCarrierFittingTypeEnum { fn default () -> Self { IfcCableCarrierFittingTypeEnum :: Bend } } impl From < String > for IfcCableCarrierFittingTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BEND" => IfcCableCarrierFittingTypeEnum :: Bend , "CROSS" => IfcCableCarrierFittingTypeEnum :: Cross , "REDUCER" => IfcCableCarrierFittingTypeEnum :: Reducer , "TEE" => IfcCableCarrierFittingTypeEnum :: Tee , "USERDEFINED" => IfcCableCarrierFittingTypeEnum :: Userdefined , "NOTDEFINED" => IfcCableCarrierFittingTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCableCarrierFittingTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCableCarrierFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCableCarrierFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCableCarrierSegmentTypeEnum { Cableladdersegment , Cabletraysegment , Cabletrunkingsegment , Conduitsegment , Userdefined , Notdefined , } impl Default for IfcCableCarrierSegmentTypeEnum { fn default () -> Self { IfcCableCarrierSegmentTypeEnum :: Cableladdersegment } } impl From < String > for IfcCableCarrierSegmentTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CABLELADDERSEGMENT" => IfcCableCarrierSegmentTypeEnum :: Cableladdersegment , "CABLETRAYSEGMENT" => IfcCableCarrierSegmentTypeEnum :: Cabletraysegment , "CABLETRUNKINGSEGMENT" => IfcCableCarrierSegmentTypeEnum :: Cabletrunkingsegment , "CONDUITSEGMENT" => IfcCableCarrierSegmentTypeEnum :: Conduitsegment , "USERDEFINED" => IfcCableCarrierSegmentTypeEnum :: Userdefined , "NOTDEFINED" => IfcCableCarrierSegmentTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCableCarrierSegmentTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCableCarrierSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCableCarrierSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCableFittingTypeEnum { Connector , Entry , Exit , Junction , Transition , Userdefined , Notdefined , } impl Default for IfcCableFittingTypeEnum { fn default () -> Self { IfcCableFittingTypeEnum :: Connector } } impl From < String > for IfcCableFittingTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONNECTOR" => IfcCableFittingTypeEnum :: Connector , "ENTRY" => IfcCableFittingTypeEnum :: Entry , "EXIT" => IfcCableFittingTypeEnum :: Exit , "JUNCTION" => IfcCableFittingTypeEnum :: Junction , "TRANSITION" => IfcCableFittingTypeEnum :: Transition , "USERDEFINED" => IfcCableFittingTypeEnum :: Userdefined , "NOTDEFINED" => IfcCableFittingTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCableFittingTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCableFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCableFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCableSegmentTypeEnum { Busbarsegment , Cablesegment , Conductorsegment , Coresegment , Userdefined , Notdefined , } impl Default for IfcCableSegmentTypeEnum { fn default () -> Self { IfcCableSegmentTypeEnum :: Busbarsegment } } impl From < String > for IfcCableSegmentTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BUSBARSEGMENT" => IfcCableSegmentTypeEnum :: Busbarsegment , "CABLESEGMENT" => IfcCableSegmentTypeEnum :: Cablesegment , "CONDUCTORSEGMENT" => IfcCableSegmentTypeEnum :: Conductorsegment , "CORESEGMENT" => IfcCableSegmentTypeEnum :: Coresegment , "USERDEFINED" => IfcCableSegmentTypeEnum :: Userdefined , "NOTDEFINED" => IfcCableSegmentTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCableSegmentTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCableSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCableSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcChangeActionEnum { Nochange , Modified , Added , Deleted , Notdefined , } impl Default for IfcChangeActionEnum { fn default () -> Self { IfcChangeActionEnum :: Nochange } } impl From < String > for IfcChangeActionEnum { fn from (value : String) -> Self { match value . as_str () { "NOCHANGE" => IfcChangeActionEnum :: Nochange , "MODIFIED" => IfcChangeActionEnum :: Modified , "ADDED" => IfcChangeActionEnum :: Added , "DELETED" => IfcChangeActionEnum :: Deleted , "NOTDEFINED" => IfcChangeActionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcChangeActionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcChangeActionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcChangeActionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcChillerTypeEnum { Aircooled , Watercooled , Heatrecovery , Userdefined , Notdefined , } impl Default for IfcChillerTypeEnum { fn default () -> Self { IfcChillerTypeEnum :: Aircooled } } impl From < String > for IfcChillerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AIRCOOLED" => IfcChillerTypeEnum :: Aircooled , "WATERCOOLED" => IfcChillerTypeEnum :: Watercooled , "HEATRECOVERY" => IfcChillerTypeEnum :: Heatrecovery , "USERDEFINED" => IfcChillerTypeEnum :: Userdefined , "NOTDEFINED" => IfcChillerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcChillerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcChillerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcChillerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcChimneyTypeEnum { Userdefined , Notdefined , } impl Default for IfcChimneyTypeEnum { fn default () -> Self { IfcChimneyTypeEnum :: Userdefined } } impl From < String > for IfcChimneyTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcChimneyTypeEnum :: Userdefined , "NOTDEFINED" => IfcChimneyTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcChimneyTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcChimneyTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcChimneyTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCoilTypeEnum { Dxcoolingcoil , Electricheatingcoil , Gasheatingcoil , Hydroniccoil , Steamheatingcoil , Watercoolingcoil , Waterheatingcoil , Userdefined , Notdefined , } impl Default for IfcCoilTypeEnum { fn default () -> Self { IfcCoilTypeEnum :: Dxcoolingcoil } } impl From < String > for IfcCoilTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DXCOOLINGCOIL" => IfcCoilTypeEnum :: Dxcoolingcoil , "ELECTRICHEATINGCOIL" => IfcCoilTypeEnum :: Electricheatingcoil , "GASHEATINGCOIL" => IfcCoilTypeEnum :: Gasheatingcoil , "HYDRONICCOIL" => IfcCoilTypeEnum :: Hydroniccoil , "STEAMHEATINGCOIL" => IfcCoilTypeEnum :: Steamheatingcoil , "WATERCOOLINGCOIL" => IfcCoilTypeEnum :: Watercoolingcoil , "WATERHEATINGCOIL" => IfcCoilTypeEnum :: Waterheatingcoil , "USERDEFINED" => IfcCoilTypeEnum :: Userdefined , "NOTDEFINED" => IfcCoilTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCoilTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCoilTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCoilTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcColumnTypeEnum { Column , Pilaster , Userdefined , Notdefined , } impl Default for IfcColumnTypeEnum { fn default () -> Self { IfcColumnTypeEnum :: Column } } impl From < String > for IfcColumnTypeEnum { fn from (value : String) -> Self { match value . as_str () { "COLUMN" => IfcColumnTypeEnum :: Column , "PILASTER" => IfcColumnTypeEnum :: Pilaster , "USERDEFINED" => IfcColumnTypeEnum :: Userdefined , "NOTDEFINED" => IfcColumnTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcColumnTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcColumnTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcColumnTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCommunicationsApplianceTypeEnum { Antenna , Computer , Fax , Gateway , Modem , Networkappliance , Networkbridge , Networkhub , Printer , Repeater , Router , Scanner , Userdefined , Notdefined , } impl Default for IfcCommunicationsApplianceTypeEnum { fn default () -> Self { IfcCommunicationsApplianceTypeEnum :: Antenna } } impl From < String > for IfcCommunicationsApplianceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ANTENNA" => IfcCommunicationsApplianceTypeEnum :: Antenna , "COMPUTER" => IfcCommunicationsApplianceTypeEnum :: Computer , "FAX" => IfcCommunicationsApplianceTypeEnum :: Fax , "GATEWAY" => IfcCommunicationsApplianceTypeEnum :: Gateway , "MODEM" => IfcCommunicationsApplianceTypeEnum :: Modem , "NETWORKAPPLIANCE" => IfcCommunicationsApplianceTypeEnum :: Networkappliance , "NETWORKBRIDGE" => IfcCommunicationsApplianceTypeEnum :: Networkbridge , "NETWORKHUB" => IfcCommunicationsApplianceTypeEnum :: Networkhub , "PRINTER" => IfcCommunicationsApplianceTypeEnum :: Printer , "REPEATER" => IfcCommunicationsApplianceTypeEnum :: Repeater , "ROUTER" => IfcCommunicationsApplianceTypeEnum :: Router , "SCANNER" => IfcCommunicationsApplianceTypeEnum :: Scanner , "USERDEFINED" => IfcCommunicationsApplianceTypeEnum :: Userdefined , "NOTDEFINED" => IfcCommunicationsApplianceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCommunicationsApplianceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCommunicationsApplianceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCommunicationsApplianceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcComplexPropertyTemplateTypeEnum { PComplex , QComplex , } impl Default for IfcComplexPropertyTemplateTypeEnum { fn default () -> Self { IfcComplexPropertyTemplateTypeEnum :: PComplex } } impl From < String > for IfcComplexPropertyTemplateTypeEnum { fn from (value : String) -> Self { match value . as_str () { "P_COMPLEX" => IfcComplexPropertyTemplateTypeEnum :: PComplex , "Q_COMPLEX" => IfcComplexPropertyTemplateTypeEnum :: QComplex , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcComplexPropertyTemplateTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcComplexPropertyTemplateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcComplexPropertyTemplateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCompressorTypeEnum { Dynamic , Reciprocating , Rotary , Scroll , Trochoidal , Singlestage , Booster , Opentype , Hermetic , Semihermetic , Weldedshellhermetic , Rollingpiston , Rotaryvane , Singlescrew , Twinscrew , Userdefined , Notdefined , } impl Default for IfcCompressorTypeEnum { fn default () -> Self { IfcCompressorTypeEnum :: Dynamic } } impl From < String > for IfcCompressorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DYNAMIC" => IfcCompressorTypeEnum :: Dynamic , "RECIPROCATING" => IfcCompressorTypeEnum :: Reciprocating , "ROTARY" => IfcCompressorTypeEnum :: Rotary , "SCROLL" => IfcCompressorTypeEnum :: Scroll , "TROCHOIDAL" => IfcCompressorTypeEnum :: Trochoidal , "SINGLESTAGE" => IfcCompressorTypeEnum :: Singlestage , "BOOSTER" => IfcCompressorTypeEnum :: Booster , "OPENTYPE" => IfcCompressorTypeEnum :: Opentype , "HERMETIC" => IfcCompressorTypeEnum :: Hermetic , "SEMIHERMETIC" => IfcCompressorTypeEnum :: Semihermetic , "WELDEDSHELLHERMETIC" => IfcCompressorTypeEnum :: Weldedshellhermetic , "ROLLINGPISTON" => IfcCompressorTypeEnum :: Rollingpiston , "ROTARYVANE" => IfcCompressorTypeEnum :: Rotaryvane , "SINGLESCREW" => IfcCompressorTypeEnum :: Singlescrew , "TWINSCREW" => IfcCompressorTypeEnum :: Twinscrew , "USERDEFINED" => IfcCompressorTypeEnum :: Userdefined , "NOTDEFINED" => IfcCompressorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCompressorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCompressorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCompressorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCondenserTypeEnum { Aircooled , Evaporativecooled , Watercooled , Watercooledbrazedplate , Watercooledshellcoil , Watercooledshelltube , Watercooledtubeintube , Userdefined , Notdefined , } impl Default for IfcCondenserTypeEnum { fn default () -> Self { IfcCondenserTypeEnum :: Aircooled } } impl From < String > for IfcCondenserTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AIRCOOLED" => IfcCondenserTypeEnum :: Aircooled , "EVAPORATIVECOOLED" => IfcCondenserTypeEnum :: Evaporativecooled , "WATERCOOLED" => IfcCondenserTypeEnum :: Watercooled , "WATERCOOLEDBRAZEDPLATE" => IfcCondenserTypeEnum :: Watercooledbrazedplate , "WATERCOOLEDSHELLCOIL" => IfcCondenserTypeEnum :: Watercooledshellcoil , "WATERCOOLEDSHELLTUBE" => IfcCondenserTypeEnum :: Watercooledshelltube , "WATERCOOLEDTUBEINTUBE" => IfcCondenserTypeEnum :: Watercooledtubeintube , "USERDEFINED" => IfcCondenserTypeEnum :: Userdefined , "NOTDEFINED" => IfcCondenserTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCondenserTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCondenserTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCondenserTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcConnectionTypeEnum { Atpath , Atstart , Atend , Notdefined , } impl Default for IfcConnectionTypeEnum { fn default () -> Self { IfcConnectionTypeEnum :: Atpath } } impl From < String > for IfcConnectionTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ATPATH" => IfcConnectionTypeEnum :: Atpath , "ATSTART" => IfcConnectionTypeEnum :: Atstart , "ATEND" => IfcConnectionTypeEnum :: Atend , "NOTDEFINED" => IfcConnectionTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcConnectionTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcConnectionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcConnectionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcConstraintEnum { Hard , Soft , Advisory , Userdefined , Notdefined , } impl Default for IfcConstraintEnum { fn default () -> Self { IfcConstraintEnum :: Hard } } impl From < String > for IfcConstraintEnum { fn from (value : String) -> Self { match value . as_str () { "HARD" => IfcConstraintEnum :: Hard , "SOFT" => IfcConstraintEnum :: Soft , "ADVISORY" => IfcConstraintEnum :: Advisory , "USERDEFINED" => IfcConstraintEnum :: Userdefined , "NOTDEFINED" => IfcConstraintEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcConstraintEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcConstraintEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcConstraintEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcConstructionEquipmentResourceTypeEnum { Demolishing , Earthmoving , Erecting , Heating , Lighting , Paving , Pumping , Transporting , Userdefined , Notdefined , } impl Default for IfcConstructionEquipmentResourceTypeEnum { fn default () -> Self { IfcConstructionEquipmentResourceTypeEnum :: Demolishing } } impl From < String > for IfcConstructionEquipmentResourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DEMOLISHING" => IfcConstructionEquipmentResourceTypeEnum :: Demolishing , "EARTHMOVING" => IfcConstructionEquipmentResourceTypeEnum :: Earthmoving , "ERECTING" => IfcConstructionEquipmentResourceTypeEnum :: Erecting , "HEATING" => IfcConstructionEquipmentResourceTypeEnum :: Heating , "LIGHTING" => IfcConstructionEquipmentResourceTypeEnum :: Lighting , "PAVING" => IfcConstructionEquipmentResourceTypeEnum :: Paving , "PUMPING" => IfcConstructionEquipmentResourceTypeEnum :: Pumping , "TRANSPORTING" => IfcConstructionEquipmentResourceTypeEnum :: Transporting , "USERDEFINED" => IfcConstructionEquipmentResourceTypeEnum :: Userdefined , "NOTDEFINED" => IfcConstructionEquipmentResourceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcConstructionEquipmentResourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcConstructionEquipmentResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcConstructionEquipmentResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcConstructionMaterialResourceTypeEnum { Aggregates , Concrete , Drywall , Fuel , Gypsum , Masonry , Metal , Plastic , Wood , Notdefined , Userdefined , } impl Default for IfcConstructionMaterialResourceTypeEnum { fn default () -> Self { IfcConstructionMaterialResourceTypeEnum :: Aggregates } } impl From < String > for IfcConstructionMaterialResourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AGGREGATES" => IfcConstructionMaterialResourceTypeEnum :: Aggregates , "CONCRETE" => IfcConstructionMaterialResourceTypeEnum :: Concrete , "DRYWALL" => IfcConstructionMaterialResourceTypeEnum :: Drywall , "FUEL" => IfcConstructionMaterialResourceTypeEnum :: Fuel , "GYPSUM" => IfcConstructionMaterialResourceTypeEnum :: Gypsum , "MASONRY" => IfcConstructionMaterialResourceTypeEnum :: Masonry , "METAL" => IfcConstructionMaterialResourceTypeEnum :: Metal , "PLASTIC" => IfcConstructionMaterialResourceTypeEnum :: Plastic , "WOOD" => IfcConstructionMaterialResourceTypeEnum :: Wood , "NOTDEFINED" => IfcConstructionMaterialResourceTypeEnum :: Notdefined , "USERDEFINED" => IfcConstructionMaterialResourceTypeEnum :: Userdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcConstructionMaterialResourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcConstructionMaterialResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcConstructionMaterialResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcConstructionProductResourceTypeEnum { Assembly , Formwork , Userdefined , Notdefined , } impl Default for IfcConstructionProductResourceTypeEnum { fn default () -> Self { IfcConstructionProductResourceTypeEnum :: Assembly } } impl From < String > for IfcConstructionProductResourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ASSEMBLY" => IfcConstructionProductResourceTypeEnum :: Assembly , "FORMWORK" => IfcConstructionProductResourceTypeEnum :: Formwork , "USERDEFINED" => IfcConstructionProductResourceTypeEnum :: Userdefined , "NOTDEFINED" => IfcConstructionProductResourceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcConstructionProductResourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcConstructionProductResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcConstructionProductResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcControllerTypeEnum { Floating , Programmable , Proportional , Multiposition , Twoposition , Userdefined , Notdefined , } impl Default for IfcControllerTypeEnum { fn default () -> Self { IfcControllerTypeEnum :: Floating } } impl From < String > for IfcControllerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FLOATING" => IfcControllerTypeEnum :: Floating , "PROGRAMMABLE" => IfcControllerTypeEnum :: Programmable , "PROPORTIONAL" => IfcControllerTypeEnum :: Proportional , "MULTIPOSITION" => IfcControllerTypeEnum :: Multiposition , "TWOPOSITION" => IfcControllerTypeEnum :: Twoposition , "USERDEFINED" => IfcControllerTypeEnum :: Userdefined , "NOTDEFINED" => IfcControllerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcControllerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcControllerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcControllerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCooledBeamTypeEnum { Active , Passive , Userdefined , Notdefined , } impl Default for IfcCooledBeamTypeEnum { fn default () -> Self { IfcCooledBeamTypeEnum :: Active } } impl From < String > for IfcCooledBeamTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ACTIVE" => IfcCooledBeamTypeEnum :: Active , "PASSIVE" => IfcCooledBeamTypeEnum :: Passive , "USERDEFINED" => IfcCooledBeamTypeEnum :: Userdefined , "NOTDEFINED" => IfcCooledBeamTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCooledBeamTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCooledBeamTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCooledBeamTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCoolingTowerTypeEnum { Naturaldraft , Mechanicalinduceddraft , Mechanicalforceddraft , Userdefined , Notdefined , } impl Default for IfcCoolingTowerTypeEnum { fn default () -> Self { IfcCoolingTowerTypeEnum :: Naturaldraft } } impl From < String > for IfcCoolingTowerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "NATURALDRAFT" => IfcCoolingTowerTypeEnum :: Naturaldraft , "MECHANICALINDUCEDDRAFT" => IfcCoolingTowerTypeEnum :: Mechanicalinduceddraft , "MECHANICALFORCEDDRAFT" => IfcCoolingTowerTypeEnum :: Mechanicalforceddraft , "USERDEFINED" => IfcCoolingTowerTypeEnum :: Userdefined , "NOTDEFINED" => IfcCoolingTowerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCoolingTowerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCoolingTowerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCoolingTowerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCostItemTypeEnum { Userdefined , Notdefined , } impl Default for IfcCostItemTypeEnum { fn default () -> Self { IfcCostItemTypeEnum :: Userdefined } } impl From < String > for IfcCostItemTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcCostItemTypeEnum :: Userdefined , "NOTDEFINED" => IfcCostItemTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCostItemTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCostItemTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCostItemTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCostScheduleTypeEnum { Budget , Costplan , Estimate , Tender , Pricedbillofquantities , Unpricedbillofquantities , Scheduleofrates , Userdefined , Notdefined , } impl Default for IfcCostScheduleTypeEnum { fn default () -> Self { IfcCostScheduleTypeEnum :: Budget } } impl From < String > for IfcCostScheduleTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BUDGET" => IfcCostScheduleTypeEnum :: Budget , "COSTPLAN" => IfcCostScheduleTypeEnum :: Costplan , "ESTIMATE" => IfcCostScheduleTypeEnum :: Estimate , "TENDER" => IfcCostScheduleTypeEnum :: Tender , "PRICEDBILLOFQUANTITIES" => IfcCostScheduleTypeEnum :: Pricedbillofquantities , "UNPRICEDBILLOFQUANTITIES" => IfcCostScheduleTypeEnum :: Unpricedbillofquantities , "SCHEDULEOFRATES" => IfcCostScheduleTypeEnum :: Scheduleofrates , "USERDEFINED" => IfcCostScheduleTypeEnum :: Userdefined , "NOTDEFINED" => IfcCostScheduleTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCostScheduleTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCostScheduleTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCostScheduleTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCoveringTypeEnum { Ceiling , Flooring , Cladding , Roofing , Molding , Skirtingboard , Insulation , Membrane , Sleeving , Wrapping , Userdefined , Notdefined , } impl Default for IfcCoveringTypeEnum { fn default () -> Self { IfcCoveringTypeEnum :: Ceiling } } impl From < String > for IfcCoveringTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CEILING" => IfcCoveringTypeEnum :: Ceiling , "FLOORING" => IfcCoveringTypeEnum :: Flooring , "CLADDING" => IfcCoveringTypeEnum :: Cladding , "ROOFING" => IfcCoveringTypeEnum :: Roofing , "MOLDING" => IfcCoveringTypeEnum :: Molding , "SKIRTINGBOARD" => IfcCoveringTypeEnum :: Skirtingboard , "INSULATION" => IfcCoveringTypeEnum :: Insulation , "MEMBRANE" => IfcCoveringTypeEnum :: Membrane , "SLEEVING" => IfcCoveringTypeEnum :: Sleeving , "WRAPPING" => IfcCoveringTypeEnum :: Wrapping , "USERDEFINED" => IfcCoveringTypeEnum :: Userdefined , "NOTDEFINED" => IfcCoveringTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCoveringTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCoveringTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCoveringTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCrewResourceTypeEnum { Office , Site , Userdefined , Notdefined , } impl Default for IfcCrewResourceTypeEnum { fn default () -> Self { IfcCrewResourceTypeEnum :: Office } } impl From < String > for IfcCrewResourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "OFFICE" => IfcCrewResourceTypeEnum :: Office , "SITE" => IfcCrewResourceTypeEnum :: Site , "USERDEFINED" => IfcCrewResourceTypeEnum :: Userdefined , "NOTDEFINED" => IfcCrewResourceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCrewResourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCrewResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCrewResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCurtainWallTypeEnum { Userdefined , Notdefined , } impl Default for IfcCurtainWallTypeEnum { fn default () -> Self { IfcCurtainWallTypeEnum :: Userdefined } } impl From < String > for IfcCurtainWallTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcCurtainWallTypeEnum :: Userdefined , "NOTDEFINED" => IfcCurtainWallTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCurtainWallTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCurtainWallTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCurtainWallTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcCurveInterpolationEnum { Linear , LogLinear , LogLog , Notdefined , } impl Default for IfcCurveInterpolationEnum { fn default () -> Self { IfcCurveInterpolationEnum :: Linear } } impl From < String > for IfcCurveInterpolationEnum { fn from (value : String) -> Self { match value . as_str () { "LINEAR" => IfcCurveInterpolationEnum :: Linear , "LOG_LINEAR" => IfcCurveInterpolationEnum :: LogLinear , "LOG_LOG" => IfcCurveInterpolationEnum :: LogLog , "NOTDEFINED" => IfcCurveInterpolationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcCurveInterpolationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcCurveInterpolationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcCurveInterpolationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDamperTypeEnum { Backdraftdamper , Balancingdamper , Blastdamper , Controldamper , Firedamper , Firesmokedamper , Fumehoodexhaust , Gravitydamper , Gravityreliefdamper , Reliefdamper , Smokedamper , Userdefined , Notdefined , } impl Default for IfcDamperTypeEnum { fn default () -> Self { IfcDamperTypeEnum :: Backdraftdamper } } impl From < String > for IfcDamperTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BACKDRAFTDAMPER" => IfcDamperTypeEnum :: Backdraftdamper , "BALANCINGDAMPER" => IfcDamperTypeEnum :: Balancingdamper , "BLASTDAMPER" => IfcDamperTypeEnum :: Blastdamper , "CONTROLDAMPER" => IfcDamperTypeEnum :: Controldamper , "FIREDAMPER" => IfcDamperTypeEnum :: Firedamper , "FIRESMOKEDAMPER" => IfcDamperTypeEnum :: Firesmokedamper , "FUMEHOODEXHAUST" => IfcDamperTypeEnum :: Fumehoodexhaust , "GRAVITYDAMPER" => IfcDamperTypeEnum :: Gravitydamper , "GRAVITYRELIEFDAMPER" => IfcDamperTypeEnum :: Gravityreliefdamper , "RELIEFDAMPER" => IfcDamperTypeEnum :: Reliefdamper , "SMOKEDAMPER" => IfcDamperTypeEnum :: Smokedamper , "USERDEFINED" => IfcDamperTypeEnum :: Userdefined , "NOTDEFINED" => IfcDamperTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDamperTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDamperTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDamperTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDataOriginEnum { Measured , Predicted , Simulated , Userdefined , Notdefined , } impl Default for IfcDataOriginEnum { fn default () -> Self { IfcDataOriginEnum :: Measured } } impl From < String > for IfcDataOriginEnum { fn from (value : String) -> Self { match value . as_str () { "MEASURED" => IfcDataOriginEnum :: Measured , "PREDICTED" => IfcDataOriginEnum :: Predicted , "SIMULATED" => IfcDataOriginEnum :: Simulated , "USERDEFINED" => IfcDataOriginEnum :: Userdefined , "NOTDEFINED" => IfcDataOriginEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDataOriginEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDataOriginEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDataOriginEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDerivedUnitEnum { Angularvelocityunit , Areadensityunit , Compoundplaneangleunit , Dynamicviscosityunit , Heatfluxdensityunit , Integercountrateunit , Isothermalmoisturecapacityunit , Kinematicviscosityunit , Linearvelocityunit , Massdensityunit , Massflowrateunit , Moisturediffusivityunit , Molecularweightunit , Specificheatcapacityunit , Thermaladmittanceunit , Thermalconductanceunit , Thermalresistanceunit , Thermaltransmittanceunit , Vaporpermeabilityunit , Volumetricflowrateunit , Rotationalfrequencyunit , Torqueunit , Momentofinertiaunit , Linearmomentunit , Linearforceunit , Planarforceunit , Modulusofelasticityunit , Shearmodulusunit , Linearstiffnessunit , Rotationalstiffnessunit , Modulusofsubgradereactionunit , Accelerationunit , Curvatureunit , Heatingvalueunit , Ionconcentrationunit , Luminousintensitydistributionunit , Massperlengthunit , Modulusoflinearsubgradereactionunit , Modulusofrotationalsubgradereactionunit , Phunit , Rotationalmassunit , Sectionareaintegralunit , Sectionmodulusunit , Soundpowerlevelunit , Soundpowerunit , Soundpressurelevelunit , Soundpressureunit , Temperaturegradientunit , Temperaturerateofchangeunit , Thermalexpansioncoefficientunit , Warpingconstantunit , Warpingmomentunit , Userdefined , } impl Default for IfcDerivedUnitEnum { fn default () -> Self { IfcDerivedUnitEnum :: Angularvelocityunit } } impl From < String > for IfcDerivedUnitEnum { fn from (value : String) -> Self { match value . as_str () { "ANGULARVELOCITYUNIT" => IfcDerivedUnitEnum :: Angularvelocityunit , "AREADENSITYUNIT" => IfcDerivedUnitEnum :: Areadensityunit , "COMPOUNDPLANEANGLEUNIT" => IfcDerivedUnitEnum :: Compoundplaneangleunit , "DYNAMICVISCOSITYUNIT" => IfcDerivedUnitEnum :: Dynamicviscosityunit , "HEATFLUXDENSITYUNIT" => IfcDerivedUnitEnum :: Heatfluxdensityunit , "INTEGERCOUNTRATEUNIT" => IfcDerivedUnitEnum :: Integercountrateunit , "ISOTHERMALMOISTURECAPACITYUNIT" => IfcDerivedUnitEnum :: Isothermalmoisturecapacityunit , "KINEMATICVISCOSITYUNIT" => IfcDerivedUnitEnum :: Kinematicviscosityunit , "LINEARVELOCITYUNIT" => IfcDerivedUnitEnum :: Linearvelocityunit , "MASSDENSITYUNIT" => IfcDerivedUnitEnum :: Massdensityunit , "MASSFLOWRATEUNIT" => IfcDerivedUnitEnum :: Massflowrateunit , "MOISTUREDIFFUSIVITYUNIT" => IfcDerivedUnitEnum :: Moisturediffusivityunit , "MOLECULARWEIGHTUNIT" => IfcDerivedUnitEnum :: Molecularweightunit , "SPECIFICHEATCAPACITYUNIT" => IfcDerivedUnitEnum :: Specificheatcapacityunit , "THERMALADMITTANCEUNIT" => IfcDerivedUnitEnum :: Thermaladmittanceunit , "THERMALCONDUCTANCEUNIT" => IfcDerivedUnitEnum :: Thermalconductanceunit , "THERMALRESISTANCEUNIT" => IfcDerivedUnitEnum :: Thermalresistanceunit , "THERMALTRANSMITTANCEUNIT" => IfcDerivedUnitEnum :: Thermaltransmittanceunit , "VAPORPERMEABILITYUNIT" => IfcDerivedUnitEnum :: Vaporpermeabilityunit , "VOLUMETRICFLOWRATEUNIT" => IfcDerivedUnitEnum :: Volumetricflowrateunit , "ROTATIONALFREQUENCYUNIT" => IfcDerivedUnitEnum :: Rotationalfrequencyunit , "TORQUEUNIT" => IfcDerivedUnitEnum :: Torqueunit , "MOMENTOFINERTIAUNIT" => IfcDerivedUnitEnum :: Momentofinertiaunit , "LINEARMOMENTUNIT" => IfcDerivedUnitEnum :: Linearmomentunit , "LINEARFORCEUNIT" => IfcDerivedUnitEnum :: Linearforceunit , "PLANARFORCEUNIT" => IfcDerivedUnitEnum :: Planarforceunit , "MODULUSOFELASTICITYUNIT" => IfcDerivedUnitEnum :: Modulusofelasticityunit , "SHEARMODULUSUNIT" => IfcDerivedUnitEnum :: Shearmodulusunit , "LINEARSTIFFNESSUNIT" => IfcDerivedUnitEnum :: Linearstiffnessunit , "ROTATIONALSTIFFNESSUNIT" => IfcDerivedUnitEnum :: Rotationalstiffnessunit , "MODULUSOFSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum :: Modulusofsubgradereactionunit , "ACCELERATIONUNIT" => IfcDerivedUnitEnum :: Accelerationunit , "CURVATUREUNIT" => IfcDerivedUnitEnum :: Curvatureunit , "HEATINGVALUEUNIT" => IfcDerivedUnitEnum :: Heatingvalueunit , "IONCONCENTRATIONUNIT" => IfcDerivedUnitEnum :: Ionconcentrationunit , "LUMINOUSINTENSITYDISTRIBUTIONUNIT" => IfcDerivedUnitEnum :: Luminousintensitydistributionunit , "MASSPERLENGTHUNIT" => IfcDerivedUnitEnum :: Massperlengthunit , "MODULUSOFLINEARSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum :: Modulusoflinearsubgradereactionunit , "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum :: Modulusofrotationalsubgradereactionunit , "PHUNIT" => IfcDerivedUnitEnum :: Phunit , "ROTATIONALMASSUNIT" => IfcDerivedUnitEnum :: Rotationalmassunit , "SECTIONAREAINTEGRALUNIT" => IfcDerivedUnitEnum :: Sectionareaintegralunit , "SECTIONMODULUSUNIT" => IfcDerivedUnitEnum :: Sectionmodulusunit , "SOUNDPOWERLEVELUNIT" => IfcDerivedUnitEnum :: Soundpowerlevelunit , "SOUNDPOWERUNIT" => IfcDerivedUnitEnum :: Soundpowerunit , "SOUNDPRESSURELEVELUNIT" => IfcDerivedUnitEnum :: Soundpressurelevelunit , "SOUNDPRESSUREUNIT" => IfcDerivedUnitEnum :: Soundpressureunit , "TEMPERATUREGRADIENTUNIT" => IfcDerivedUnitEnum :: Temperaturegradientunit , "TEMPERATURERATEOFCHANGEUNIT" => IfcDerivedUnitEnum :: Temperaturerateofchangeunit , "THERMALEXPANSIONCOEFFICIENTUNIT" => IfcDerivedUnitEnum :: Thermalexpansioncoefficientunit , "WARPINGCONSTANTUNIT" => IfcDerivedUnitEnum :: Warpingconstantunit , "WARPINGMOMENTUNIT" => IfcDerivedUnitEnum :: Warpingmomentunit , "USERDEFINED" => IfcDerivedUnitEnum :: Userdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDerivedUnitEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDerivedUnitEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDerivedUnitEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDirectionSenseEnum { Positive , Negative , } impl Default for IfcDirectionSenseEnum { fn default () -> Self { IfcDirectionSenseEnum :: Positive } } impl From < String > for IfcDirectionSenseEnum { fn from (value : String) -> Self { match value . as_str () { "POSITIVE" => IfcDirectionSenseEnum :: Positive , "NEGATIVE" => IfcDirectionSenseEnum :: Negative , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDirectionSenseEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDirectionSenseEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDirectionSenseEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDiscreteAccessoryTypeEnum { Anchorplate , Bracket , Shoe , Userdefined , Notdefined , } impl Default for IfcDiscreteAccessoryTypeEnum { fn default () -> Self { IfcDiscreteAccessoryTypeEnum :: Anchorplate } } impl From < String > for IfcDiscreteAccessoryTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ANCHORPLATE" => IfcDiscreteAccessoryTypeEnum :: Anchorplate , "BRACKET" => IfcDiscreteAccessoryTypeEnum :: Bracket , "SHOE" => IfcDiscreteAccessoryTypeEnum :: Shoe , "USERDEFINED" => IfcDiscreteAccessoryTypeEnum :: Userdefined , "NOTDEFINED" => IfcDiscreteAccessoryTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDiscreteAccessoryTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDiscreteAccessoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDiscreteAccessoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDistributionChamberElementTypeEnum { Formedduct , Inspectionchamber , Inspectionpit , Manhole , Meterchamber , Sump , Trench , Valvechamber , Userdefined , Notdefined , } impl Default for IfcDistributionChamberElementTypeEnum { fn default () -> Self { IfcDistributionChamberElementTypeEnum :: Formedduct } } impl From < String > for IfcDistributionChamberElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FORMEDDUCT" => IfcDistributionChamberElementTypeEnum :: Formedduct , "INSPECTIONCHAMBER" => IfcDistributionChamberElementTypeEnum :: Inspectionchamber , "INSPECTIONPIT" => IfcDistributionChamberElementTypeEnum :: Inspectionpit , "MANHOLE" => IfcDistributionChamberElementTypeEnum :: Manhole , "METERCHAMBER" => IfcDistributionChamberElementTypeEnum :: Meterchamber , "SUMP" => IfcDistributionChamberElementTypeEnum :: Sump , "TRENCH" => IfcDistributionChamberElementTypeEnum :: Trench , "VALVECHAMBER" => IfcDistributionChamberElementTypeEnum :: Valvechamber , "USERDEFINED" => IfcDistributionChamberElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcDistributionChamberElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDistributionChamberElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDistributionChamberElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDistributionChamberElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDistributionPortTypeEnum { Cable , Cablecarrier , Duct , Pipe , Userdefined , Notdefined , } impl Default for IfcDistributionPortTypeEnum { fn default () -> Self { IfcDistributionPortTypeEnum :: Cable } } impl From < String > for IfcDistributionPortTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CABLE" => IfcDistributionPortTypeEnum :: Cable , "CABLECARRIER" => IfcDistributionPortTypeEnum :: Cablecarrier , "DUCT" => IfcDistributionPortTypeEnum :: Duct , "PIPE" => IfcDistributionPortTypeEnum :: Pipe , "USERDEFINED" => IfcDistributionPortTypeEnum :: Userdefined , "NOTDEFINED" => IfcDistributionPortTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDistributionPortTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDistributionPortTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDistributionPortTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDistributionSystemEnum { Airconditioning , Audiovisual , Chemical , Chilledwater , Communication , Compressedair , Condenserwater , Control , Conveying , Data , Disposal , Domesticcoldwater , Domestichotwater , Drainage , Earthing , Electrical , Electroacoustic , Exhaust , Fireprotection , Fuel , Gas , Hazardous , Heating , Lighting , Lightningprotection , Municipalsolidwaste , Oil , Operational , Powergeneration , Rainwater , Refrigeration , Security , Sewage , Signal , Stormwater , Telephone , Tv , Vacuum , Vent , Ventilation , Wastewater , Watersupply , Userdefined , Notdefined , } impl Default for IfcDistributionSystemEnum { fn default () -> Self { IfcDistributionSystemEnum :: Airconditioning } } impl From < String > for IfcDistributionSystemEnum { fn from (value : String) -> Self { match value . as_str () { "AIRCONDITIONING" => IfcDistributionSystemEnum :: Airconditioning , "AUDIOVISUAL" => IfcDistributionSystemEnum :: Audiovisual , "CHEMICAL" => IfcDistributionSystemEnum :: Chemical , "CHILLEDWATER" => IfcDistributionSystemEnum :: Chilledwater , "COMMUNICATION" => IfcDistributionSystemEnum :: Communication , "COMPRESSEDAIR" => IfcDistributionSystemEnum :: Compressedair , "CONDENSERWATER" => IfcDistributionSystemEnum :: Condenserwater , "CONTROL" => IfcDistributionSystemEnum :: Control , "CONVEYING" => IfcDistributionSystemEnum :: Conveying , "DATA" => IfcDistributionSystemEnum :: Data , "DISPOSAL" => IfcDistributionSystemEnum :: Disposal , "DOMESTICCOLDWATER" => IfcDistributionSystemEnum :: Domesticcoldwater , "DOMESTICHOTWATER" => IfcDistributionSystemEnum :: Domestichotwater , "DRAINAGE" => IfcDistributionSystemEnum :: Drainage , "EARTHING" => IfcDistributionSystemEnum :: Earthing , "ELECTRICAL" => IfcDistributionSystemEnum :: Electrical , "ELECTROACOUSTIC" => IfcDistributionSystemEnum :: Electroacoustic , "EXHAUST" => IfcDistributionSystemEnum :: Exhaust , "FIREPROTECTION" => IfcDistributionSystemEnum :: Fireprotection , "FUEL" => IfcDistributionSystemEnum :: Fuel , "GAS" => IfcDistributionSystemEnum :: Gas , "HAZARDOUS" => IfcDistributionSystemEnum :: Hazardous , "HEATING" => IfcDistributionSystemEnum :: Heating , "LIGHTING" => IfcDistributionSystemEnum :: Lighting , "LIGHTNINGPROTECTION" => IfcDistributionSystemEnum :: Lightningprotection , "MUNICIPALSOLIDWASTE" => IfcDistributionSystemEnum :: Municipalsolidwaste , "OIL" => IfcDistributionSystemEnum :: Oil , "OPERATIONAL" => IfcDistributionSystemEnum :: Operational , "POWERGENERATION" => IfcDistributionSystemEnum :: Powergeneration , "RAINWATER" => IfcDistributionSystemEnum :: Rainwater , "REFRIGERATION" => IfcDistributionSystemEnum :: Refrigeration , "SECURITY" => IfcDistributionSystemEnum :: Security , "SEWAGE" => IfcDistributionSystemEnum :: Sewage , "SIGNAL" => IfcDistributionSystemEnum :: Signal , "STORMWATER" => IfcDistributionSystemEnum :: Stormwater , "TELEPHONE" => IfcDistributionSystemEnum :: Telephone , "TV" => IfcDistributionSystemEnum :: Tv , "VACUUM" => IfcDistributionSystemEnum :: Vacuum , "VENT" => IfcDistributionSystemEnum :: Vent , "VENTILATION" => IfcDistributionSystemEnum :: Ventilation , "WASTEWATER" => IfcDistributionSystemEnum :: Wastewater , "WATERSUPPLY" => IfcDistributionSystemEnum :: Watersupply , "USERDEFINED" => IfcDistributionSystemEnum :: Userdefined , "NOTDEFINED" => IfcDistributionSystemEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDistributionSystemEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDistributionSystemEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDistributionSystemEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDocumentConfidentialityEnum { Public , Restricted , Confidential , Personal , Userdefined , Notdefined , } impl Default for IfcDocumentConfidentialityEnum { fn default () -> Self { IfcDocumentConfidentialityEnum :: Public } } impl From < String > for IfcDocumentConfidentialityEnum { fn from (value : String) -> Self { match value . as_str () { "PUBLIC" => IfcDocumentConfidentialityEnum :: Public , "RESTRICTED" => IfcDocumentConfidentialityEnum :: Restricted , "CONFIDENTIAL" => IfcDocumentConfidentialityEnum :: Confidential , "PERSONAL" => IfcDocumentConfidentialityEnum :: Personal , "USERDEFINED" => IfcDocumentConfidentialityEnum :: Userdefined , "NOTDEFINED" => IfcDocumentConfidentialityEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDocumentConfidentialityEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDocumentConfidentialityEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDocumentConfidentialityEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDocumentStatusEnum { Draft , Finaldraft , Final , Revision , Notdefined , } impl Default for IfcDocumentStatusEnum { fn default () -> Self { IfcDocumentStatusEnum :: Draft } } impl From < String > for IfcDocumentStatusEnum { fn from (value : String) -> Self { match value . as_str () { "DRAFT" => IfcDocumentStatusEnum :: Draft , "FINALDRAFT" => IfcDocumentStatusEnum :: Finaldraft , "FINAL" => IfcDocumentStatusEnum :: Final , "REVISION" => IfcDocumentStatusEnum :: Revision , "NOTDEFINED" => IfcDocumentStatusEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDocumentStatusEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDocumentStatusEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDocumentStatusEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDoorPanelOperationEnum { Swinging , DoubleActing , Sliding , Folding , Revolving , Rollingup , Fixedpanel , Userdefined , Notdefined , } impl Default for IfcDoorPanelOperationEnum { fn default () -> Self { IfcDoorPanelOperationEnum :: Swinging } } impl From < String > for IfcDoorPanelOperationEnum { fn from (value : String) -> Self { match value . as_str () { "SWINGING" => IfcDoorPanelOperationEnum :: Swinging , "DOUBLE_ACTING" => IfcDoorPanelOperationEnum :: DoubleActing , "SLIDING" => IfcDoorPanelOperationEnum :: Sliding , "FOLDING" => IfcDoorPanelOperationEnum :: Folding , "REVOLVING" => IfcDoorPanelOperationEnum :: Revolving , "ROLLINGUP" => IfcDoorPanelOperationEnum :: Rollingup , "FIXEDPANEL" => IfcDoorPanelOperationEnum :: Fixedpanel , "USERDEFINED" => IfcDoorPanelOperationEnum :: Userdefined , "NOTDEFINED" => IfcDoorPanelOperationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDoorPanelOperationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDoorPanelOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDoorPanelOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDoorPanelPositionEnum { Left , Middle , Right , Notdefined , } impl Default for IfcDoorPanelPositionEnum { fn default () -> Self { IfcDoorPanelPositionEnum :: Left } } impl From < String > for IfcDoorPanelPositionEnum { fn from (value : String) -> Self { match value . as_str () { "LEFT" => IfcDoorPanelPositionEnum :: Left , "MIDDLE" => IfcDoorPanelPositionEnum :: Middle , "RIGHT" => IfcDoorPanelPositionEnum :: Right , "NOTDEFINED" => IfcDoorPanelPositionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDoorPanelPositionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDoorPanelPositionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDoorPanelPositionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDoorStyleConstructionEnum { Aluminium , HighGradeSteel , Steel , Wood , AluminiumWood , AluminiumPlastic , Plastic , Userdefined , Notdefined , } impl Default for IfcDoorStyleConstructionEnum { fn default () -> Self { IfcDoorStyleConstructionEnum :: Aluminium } } impl From < String > for IfcDoorStyleConstructionEnum { fn from (value : String) -> Self { match value . as_str () { "ALUMINIUM" => IfcDoorStyleConstructionEnum :: Aluminium , "HIGH_GRADE_STEEL" => IfcDoorStyleConstructionEnum :: HighGradeSteel , "STEEL" => IfcDoorStyleConstructionEnum :: Steel , "WOOD" => IfcDoorStyleConstructionEnum :: Wood , "ALUMINIUM_WOOD" => IfcDoorStyleConstructionEnum :: AluminiumWood , "ALUMINIUM_PLASTIC" => IfcDoorStyleConstructionEnum :: AluminiumPlastic , "PLASTIC" => IfcDoorStyleConstructionEnum :: Plastic , "USERDEFINED" => IfcDoorStyleConstructionEnum :: Userdefined , "NOTDEFINED" => IfcDoorStyleConstructionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDoorStyleConstructionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDoorStyleConstructionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDoorStyleConstructionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDoorStyleOperationEnum { SingleSwingLeft , SingleSwingRight , DoubleDoorSingleSwing , DoubleDoorSingleSwingOppositeLeft , DoubleDoorSingleSwingOppositeRight , DoubleSwingLeft , DoubleSwingRight , DoubleDoorDoubleSwing , SlidingToLeft , SlidingToRight , DoubleDoorSliding , FoldingToLeft , FoldingToRight , DoubleDoorFolding , Revolving , Rollingup , Userdefined , Notdefined , } impl Default for IfcDoorStyleOperationEnum { fn default () -> Self { IfcDoorStyleOperationEnum :: SingleSwingLeft } } impl From < String > for IfcDoorStyleOperationEnum { fn from (value : String) -> Self { match value . as_str () { "SINGLE_SWING_LEFT" => IfcDoorStyleOperationEnum :: SingleSwingLeft , "SINGLE_SWING_RIGHT" => IfcDoorStyleOperationEnum :: SingleSwingRight , "DOUBLE_DOOR_SINGLE_SWING" => IfcDoorStyleOperationEnum :: DoubleDoorSingleSwing , "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT" => IfcDoorStyleOperationEnum :: DoubleDoorSingleSwingOppositeLeft , "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT" => IfcDoorStyleOperationEnum :: DoubleDoorSingleSwingOppositeRight , "DOUBLE_SWING_LEFT" => IfcDoorStyleOperationEnum :: DoubleSwingLeft , "DOUBLE_SWING_RIGHT" => IfcDoorStyleOperationEnum :: DoubleSwingRight , "DOUBLE_DOOR_DOUBLE_SWING" => IfcDoorStyleOperationEnum :: DoubleDoorDoubleSwing , "SLIDING_TO_LEFT" => IfcDoorStyleOperationEnum :: SlidingToLeft , "SLIDING_TO_RIGHT" => IfcDoorStyleOperationEnum :: SlidingToRight , "DOUBLE_DOOR_SLIDING" => IfcDoorStyleOperationEnum :: DoubleDoorSliding , "FOLDING_TO_LEFT" => IfcDoorStyleOperationEnum :: FoldingToLeft , "FOLDING_TO_RIGHT" => IfcDoorStyleOperationEnum :: FoldingToRight , "DOUBLE_DOOR_FOLDING" => IfcDoorStyleOperationEnum :: DoubleDoorFolding , "REVOLVING" => IfcDoorStyleOperationEnum :: Revolving , "ROLLINGUP" => IfcDoorStyleOperationEnum :: Rollingup , "USERDEFINED" => IfcDoorStyleOperationEnum :: Userdefined , "NOTDEFINED" => IfcDoorStyleOperationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDoorStyleOperationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDoorStyleOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDoorStyleOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDoorTypeEnum { Door , Gate , Trapdoor , Userdefined , Notdefined , } impl Default for IfcDoorTypeEnum { fn default () -> Self { IfcDoorTypeEnum :: Door } } impl From < String > for IfcDoorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DOOR" => IfcDoorTypeEnum :: Door , "GATE" => IfcDoorTypeEnum :: Gate , "TRAPDOOR" => IfcDoorTypeEnum :: Trapdoor , "USERDEFINED" => IfcDoorTypeEnum :: Userdefined , "NOTDEFINED" => IfcDoorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDoorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDoorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDoorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDoorTypeOperationEnum { SingleSwingLeft , SingleSwingRight , DoubleDoorSingleSwing , DoubleDoorSingleSwingOppositeLeft , DoubleDoorSingleSwingOppositeRight , DoubleSwingLeft , DoubleSwingRight , DoubleDoorDoubleSwing , SlidingToLeft , SlidingToRight , DoubleDoorSliding , FoldingToLeft , FoldingToRight , DoubleDoorFolding , Revolving , Rollingup , SwingFixedLeft , SwingFixedRight , Userdefined , Notdefined , } impl Default for IfcDoorTypeOperationEnum { fn default () -> Self { IfcDoorTypeOperationEnum :: SingleSwingLeft } } impl From < String > for IfcDoorTypeOperationEnum { fn from (value : String) -> Self { match value . as_str () { "SINGLE_SWING_LEFT" => IfcDoorTypeOperationEnum :: SingleSwingLeft , "SINGLE_SWING_RIGHT" => IfcDoorTypeOperationEnum :: SingleSwingRight , "DOUBLE_DOOR_SINGLE_SWING" => IfcDoorTypeOperationEnum :: DoubleDoorSingleSwing , "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT" => IfcDoorTypeOperationEnum :: DoubleDoorSingleSwingOppositeLeft , "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT" => IfcDoorTypeOperationEnum :: DoubleDoorSingleSwingOppositeRight , "DOUBLE_SWING_LEFT" => IfcDoorTypeOperationEnum :: DoubleSwingLeft , "DOUBLE_SWING_RIGHT" => IfcDoorTypeOperationEnum :: DoubleSwingRight , "DOUBLE_DOOR_DOUBLE_SWING" => IfcDoorTypeOperationEnum :: DoubleDoorDoubleSwing , "SLIDING_TO_LEFT" => IfcDoorTypeOperationEnum :: SlidingToLeft , "SLIDING_TO_RIGHT" => IfcDoorTypeOperationEnum :: SlidingToRight , "DOUBLE_DOOR_SLIDING" => IfcDoorTypeOperationEnum :: DoubleDoorSliding , "FOLDING_TO_LEFT" => IfcDoorTypeOperationEnum :: FoldingToLeft , "FOLDING_TO_RIGHT" => IfcDoorTypeOperationEnum :: FoldingToRight , "DOUBLE_DOOR_FOLDING" => IfcDoorTypeOperationEnum :: DoubleDoorFolding , "REVOLVING" => IfcDoorTypeOperationEnum :: Revolving , "ROLLINGUP" => IfcDoorTypeOperationEnum :: Rollingup , "SWING_FIXED_LEFT" => IfcDoorTypeOperationEnum :: SwingFixedLeft , "SWING_FIXED_RIGHT" => IfcDoorTypeOperationEnum :: SwingFixedRight , "USERDEFINED" => IfcDoorTypeOperationEnum :: Userdefined , "NOTDEFINED" => IfcDoorTypeOperationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDoorTypeOperationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDoorTypeOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDoorTypeOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDuctFittingTypeEnum { Bend , Connector , Entry , Exit , Junction , Obstruction , Transition , Userdefined , Notdefined , } impl Default for IfcDuctFittingTypeEnum { fn default () -> Self { IfcDuctFittingTypeEnum :: Bend } } impl From < String > for IfcDuctFittingTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BEND" => IfcDuctFittingTypeEnum :: Bend , "CONNECTOR" => IfcDuctFittingTypeEnum :: Connector , "ENTRY" => IfcDuctFittingTypeEnum :: Entry , "EXIT" => IfcDuctFittingTypeEnum :: Exit , "JUNCTION" => IfcDuctFittingTypeEnum :: Junction , "OBSTRUCTION" => IfcDuctFittingTypeEnum :: Obstruction , "TRANSITION" => IfcDuctFittingTypeEnum :: Transition , "USERDEFINED" => IfcDuctFittingTypeEnum :: Userdefined , "NOTDEFINED" => IfcDuctFittingTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDuctFittingTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDuctFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDuctFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDuctSegmentTypeEnum { Rigidsegment , Flexiblesegment , Userdefined , Notdefined , } impl Default for IfcDuctSegmentTypeEnum { fn default () -> Self { IfcDuctSegmentTypeEnum :: Rigidsegment } } impl From < String > for IfcDuctSegmentTypeEnum { fn from (value : String) -> Self { match value . as_str () { "RIGIDSEGMENT" => IfcDuctSegmentTypeEnum :: Rigidsegment , "FLEXIBLESEGMENT" => IfcDuctSegmentTypeEnum :: Flexiblesegment , "USERDEFINED" => IfcDuctSegmentTypeEnum :: Userdefined , "NOTDEFINED" => IfcDuctSegmentTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDuctSegmentTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDuctSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDuctSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDuctSilencerTypeEnum { Flatoval , Rectangular , Round , Userdefined , Notdefined , } impl Default for IfcDuctSilencerTypeEnum { fn default () -> Self { IfcDuctSilencerTypeEnum :: Flatoval } } impl From < String > for IfcDuctSilencerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FLATOVAL" => IfcDuctSilencerTypeEnum :: Flatoval , "RECTANGULAR" => IfcDuctSilencerTypeEnum :: Rectangular , "ROUND" => IfcDuctSilencerTypeEnum :: Round , "USERDEFINED" => IfcDuctSilencerTypeEnum :: Userdefined , "NOTDEFINED" => IfcDuctSilencerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcDuctSilencerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcDuctSilencerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcDuctSilencerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElectricApplianceTypeEnum { Dishwasher , Electriccooker , Freestandingelectricheater , Freestandingfan , Freestandingwaterheater , Freestandingwatercooler , Freezer , FridgeFreezer , Handdryer , Kitchenmachine , Microwave , Photocopier , Refrigerator , Tumbledryer , Vendingmachine , Washingmachine , Userdefined , Notdefined , } impl Default for IfcElectricApplianceTypeEnum { fn default () -> Self { IfcElectricApplianceTypeEnum :: Dishwasher } } impl From < String > for IfcElectricApplianceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DISHWASHER" => IfcElectricApplianceTypeEnum :: Dishwasher , "ELECTRICCOOKER" => IfcElectricApplianceTypeEnum :: Electriccooker , "FREESTANDINGELECTRICHEATER" => IfcElectricApplianceTypeEnum :: Freestandingelectricheater , "FREESTANDINGFAN" => IfcElectricApplianceTypeEnum :: Freestandingfan , "FREESTANDINGWATERHEATER" => IfcElectricApplianceTypeEnum :: Freestandingwaterheater , "FREESTANDINGWATERCOOLER" => IfcElectricApplianceTypeEnum :: Freestandingwatercooler , "FREEZER" => IfcElectricApplianceTypeEnum :: Freezer , "FRIDGE_FREEZER" => IfcElectricApplianceTypeEnum :: FridgeFreezer , "HANDDRYER" => IfcElectricApplianceTypeEnum :: Handdryer , "KITCHENMACHINE" => IfcElectricApplianceTypeEnum :: Kitchenmachine , "MICROWAVE" => IfcElectricApplianceTypeEnum :: Microwave , "PHOTOCOPIER" => IfcElectricApplianceTypeEnum :: Photocopier , "REFRIGERATOR" => IfcElectricApplianceTypeEnum :: Refrigerator , "TUMBLEDRYER" => IfcElectricApplianceTypeEnum :: Tumbledryer , "VENDINGMACHINE" => IfcElectricApplianceTypeEnum :: Vendingmachine , "WASHINGMACHINE" => IfcElectricApplianceTypeEnum :: Washingmachine , "USERDEFINED" => IfcElectricApplianceTypeEnum :: Userdefined , "NOTDEFINED" => IfcElectricApplianceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElectricApplianceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElectricApplianceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElectricApplianceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElectricDistributionBoardTypeEnum { Consumerunit , Distributionboard , Motorcontrolcentre , Switchboard , Userdefined , Notdefined , } impl Default for IfcElectricDistributionBoardTypeEnum { fn default () -> Self { IfcElectricDistributionBoardTypeEnum :: Consumerunit } } impl From < String > for IfcElectricDistributionBoardTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONSUMERUNIT" => IfcElectricDistributionBoardTypeEnum :: Consumerunit , "DISTRIBUTIONBOARD" => IfcElectricDistributionBoardTypeEnum :: Distributionboard , "MOTORCONTROLCENTRE" => IfcElectricDistributionBoardTypeEnum :: Motorcontrolcentre , "SWITCHBOARD" => IfcElectricDistributionBoardTypeEnum :: Switchboard , "USERDEFINED" => IfcElectricDistributionBoardTypeEnum :: Userdefined , "NOTDEFINED" => IfcElectricDistributionBoardTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElectricDistributionBoardTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElectricDistributionBoardTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElectricDistributionBoardTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElectricFlowStorageDeviceTypeEnum { Battery , Capacitorbank , Harmonicfilter , Inductorbank , Ups , Userdefined , Notdefined , } impl Default for IfcElectricFlowStorageDeviceTypeEnum { fn default () -> Self { IfcElectricFlowStorageDeviceTypeEnum :: Battery } } impl From < String > for IfcElectricFlowStorageDeviceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BATTERY" => IfcElectricFlowStorageDeviceTypeEnum :: Battery , "CAPACITORBANK" => IfcElectricFlowStorageDeviceTypeEnum :: Capacitorbank , "HARMONICFILTER" => IfcElectricFlowStorageDeviceTypeEnum :: Harmonicfilter , "INDUCTORBANK" => IfcElectricFlowStorageDeviceTypeEnum :: Inductorbank , "UPS" => IfcElectricFlowStorageDeviceTypeEnum :: Ups , "USERDEFINED" => IfcElectricFlowStorageDeviceTypeEnum :: Userdefined , "NOTDEFINED" => IfcElectricFlowStorageDeviceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElectricFlowStorageDeviceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElectricFlowStorageDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElectricFlowStorageDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElectricGeneratorTypeEnum { Chp , Enginegenerator , Standalone , Userdefined , Notdefined , } impl Default for IfcElectricGeneratorTypeEnum { fn default () -> Self { IfcElectricGeneratorTypeEnum :: Chp } } impl From < String > for IfcElectricGeneratorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CHP" => IfcElectricGeneratorTypeEnum :: Chp , "ENGINEGENERATOR" => IfcElectricGeneratorTypeEnum :: Enginegenerator , "STANDALONE" => IfcElectricGeneratorTypeEnum :: Standalone , "USERDEFINED" => IfcElectricGeneratorTypeEnum :: Userdefined , "NOTDEFINED" => IfcElectricGeneratorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElectricGeneratorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElectricGeneratorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElectricGeneratorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElectricMotorTypeEnum { Dc , Induction , Polyphase , Reluctancesynchronous , Synchronous , Userdefined , Notdefined , } impl Default for IfcElectricMotorTypeEnum { fn default () -> Self { IfcElectricMotorTypeEnum :: Dc } } impl From < String > for IfcElectricMotorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DC" => IfcElectricMotorTypeEnum :: Dc , "INDUCTION" => IfcElectricMotorTypeEnum :: Induction , "POLYPHASE" => IfcElectricMotorTypeEnum :: Polyphase , "RELUCTANCESYNCHRONOUS" => IfcElectricMotorTypeEnum :: Reluctancesynchronous , "SYNCHRONOUS" => IfcElectricMotorTypeEnum :: Synchronous , "USERDEFINED" => IfcElectricMotorTypeEnum :: Userdefined , "NOTDEFINED" => IfcElectricMotorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElectricMotorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElectricMotorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElectricMotorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElectricTimeControlTypeEnum { Timeclock , Timedelay , Relay , Userdefined , Notdefined , } impl Default for IfcElectricTimeControlTypeEnum { fn default () -> Self { IfcElectricTimeControlTypeEnum :: Timeclock } } impl From < String > for IfcElectricTimeControlTypeEnum { fn from (value : String) -> Self { match value . as_str () { "TIMECLOCK" => IfcElectricTimeControlTypeEnum :: Timeclock , "TIMEDELAY" => IfcElectricTimeControlTypeEnum :: Timedelay , "RELAY" => IfcElectricTimeControlTypeEnum :: Relay , "USERDEFINED" => IfcElectricTimeControlTypeEnum :: Userdefined , "NOTDEFINED" => IfcElectricTimeControlTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElectricTimeControlTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElectricTimeControlTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElectricTimeControlTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElementAssemblyTypeEnum { AccessoryAssembly , Arch , BeamGrid , BracedFrame , Girder , ReinforcementUnit , RigidFrame , SlabField , Truss , Userdefined , Notdefined , } impl Default for IfcElementAssemblyTypeEnum { fn default () -> Self { IfcElementAssemblyTypeEnum :: AccessoryAssembly } } impl From < String > for IfcElementAssemblyTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ACCESSORY_ASSEMBLY" => IfcElementAssemblyTypeEnum :: AccessoryAssembly , "ARCH" => IfcElementAssemblyTypeEnum :: Arch , "BEAM_GRID" => IfcElementAssemblyTypeEnum :: BeamGrid , "BRACED_FRAME" => IfcElementAssemblyTypeEnum :: BracedFrame , "GIRDER" => IfcElementAssemblyTypeEnum :: Girder , "REINFORCEMENT_UNIT" => IfcElementAssemblyTypeEnum :: ReinforcementUnit , "RIGID_FRAME" => IfcElementAssemblyTypeEnum :: RigidFrame , "SLAB_FIELD" => IfcElementAssemblyTypeEnum :: SlabField , "TRUSS" => IfcElementAssemblyTypeEnum :: Truss , "USERDEFINED" => IfcElementAssemblyTypeEnum :: Userdefined , "NOTDEFINED" => IfcElementAssemblyTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElementAssemblyTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElementAssemblyTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElementAssemblyTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcElementCompositionEnum { Complex , Element , Partial , } impl Default for IfcElementCompositionEnum { fn default () -> Self { IfcElementCompositionEnum :: Complex } } impl From < String > for IfcElementCompositionEnum { fn from (value : String) -> Self { match value . as_str () { "COMPLEX" => IfcElementCompositionEnum :: Complex , "ELEMENT" => IfcElementCompositionEnum :: Element , "PARTIAL" => IfcElementCompositionEnum :: Partial , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcElementCompositionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcElementCompositionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcElementCompositionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcEngineTypeEnum { Externalcombustion , Internalcombustion , Userdefined , Notdefined , } impl Default for IfcEngineTypeEnum { fn default () -> Self { IfcEngineTypeEnum :: Externalcombustion } } impl From < String > for IfcEngineTypeEnum { fn from (value : String) -> Self { match value . as_str () { "EXTERNALCOMBUSTION" => IfcEngineTypeEnum :: Externalcombustion , "INTERNALCOMBUSTION" => IfcEngineTypeEnum :: Internalcombustion , "USERDEFINED" => IfcEngineTypeEnum :: Userdefined , "NOTDEFINED" => IfcEngineTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcEngineTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcEngineTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcEngineTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcEvaporativeCoolerTypeEnum { Directevaporativerandommediaaircooler , Directevaporativerigidmediaaircooler , Directevaporativeslingerspackagedaircooler , Directevaporativepackagedrotaryaircooler , Directevaporativeairwasher , Indirectevaporativepackageaircooler , Indirectevaporativewetcoil , Indirectevaporativecoolingtowerorcoilcooler , Indirectdirectcombination , Userdefined , Notdefined , } impl Default for IfcEvaporativeCoolerTypeEnum { fn default () -> Self { IfcEvaporativeCoolerTypeEnum :: Directevaporativerandommediaaircooler } } impl From < String > for IfcEvaporativeCoolerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER" => IfcEvaporativeCoolerTypeEnum :: Directevaporativerandommediaaircooler , "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER" => IfcEvaporativeCoolerTypeEnum :: Directevaporativerigidmediaaircooler , "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER" => IfcEvaporativeCoolerTypeEnum :: Directevaporativeslingerspackagedaircooler , "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER" => IfcEvaporativeCoolerTypeEnum :: Directevaporativepackagedrotaryaircooler , "DIRECTEVAPORATIVEAIRWASHER" => IfcEvaporativeCoolerTypeEnum :: Directevaporativeairwasher , "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER" => IfcEvaporativeCoolerTypeEnum :: Indirectevaporativepackageaircooler , "INDIRECTEVAPORATIVEWETCOIL" => IfcEvaporativeCoolerTypeEnum :: Indirectevaporativewetcoil , "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER" => IfcEvaporativeCoolerTypeEnum :: Indirectevaporativecoolingtowerorcoilcooler , "INDIRECTDIRECTCOMBINATION" => IfcEvaporativeCoolerTypeEnum :: Indirectdirectcombination , "USERDEFINED" => IfcEvaporativeCoolerTypeEnum :: Userdefined , "NOTDEFINED" => IfcEvaporativeCoolerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcEvaporativeCoolerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcEvaporativeCoolerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcEvaporativeCoolerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcEvaporatorTypeEnum { Directexpansion , Directexpansionshellandtube , Directexpansiontubeintube , Directexpansionbrazedplate , Floodedshellandtube , Shellandcoil , Userdefined , Notdefined , } impl Default for IfcEvaporatorTypeEnum { fn default () -> Self { IfcEvaporatorTypeEnum :: Directexpansion } } impl From < String > for IfcEvaporatorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DIRECTEXPANSION" => IfcEvaporatorTypeEnum :: Directexpansion , "DIRECTEXPANSIONSHELLANDTUBE" => IfcEvaporatorTypeEnum :: Directexpansionshellandtube , "DIRECTEXPANSIONTUBEINTUBE" => IfcEvaporatorTypeEnum :: Directexpansiontubeintube , "DIRECTEXPANSIONBRAZEDPLATE" => IfcEvaporatorTypeEnum :: Directexpansionbrazedplate , "FLOODEDSHELLANDTUBE" => IfcEvaporatorTypeEnum :: Floodedshellandtube , "SHELLANDCOIL" => IfcEvaporatorTypeEnum :: Shellandcoil , "USERDEFINED" => IfcEvaporatorTypeEnum :: Userdefined , "NOTDEFINED" => IfcEvaporatorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcEvaporatorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcEvaporatorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcEvaporatorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcEventTriggerTypeEnum { Eventrule , Eventmessage , Eventtime , Eventcomplex , Userdefined , Notdefined , } impl Default for IfcEventTriggerTypeEnum { fn default () -> Self { IfcEventTriggerTypeEnum :: Eventrule } } impl From < String > for IfcEventTriggerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "EVENTRULE" => IfcEventTriggerTypeEnum :: Eventrule , "EVENTMESSAGE" => IfcEventTriggerTypeEnum :: Eventmessage , "EVENTTIME" => IfcEventTriggerTypeEnum :: Eventtime , "EVENTCOMPLEX" => IfcEventTriggerTypeEnum :: Eventcomplex , "USERDEFINED" => IfcEventTriggerTypeEnum :: Userdefined , "NOTDEFINED" => IfcEventTriggerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcEventTriggerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcEventTriggerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcEventTriggerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcEventTypeEnum { Startevent , Endevent , Intermediateevent , Userdefined , Notdefined , } impl Default for IfcEventTypeEnum { fn default () -> Self { IfcEventTypeEnum :: Startevent } } impl From < String > for IfcEventTypeEnum { fn from (value : String) -> Self { match value . as_str () { "STARTEVENT" => IfcEventTypeEnum :: Startevent , "ENDEVENT" => IfcEventTypeEnum :: Endevent , "INTERMEDIATEEVENT" => IfcEventTypeEnum :: Intermediateevent , "USERDEFINED" => IfcEventTypeEnum :: Userdefined , "NOTDEFINED" => IfcEventTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcEventTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcEventTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcEventTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcExternalSpatialElementTypeEnum { External , ExternalEarth , ExternalWater , ExternalFire , Userdefined , Notdefined , } impl Default for IfcExternalSpatialElementTypeEnum { fn default () -> Self { IfcExternalSpatialElementTypeEnum :: External } } impl From < String > for IfcExternalSpatialElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "EXTERNAL" => IfcExternalSpatialElementTypeEnum :: External , "EXTERNAL_EARTH" => IfcExternalSpatialElementTypeEnum :: ExternalEarth , "EXTERNAL_WATER" => IfcExternalSpatialElementTypeEnum :: ExternalWater , "EXTERNAL_FIRE" => IfcExternalSpatialElementTypeEnum :: ExternalFire , "USERDEFINED" => IfcExternalSpatialElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcExternalSpatialElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcExternalSpatialElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcExternalSpatialElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcExternalSpatialElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFanTypeEnum { Centrifugalforwardcurved , Centrifugalradial , Centrifugalbackwardinclinedcurved , Centrifugalairfoil , Tubeaxial , Vaneaxial , Propelloraxial , Userdefined , Notdefined , } impl Default for IfcFanTypeEnum { fn default () -> Self { IfcFanTypeEnum :: Centrifugalforwardcurved } } impl From < String > for IfcFanTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CENTRIFUGALFORWARDCURVED" => IfcFanTypeEnum :: Centrifugalforwardcurved , "CENTRIFUGALRADIAL" => IfcFanTypeEnum :: Centrifugalradial , "CENTRIFUGALBACKWARDINCLINEDCURVED" => IfcFanTypeEnum :: Centrifugalbackwardinclinedcurved , "CENTRIFUGALAIRFOIL" => IfcFanTypeEnum :: Centrifugalairfoil , "TUBEAXIAL" => IfcFanTypeEnum :: Tubeaxial , "VANEAXIAL" => IfcFanTypeEnum :: Vaneaxial , "PROPELLORAXIAL" => IfcFanTypeEnum :: Propelloraxial , "USERDEFINED" => IfcFanTypeEnum :: Userdefined , "NOTDEFINED" => IfcFanTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFanTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFanTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFanTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFastenerTypeEnum { Glue , Mortar , Weld , Userdefined , Notdefined , } impl Default for IfcFastenerTypeEnum { fn default () -> Self { IfcFastenerTypeEnum :: Glue } } impl From < String > for IfcFastenerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "GLUE" => IfcFastenerTypeEnum :: Glue , "MORTAR" => IfcFastenerTypeEnum :: Mortar , "WELD" => IfcFastenerTypeEnum :: Weld , "USERDEFINED" => IfcFastenerTypeEnum :: Userdefined , "NOTDEFINED" => IfcFastenerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFastenerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFastenerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFastenerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFilterTypeEnum { Airparticlefilter , Compressedairfilter , Odorfilter , Oilfilter , Strainer , Waterfilter , Userdefined , Notdefined , } impl Default for IfcFilterTypeEnum { fn default () -> Self { IfcFilterTypeEnum :: Airparticlefilter } } impl From < String > for IfcFilterTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AIRPARTICLEFILTER" => IfcFilterTypeEnum :: Airparticlefilter , "COMPRESSEDAIRFILTER" => IfcFilterTypeEnum :: Compressedairfilter , "ODORFILTER" => IfcFilterTypeEnum :: Odorfilter , "OILFILTER" => IfcFilterTypeEnum :: Oilfilter , "STRAINER" => IfcFilterTypeEnum :: Strainer , "WATERFILTER" => IfcFilterTypeEnum :: Waterfilter , "USERDEFINED" => IfcFilterTypeEnum :: Userdefined , "NOTDEFINED" => IfcFilterTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFilterTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFilterTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFilterTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFireSuppressionTerminalTypeEnum { Breechinginlet , Firehydrant , Hosereel , Sprinkler , Sprinklerdeflector , Userdefined , Notdefined , } impl Default for IfcFireSuppressionTerminalTypeEnum { fn default () -> Self { IfcFireSuppressionTerminalTypeEnum :: Breechinginlet } } impl From < String > for IfcFireSuppressionTerminalTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BREECHINGINLET" => IfcFireSuppressionTerminalTypeEnum :: Breechinginlet , "FIREHYDRANT" => IfcFireSuppressionTerminalTypeEnum :: Firehydrant , "HOSEREEL" => IfcFireSuppressionTerminalTypeEnum :: Hosereel , "SPRINKLER" => IfcFireSuppressionTerminalTypeEnum :: Sprinkler , "SPRINKLERDEFLECTOR" => IfcFireSuppressionTerminalTypeEnum :: Sprinklerdeflector , "USERDEFINED" => IfcFireSuppressionTerminalTypeEnum :: Userdefined , "NOTDEFINED" => IfcFireSuppressionTerminalTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFireSuppressionTerminalTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFireSuppressionTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFireSuppressionTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFlowDirectionEnum { Source , Sink , Sourceandsink , Notdefined , } impl Default for IfcFlowDirectionEnum { fn default () -> Self { IfcFlowDirectionEnum :: Source } } impl From < String > for IfcFlowDirectionEnum { fn from (value : String) -> Self { match value . as_str () { "SOURCE" => IfcFlowDirectionEnum :: Source , "SINK" => IfcFlowDirectionEnum :: Sink , "SOURCEANDSINK" => IfcFlowDirectionEnum :: Sourceandsink , "NOTDEFINED" => IfcFlowDirectionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFlowDirectionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFlowDirectionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFlowDirectionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFlowInstrumentTypeEnum { Pressuregauge , Thermometer , Ammeter , Frequencymeter , Powerfactormeter , Phaseanglemeter , VoltmeterPeak , VoltmeterRms , Userdefined , Notdefined , } impl Default for IfcFlowInstrumentTypeEnum { fn default () -> Self { IfcFlowInstrumentTypeEnum :: Pressuregauge } } impl From < String > for IfcFlowInstrumentTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PRESSUREGAUGE" => IfcFlowInstrumentTypeEnum :: Pressuregauge , "THERMOMETER" => IfcFlowInstrumentTypeEnum :: Thermometer , "AMMETER" => IfcFlowInstrumentTypeEnum :: Ammeter , "FREQUENCYMETER" => IfcFlowInstrumentTypeEnum :: Frequencymeter , "POWERFACTORMETER" => IfcFlowInstrumentTypeEnum :: Powerfactormeter , "PHASEANGLEMETER" => IfcFlowInstrumentTypeEnum :: Phaseanglemeter , "VOLTMETER_PEAK" => IfcFlowInstrumentTypeEnum :: VoltmeterPeak , "VOLTMETER_RMS" => IfcFlowInstrumentTypeEnum :: VoltmeterRms , "USERDEFINED" => IfcFlowInstrumentTypeEnum :: Userdefined , "NOTDEFINED" => IfcFlowInstrumentTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFlowInstrumentTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFlowInstrumentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFlowInstrumentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFlowMeterTypeEnum { Energymeter , Gasmeter , Oilmeter , Watermeter , Userdefined , Notdefined , } impl Default for IfcFlowMeterTypeEnum { fn default () -> Self { IfcFlowMeterTypeEnum :: Energymeter } } impl From < String > for IfcFlowMeterTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ENERGYMETER" => IfcFlowMeterTypeEnum :: Energymeter , "GASMETER" => IfcFlowMeterTypeEnum :: Gasmeter , "OILMETER" => IfcFlowMeterTypeEnum :: Oilmeter , "WATERMETER" => IfcFlowMeterTypeEnum :: Watermeter , "USERDEFINED" => IfcFlowMeterTypeEnum :: Userdefined , "NOTDEFINED" => IfcFlowMeterTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFlowMeterTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFlowMeterTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFlowMeterTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFootingTypeEnum { CaissonFoundation , FootingBeam , PadFooting , PileCap , StripFooting , Userdefined , Notdefined , } impl Default for IfcFootingTypeEnum { fn default () -> Self { IfcFootingTypeEnum :: CaissonFoundation } } impl From < String > for IfcFootingTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CAISSON_FOUNDATION" => IfcFootingTypeEnum :: CaissonFoundation , "FOOTING_BEAM" => IfcFootingTypeEnum :: FootingBeam , "PAD_FOOTING" => IfcFootingTypeEnum :: PadFooting , "PILE_CAP" => IfcFootingTypeEnum :: PileCap , "STRIP_FOOTING" => IfcFootingTypeEnum :: StripFooting , "USERDEFINED" => IfcFootingTypeEnum :: Userdefined , "NOTDEFINED" => IfcFootingTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFootingTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFootingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFootingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFurnitureTypeEnum { Chair , Table , Desk , Bed , Filecabinet , Shelf , Sofa , Userdefined , Notdefined , } impl Default for IfcFurnitureTypeEnum { fn default () -> Self { IfcFurnitureTypeEnum :: Chair } } impl From < String > for IfcFurnitureTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CHAIR" => IfcFurnitureTypeEnum :: Chair , "TABLE" => IfcFurnitureTypeEnum :: Table , "DESK" => IfcFurnitureTypeEnum :: Desk , "BED" => IfcFurnitureTypeEnum :: Bed , "FILECABINET" => IfcFurnitureTypeEnum :: Filecabinet , "SHELF" => IfcFurnitureTypeEnum :: Shelf , "SOFA" => IfcFurnitureTypeEnum :: Sofa , "USERDEFINED" => IfcFurnitureTypeEnum :: Userdefined , "NOTDEFINED" => IfcFurnitureTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcFurnitureTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcFurnitureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcFurnitureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcGeographicElementTypeEnum { Terrain , Userdefined , Notdefined , } impl Default for IfcGeographicElementTypeEnum { fn default () -> Self { IfcGeographicElementTypeEnum :: Terrain } } impl From < String > for IfcGeographicElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "TERRAIN" => IfcGeographicElementTypeEnum :: Terrain , "USERDEFINED" => IfcGeographicElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcGeographicElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcGeographicElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcGeographicElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcGeographicElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcGeometricProjectionEnum { GraphView , SketchView , ModelView , PlanView , ReflectedPlanView , SectionView , ElevationView , Userdefined , Notdefined , } impl Default for IfcGeometricProjectionEnum { fn default () -> Self { IfcGeometricProjectionEnum :: GraphView } } impl From < String > for IfcGeometricProjectionEnum { fn from (value : String) -> Self { match value . as_str () { "GRAPH_VIEW" => IfcGeometricProjectionEnum :: GraphView , "SKETCH_VIEW" => IfcGeometricProjectionEnum :: SketchView , "MODEL_VIEW" => IfcGeometricProjectionEnum :: ModelView , "PLAN_VIEW" => IfcGeometricProjectionEnum :: PlanView , "REFLECTED_PLAN_VIEW" => IfcGeometricProjectionEnum :: ReflectedPlanView , "SECTION_VIEW" => IfcGeometricProjectionEnum :: SectionView , "ELEVATION_VIEW" => IfcGeometricProjectionEnum :: ElevationView , "USERDEFINED" => IfcGeometricProjectionEnum :: Userdefined , "NOTDEFINED" => IfcGeometricProjectionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcGeometricProjectionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcGeometricProjectionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcGeometricProjectionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcGlobalOrLocalEnum { GlobalCoords , LocalCoords , } impl Default for IfcGlobalOrLocalEnum { fn default () -> Self { IfcGlobalOrLocalEnum :: GlobalCoords } } impl From < String > for IfcGlobalOrLocalEnum { fn from (value : String) -> Self { match value . as_str () { "GLOBAL_COORDS" => IfcGlobalOrLocalEnum :: GlobalCoords , "LOCAL_COORDS" => IfcGlobalOrLocalEnum :: LocalCoords , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcGlobalOrLocalEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcGlobalOrLocalEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcGlobalOrLocalEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcGridTypeEnum { Rectangular , Radial , Triangular , Irregular , Userdefined , Notdefined , } impl Default for IfcGridTypeEnum { fn default () -> Self { IfcGridTypeEnum :: Rectangular } } impl From < String > for IfcGridTypeEnum { fn from (value : String) -> Self { match value . as_str () { "RECTANGULAR" => IfcGridTypeEnum :: Rectangular , "RADIAL" => IfcGridTypeEnum :: Radial , "TRIANGULAR" => IfcGridTypeEnum :: Triangular , "IRREGULAR" => IfcGridTypeEnum :: Irregular , "USERDEFINED" => IfcGridTypeEnum :: Userdefined , "NOTDEFINED" => IfcGridTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcGridTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcGridTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcGridTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcHeatExchangerTypeEnum { Plate , Shellandtube , Userdefined , Notdefined , } impl Default for IfcHeatExchangerTypeEnum { fn default () -> Self { IfcHeatExchangerTypeEnum :: Plate } } impl From < String > for IfcHeatExchangerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PLATE" => IfcHeatExchangerTypeEnum :: Plate , "SHELLANDTUBE" => IfcHeatExchangerTypeEnum :: Shellandtube , "USERDEFINED" => IfcHeatExchangerTypeEnum :: Userdefined , "NOTDEFINED" => IfcHeatExchangerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcHeatExchangerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcHeatExchangerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcHeatExchangerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcHumidifierTypeEnum { Steaminjection , Adiabaticairwasher , Adiabaticpan , Adiabaticwettedelement , Adiabaticatomizing , Adiabaticultrasonic , Adiabaticrigidmedia , Adiabaticcompressedairnozzle , Assistedelectric , Assistednaturalgas , Assistedpropane , Assistedbutane , Assistedsteam , Userdefined , Notdefined , } impl Default for IfcHumidifierTypeEnum { fn default () -> Self { IfcHumidifierTypeEnum :: Steaminjection } } impl From < String > for IfcHumidifierTypeEnum { fn from (value : String) -> Self { match value . as_str () { "STEAMINJECTION" => IfcHumidifierTypeEnum :: Steaminjection , "ADIABATICAIRWASHER" => IfcHumidifierTypeEnum :: Adiabaticairwasher , "ADIABATICPAN" => IfcHumidifierTypeEnum :: Adiabaticpan , "ADIABATICWETTEDELEMENT" => IfcHumidifierTypeEnum :: Adiabaticwettedelement , "ADIABATICATOMIZING" => IfcHumidifierTypeEnum :: Adiabaticatomizing , "ADIABATICULTRASONIC" => IfcHumidifierTypeEnum :: Adiabaticultrasonic , "ADIABATICRIGIDMEDIA" => IfcHumidifierTypeEnum :: Adiabaticrigidmedia , "ADIABATICCOMPRESSEDAIRNOZZLE" => IfcHumidifierTypeEnum :: Adiabaticcompressedairnozzle , "ASSISTEDELECTRIC" => IfcHumidifierTypeEnum :: Assistedelectric , "ASSISTEDNATURALGAS" => IfcHumidifierTypeEnum :: Assistednaturalgas , "ASSISTEDPROPANE" => IfcHumidifierTypeEnum :: Assistedpropane , "ASSISTEDBUTANE" => IfcHumidifierTypeEnum :: Assistedbutane , "ASSISTEDSTEAM" => IfcHumidifierTypeEnum :: Assistedsteam , "USERDEFINED" => IfcHumidifierTypeEnum :: Userdefined , "NOTDEFINED" => IfcHumidifierTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcHumidifierTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcHumidifierTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcHumidifierTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcInterceptorTypeEnum { Cyclonic , Grease , Oil , Petrol , Userdefined , Notdefined , } impl Default for IfcInterceptorTypeEnum { fn default () -> Self { IfcInterceptorTypeEnum :: Cyclonic } } impl From < String > for IfcInterceptorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CYCLONIC" => IfcInterceptorTypeEnum :: Cyclonic , "GREASE" => IfcInterceptorTypeEnum :: Grease , "OIL" => IfcInterceptorTypeEnum :: Oil , "PETROL" => IfcInterceptorTypeEnum :: Petrol , "USERDEFINED" => IfcInterceptorTypeEnum :: Userdefined , "NOTDEFINED" => IfcInterceptorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcInterceptorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcInterceptorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcInterceptorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcInternalOrExternalEnum { Internal , External , ExternalEarth , ExternalWater , ExternalFire , Notdefined , } impl Default for IfcInternalOrExternalEnum { fn default () -> Self { IfcInternalOrExternalEnum :: Internal } } impl From < String > for IfcInternalOrExternalEnum { fn from (value : String) -> Self { match value . as_str () { "INTERNAL" => IfcInternalOrExternalEnum :: Internal , "EXTERNAL" => IfcInternalOrExternalEnum :: External , "EXTERNAL_EARTH" => IfcInternalOrExternalEnum :: ExternalEarth , "EXTERNAL_WATER" => IfcInternalOrExternalEnum :: ExternalWater , "EXTERNAL_FIRE" => IfcInternalOrExternalEnum :: ExternalFire , "NOTDEFINED" => IfcInternalOrExternalEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcInternalOrExternalEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcInternalOrExternalEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcInternalOrExternalEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcInventoryTypeEnum { Assetinventory , Spaceinventory , Furnitureinventory , Userdefined , Notdefined , } impl Default for IfcInventoryTypeEnum { fn default () -> Self { IfcInventoryTypeEnum :: Assetinventory } } impl From < String > for IfcInventoryTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ASSETINVENTORY" => IfcInventoryTypeEnum :: Assetinventory , "SPACEINVENTORY" => IfcInventoryTypeEnum :: Spaceinventory , "FURNITUREINVENTORY" => IfcInventoryTypeEnum :: Furnitureinventory , "USERDEFINED" => IfcInventoryTypeEnum :: Userdefined , "NOTDEFINED" => IfcInventoryTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcInventoryTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcInventoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcInventoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcJunctionBoxTypeEnum { Data , Power , Userdefined , Notdefined , } impl Default for IfcJunctionBoxTypeEnum { fn default () -> Self { IfcJunctionBoxTypeEnum :: Data } } impl From < String > for IfcJunctionBoxTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DATA" => IfcJunctionBoxTypeEnum :: Data , "POWER" => IfcJunctionBoxTypeEnum :: Power , "USERDEFINED" => IfcJunctionBoxTypeEnum :: Userdefined , "NOTDEFINED" => IfcJunctionBoxTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcJunctionBoxTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcJunctionBoxTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcJunctionBoxTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcKnotType { UniformKnots , QuasiUniformKnots , PiecewiseBezierKnots , Unspecified , } impl Default for IfcKnotType { fn default () -> Self { IfcKnotType :: UniformKnots } } impl From < String > for IfcKnotType { fn from (value : String) -> Self { match value . as_str () { "UNIFORM_KNOTS" => IfcKnotType :: UniformKnots , "QUASI_UNIFORM_KNOTS" => IfcKnotType :: QuasiUniformKnots , "PIECEWISE_BEZIER_KNOTS" => IfcKnotType :: PiecewiseBezierKnots , "UNSPECIFIED" => IfcKnotType :: Unspecified , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcKnotType { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcKnotType :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcKnotType :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLaborResourceTypeEnum { Administration , Carpentry , Cleaning , Concrete , Drywall , Electric , Finishing , Flooring , General , Hvac , Landscaping , Masonry , Painting , Paving , Plumbing , Roofing , Sitegrading , Steelwork , Surveying , Userdefined , Notdefined , } impl Default for IfcLaborResourceTypeEnum { fn default () -> Self { IfcLaborResourceTypeEnum :: Administration } } impl From < String > for IfcLaborResourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ADMINISTRATION" => IfcLaborResourceTypeEnum :: Administration , "CARPENTRY" => IfcLaborResourceTypeEnum :: Carpentry , "CLEANING" => IfcLaborResourceTypeEnum :: Cleaning , "CONCRETE" => IfcLaborResourceTypeEnum :: Concrete , "DRYWALL" => IfcLaborResourceTypeEnum :: Drywall , "ELECTRIC" => IfcLaborResourceTypeEnum :: Electric , "FINISHING" => IfcLaborResourceTypeEnum :: Finishing , "FLOORING" => IfcLaborResourceTypeEnum :: Flooring , "GENERAL" => IfcLaborResourceTypeEnum :: General , "HVAC" => IfcLaborResourceTypeEnum :: Hvac , "LANDSCAPING" => IfcLaborResourceTypeEnum :: Landscaping , "MASONRY" => IfcLaborResourceTypeEnum :: Masonry , "PAINTING" => IfcLaborResourceTypeEnum :: Painting , "PAVING" => IfcLaborResourceTypeEnum :: Paving , "PLUMBING" => IfcLaborResourceTypeEnum :: Plumbing , "ROOFING" => IfcLaborResourceTypeEnum :: Roofing , "SITEGRADING" => IfcLaborResourceTypeEnum :: Sitegrading , "STEELWORK" => IfcLaborResourceTypeEnum :: Steelwork , "SURVEYING" => IfcLaborResourceTypeEnum :: Surveying , "USERDEFINED" => IfcLaborResourceTypeEnum :: Userdefined , "NOTDEFINED" => IfcLaborResourceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLaborResourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLaborResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLaborResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLampTypeEnum { Compactfluorescent , Fluorescent , Halogen , Highpressuremercury , Highpressuresodium , Led , Metalhalide , Oled , Tungstenfilament , Userdefined , Notdefined , } impl Default for IfcLampTypeEnum { fn default () -> Self { IfcLampTypeEnum :: Compactfluorescent } } impl From < String > for IfcLampTypeEnum { fn from (value : String) -> Self { match value . as_str () { "COMPACTFLUORESCENT" => IfcLampTypeEnum :: Compactfluorescent , "FLUORESCENT" => IfcLampTypeEnum :: Fluorescent , "HALOGEN" => IfcLampTypeEnum :: Halogen , "HIGHPRESSUREMERCURY" => IfcLampTypeEnum :: Highpressuremercury , "HIGHPRESSURESODIUM" => IfcLampTypeEnum :: Highpressuresodium , "LED" => IfcLampTypeEnum :: Led , "METALHALIDE" => IfcLampTypeEnum :: Metalhalide , "OLED" => IfcLampTypeEnum :: Oled , "TUNGSTENFILAMENT" => IfcLampTypeEnum :: Tungstenfilament , "USERDEFINED" => IfcLampTypeEnum :: Userdefined , "NOTDEFINED" => IfcLampTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLampTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLampTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLampTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLayerSetDirectionEnum { Axis1 , Axis2 , Axis3 , } impl Default for IfcLayerSetDirectionEnum { fn default () -> Self { IfcLayerSetDirectionEnum :: Axis1 } } impl From < String > for IfcLayerSetDirectionEnum { fn from (value : String) -> Self { match value . as_str () { "AXIS1" => IfcLayerSetDirectionEnum :: Axis1 , "AXIS2" => IfcLayerSetDirectionEnum :: Axis2 , "AXIS3" => IfcLayerSetDirectionEnum :: Axis3 , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLayerSetDirectionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLayerSetDirectionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLayerSetDirectionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLightDistributionCurveEnum { TypeA , TypeB , TypeC , Notdefined , } impl Default for IfcLightDistributionCurveEnum { fn default () -> Self { IfcLightDistributionCurveEnum :: TypeA } } impl From < String > for IfcLightDistributionCurveEnum { fn from (value : String) -> Self { match value . as_str () { "TYPE_A" => IfcLightDistributionCurveEnum :: TypeA , "TYPE_B" => IfcLightDistributionCurveEnum :: TypeB , "TYPE_C" => IfcLightDistributionCurveEnum :: TypeC , "NOTDEFINED" => IfcLightDistributionCurveEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLightDistributionCurveEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLightDistributionCurveEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLightDistributionCurveEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLightEmissionSourceEnum { Compactfluorescent , Fluorescent , Highpressuremercury , Highpressuresodium , Lightemittingdiode , Lowpressuresodium , Lowvoltagehalogen , Mainvoltagehalogen , Metalhalide , Tungstenfilament , Notdefined , } impl Default for IfcLightEmissionSourceEnum { fn default () -> Self { IfcLightEmissionSourceEnum :: Compactfluorescent } } impl From < String > for IfcLightEmissionSourceEnum { fn from (value : String) -> Self { match value . as_str () { "COMPACTFLUORESCENT" => IfcLightEmissionSourceEnum :: Compactfluorescent , "FLUORESCENT" => IfcLightEmissionSourceEnum :: Fluorescent , "HIGHPRESSUREMERCURY" => IfcLightEmissionSourceEnum :: Highpressuremercury , "HIGHPRESSURESODIUM" => IfcLightEmissionSourceEnum :: Highpressuresodium , "LIGHTEMITTINGDIODE" => IfcLightEmissionSourceEnum :: Lightemittingdiode , "LOWPRESSURESODIUM" => IfcLightEmissionSourceEnum :: Lowpressuresodium , "LOWVOLTAGEHALOGEN" => IfcLightEmissionSourceEnum :: Lowvoltagehalogen , "MAINVOLTAGEHALOGEN" => IfcLightEmissionSourceEnum :: Mainvoltagehalogen , "METALHALIDE" => IfcLightEmissionSourceEnum :: Metalhalide , "TUNGSTENFILAMENT" => IfcLightEmissionSourceEnum :: Tungstenfilament , "NOTDEFINED" => IfcLightEmissionSourceEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLightEmissionSourceEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLightEmissionSourceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLightEmissionSourceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLightFixtureTypeEnum { Pointsource , Directionsource , Securitylighting , Userdefined , Notdefined , } impl Default for IfcLightFixtureTypeEnum { fn default () -> Self { IfcLightFixtureTypeEnum :: Pointsource } } impl From < String > for IfcLightFixtureTypeEnum { fn from (value : String) -> Self { match value . as_str () { "POINTSOURCE" => IfcLightFixtureTypeEnum :: Pointsource , "DIRECTIONSOURCE" => IfcLightFixtureTypeEnum :: Directionsource , "SECURITYLIGHTING" => IfcLightFixtureTypeEnum :: Securitylighting , "USERDEFINED" => IfcLightFixtureTypeEnum :: Userdefined , "NOTDEFINED" => IfcLightFixtureTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLightFixtureTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLightFixtureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLightFixtureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLoadGroupTypeEnum { LoadGroup , LoadCase , LoadCombination , Userdefined , Notdefined , } impl Default for IfcLoadGroupTypeEnum { fn default () -> Self { IfcLoadGroupTypeEnum :: LoadGroup } } impl From < String > for IfcLoadGroupTypeEnum { fn from (value : String) -> Self { match value . as_str () { "LOAD_GROUP" => IfcLoadGroupTypeEnum :: LoadGroup , "LOAD_CASE" => IfcLoadGroupTypeEnum :: LoadCase , "LOAD_COMBINATION" => IfcLoadGroupTypeEnum :: LoadCombination , "USERDEFINED" => IfcLoadGroupTypeEnum :: Userdefined , "NOTDEFINED" => IfcLoadGroupTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLoadGroupTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLoadGroupTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLoadGroupTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLogicalOperatorEnum { Logicaland , Logicalor , Logicalxor , Logicalnotand , Logicalnotor , } impl Default for IfcLogicalOperatorEnum { fn default () -> Self { IfcLogicalOperatorEnum :: Logicaland } } impl From < String > for IfcLogicalOperatorEnum { fn from (value : String) -> Self { match value . as_str () { "LOGICALAND" => IfcLogicalOperatorEnum :: Logicaland , "LOGICALOR" => IfcLogicalOperatorEnum :: Logicalor , "LOGICALXOR" => IfcLogicalOperatorEnum :: Logicalxor , "LOGICALNOTAND" => IfcLogicalOperatorEnum :: Logicalnotand , "LOGICALNOTOR" => IfcLogicalOperatorEnum :: Logicalnotor , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcLogicalOperatorEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcLogicalOperatorEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcLogicalOperatorEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcMechanicalFastenerTypeEnum { Anchorbolt , Bolt , Dowel , Nail , Nailplate , Rivet , Screw , Shearconnector , Staple , Studshearconnector , Userdefined , Notdefined , } impl Default for IfcMechanicalFastenerTypeEnum { fn default () -> Self { IfcMechanicalFastenerTypeEnum :: Anchorbolt } } impl From < String > for IfcMechanicalFastenerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ANCHORBOLT" => IfcMechanicalFastenerTypeEnum :: Anchorbolt , "BOLT" => IfcMechanicalFastenerTypeEnum :: Bolt , "DOWEL" => IfcMechanicalFastenerTypeEnum :: Dowel , "NAIL" => IfcMechanicalFastenerTypeEnum :: Nail , "NAILPLATE" => IfcMechanicalFastenerTypeEnum :: Nailplate , "RIVET" => IfcMechanicalFastenerTypeEnum :: Rivet , "SCREW" => IfcMechanicalFastenerTypeEnum :: Screw , "SHEARCONNECTOR" => IfcMechanicalFastenerTypeEnum :: Shearconnector , "STAPLE" => IfcMechanicalFastenerTypeEnum :: Staple , "STUDSHEARCONNECTOR" => IfcMechanicalFastenerTypeEnum :: Studshearconnector , "USERDEFINED" => IfcMechanicalFastenerTypeEnum :: Userdefined , "NOTDEFINED" => IfcMechanicalFastenerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcMechanicalFastenerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcMechanicalFastenerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcMechanicalFastenerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcMedicalDeviceTypeEnum { Airstation , Feedairunit , Oxygengenerator , Oxygenplant , Vacuumstation , Userdefined , Notdefined , } impl Default for IfcMedicalDeviceTypeEnum { fn default () -> Self { IfcMedicalDeviceTypeEnum :: Airstation } } impl From < String > for IfcMedicalDeviceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AIRSTATION" => IfcMedicalDeviceTypeEnum :: Airstation , "FEEDAIRUNIT" => IfcMedicalDeviceTypeEnum :: Feedairunit , "OXYGENGENERATOR" => IfcMedicalDeviceTypeEnum :: Oxygengenerator , "OXYGENPLANT" => IfcMedicalDeviceTypeEnum :: Oxygenplant , "VACUUMSTATION" => IfcMedicalDeviceTypeEnum :: Vacuumstation , "USERDEFINED" => IfcMedicalDeviceTypeEnum :: Userdefined , "NOTDEFINED" => IfcMedicalDeviceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcMedicalDeviceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcMedicalDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcMedicalDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcMemberTypeEnum { Brace , Chord , Collar , Member , Mullion , Plate , Post , Purlin , Rafter , Stringer , Strut , Stud , Userdefined , Notdefined , } impl Default for IfcMemberTypeEnum { fn default () -> Self { IfcMemberTypeEnum :: Brace } } impl From < String > for IfcMemberTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BRACE" => IfcMemberTypeEnum :: Brace , "CHORD" => IfcMemberTypeEnum :: Chord , "COLLAR" => IfcMemberTypeEnum :: Collar , "MEMBER" => IfcMemberTypeEnum :: Member , "MULLION" => IfcMemberTypeEnum :: Mullion , "PLATE" => IfcMemberTypeEnum :: Plate , "POST" => IfcMemberTypeEnum :: Post , "PURLIN" => IfcMemberTypeEnum :: Purlin , "RAFTER" => IfcMemberTypeEnum :: Rafter , "STRINGER" => IfcMemberTypeEnum :: Stringer , "STRUT" => IfcMemberTypeEnum :: Strut , "STUD" => IfcMemberTypeEnum :: Stud , "USERDEFINED" => IfcMemberTypeEnum :: Userdefined , "NOTDEFINED" => IfcMemberTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcMemberTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcMemberTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcMemberTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcMotorConnectionTypeEnum { Beltdrive , Coupling , Directdrive , Userdefined , Notdefined , } impl Default for IfcMotorConnectionTypeEnum { fn default () -> Self { IfcMotorConnectionTypeEnum :: Beltdrive } } impl From < String > for IfcMotorConnectionTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BELTDRIVE" => IfcMotorConnectionTypeEnum :: Beltdrive , "COUPLING" => IfcMotorConnectionTypeEnum :: Coupling , "DIRECTDRIVE" => IfcMotorConnectionTypeEnum :: Directdrive , "USERDEFINED" => IfcMotorConnectionTypeEnum :: Userdefined , "NOTDEFINED" => IfcMotorConnectionTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcMotorConnectionTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcMotorConnectionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcMotorConnectionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcNullStyle { Null , } impl Default for IfcNullStyle { fn default () -> Self { IfcNullStyle :: Null } } impl From < String > for IfcNullStyle { fn from (value : String) -> Self { match value . as_str () { "NULL" => IfcNullStyle :: Null , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcNullStyle { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcNullStyle :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcNullStyle :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcObjectTypeEnum { Product , Process , Control , Resource , Actor , Group , Project , Notdefined , } impl Default for IfcObjectTypeEnum { fn default () -> Self { IfcObjectTypeEnum :: Product } } impl From < String > for IfcObjectTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PRODUCT" => IfcObjectTypeEnum :: Product , "PROCESS" => IfcObjectTypeEnum :: Process , "CONTROL" => IfcObjectTypeEnum :: Control , "RESOURCE" => IfcObjectTypeEnum :: Resource , "ACTOR" => IfcObjectTypeEnum :: Actor , "GROUP" => IfcObjectTypeEnum :: Group , "PROJECT" => IfcObjectTypeEnum :: Project , "NOTDEFINED" => IfcObjectTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcObjectTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcObjectTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcObjectTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcObjectiveEnum { Codecompliance , Codewaiver , Designintent , External , Healthandsafety , Mergeconflict , Modelview , Parameter , Requirement , Specification , Triggercondition , Userdefined , Notdefined , } impl Default for IfcObjectiveEnum { fn default () -> Self { IfcObjectiveEnum :: Codecompliance } } impl From < String > for IfcObjectiveEnum { fn from (value : String) -> Self { match value . as_str () { "CODECOMPLIANCE" => IfcObjectiveEnum :: Codecompliance , "CODEWAIVER" => IfcObjectiveEnum :: Codewaiver , "DESIGNINTENT" => IfcObjectiveEnum :: Designintent , "EXTERNAL" => IfcObjectiveEnum :: External , "HEALTHANDSAFETY" => IfcObjectiveEnum :: Healthandsafety , "MERGECONFLICT" => IfcObjectiveEnum :: Mergeconflict , "MODELVIEW" => IfcObjectiveEnum :: Modelview , "PARAMETER" => IfcObjectiveEnum :: Parameter , "REQUIREMENT" => IfcObjectiveEnum :: Requirement , "SPECIFICATION" => IfcObjectiveEnum :: Specification , "TRIGGERCONDITION" => IfcObjectiveEnum :: Triggercondition , "USERDEFINED" => IfcObjectiveEnum :: Userdefined , "NOTDEFINED" => IfcObjectiveEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcObjectiveEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcObjectiveEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcObjectiveEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcOccupantTypeEnum { Assignee , Assignor , Lessee , Lessor , Lettingagent , Owner , Tenant , Userdefined , Notdefined , } impl Default for IfcOccupantTypeEnum { fn default () -> Self { IfcOccupantTypeEnum :: Assignee } } impl From < String > for IfcOccupantTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ASSIGNEE" => IfcOccupantTypeEnum :: Assignee , "ASSIGNOR" => IfcOccupantTypeEnum :: Assignor , "LESSEE" => IfcOccupantTypeEnum :: Lessee , "LESSOR" => IfcOccupantTypeEnum :: Lessor , "LETTINGAGENT" => IfcOccupantTypeEnum :: Lettingagent , "OWNER" => IfcOccupantTypeEnum :: Owner , "TENANT" => IfcOccupantTypeEnum :: Tenant , "USERDEFINED" => IfcOccupantTypeEnum :: Userdefined , "NOTDEFINED" => IfcOccupantTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcOccupantTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcOccupantTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcOccupantTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcOpeningElementTypeEnum { Opening , Recess , Userdefined , Notdefined , } impl Default for IfcOpeningElementTypeEnum { fn default () -> Self { IfcOpeningElementTypeEnum :: Opening } } impl From < String > for IfcOpeningElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "OPENING" => IfcOpeningElementTypeEnum :: Opening , "RECESS" => IfcOpeningElementTypeEnum :: Recess , "USERDEFINED" => IfcOpeningElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcOpeningElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcOpeningElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcOpeningElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcOpeningElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcOutletTypeEnum { Audiovisualoutlet , Communicationsoutlet , Poweroutlet , Dataoutlet , Telephoneoutlet , Userdefined , Notdefined , } impl Default for IfcOutletTypeEnum { fn default () -> Self { IfcOutletTypeEnum :: Audiovisualoutlet } } impl From < String > for IfcOutletTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AUDIOVISUALOUTLET" => IfcOutletTypeEnum :: Audiovisualoutlet , "COMMUNICATIONSOUTLET" => IfcOutletTypeEnum :: Communicationsoutlet , "POWEROUTLET" => IfcOutletTypeEnum :: Poweroutlet , "DATAOUTLET" => IfcOutletTypeEnum :: Dataoutlet , "TELEPHONEOUTLET" => IfcOutletTypeEnum :: Telephoneoutlet , "USERDEFINED" => IfcOutletTypeEnum :: Userdefined , "NOTDEFINED" => IfcOutletTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcOutletTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcOutletTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcOutletTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPerformanceHistoryTypeEnum { Userdefined , Notdefined , } impl Default for IfcPerformanceHistoryTypeEnum { fn default () -> Self { IfcPerformanceHistoryTypeEnum :: Userdefined } } impl From < String > for IfcPerformanceHistoryTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcPerformanceHistoryTypeEnum :: Userdefined , "NOTDEFINED" => IfcPerformanceHistoryTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPerformanceHistoryTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPerformanceHistoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPerformanceHistoryTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPermeableCoveringOperationEnum { Grill , Louver , Screen , Userdefined , Notdefined , } impl Default for IfcPermeableCoveringOperationEnum { fn default () -> Self { IfcPermeableCoveringOperationEnum :: Grill } } impl From < String > for IfcPermeableCoveringOperationEnum { fn from (value : String) -> Self { match value . as_str () { "GRILL" => IfcPermeableCoveringOperationEnum :: Grill , "LOUVER" => IfcPermeableCoveringOperationEnum :: Louver , "SCREEN" => IfcPermeableCoveringOperationEnum :: Screen , "USERDEFINED" => IfcPermeableCoveringOperationEnum :: Userdefined , "NOTDEFINED" => IfcPermeableCoveringOperationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPermeableCoveringOperationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPermeableCoveringOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPermeableCoveringOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPermitTypeEnum { Access , Building , Work , Userdefined , Notdefined , } impl Default for IfcPermitTypeEnum { fn default () -> Self { IfcPermitTypeEnum :: Access } } impl From < String > for IfcPermitTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ACCESS" => IfcPermitTypeEnum :: Access , "BUILDING" => IfcPermitTypeEnum :: Building , "WORK" => IfcPermitTypeEnum :: Work , "USERDEFINED" => IfcPermitTypeEnum :: Userdefined , "NOTDEFINED" => IfcPermitTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPermitTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPermitTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPermitTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPhysicalOrVirtualEnum { Physical , Virtual , Notdefined , } impl Default for IfcPhysicalOrVirtualEnum { fn default () -> Self { IfcPhysicalOrVirtualEnum :: Physical } } impl From < String > for IfcPhysicalOrVirtualEnum { fn from (value : String) -> Self { match value . as_str () { "PHYSICAL" => IfcPhysicalOrVirtualEnum :: Physical , "VIRTUAL" => IfcPhysicalOrVirtualEnum :: Virtual , "NOTDEFINED" => IfcPhysicalOrVirtualEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPhysicalOrVirtualEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPhysicalOrVirtualEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPhysicalOrVirtualEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPileConstructionEnum { CastInPlace , Composite , PrecastConcrete , PrefabSteel , Userdefined , Notdefined , } impl Default for IfcPileConstructionEnum { fn default () -> Self { IfcPileConstructionEnum :: CastInPlace } } impl From < String > for IfcPileConstructionEnum { fn from (value : String) -> Self { match value . as_str () { "CAST_IN_PLACE" => IfcPileConstructionEnum :: CastInPlace , "COMPOSITE" => IfcPileConstructionEnum :: Composite , "PRECAST_CONCRETE" => IfcPileConstructionEnum :: PrecastConcrete , "PREFAB_STEEL" => IfcPileConstructionEnum :: PrefabSteel , "USERDEFINED" => IfcPileConstructionEnum :: Userdefined , "NOTDEFINED" => IfcPileConstructionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPileConstructionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPileConstructionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPileConstructionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPileTypeEnum { Bored , Driven , Jetgrouting , Cohesion , Friction , Support , Userdefined , Notdefined , } impl Default for IfcPileTypeEnum { fn default () -> Self { IfcPileTypeEnum :: Bored } } impl From < String > for IfcPileTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BORED" => IfcPileTypeEnum :: Bored , "DRIVEN" => IfcPileTypeEnum :: Driven , "JETGROUTING" => IfcPileTypeEnum :: Jetgrouting , "COHESION" => IfcPileTypeEnum :: Cohesion , "FRICTION" => IfcPileTypeEnum :: Friction , "SUPPORT" => IfcPileTypeEnum :: Support , "USERDEFINED" => IfcPileTypeEnum :: Userdefined , "NOTDEFINED" => IfcPileTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPileTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPileTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPileTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPipeFittingTypeEnum { Bend , Connector , Entry , Exit , Junction , Obstruction , Transition , Userdefined , Notdefined , } impl Default for IfcPipeFittingTypeEnum { fn default () -> Self { IfcPipeFittingTypeEnum :: Bend } } impl From < String > for IfcPipeFittingTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BEND" => IfcPipeFittingTypeEnum :: Bend , "CONNECTOR" => IfcPipeFittingTypeEnum :: Connector , "ENTRY" => IfcPipeFittingTypeEnum :: Entry , "EXIT" => IfcPipeFittingTypeEnum :: Exit , "JUNCTION" => IfcPipeFittingTypeEnum :: Junction , "OBSTRUCTION" => IfcPipeFittingTypeEnum :: Obstruction , "TRANSITION" => IfcPipeFittingTypeEnum :: Transition , "USERDEFINED" => IfcPipeFittingTypeEnum :: Userdefined , "NOTDEFINED" => IfcPipeFittingTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPipeFittingTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPipeFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPipeFittingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPipeSegmentTypeEnum { Culvert , Flexiblesegment , Rigidsegment , Gutter , Spool , Userdefined , Notdefined , } impl Default for IfcPipeSegmentTypeEnum { fn default () -> Self { IfcPipeSegmentTypeEnum :: Culvert } } impl From < String > for IfcPipeSegmentTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CULVERT" => IfcPipeSegmentTypeEnum :: Culvert , "FLEXIBLESEGMENT" => IfcPipeSegmentTypeEnum :: Flexiblesegment , "RIGIDSEGMENT" => IfcPipeSegmentTypeEnum :: Rigidsegment , "GUTTER" => IfcPipeSegmentTypeEnum :: Gutter , "SPOOL" => IfcPipeSegmentTypeEnum :: Spool , "USERDEFINED" => IfcPipeSegmentTypeEnum :: Userdefined , "NOTDEFINED" => IfcPipeSegmentTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPipeSegmentTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPipeSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPipeSegmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPlateTypeEnum { CurtainPanel , Sheet , Userdefined , Notdefined , } impl Default for IfcPlateTypeEnum { fn default () -> Self { IfcPlateTypeEnum :: CurtainPanel } } impl From < String > for IfcPlateTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CURTAIN_PANEL" => IfcPlateTypeEnum :: CurtainPanel , "SHEET" => IfcPlateTypeEnum :: Sheet , "USERDEFINED" => IfcPlateTypeEnum :: Userdefined , "NOTDEFINED" => IfcPlateTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPlateTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPlateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPlateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPreferredSurfaceCurveRepresentation { Curve3d , PcurveS1 , PcurveS2 , } impl Default for IfcPreferredSurfaceCurveRepresentation { fn default () -> Self { IfcPreferredSurfaceCurveRepresentation :: Curve3d } } impl From < String > for IfcPreferredSurfaceCurveRepresentation { fn from (value : String) -> Self { match value . as_str () { "CURVE3D" => IfcPreferredSurfaceCurveRepresentation :: Curve3d , "PCURVE_S1" => IfcPreferredSurfaceCurveRepresentation :: PcurveS1 , "PCURVE_S2" => IfcPreferredSurfaceCurveRepresentation :: PcurveS2 , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPreferredSurfaceCurveRepresentation { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPreferredSurfaceCurveRepresentation :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPreferredSurfaceCurveRepresentation :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProcedureTypeEnum { AdviceCaution , AdviceNote , AdviceWarning , Calibration , Diagnostic , Shutdown , Startup , Userdefined , Notdefined , } impl Default for IfcProcedureTypeEnum { fn default () -> Self { IfcProcedureTypeEnum :: AdviceCaution } } impl From < String > for IfcProcedureTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ADVICE_CAUTION" => IfcProcedureTypeEnum :: AdviceCaution , "ADVICE_NOTE" => IfcProcedureTypeEnum :: AdviceNote , "ADVICE_WARNING" => IfcProcedureTypeEnum :: AdviceWarning , "CALIBRATION" => IfcProcedureTypeEnum :: Calibration , "DIAGNOSTIC" => IfcProcedureTypeEnum :: Diagnostic , "SHUTDOWN" => IfcProcedureTypeEnum :: Shutdown , "STARTUP" => IfcProcedureTypeEnum :: Startup , "USERDEFINED" => IfcProcedureTypeEnum :: Userdefined , "NOTDEFINED" => IfcProcedureTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProcedureTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProcedureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProcedureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProfileTypeEnum { Curve , Area , } impl Default for IfcProfileTypeEnum { fn default () -> Self { IfcProfileTypeEnum :: Curve } } impl From < String > for IfcProfileTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CURVE" => IfcProfileTypeEnum :: Curve , "AREA" => IfcProfileTypeEnum :: Area , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProfileTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProfileTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProfileTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProjectOrderTypeEnum { Changeorder , Maintenanceworkorder , Moveorder , Purchaseorder , Workorder , Userdefined , Notdefined , } impl Default for IfcProjectOrderTypeEnum { fn default () -> Self { IfcProjectOrderTypeEnum :: Changeorder } } impl From < String > for IfcProjectOrderTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CHANGEORDER" => IfcProjectOrderTypeEnum :: Changeorder , "MAINTENANCEWORKORDER" => IfcProjectOrderTypeEnum :: Maintenanceworkorder , "MOVEORDER" => IfcProjectOrderTypeEnum :: Moveorder , "PURCHASEORDER" => IfcProjectOrderTypeEnum :: Purchaseorder , "WORKORDER" => IfcProjectOrderTypeEnum :: Workorder , "USERDEFINED" => IfcProjectOrderTypeEnum :: Userdefined , "NOTDEFINED" => IfcProjectOrderTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProjectOrderTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProjectOrderTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProjectOrderTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProjectedOrTrueLengthEnum { ProjectedLength , TrueLength , } impl Default for IfcProjectedOrTrueLengthEnum { fn default () -> Self { IfcProjectedOrTrueLengthEnum :: ProjectedLength } } impl From < String > for IfcProjectedOrTrueLengthEnum { fn from (value : String) -> Self { match value . as_str () { "PROJECTED_LENGTH" => IfcProjectedOrTrueLengthEnum :: ProjectedLength , "TRUE_LENGTH" => IfcProjectedOrTrueLengthEnum :: TrueLength , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProjectedOrTrueLengthEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProjectedOrTrueLengthEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProjectedOrTrueLengthEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProjectionElementTypeEnum { Userdefined , Notdefined , } impl Default for IfcProjectionElementTypeEnum { fn default () -> Self { IfcProjectionElementTypeEnum :: Userdefined } } impl From < String > for IfcProjectionElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcProjectionElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcProjectionElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProjectionElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProjectionElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProjectionElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPropertySetTemplateTypeEnum { PsetTypedrivenonly , PsetTypedrivenoverride , PsetOccurrencedriven , PsetPerformancedriven , QtoTypedrivenonly , QtoTypedrivenoverride , QtoOccurrencedriven , Notdefined , } impl Default for IfcPropertySetTemplateTypeEnum { fn default () -> Self { IfcPropertySetTemplateTypeEnum :: PsetTypedrivenonly } } impl From < String > for IfcPropertySetTemplateTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PSET_TYPEDRIVENONLY" => IfcPropertySetTemplateTypeEnum :: PsetTypedrivenonly , "PSET_TYPEDRIVENOVERRIDE" => IfcPropertySetTemplateTypeEnum :: PsetTypedrivenoverride , "PSET_OCCURRENCEDRIVEN" => IfcPropertySetTemplateTypeEnum :: PsetOccurrencedriven , "PSET_PERFORMANCEDRIVEN" => IfcPropertySetTemplateTypeEnum :: PsetPerformancedriven , "QTO_TYPEDRIVENONLY" => IfcPropertySetTemplateTypeEnum :: QtoTypedrivenonly , "QTO_TYPEDRIVENOVERRIDE" => IfcPropertySetTemplateTypeEnum :: QtoTypedrivenoverride , "QTO_OCCURRENCEDRIVEN" => IfcPropertySetTemplateTypeEnum :: QtoOccurrencedriven , "NOTDEFINED" => IfcPropertySetTemplateTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPropertySetTemplateTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPropertySetTemplateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPropertySetTemplateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProtectiveDeviceTrippingUnitTypeEnum { Electronic , Electromagnetic , Residualcurrent , Thermal , Userdefined , Notdefined , } impl Default for IfcProtectiveDeviceTrippingUnitTypeEnum { fn default () -> Self { IfcProtectiveDeviceTrippingUnitTypeEnum :: Electronic } } impl From < String > for IfcProtectiveDeviceTrippingUnitTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ELECTRONIC" => IfcProtectiveDeviceTrippingUnitTypeEnum :: Electronic , "ELECTROMAGNETIC" => IfcProtectiveDeviceTrippingUnitTypeEnum :: Electromagnetic , "RESIDUALCURRENT" => IfcProtectiveDeviceTrippingUnitTypeEnum :: Residualcurrent , "THERMAL" => IfcProtectiveDeviceTrippingUnitTypeEnum :: Thermal , "USERDEFINED" => IfcProtectiveDeviceTrippingUnitTypeEnum :: Userdefined , "NOTDEFINED" => IfcProtectiveDeviceTrippingUnitTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProtectiveDeviceTrippingUnitTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProtectiveDeviceTrippingUnitTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProtectiveDeviceTrippingUnitTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcProtectiveDeviceTypeEnum { Circuitbreaker , Earthleakagecircuitbreaker , Earthingswitch , Fusedisconnector , Residualcurrentcircuitbreaker , Residualcurrentswitch , Varistor , Userdefined , Notdefined , } impl Default for IfcProtectiveDeviceTypeEnum { fn default () -> Self { IfcProtectiveDeviceTypeEnum :: Circuitbreaker } } impl From < String > for IfcProtectiveDeviceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum :: Circuitbreaker , "EARTHLEAKAGECIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum :: Earthleakagecircuitbreaker , "EARTHINGSWITCH" => IfcProtectiveDeviceTypeEnum :: Earthingswitch , "FUSEDISCONNECTOR" => IfcProtectiveDeviceTypeEnum :: Fusedisconnector , "RESIDUALCURRENTCIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum :: Residualcurrentcircuitbreaker , "RESIDUALCURRENTSWITCH" => IfcProtectiveDeviceTypeEnum :: Residualcurrentswitch , "VARISTOR" => IfcProtectiveDeviceTypeEnum :: Varistor , "USERDEFINED" => IfcProtectiveDeviceTypeEnum :: Userdefined , "NOTDEFINED" => IfcProtectiveDeviceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcProtectiveDeviceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcProtectiveDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcProtectiveDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPumpTypeEnum { Circulator , Endsuction , Splitcase , Submersiblepump , Sumppump , Verticalinline , Verticalturbine , Userdefined , Notdefined , } impl Default for IfcPumpTypeEnum { fn default () -> Self { IfcPumpTypeEnum :: Circulator } } impl From < String > for IfcPumpTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CIRCULATOR" => IfcPumpTypeEnum :: Circulator , "ENDSUCTION" => IfcPumpTypeEnum :: Endsuction , "SPLITCASE" => IfcPumpTypeEnum :: Splitcase , "SUBMERSIBLEPUMP" => IfcPumpTypeEnum :: Submersiblepump , "SUMPPUMP" => IfcPumpTypeEnum :: Sumppump , "VERTICALINLINE" => IfcPumpTypeEnum :: Verticalinline , "VERTICALTURBINE" => IfcPumpTypeEnum :: Verticalturbine , "USERDEFINED" => IfcPumpTypeEnum :: Userdefined , "NOTDEFINED" => IfcPumpTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcPumpTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcPumpTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcPumpTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcRailingTypeEnum { Handrail , Guardrail , Balustrade , Userdefined , Notdefined , } impl Default for IfcRailingTypeEnum { fn default () -> Self { IfcRailingTypeEnum :: Handrail } } impl From < String > for IfcRailingTypeEnum { fn from (value : String) -> Self { match value . as_str () { "HANDRAIL" => IfcRailingTypeEnum :: Handrail , "GUARDRAIL" => IfcRailingTypeEnum :: Guardrail , "BALUSTRADE" => IfcRailingTypeEnum :: Balustrade , "USERDEFINED" => IfcRailingTypeEnum :: Userdefined , "NOTDEFINED" => IfcRailingTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcRailingTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcRailingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcRailingTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcRampFlightTypeEnum { Straight , Spiral , Userdefined , Notdefined , } impl Default for IfcRampFlightTypeEnum { fn default () -> Self { IfcRampFlightTypeEnum :: Straight } } impl From < String > for IfcRampFlightTypeEnum { fn from (value : String) -> Self { match value . as_str () { "STRAIGHT" => IfcRampFlightTypeEnum :: Straight , "SPIRAL" => IfcRampFlightTypeEnum :: Spiral , "USERDEFINED" => IfcRampFlightTypeEnum :: Userdefined , "NOTDEFINED" => IfcRampFlightTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcRampFlightTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcRampFlightTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcRampFlightTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcRampTypeEnum { StraightRunRamp , TwoStraightRunRamp , QuarterTurnRamp , TwoQuarterTurnRamp , HalfTurnRamp , SpiralRamp , Userdefined , Notdefined , } impl Default for IfcRampTypeEnum { fn default () -> Self { IfcRampTypeEnum :: StraightRunRamp } } impl From < String > for IfcRampTypeEnum { fn from (value : String) -> Self { match value . as_str () { "STRAIGHT_RUN_RAMP" => IfcRampTypeEnum :: StraightRunRamp , "TWO_STRAIGHT_RUN_RAMP" => IfcRampTypeEnum :: TwoStraightRunRamp , "QUARTER_TURN_RAMP" => IfcRampTypeEnum :: QuarterTurnRamp , "TWO_QUARTER_TURN_RAMP" => IfcRampTypeEnum :: TwoQuarterTurnRamp , "HALF_TURN_RAMP" => IfcRampTypeEnum :: HalfTurnRamp , "SPIRAL_RAMP" => IfcRampTypeEnum :: SpiralRamp , "USERDEFINED" => IfcRampTypeEnum :: Userdefined , "NOTDEFINED" => IfcRampTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcRampTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcRampTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcRampTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcRecurrenceTypeEnum { Daily , Weekly , MonthlyByDayOfMonth , MonthlyByPosition , ByDayCount , ByWeekdayCount , YearlyByDayOfMonth , YearlyByPosition , } impl Default for IfcRecurrenceTypeEnum { fn default () -> Self { IfcRecurrenceTypeEnum :: Daily } } impl From < String > for IfcRecurrenceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "DAILY" => IfcRecurrenceTypeEnum :: Daily , "WEEKLY" => IfcRecurrenceTypeEnum :: Weekly , "MONTHLY_BY_DAY_OF_MONTH" => IfcRecurrenceTypeEnum :: MonthlyByDayOfMonth , "MONTHLY_BY_POSITION" => IfcRecurrenceTypeEnum :: MonthlyByPosition , "BY_DAY_COUNT" => IfcRecurrenceTypeEnum :: ByDayCount , "BY_WEEKDAY_COUNT" => IfcRecurrenceTypeEnum :: ByWeekdayCount , "YEARLY_BY_DAY_OF_MONTH" => IfcRecurrenceTypeEnum :: YearlyByDayOfMonth , "YEARLY_BY_POSITION" => IfcRecurrenceTypeEnum :: YearlyByPosition , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcRecurrenceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcRecurrenceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcRecurrenceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcReflectanceMethodEnum { Blinn , Flat , Glass , Matt , Metal , Mirror , Phong , Plastic , Strauss , Notdefined , } impl Default for IfcReflectanceMethodEnum { fn default () -> Self { IfcReflectanceMethodEnum :: Blinn } } impl From < String > for IfcReflectanceMethodEnum { fn from (value : String) -> Self { match value . as_str () { "BLINN" => IfcReflectanceMethodEnum :: Blinn , "FLAT" => IfcReflectanceMethodEnum :: Flat , "GLASS" => IfcReflectanceMethodEnum :: Glass , "MATT" => IfcReflectanceMethodEnum :: Matt , "METAL" => IfcReflectanceMethodEnum :: Metal , "MIRROR" => IfcReflectanceMethodEnum :: Mirror , "PHONG" => IfcReflectanceMethodEnum :: Phong , "PLASTIC" => IfcReflectanceMethodEnum :: Plastic , "STRAUSS" => IfcReflectanceMethodEnum :: Strauss , "NOTDEFINED" => IfcReflectanceMethodEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcReflectanceMethodEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcReflectanceMethodEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcReflectanceMethodEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcReinforcingBarRoleEnum { Main , Shear , Ligature , Stud , Punching , Edge , Ring , Anchoring , Userdefined , Notdefined , } impl Default for IfcReinforcingBarRoleEnum { fn default () -> Self { IfcReinforcingBarRoleEnum :: Main } } impl From < String > for IfcReinforcingBarRoleEnum { fn from (value : String) -> Self { match value . as_str () { "MAIN" => IfcReinforcingBarRoleEnum :: Main , "SHEAR" => IfcReinforcingBarRoleEnum :: Shear , "LIGATURE" => IfcReinforcingBarRoleEnum :: Ligature , "STUD" => IfcReinforcingBarRoleEnum :: Stud , "PUNCHING" => IfcReinforcingBarRoleEnum :: Punching , "EDGE" => IfcReinforcingBarRoleEnum :: Edge , "RING" => IfcReinforcingBarRoleEnum :: Ring , "ANCHORING" => IfcReinforcingBarRoleEnum :: Anchoring , "USERDEFINED" => IfcReinforcingBarRoleEnum :: Userdefined , "NOTDEFINED" => IfcReinforcingBarRoleEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcReinforcingBarRoleEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcReinforcingBarRoleEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcReinforcingBarRoleEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcReinforcingBarSurfaceEnum { Plain , Textured , } impl Default for IfcReinforcingBarSurfaceEnum { fn default () -> Self { IfcReinforcingBarSurfaceEnum :: Plain } } impl From < String > for IfcReinforcingBarSurfaceEnum { fn from (value : String) -> Self { match value . as_str () { "PLAIN" => IfcReinforcingBarSurfaceEnum :: Plain , "TEXTURED" => IfcReinforcingBarSurfaceEnum :: Textured , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcReinforcingBarSurfaceEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcReinforcingBarSurfaceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcReinforcingBarSurfaceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcReinforcingBarTypeEnum { Anchoring , Edge , Ligature , Main , Punching , Ring , Shear , Stud , Userdefined , Notdefined , } impl Default for IfcReinforcingBarTypeEnum { fn default () -> Self { IfcReinforcingBarTypeEnum :: Anchoring } } impl From < String > for IfcReinforcingBarTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ANCHORING" => IfcReinforcingBarTypeEnum :: Anchoring , "EDGE" => IfcReinforcingBarTypeEnum :: Edge , "LIGATURE" => IfcReinforcingBarTypeEnum :: Ligature , "MAIN" => IfcReinforcingBarTypeEnum :: Main , "PUNCHING" => IfcReinforcingBarTypeEnum :: Punching , "RING" => IfcReinforcingBarTypeEnum :: Ring , "SHEAR" => IfcReinforcingBarTypeEnum :: Shear , "STUD" => IfcReinforcingBarTypeEnum :: Stud , "USERDEFINED" => IfcReinforcingBarTypeEnum :: Userdefined , "NOTDEFINED" => IfcReinforcingBarTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcReinforcingBarTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcReinforcingBarTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcReinforcingBarTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcReinforcingMeshTypeEnum { Userdefined , Notdefined , } impl Default for IfcReinforcingMeshTypeEnum { fn default () -> Self { IfcReinforcingMeshTypeEnum :: Userdefined } } impl From < String > for IfcReinforcingMeshTypeEnum { fn from (value : String) -> Self { match value . as_str () { "USERDEFINED" => IfcReinforcingMeshTypeEnum :: Userdefined , "NOTDEFINED" => IfcReinforcingMeshTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcReinforcingMeshTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcReinforcingMeshTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcReinforcingMeshTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcRoleEnum { Supplier , Manufacturer , Contractor , Subcontractor , Architect , Structuralengineer , Costengineer , Client , Buildingowner , Buildingoperator , Mechanicalengineer , Electricalengineer , Projectmanager , Facilitiesmanager , Civilengineer , Commissioningengineer , Engineer , Owner , Consultant , Constructionmanager , Fieldconstructionmanager , Reseller , Userdefined , } impl Default for IfcRoleEnum { fn default () -> Self { IfcRoleEnum :: Supplier } } impl From < String > for IfcRoleEnum { fn from (value : String) -> Self { match value . as_str () { "SUPPLIER" => IfcRoleEnum :: Supplier , "MANUFACTURER" => IfcRoleEnum :: Manufacturer , "CONTRACTOR" => IfcRoleEnum :: Contractor , "SUBCONTRACTOR" => IfcRoleEnum :: Subcontractor , "ARCHITECT" => IfcRoleEnum :: Architect , "STRUCTURALENGINEER" => IfcRoleEnum :: Structuralengineer , "COSTENGINEER" => IfcRoleEnum :: Costengineer , "CLIENT" => IfcRoleEnum :: Client , "BUILDINGOWNER" => IfcRoleEnum :: Buildingowner , "BUILDINGOPERATOR" => IfcRoleEnum :: Buildingoperator , "MECHANICALENGINEER" => IfcRoleEnum :: Mechanicalengineer , "ELECTRICALENGINEER" => IfcRoleEnum :: Electricalengineer , "PROJECTMANAGER" => IfcRoleEnum :: Projectmanager , "FACILITIESMANAGER" => IfcRoleEnum :: Facilitiesmanager , "CIVILENGINEER" => IfcRoleEnum :: Civilengineer , "COMMISSIONINGENGINEER" => IfcRoleEnum :: Commissioningengineer , "ENGINEER" => IfcRoleEnum :: Engineer , "OWNER" => IfcRoleEnum :: Owner , "CONSULTANT" => IfcRoleEnum :: Consultant , "CONSTRUCTIONMANAGER" => IfcRoleEnum :: Constructionmanager , "FIELDCONSTRUCTIONMANAGER" => IfcRoleEnum :: Fieldconstructionmanager , "RESELLER" => IfcRoleEnum :: Reseller , "USERDEFINED" => IfcRoleEnum :: Userdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcRoleEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcRoleEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcRoleEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcRoofTypeEnum { FlatRoof , ShedRoof , GableRoof , HipRoof , HippedGableRoof , GambrelRoof , MansardRoof , BarrelRoof , RainbowRoof , ButterflyRoof , PavilionRoof , DomeRoof , Freeform , Userdefined , Notdefined , } impl Default for IfcRoofTypeEnum { fn default () -> Self { IfcRoofTypeEnum :: FlatRoof } } impl From < String > for IfcRoofTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FLAT_ROOF" => IfcRoofTypeEnum :: FlatRoof , "SHED_ROOF" => IfcRoofTypeEnum :: ShedRoof , "GABLE_ROOF" => IfcRoofTypeEnum :: GableRoof , "HIP_ROOF" => IfcRoofTypeEnum :: HipRoof , "HIPPED_GABLE_ROOF" => IfcRoofTypeEnum :: HippedGableRoof , "GAMBREL_ROOF" => IfcRoofTypeEnum :: GambrelRoof , "MANSARD_ROOF" => IfcRoofTypeEnum :: MansardRoof , "BARREL_ROOF" => IfcRoofTypeEnum :: BarrelRoof , "RAINBOW_ROOF" => IfcRoofTypeEnum :: RainbowRoof , "BUTTERFLY_ROOF" => IfcRoofTypeEnum :: ButterflyRoof , "PAVILION_ROOF" => IfcRoofTypeEnum :: PavilionRoof , "DOME_ROOF" => IfcRoofTypeEnum :: DomeRoof , "FREEFORM" => IfcRoofTypeEnum :: Freeform , "USERDEFINED" => IfcRoofTypeEnum :: Userdefined , "NOTDEFINED" => IfcRoofTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcRoofTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcRoofTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcRoofTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSiPrefix { Exa , Peta , Tera , Giga , Mega , Kilo , Hecto , Deca , Deci , Centi , Milli , Micro , Nano , Pico , Femto , Atto , } impl Default for IfcSiPrefix { fn default () -> Self { IfcSiPrefix :: Exa } } impl From < String > for IfcSiPrefix { fn from (value : String) -> Self { match value . as_str () { "EXA" => IfcSiPrefix :: Exa , "PETA" => IfcSiPrefix :: Peta , "TERA" => IfcSiPrefix :: Tera , "GIGA" => IfcSiPrefix :: Giga , "MEGA" => IfcSiPrefix :: Mega , "KILO" => IfcSiPrefix :: Kilo , "HECTO" => IfcSiPrefix :: Hecto , "DECA" => IfcSiPrefix :: Deca , "DECI" => IfcSiPrefix :: Deci , "CENTI" => IfcSiPrefix :: Centi , "MILLI" => IfcSiPrefix :: Milli , "MICRO" => IfcSiPrefix :: Micro , "NANO" => IfcSiPrefix :: Nano , "PICO" => IfcSiPrefix :: Pico , "FEMTO" => IfcSiPrefix :: Femto , "ATTO" => IfcSiPrefix :: Atto , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSiPrefix { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSiPrefix :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSiPrefix :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSiUnitName { Ampere , Becquerel , Candela , Coulomb , CubicMetre , DegreeCelsius , Farad , Gram , Gray , Henry , Hertz , Joule , Kelvin , Lumen , Lux , Metre , Mole , Newton , Ohm , Pascal , Radian , Second , Siemens , Sievert , SquareMetre , Steradian , Tesla , Volt , Watt , Weber , } impl Default for IfcSiUnitName { fn default () -> Self { IfcSiUnitName :: Ampere } } impl From < String > for IfcSiUnitName { fn from (value : String) -> Self { match value . as_str () { "AMPERE" => IfcSiUnitName :: Ampere , "BECQUEREL" => IfcSiUnitName :: Becquerel , "CANDELA" => IfcSiUnitName :: Candela , "COULOMB" => IfcSiUnitName :: Coulomb , "CUBIC_METRE" => IfcSiUnitName :: CubicMetre , "DEGREE_CELSIUS" => IfcSiUnitName :: DegreeCelsius , "FARAD" => IfcSiUnitName :: Farad , "GRAM" => IfcSiUnitName :: Gram , "GRAY" => IfcSiUnitName :: Gray , "HENRY" => IfcSiUnitName :: Henry , "HERTZ" => IfcSiUnitName :: Hertz , "JOULE" => IfcSiUnitName :: Joule , "KELVIN" => IfcSiUnitName :: Kelvin , "LUMEN" => IfcSiUnitName :: Lumen , "LUX" => IfcSiUnitName :: Lux , "METRE" => IfcSiUnitName :: Metre , "MOLE" => IfcSiUnitName :: Mole , "NEWTON" => IfcSiUnitName :: Newton , "OHM" => IfcSiUnitName :: Ohm , "PASCAL" => IfcSiUnitName :: Pascal , "RADIAN" => IfcSiUnitName :: Radian , "SECOND" => IfcSiUnitName :: Second , "SIEMENS" => IfcSiUnitName :: Siemens , "SIEVERT" => IfcSiUnitName :: Sievert , "SQUARE_METRE" => IfcSiUnitName :: SquareMetre , "STERADIAN" => IfcSiUnitName :: Steradian , "TESLA" => IfcSiUnitName :: Tesla , "VOLT" => IfcSiUnitName :: Volt , "WATT" => IfcSiUnitName :: Watt , "WEBER" => IfcSiUnitName :: Weber , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSiUnitName { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSiUnitName :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSiUnitName :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSanitaryTerminalTypeEnum { Bath , Bidet , Cistern , Shower , Sink , Sanitaryfountain , Toiletpan , Urinal , Washhandbasin , Wcseat , Userdefined , Notdefined , } impl Default for IfcSanitaryTerminalTypeEnum { fn default () -> Self { IfcSanitaryTerminalTypeEnum :: Bath } } impl From < String > for IfcSanitaryTerminalTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BATH" => IfcSanitaryTerminalTypeEnum :: Bath , "BIDET" => IfcSanitaryTerminalTypeEnum :: Bidet , "CISTERN" => IfcSanitaryTerminalTypeEnum :: Cistern , "SHOWER" => IfcSanitaryTerminalTypeEnum :: Shower , "SINK" => IfcSanitaryTerminalTypeEnum :: Sink , "SANITARYFOUNTAIN" => IfcSanitaryTerminalTypeEnum :: Sanitaryfountain , "TOILETPAN" => IfcSanitaryTerminalTypeEnum :: Toiletpan , "URINAL" => IfcSanitaryTerminalTypeEnum :: Urinal , "WASHHANDBASIN" => IfcSanitaryTerminalTypeEnum :: Washhandbasin , "WCSEAT" => IfcSanitaryTerminalTypeEnum :: Wcseat , "USERDEFINED" => IfcSanitaryTerminalTypeEnum :: Userdefined , "NOTDEFINED" => IfcSanitaryTerminalTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSanitaryTerminalTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSanitaryTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSanitaryTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSectionTypeEnum { Uniform , Tapered , } impl Default for IfcSectionTypeEnum { fn default () -> Self { IfcSectionTypeEnum :: Uniform } } impl From < String > for IfcSectionTypeEnum { fn from (value : String) -> Self { match value . as_str () { "UNIFORM" => IfcSectionTypeEnum :: Uniform , "TAPERED" => IfcSectionTypeEnum :: Tapered , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSectionTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSectionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSectionTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSensorTypeEnum { Cosensor , Co2sensor , Conductancesensor , Contactsensor , Firesensor , Flowsensor , Frostsensor , Gassensor , Heatsensor , Humiditysensor , Identifiersensor , Ionconcentrationsensor , Levelsensor , Lightsensor , Moisturesensor , Movementsensor , Phsensor , Pressuresensor , Radiationsensor , Radioactivitysensor , Smokesensor , Soundsensor , Temperaturesensor , Windsensor , Userdefined , Notdefined , } impl Default for IfcSensorTypeEnum { fn default () -> Self { IfcSensorTypeEnum :: Cosensor } } impl From < String > for IfcSensorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "COSENSOR" => IfcSensorTypeEnum :: Cosensor , "CO2SENSOR" => IfcSensorTypeEnum :: Co2sensor , "CONDUCTANCESENSOR" => IfcSensorTypeEnum :: Conductancesensor , "CONTACTSENSOR" => IfcSensorTypeEnum :: Contactsensor , "FIRESENSOR" => IfcSensorTypeEnum :: Firesensor , "FLOWSENSOR" => IfcSensorTypeEnum :: Flowsensor , "FROSTSENSOR" => IfcSensorTypeEnum :: Frostsensor , "GASSENSOR" => IfcSensorTypeEnum :: Gassensor , "HEATSENSOR" => IfcSensorTypeEnum :: Heatsensor , "HUMIDITYSENSOR" => IfcSensorTypeEnum :: Humiditysensor , "IDENTIFIERSENSOR" => IfcSensorTypeEnum :: Identifiersensor , "IONCONCENTRATIONSENSOR" => IfcSensorTypeEnum :: Ionconcentrationsensor , "LEVELSENSOR" => IfcSensorTypeEnum :: Levelsensor , "LIGHTSENSOR" => IfcSensorTypeEnum :: Lightsensor , "MOISTURESENSOR" => IfcSensorTypeEnum :: Moisturesensor , "MOVEMENTSENSOR" => IfcSensorTypeEnum :: Movementsensor , "PHSENSOR" => IfcSensorTypeEnum :: Phsensor , "PRESSURESENSOR" => IfcSensorTypeEnum :: Pressuresensor , "RADIATIONSENSOR" => IfcSensorTypeEnum :: Radiationsensor , "RADIOACTIVITYSENSOR" => IfcSensorTypeEnum :: Radioactivitysensor , "SMOKESENSOR" => IfcSensorTypeEnum :: Smokesensor , "SOUNDSENSOR" => IfcSensorTypeEnum :: Soundsensor , "TEMPERATURESENSOR" => IfcSensorTypeEnum :: Temperaturesensor , "WINDSENSOR" => IfcSensorTypeEnum :: Windsensor , "USERDEFINED" => IfcSensorTypeEnum :: Userdefined , "NOTDEFINED" => IfcSensorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSensorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSensorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSensorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSequenceEnum { StartStart , StartFinish , FinishStart , FinishFinish , Userdefined , Notdefined , } impl Default for IfcSequenceEnum { fn default () -> Self { IfcSequenceEnum :: StartStart } } impl From < String > for IfcSequenceEnum { fn from (value : String) -> Self { match value . as_str () { "START_START" => IfcSequenceEnum :: StartStart , "START_FINISH" => IfcSequenceEnum :: StartFinish , "FINISH_START" => IfcSequenceEnum :: FinishStart , "FINISH_FINISH" => IfcSequenceEnum :: FinishFinish , "USERDEFINED" => IfcSequenceEnum :: Userdefined , "NOTDEFINED" => IfcSequenceEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSequenceEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSequenceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSequenceEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcShadingDeviceTypeEnum { Jalousie , Shutter , Awning , Userdefined , Notdefined , } impl Default for IfcShadingDeviceTypeEnum { fn default () -> Self { IfcShadingDeviceTypeEnum :: Jalousie } } impl From < String > for IfcShadingDeviceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "JALOUSIE" => IfcShadingDeviceTypeEnum :: Jalousie , "SHUTTER" => IfcShadingDeviceTypeEnum :: Shutter , "AWNING" => IfcShadingDeviceTypeEnum :: Awning , "USERDEFINED" => IfcShadingDeviceTypeEnum :: Userdefined , "NOTDEFINED" => IfcShadingDeviceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcShadingDeviceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcShadingDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcShadingDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSimplePropertyTemplateTypeEnum { PSinglevalue , PEnumeratedvalue , PBoundedvalue , PListvalue , PTablevalue , PReferencevalue , QLength , QArea , QVolume , QCount , QWeight , QTime , } impl Default for IfcSimplePropertyTemplateTypeEnum { fn default () -> Self { IfcSimplePropertyTemplateTypeEnum :: PSinglevalue } } impl From < String > for IfcSimplePropertyTemplateTypeEnum { fn from (value : String) -> Self { match value . as_str () { "P_SINGLEVALUE" => IfcSimplePropertyTemplateTypeEnum :: PSinglevalue , "P_ENUMERATEDVALUE" => IfcSimplePropertyTemplateTypeEnum :: PEnumeratedvalue , "P_BOUNDEDVALUE" => IfcSimplePropertyTemplateTypeEnum :: PBoundedvalue , "P_LISTVALUE" => IfcSimplePropertyTemplateTypeEnum :: PListvalue , "P_TABLEVALUE" => IfcSimplePropertyTemplateTypeEnum :: PTablevalue , "P_REFERENCEVALUE" => IfcSimplePropertyTemplateTypeEnum :: PReferencevalue , "Q_LENGTH" => IfcSimplePropertyTemplateTypeEnum :: QLength , "Q_AREA" => IfcSimplePropertyTemplateTypeEnum :: QArea , "Q_VOLUME" => IfcSimplePropertyTemplateTypeEnum :: QVolume , "Q_COUNT" => IfcSimplePropertyTemplateTypeEnum :: QCount , "Q_WEIGHT" => IfcSimplePropertyTemplateTypeEnum :: QWeight , "Q_TIME" => IfcSimplePropertyTemplateTypeEnum :: QTime , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSimplePropertyTemplateTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSimplePropertyTemplateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSimplePropertyTemplateTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSlabTypeEnum { Floor , Roof , Landing , Baseslab , Userdefined , Notdefined , } impl Default for IfcSlabTypeEnum { fn default () -> Self { IfcSlabTypeEnum :: Floor } } impl From < String > for IfcSlabTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FLOOR" => IfcSlabTypeEnum :: Floor , "ROOF" => IfcSlabTypeEnum :: Roof , "LANDING" => IfcSlabTypeEnum :: Landing , "BASESLAB" => IfcSlabTypeEnum :: Baseslab , "USERDEFINED" => IfcSlabTypeEnum :: Userdefined , "NOTDEFINED" => IfcSlabTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSlabTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSlabTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSlabTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSolarDeviceTypeEnum { Solarcollector , Solarpanel , Userdefined , Notdefined , } impl Default for IfcSolarDeviceTypeEnum { fn default () -> Self { IfcSolarDeviceTypeEnum :: Solarcollector } } impl From < String > for IfcSolarDeviceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "SOLARCOLLECTOR" => IfcSolarDeviceTypeEnum :: Solarcollector , "SOLARPANEL" => IfcSolarDeviceTypeEnum :: Solarpanel , "USERDEFINED" => IfcSolarDeviceTypeEnum :: Userdefined , "NOTDEFINED" => IfcSolarDeviceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSolarDeviceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSolarDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSolarDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSpaceHeaterTypeEnum { Convector , Radiator , Userdefined , Notdefined , } impl Default for IfcSpaceHeaterTypeEnum { fn default () -> Self { IfcSpaceHeaterTypeEnum :: Convector } } impl From < String > for IfcSpaceHeaterTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONVECTOR" => IfcSpaceHeaterTypeEnum :: Convector , "RADIATOR" => IfcSpaceHeaterTypeEnum :: Radiator , "USERDEFINED" => IfcSpaceHeaterTypeEnum :: Userdefined , "NOTDEFINED" => IfcSpaceHeaterTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSpaceHeaterTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSpaceHeaterTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSpaceHeaterTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSpaceTypeEnum { Space , Parking , Gfa , Internal , External , Userdefined , Notdefined , } impl Default for IfcSpaceTypeEnum { fn default () -> Self { IfcSpaceTypeEnum :: Space } } impl From < String > for IfcSpaceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "SPACE" => IfcSpaceTypeEnum :: Space , "PARKING" => IfcSpaceTypeEnum :: Parking , "GFA" => IfcSpaceTypeEnum :: Gfa , "INTERNAL" => IfcSpaceTypeEnum :: Internal , "EXTERNAL" => IfcSpaceTypeEnum :: External , "USERDEFINED" => IfcSpaceTypeEnum :: Userdefined , "NOTDEFINED" => IfcSpaceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSpaceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSpaceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSpaceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSpatialZoneTypeEnum { Construction , Firesafety , Lighting , Occupancy , Security , Thermal , Transport , Ventilation , Userdefined , Notdefined , } impl Default for IfcSpatialZoneTypeEnum { fn default () -> Self { IfcSpatialZoneTypeEnum :: Construction } } impl From < String > for IfcSpatialZoneTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONSTRUCTION" => IfcSpatialZoneTypeEnum :: Construction , "FIRESAFETY" => IfcSpatialZoneTypeEnum :: Firesafety , "LIGHTING" => IfcSpatialZoneTypeEnum :: Lighting , "OCCUPANCY" => IfcSpatialZoneTypeEnum :: Occupancy , "SECURITY" => IfcSpatialZoneTypeEnum :: Security , "THERMAL" => IfcSpatialZoneTypeEnum :: Thermal , "TRANSPORT" => IfcSpatialZoneTypeEnum :: Transport , "VENTILATION" => IfcSpatialZoneTypeEnum :: Ventilation , "USERDEFINED" => IfcSpatialZoneTypeEnum :: Userdefined , "NOTDEFINED" => IfcSpatialZoneTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSpatialZoneTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSpatialZoneTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSpatialZoneTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStackTerminalTypeEnum { Birdcage , Cowl , Rainwaterhopper , Userdefined , Notdefined , } impl Default for IfcStackTerminalTypeEnum { fn default () -> Self { IfcStackTerminalTypeEnum :: Birdcage } } impl From < String > for IfcStackTerminalTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BIRDCAGE" => IfcStackTerminalTypeEnum :: Birdcage , "COWL" => IfcStackTerminalTypeEnum :: Cowl , "RAINWATERHOPPER" => IfcStackTerminalTypeEnum :: Rainwaterhopper , "USERDEFINED" => IfcStackTerminalTypeEnum :: Userdefined , "NOTDEFINED" => IfcStackTerminalTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStackTerminalTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStackTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStackTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStairFlightTypeEnum { Straight , Winder , Spiral , Curved , Freeform , Userdefined , Notdefined , } impl Default for IfcStairFlightTypeEnum { fn default () -> Self { IfcStairFlightTypeEnum :: Straight } } impl From < String > for IfcStairFlightTypeEnum { fn from (value : String) -> Self { match value . as_str () { "STRAIGHT" => IfcStairFlightTypeEnum :: Straight , "WINDER" => IfcStairFlightTypeEnum :: Winder , "SPIRAL" => IfcStairFlightTypeEnum :: Spiral , "CURVED" => IfcStairFlightTypeEnum :: Curved , "FREEFORM" => IfcStairFlightTypeEnum :: Freeform , "USERDEFINED" => IfcStairFlightTypeEnum :: Userdefined , "NOTDEFINED" => IfcStairFlightTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStairFlightTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStairFlightTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStairFlightTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStairTypeEnum { StraightRunStair , TwoStraightRunStair , QuarterWindingStair , QuarterTurnStair , HalfWindingStair , HalfTurnStair , TwoQuarterWindingStair , TwoQuarterTurnStair , ThreeQuarterWindingStair , ThreeQuarterTurnStair , SpiralStair , DoubleReturnStair , CurvedRunStair , TwoCurvedRunStair , Userdefined , Notdefined , } impl Default for IfcStairTypeEnum { fn default () -> Self { IfcStairTypeEnum :: StraightRunStair } } impl From < String > for IfcStairTypeEnum { fn from (value : String) -> Self { match value . as_str () { "STRAIGHT_RUN_STAIR" => IfcStairTypeEnum :: StraightRunStair , "TWO_STRAIGHT_RUN_STAIR" => IfcStairTypeEnum :: TwoStraightRunStair , "QUARTER_WINDING_STAIR" => IfcStairTypeEnum :: QuarterWindingStair , "QUARTER_TURN_STAIR" => IfcStairTypeEnum :: QuarterTurnStair , "HALF_WINDING_STAIR" => IfcStairTypeEnum :: HalfWindingStair , "HALF_TURN_STAIR" => IfcStairTypeEnum :: HalfTurnStair , "TWO_QUARTER_WINDING_STAIR" => IfcStairTypeEnum :: TwoQuarterWindingStair , "TWO_QUARTER_TURN_STAIR" => IfcStairTypeEnum :: TwoQuarterTurnStair , "THREE_QUARTER_WINDING_STAIR" => IfcStairTypeEnum :: ThreeQuarterWindingStair , "THREE_QUARTER_TURN_STAIR" => IfcStairTypeEnum :: ThreeQuarterTurnStair , "SPIRAL_STAIR" => IfcStairTypeEnum :: SpiralStair , "DOUBLE_RETURN_STAIR" => IfcStairTypeEnum :: DoubleReturnStair , "CURVED_RUN_STAIR" => IfcStairTypeEnum :: CurvedRunStair , "TWO_CURVED_RUN_STAIR" => IfcStairTypeEnum :: TwoCurvedRunStair , "USERDEFINED" => IfcStairTypeEnum :: Userdefined , "NOTDEFINED" => IfcStairTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStairTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStairTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStairTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStateEnum { Readwrite , Readonly , Locked , Readwritelocked , Readonlylocked , } impl Default for IfcStateEnum { fn default () -> Self { IfcStateEnum :: Readwrite } } impl From < String > for IfcStateEnum { fn from (value : String) -> Self { match value . as_str () { "READWRITE" => IfcStateEnum :: Readwrite , "READONLY" => IfcStateEnum :: Readonly , "LOCKED" => IfcStateEnum :: Locked , "READWRITELOCKED" => IfcStateEnum :: Readwritelocked , "READONLYLOCKED" => IfcStateEnum :: Readonlylocked , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStateEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStateEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStateEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStructuralCurveActivityTypeEnum { Const , Linear , Polygonal , Equidistant , Sinus , Parabola , Discrete , Userdefined , Notdefined , } impl Default for IfcStructuralCurveActivityTypeEnum { fn default () -> Self { IfcStructuralCurveActivityTypeEnum :: Const } } impl From < String > for IfcStructuralCurveActivityTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONST" => IfcStructuralCurveActivityTypeEnum :: Const , "LINEAR" => IfcStructuralCurveActivityTypeEnum :: Linear , "POLYGONAL" => IfcStructuralCurveActivityTypeEnum :: Polygonal , "EQUIDISTANT" => IfcStructuralCurveActivityTypeEnum :: Equidistant , "SINUS" => IfcStructuralCurveActivityTypeEnum :: Sinus , "PARABOLA" => IfcStructuralCurveActivityTypeEnum :: Parabola , "DISCRETE" => IfcStructuralCurveActivityTypeEnum :: Discrete , "USERDEFINED" => IfcStructuralCurveActivityTypeEnum :: Userdefined , "NOTDEFINED" => IfcStructuralCurveActivityTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStructuralCurveActivityTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStructuralCurveActivityTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStructuralCurveActivityTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStructuralCurveMemberTypeEnum { RigidJoinedMember , PinJoinedMember , Cable , TensionMember , CompressionMember , Userdefined , Notdefined , } impl Default for IfcStructuralCurveMemberTypeEnum { fn default () -> Self { IfcStructuralCurveMemberTypeEnum :: RigidJoinedMember } } impl From < String > for IfcStructuralCurveMemberTypeEnum { fn from (value : String) -> Self { match value . as_str () { "RIGID_JOINED_MEMBER" => IfcStructuralCurveMemberTypeEnum :: RigidJoinedMember , "PIN_JOINED_MEMBER" => IfcStructuralCurveMemberTypeEnum :: PinJoinedMember , "CABLE" => IfcStructuralCurveMemberTypeEnum :: Cable , "TENSION_MEMBER" => IfcStructuralCurveMemberTypeEnum :: TensionMember , "COMPRESSION_MEMBER" => IfcStructuralCurveMemberTypeEnum :: CompressionMember , "USERDEFINED" => IfcStructuralCurveMemberTypeEnum :: Userdefined , "NOTDEFINED" => IfcStructuralCurveMemberTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStructuralCurveMemberTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStructuralCurveMemberTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStructuralCurveMemberTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStructuralSurfaceActivityTypeEnum { Const , Bilinear , Discrete , Isocontour , Userdefined , Notdefined , } impl Default for IfcStructuralSurfaceActivityTypeEnum { fn default () -> Self { IfcStructuralSurfaceActivityTypeEnum :: Const } } impl From < String > for IfcStructuralSurfaceActivityTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONST" => IfcStructuralSurfaceActivityTypeEnum :: Const , "BILINEAR" => IfcStructuralSurfaceActivityTypeEnum :: Bilinear , "DISCRETE" => IfcStructuralSurfaceActivityTypeEnum :: Discrete , "ISOCONTOUR" => IfcStructuralSurfaceActivityTypeEnum :: Isocontour , "USERDEFINED" => IfcStructuralSurfaceActivityTypeEnum :: Userdefined , "NOTDEFINED" => IfcStructuralSurfaceActivityTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStructuralSurfaceActivityTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStructuralSurfaceActivityTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStructuralSurfaceActivityTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStructuralSurfaceMemberTypeEnum { BendingElement , MembraneElement , Shell , Userdefined , Notdefined , } impl Default for IfcStructuralSurfaceMemberTypeEnum { fn default () -> Self { IfcStructuralSurfaceMemberTypeEnum :: BendingElement } } impl From < String > for IfcStructuralSurfaceMemberTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BENDING_ELEMENT" => IfcStructuralSurfaceMemberTypeEnum :: BendingElement , "MEMBRANE_ELEMENT" => IfcStructuralSurfaceMemberTypeEnum :: MembraneElement , "SHELL" => IfcStructuralSurfaceMemberTypeEnum :: Shell , "USERDEFINED" => IfcStructuralSurfaceMemberTypeEnum :: Userdefined , "NOTDEFINED" => IfcStructuralSurfaceMemberTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcStructuralSurfaceMemberTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcStructuralSurfaceMemberTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcStructuralSurfaceMemberTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSubContractResourceTypeEnum { Purchase , Work , Userdefined , Notdefined , } impl Default for IfcSubContractResourceTypeEnum { fn default () -> Self { IfcSubContractResourceTypeEnum :: Purchase } } impl From < String > for IfcSubContractResourceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PURCHASE" => IfcSubContractResourceTypeEnum :: Purchase , "WORK" => IfcSubContractResourceTypeEnum :: Work , "USERDEFINED" => IfcSubContractResourceTypeEnum :: Userdefined , "NOTDEFINED" => IfcSubContractResourceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSubContractResourceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSubContractResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSubContractResourceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSurfaceFeatureTypeEnum { Mark , Tag , Treatment , Userdefined , Notdefined , } impl Default for IfcSurfaceFeatureTypeEnum { fn default () -> Self { IfcSurfaceFeatureTypeEnum :: Mark } } impl From < String > for IfcSurfaceFeatureTypeEnum { fn from (value : String) -> Self { match value . as_str () { "MARK" => IfcSurfaceFeatureTypeEnum :: Mark , "TAG" => IfcSurfaceFeatureTypeEnum :: Tag , "TREATMENT" => IfcSurfaceFeatureTypeEnum :: Treatment , "USERDEFINED" => IfcSurfaceFeatureTypeEnum :: Userdefined , "NOTDEFINED" => IfcSurfaceFeatureTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSurfaceFeatureTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSurfaceFeatureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSurfaceFeatureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSurfaceSide { Positive , Negative , Both , } impl Default for IfcSurfaceSide { fn default () -> Self { IfcSurfaceSide :: Positive } } impl From < String > for IfcSurfaceSide { fn from (value : String) -> Self { match value . as_str () { "POSITIVE" => IfcSurfaceSide :: Positive , "NEGATIVE" => IfcSurfaceSide :: Negative , "BOTH" => IfcSurfaceSide :: Both , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSurfaceSide { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSurfaceSide :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSurfaceSide :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSwitchingDeviceTypeEnum { Contactor , Dimmerswitch , Emergencystop , Keypad , Momentaryswitch , Selectorswitch , Starter , Switchdisconnector , Toggleswitch , Userdefined , Notdefined , } impl Default for IfcSwitchingDeviceTypeEnum { fn default () -> Self { IfcSwitchingDeviceTypeEnum :: Contactor } } impl From < String > for IfcSwitchingDeviceTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONTACTOR" => IfcSwitchingDeviceTypeEnum :: Contactor , "DIMMERSWITCH" => IfcSwitchingDeviceTypeEnum :: Dimmerswitch , "EMERGENCYSTOP" => IfcSwitchingDeviceTypeEnum :: Emergencystop , "KEYPAD" => IfcSwitchingDeviceTypeEnum :: Keypad , "MOMENTARYSWITCH" => IfcSwitchingDeviceTypeEnum :: Momentaryswitch , "SELECTORSWITCH" => IfcSwitchingDeviceTypeEnum :: Selectorswitch , "STARTER" => IfcSwitchingDeviceTypeEnum :: Starter , "SWITCHDISCONNECTOR" => IfcSwitchingDeviceTypeEnum :: Switchdisconnector , "TOGGLESWITCH" => IfcSwitchingDeviceTypeEnum :: Toggleswitch , "USERDEFINED" => IfcSwitchingDeviceTypeEnum :: Userdefined , "NOTDEFINED" => IfcSwitchingDeviceTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSwitchingDeviceTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSwitchingDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSwitchingDeviceTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSystemFurnitureElementTypeEnum { Panel , Worksurface , Userdefined , Notdefined , } impl Default for IfcSystemFurnitureElementTypeEnum { fn default () -> Self { IfcSystemFurnitureElementTypeEnum :: Panel } } impl From < String > for IfcSystemFurnitureElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "PANEL" => IfcSystemFurnitureElementTypeEnum :: Panel , "WORKSURFACE" => IfcSystemFurnitureElementTypeEnum :: Worksurface , "USERDEFINED" => IfcSystemFurnitureElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcSystemFurnitureElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcSystemFurnitureElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcSystemFurnitureElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcSystemFurnitureElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTankTypeEnum { Basin , Breakpressure , Expansion , Feedandexpansion , Pressurevessel , Storage , Vessel , Userdefined , Notdefined , } impl Default for IfcTankTypeEnum { fn default () -> Self { IfcTankTypeEnum :: Basin } } impl From < String > for IfcTankTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BASIN" => IfcTankTypeEnum :: Basin , "BREAKPRESSURE" => IfcTankTypeEnum :: Breakpressure , "EXPANSION" => IfcTankTypeEnum :: Expansion , "FEEDANDEXPANSION" => IfcTankTypeEnum :: Feedandexpansion , "PRESSUREVESSEL" => IfcTankTypeEnum :: Pressurevessel , "STORAGE" => IfcTankTypeEnum :: Storage , "VESSEL" => IfcTankTypeEnum :: Vessel , "USERDEFINED" => IfcTankTypeEnum :: Userdefined , "NOTDEFINED" => IfcTankTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTankTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTankTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTankTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTaskDurationEnum { Elapsedtime , Worktime , Notdefined , } impl Default for IfcTaskDurationEnum { fn default () -> Self { IfcTaskDurationEnum :: Elapsedtime } } impl From < String > for IfcTaskDurationEnum { fn from (value : String) -> Self { match value . as_str () { "ELAPSEDTIME" => IfcTaskDurationEnum :: Elapsedtime , "WORKTIME" => IfcTaskDurationEnum :: Worktime , "NOTDEFINED" => IfcTaskDurationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTaskDurationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTaskDurationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTaskDurationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTaskTypeEnum { Attendance , Construction , Demolition , Dismantle , Disposal , Installation , Logistic , Maintenance , Move , Operation , Removal , Renovation , Userdefined , Notdefined , } impl Default for IfcTaskTypeEnum { fn default () -> Self { IfcTaskTypeEnum :: Attendance } } impl From < String > for IfcTaskTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ATTENDANCE" => IfcTaskTypeEnum :: Attendance , "CONSTRUCTION" => IfcTaskTypeEnum :: Construction , "DEMOLITION" => IfcTaskTypeEnum :: Demolition , "DISMANTLE" => IfcTaskTypeEnum :: Dismantle , "DISPOSAL" => IfcTaskTypeEnum :: Disposal , "INSTALLATION" => IfcTaskTypeEnum :: Installation , "LOGISTIC" => IfcTaskTypeEnum :: Logistic , "MAINTENANCE" => IfcTaskTypeEnum :: Maintenance , "MOVE" => IfcTaskTypeEnum :: Move , "OPERATION" => IfcTaskTypeEnum :: Operation , "REMOVAL" => IfcTaskTypeEnum :: Removal , "RENOVATION" => IfcTaskTypeEnum :: Renovation , "USERDEFINED" => IfcTaskTypeEnum :: Userdefined , "NOTDEFINED" => IfcTaskTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTaskTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTaskTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTaskTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTendonAnchorTypeEnum { Coupler , FixedEnd , TensioningEnd , Userdefined , Notdefined , } impl Default for IfcTendonAnchorTypeEnum { fn default () -> Self { IfcTendonAnchorTypeEnum :: Coupler } } impl From < String > for IfcTendonAnchorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "COUPLER" => IfcTendonAnchorTypeEnum :: Coupler , "FIXED_END" => IfcTendonAnchorTypeEnum :: FixedEnd , "TENSIONING_END" => IfcTendonAnchorTypeEnum :: TensioningEnd , "USERDEFINED" => IfcTendonAnchorTypeEnum :: Userdefined , "NOTDEFINED" => IfcTendonAnchorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTendonAnchorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTendonAnchorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTendonAnchorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTendonTypeEnum { Bar , Coated , Strand , Wire , Userdefined , Notdefined , } impl Default for IfcTendonTypeEnum { fn default () -> Self { IfcTendonTypeEnum :: Bar } } impl From < String > for IfcTendonTypeEnum { fn from (value : String) -> Self { match value . as_str () { "BAR" => IfcTendonTypeEnum :: Bar , "COATED" => IfcTendonTypeEnum :: Coated , "STRAND" => IfcTendonTypeEnum :: Strand , "WIRE" => IfcTendonTypeEnum :: Wire , "USERDEFINED" => IfcTendonTypeEnum :: Userdefined , "NOTDEFINED" => IfcTendonTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTendonTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTendonTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTendonTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTextPath { Left , Right , Up , Down , } impl Default for IfcTextPath { fn default () -> Self { IfcTextPath :: Left } } impl From < String > for IfcTextPath { fn from (value : String) -> Self { match value . as_str () { "LEFT" => IfcTextPath :: Left , "RIGHT" => IfcTextPath :: Right , "UP" => IfcTextPath :: Up , "DOWN" => IfcTextPath :: Down , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTextPath { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTextPath :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTextPath :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTimeSeriesDataTypeEnum { Continuous , Discrete , Discretebinary , Piecewisebinary , Piecewiseconstant , Piecewisecontinuous , Notdefined , } impl Default for IfcTimeSeriesDataTypeEnum { fn default () -> Self { IfcTimeSeriesDataTypeEnum :: Continuous } } impl From < String > for IfcTimeSeriesDataTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CONTINUOUS" => IfcTimeSeriesDataTypeEnum :: Continuous , "DISCRETE" => IfcTimeSeriesDataTypeEnum :: Discrete , "DISCRETEBINARY" => IfcTimeSeriesDataTypeEnum :: Discretebinary , "PIECEWISEBINARY" => IfcTimeSeriesDataTypeEnum :: Piecewisebinary , "PIECEWISECONSTANT" => IfcTimeSeriesDataTypeEnum :: Piecewiseconstant , "PIECEWISECONTINUOUS" => IfcTimeSeriesDataTypeEnum :: Piecewisecontinuous , "NOTDEFINED" => IfcTimeSeriesDataTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTimeSeriesDataTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTimeSeriesDataTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTimeSeriesDataTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTransformerTypeEnum { Current , Frequency , Inverter , Rectifier , Voltage , Userdefined , Notdefined , } impl Default for IfcTransformerTypeEnum { fn default () -> Self { IfcTransformerTypeEnum :: Current } } impl From < String > for IfcTransformerTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CURRENT" => IfcTransformerTypeEnum :: Current , "FREQUENCY" => IfcTransformerTypeEnum :: Frequency , "INVERTER" => IfcTransformerTypeEnum :: Inverter , "RECTIFIER" => IfcTransformerTypeEnum :: Rectifier , "VOLTAGE" => IfcTransformerTypeEnum :: Voltage , "USERDEFINED" => IfcTransformerTypeEnum :: Userdefined , "NOTDEFINED" => IfcTransformerTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTransformerTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTransformerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTransformerTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTransitionCode { Discontinuous , Continuous , Contsamegradient , Contsamegradientsamecurvature , } impl Default for IfcTransitionCode { fn default () -> Self { IfcTransitionCode :: Discontinuous } } impl From < String > for IfcTransitionCode { fn from (value : String) -> Self { match value . as_str () { "DISCONTINUOUS" => IfcTransitionCode :: Discontinuous , "CONTINUOUS" => IfcTransitionCode :: Continuous , "CONTSAMEGRADIENT" => IfcTransitionCode :: Contsamegradient , "CONTSAMEGRADIENTSAMECURVATURE" => IfcTransitionCode :: Contsamegradientsamecurvature , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTransitionCode { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTransitionCode :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTransitionCode :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTransportElementTypeEnum { Elevator , Escalator , Movingwalkway , Craneway , Liftinggear , Userdefined , Notdefined , } impl Default for IfcTransportElementTypeEnum { fn default () -> Self { IfcTransportElementTypeEnum :: Elevator } } impl From < String > for IfcTransportElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ELEVATOR" => IfcTransportElementTypeEnum :: Elevator , "ESCALATOR" => IfcTransportElementTypeEnum :: Escalator , "MOVINGWALKWAY" => IfcTransportElementTypeEnum :: Movingwalkway , "CRANEWAY" => IfcTransportElementTypeEnum :: Craneway , "LIFTINGGEAR" => IfcTransportElementTypeEnum :: Liftinggear , "USERDEFINED" => IfcTransportElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcTransportElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTransportElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTransportElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTransportElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTrimmingPreference { Cartesian , Parameter , Unspecified , } impl Default for IfcTrimmingPreference { fn default () -> Self { IfcTrimmingPreference :: Cartesian } } impl From < String > for IfcTrimmingPreference { fn from (value : String) -> Self { match value . as_str () { "CARTESIAN" => IfcTrimmingPreference :: Cartesian , "PARAMETER" => IfcTrimmingPreference :: Parameter , "UNSPECIFIED" => IfcTrimmingPreference :: Unspecified , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTrimmingPreference { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTrimmingPreference :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTrimmingPreference :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTubeBundleTypeEnum { Finned , Userdefined , Notdefined , } impl Default for IfcTubeBundleTypeEnum { fn default () -> Self { IfcTubeBundleTypeEnum :: Finned } } impl From < String > for IfcTubeBundleTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FINNED" => IfcTubeBundleTypeEnum :: Finned , "USERDEFINED" => IfcTubeBundleTypeEnum :: Userdefined , "NOTDEFINED" => IfcTubeBundleTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcTubeBundleTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcTubeBundleTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcTubeBundleTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcUnitEnum { Absorbeddoseunit , Amountofsubstanceunit , Areaunit , Doseequivalentunit , Electriccapacitanceunit , Electricchargeunit , Electricconductanceunit , Electriccurrentunit , Electricresistanceunit , Electricvoltageunit , Energyunit , Forceunit , Frequencyunit , Illuminanceunit , Inductanceunit , Lengthunit , Luminousfluxunit , Luminousintensityunit , Magneticfluxdensityunit , Magneticfluxunit , Massunit , Planeangleunit , Powerunit , Pressureunit , Radioactivityunit , Solidangleunit , Thermodynamictemperatureunit , Timeunit , Volumeunit , Userdefined , } impl Default for IfcUnitEnum { fn default () -> Self { IfcUnitEnum :: Absorbeddoseunit } } impl From < String > for IfcUnitEnum { fn from (value : String) -> Self { match value . as_str () { "ABSORBEDDOSEUNIT" => IfcUnitEnum :: Absorbeddoseunit , "AMOUNTOFSUBSTANCEUNIT" => IfcUnitEnum :: Amountofsubstanceunit , "AREAUNIT" => IfcUnitEnum :: Areaunit , "DOSEEQUIVALENTUNIT" => IfcUnitEnum :: Doseequivalentunit , "ELECTRICCAPACITANCEUNIT" => IfcUnitEnum :: Electriccapacitanceunit , "ELECTRICCHARGEUNIT" => IfcUnitEnum :: Electricchargeunit , "ELECTRICCONDUCTANCEUNIT" => IfcUnitEnum :: Electricconductanceunit , "ELECTRICCURRENTUNIT" => IfcUnitEnum :: Electriccurrentunit , "ELECTRICRESISTANCEUNIT" => IfcUnitEnum :: Electricresistanceunit , "ELECTRICVOLTAGEUNIT" => IfcUnitEnum :: Electricvoltageunit , "ENERGYUNIT" => IfcUnitEnum :: Energyunit , "FORCEUNIT" => IfcUnitEnum :: Forceunit , "FREQUENCYUNIT" => IfcUnitEnum :: Frequencyunit , "ILLUMINANCEUNIT" => IfcUnitEnum :: Illuminanceunit , "INDUCTANCEUNIT" => IfcUnitEnum :: Inductanceunit , "LENGTHUNIT" => IfcUnitEnum :: Lengthunit , "LUMINOUSFLUXUNIT" => IfcUnitEnum :: Luminousfluxunit , "LUMINOUSINTENSITYUNIT" => IfcUnitEnum :: Luminousintensityunit , "MAGNETICFLUXDENSITYUNIT" => IfcUnitEnum :: Magneticfluxdensityunit , "MAGNETICFLUXUNIT" => IfcUnitEnum :: Magneticfluxunit , "MASSUNIT" => IfcUnitEnum :: Massunit , "PLANEANGLEUNIT" => IfcUnitEnum :: Planeangleunit , "POWERUNIT" => IfcUnitEnum :: Powerunit , "PRESSUREUNIT" => IfcUnitEnum :: Pressureunit , "RADIOACTIVITYUNIT" => IfcUnitEnum :: Radioactivityunit , "SOLIDANGLEUNIT" => IfcUnitEnum :: Solidangleunit , "THERMODYNAMICTEMPERATUREUNIT" => IfcUnitEnum :: Thermodynamictemperatureunit , "TIMEUNIT" => IfcUnitEnum :: Timeunit , "VOLUMEUNIT" => IfcUnitEnum :: Volumeunit , "USERDEFINED" => IfcUnitEnum :: Userdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcUnitEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcUnitEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcUnitEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcUnitaryControlElementTypeEnum { Alarmpanel , Controlpanel , Gasdetectionpanel , Indicatorpanel , Mimicpanel , Humidistat , Thermostat , Weatherstation , Userdefined , Notdefined , } impl Default for IfcUnitaryControlElementTypeEnum { fn default () -> Self { IfcUnitaryControlElementTypeEnum :: Alarmpanel } } impl From < String > for IfcUnitaryControlElementTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ALARMPANEL" => IfcUnitaryControlElementTypeEnum :: Alarmpanel , "CONTROLPANEL" => IfcUnitaryControlElementTypeEnum :: Controlpanel , "GASDETECTIONPANEL" => IfcUnitaryControlElementTypeEnum :: Gasdetectionpanel , "INDICATORPANEL" => IfcUnitaryControlElementTypeEnum :: Indicatorpanel , "MIMICPANEL" => IfcUnitaryControlElementTypeEnum :: Mimicpanel , "HUMIDISTAT" => IfcUnitaryControlElementTypeEnum :: Humidistat , "THERMOSTAT" => IfcUnitaryControlElementTypeEnum :: Thermostat , "WEATHERSTATION" => IfcUnitaryControlElementTypeEnum :: Weatherstation , "USERDEFINED" => IfcUnitaryControlElementTypeEnum :: Userdefined , "NOTDEFINED" => IfcUnitaryControlElementTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcUnitaryControlElementTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcUnitaryControlElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcUnitaryControlElementTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcUnitaryEquipmentTypeEnum { Airhandler , Airconditioningunit , Dehumidifier , Splitsystem , Rooftopunit , Userdefined , Notdefined , } impl Default for IfcUnitaryEquipmentTypeEnum { fn default () -> Self { IfcUnitaryEquipmentTypeEnum :: Airhandler } } impl From < String > for IfcUnitaryEquipmentTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AIRHANDLER" => IfcUnitaryEquipmentTypeEnum :: Airhandler , "AIRCONDITIONINGUNIT" => IfcUnitaryEquipmentTypeEnum :: Airconditioningunit , "DEHUMIDIFIER" => IfcUnitaryEquipmentTypeEnum :: Dehumidifier , "SPLITSYSTEM" => IfcUnitaryEquipmentTypeEnum :: Splitsystem , "ROOFTOPUNIT" => IfcUnitaryEquipmentTypeEnum :: Rooftopunit , "USERDEFINED" => IfcUnitaryEquipmentTypeEnum :: Userdefined , "NOTDEFINED" => IfcUnitaryEquipmentTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcUnitaryEquipmentTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcUnitaryEquipmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcUnitaryEquipmentTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcValveTypeEnum { Airrelease , Antivacuum , Changeover , Check , Commissioning , Diverting , Drawoffcock , Doublecheck , Doubleregulating , Faucet , Flushing , Gascock , Gastap , Isolating , Mixing , Pressurereducing , Pressurerelief , Regulating , Safetycutoff , Steamtrap , Stopcock , Userdefined , Notdefined , } impl Default for IfcValveTypeEnum { fn default () -> Self { IfcValveTypeEnum :: Airrelease } } impl From < String > for IfcValveTypeEnum { fn from (value : String) -> Self { match value . as_str () { "AIRRELEASE" => IfcValveTypeEnum :: Airrelease , "ANTIVACUUM" => IfcValveTypeEnum :: Antivacuum , "CHANGEOVER" => IfcValveTypeEnum :: Changeover , "CHECK" => IfcValveTypeEnum :: Check , "COMMISSIONING" => IfcValveTypeEnum :: Commissioning , "DIVERTING" => IfcValveTypeEnum :: Diverting , "DRAWOFFCOCK" => IfcValveTypeEnum :: Drawoffcock , "DOUBLECHECK" => IfcValveTypeEnum :: Doublecheck , "DOUBLEREGULATING" => IfcValveTypeEnum :: Doubleregulating , "FAUCET" => IfcValveTypeEnum :: Faucet , "FLUSHING" => IfcValveTypeEnum :: Flushing , "GASCOCK" => IfcValveTypeEnum :: Gascock , "GASTAP" => IfcValveTypeEnum :: Gastap , "ISOLATING" => IfcValveTypeEnum :: Isolating , "MIXING" => IfcValveTypeEnum :: Mixing , "PRESSUREREDUCING" => IfcValveTypeEnum :: Pressurereducing , "PRESSURERELIEF" => IfcValveTypeEnum :: Pressurerelief , "REGULATING" => IfcValveTypeEnum :: Regulating , "SAFETYCUTOFF" => IfcValveTypeEnum :: Safetycutoff , "STEAMTRAP" => IfcValveTypeEnum :: Steamtrap , "STOPCOCK" => IfcValveTypeEnum :: Stopcock , "USERDEFINED" => IfcValveTypeEnum :: Userdefined , "NOTDEFINED" => IfcValveTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcValveTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcValveTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcValveTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcVibrationIsolatorTypeEnum { Compression , Spring , Userdefined , Notdefined , } impl Default for IfcVibrationIsolatorTypeEnum { fn default () -> Self { IfcVibrationIsolatorTypeEnum :: Compression } } impl From < String > for IfcVibrationIsolatorTypeEnum { fn from (value : String) -> Self { match value . as_str () { "COMPRESSION" => IfcVibrationIsolatorTypeEnum :: Compression , "SPRING" => IfcVibrationIsolatorTypeEnum :: Spring , "USERDEFINED" => IfcVibrationIsolatorTypeEnum :: Userdefined , "NOTDEFINED" => IfcVibrationIsolatorTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcVibrationIsolatorTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcVibrationIsolatorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcVibrationIsolatorTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcVoidingFeatureTypeEnum { Cutout , Notch , Hole , Miter , Chamfer , Edge , Userdefined , Notdefined , } impl Default for IfcVoidingFeatureTypeEnum { fn default () -> Self { IfcVoidingFeatureTypeEnum :: Cutout } } impl From < String > for IfcVoidingFeatureTypeEnum { fn from (value : String) -> Self { match value . as_str () { "CUTOUT" => IfcVoidingFeatureTypeEnum :: Cutout , "NOTCH" => IfcVoidingFeatureTypeEnum :: Notch , "HOLE" => IfcVoidingFeatureTypeEnum :: Hole , "MITER" => IfcVoidingFeatureTypeEnum :: Miter , "CHAMFER" => IfcVoidingFeatureTypeEnum :: Chamfer , "EDGE" => IfcVoidingFeatureTypeEnum :: Edge , "USERDEFINED" => IfcVoidingFeatureTypeEnum :: Userdefined , "NOTDEFINED" => IfcVoidingFeatureTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcVoidingFeatureTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcVoidingFeatureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcVoidingFeatureTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWallTypeEnum { Movable , Parapet , Partitioning , Plumbingwall , Shear , Solidwall , Standard , Polygonal , Elementedwall , Userdefined , Notdefined , } impl Default for IfcWallTypeEnum { fn default () -> Self { IfcWallTypeEnum :: Movable } } impl From < String > for IfcWallTypeEnum { fn from (value : String) -> Self { match value . as_str () { "MOVABLE" => IfcWallTypeEnum :: Movable , "PARAPET" => IfcWallTypeEnum :: Parapet , "PARTITIONING" => IfcWallTypeEnum :: Partitioning , "PLUMBINGWALL" => IfcWallTypeEnum :: Plumbingwall , "SHEAR" => IfcWallTypeEnum :: Shear , "SOLIDWALL" => IfcWallTypeEnum :: Solidwall , "STANDARD" => IfcWallTypeEnum :: Standard , "POLYGONAL" => IfcWallTypeEnum :: Polygonal , "ELEMENTEDWALL" => IfcWallTypeEnum :: Elementedwall , "USERDEFINED" => IfcWallTypeEnum :: Userdefined , "NOTDEFINED" => IfcWallTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWallTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWallTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWallTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWasteTerminalTypeEnum { Floortrap , Floorwaste , Gullysump , Gullytrap , Roofdrain , Wastedisposalunit , Wastetrap , Userdefined , Notdefined , } impl Default for IfcWasteTerminalTypeEnum { fn default () -> Self { IfcWasteTerminalTypeEnum :: Floortrap } } impl From < String > for IfcWasteTerminalTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FLOORTRAP" => IfcWasteTerminalTypeEnum :: Floortrap , "FLOORWASTE" => IfcWasteTerminalTypeEnum :: Floorwaste , "GULLYSUMP" => IfcWasteTerminalTypeEnum :: Gullysump , "GULLYTRAP" => IfcWasteTerminalTypeEnum :: Gullytrap , "ROOFDRAIN" => IfcWasteTerminalTypeEnum :: Roofdrain , "WASTEDISPOSALUNIT" => IfcWasteTerminalTypeEnum :: Wastedisposalunit , "WASTETRAP" => IfcWasteTerminalTypeEnum :: Wastetrap , "USERDEFINED" => IfcWasteTerminalTypeEnum :: Userdefined , "NOTDEFINED" => IfcWasteTerminalTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWasteTerminalTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWasteTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWasteTerminalTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWindowPanelOperationEnum { Sidehungrighthand , Sidehunglefthand , Tiltandturnrighthand , Tiltandturnlefthand , Tophung , Bottomhung , Pivothorizontal , Pivotvertical , Slidinghorizontal , Slidingvertical , Removablecasement , Fixedcasement , Otheroperation , Notdefined , } impl Default for IfcWindowPanelOperationEnum { fn default () -> Self { IfcWindowPanelOperationEnum :: Sidehungrighthand } } impl From < String > for IfcWindowPanelOperationEnum { fn from (value : String) -> Self { match value . as_str () { "SIDEHUNGRIGHTHAND" => IfcWindowPanelOperationEnum :: Sidehungrighthand , "SIDEHUNGLEFTHAND" => IfcWindowPanelOperationEnum :: Sidehunglefthand , "TILTANDTURNRIGHTHAND" => IfcWindowPanelOperationEnum :: Tiltandturnrighthand , "TILTANDTURNLEFTHAND" => IfcWindowPanelOperationEnum :: Tiltandturnlefthand , "TOPHUNG" => IfcWindowPanelOperationEnum :: Tophung , "BOTTOMHUNG" => IfcWindowPanelOperationEnum :: Bottomhung , "PIVOTHORIZONTAL" => IfcWindowPanelOperationEnum :: Pivothorizontal , "PIVOTVERTICAL" => IfcWindowPanelOperationEnum :: Pivotvertical , "SLIDINGHORIZONTAL" => IfcWindowPanelOperationEnum :: Slidinghorizontal , "SLIDINGVERTICAL" => IfcWindowPanelOperationEnum :: Slidingvertical , "REMOVABLECASEMENT" => IfcWindowPanelOperationEnum :: Removablecasement , "FIXEDCASEMENT" => IfcWindowPanelOperationEnum :: Fixedcasement , "OTHEROPERATION" => IfcWindowPanelOperationEnum :: Otheroperation , "NOTDEFINED" => IfcWindowPanelOperationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWindowPanelOperationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWindowPanelOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWindowPanelOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWindowPanelPositionEnum { Left , Middle , Right , Bottom , Top , Notdefined , } impl Default for IfcWindowPanelPositionEnum { fn default () -> Self { IfcWindowPanelPositionEnum :: Left } } impl From < String > for IfcWindowPanelPositionEnum { fn from (value : String) -> Self { match value . as_str () { "LEFT" => IfcWindowPanelPositionEnum :: Left , "MIDDLE" => IfcWindowPanelPositionEnum :: Middle , "RIGHT" => IfcWindowPanelPositionEnum :: Right , "BOTTOM" => IfcWindowPanelPositionEnum :: Bottom , "TOP" => IfcWindowPanelPositionEnum :: Top , "NOTDEFINED" => IfcWindowPanelPositionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWindowPanelPositionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWindowPanelPositionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWindowPanelPositionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWindowStyleConstructionEnum { Aluminium , HighGradeSteel , Steel , Wood , AluminiumWood , Plastic , OtherConstruction , Notdefined , } impl Default for IfcWindowStyleConstructionEnum { fn default () -> Self { IfcWindowStyleConstructionEnum :: Aluminium } } impl From < String > for IfcWindowStyleConstructionEnum { fn from (value : String) -> Self { match value . as_str () { "ALUMINIUM" => IfcWindowStyleConstructionEnum :: Aluminium , "HIGH_GRADE_STEEL" => IfcWindowStyleConstructionEnum :: HighGradeSteel , "STEEL" => IfcWindowStyleConstructionEnum :: Steel , "WOOD" => IfcWindowStyleConstructionEnum :: Wood , "ALUMINIUM_WOOD" => IfcWindowStyleConstructionEnum :: AluminiumWood , "PLASTIC" => IfcWindowStyleConstructionEnum :: Plastic , "OTHER_CONSTRUCTION" => IfcWindowStyleConstructionEnum :: OtherConstruction , "NOTDEFINED" => IfcWindowStyleConstructionEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWindowStyleConstructionEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWindowStyleConstructionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWindowStyleConstructionEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWindowStyleOperationEnum { SinglePanel , DoublePanelVertical , DoublePanelHorizontal , TriplePanelVertical , TriplePanelBottom , TriplePanelTop , TriplePanelLeft , TriplePanelRight , TriplePanelHorizontal , Userdefined , Notdefined , } impl Default for IfcWindowStyleOperationEnum { fn default () -> Self { IfcWindowStyleOperationEnum :: SinglePanel } } impl From < String > for IfcWindowStyleOperationEnum { fn from (value : String) -> Self { match value . as_str () { "SINGLE_PANEL" => IfcWindowStyleOperationEnum :: SinglePanel , "DOUBLE_PANEL_VERTICAL" => IfcWindowStyleOperationEnum :: DoublePanelVertical , "DOUBLE_PANEL_HORIZONTAL" => IfcWindowStyleOperationEnum :: DoublePanelHorizontal , "TRIPLE_PANEL_VERTICAL" => IfcWindowStyleOperationEnum :: TriplePanelVertical , "TRIPLE_PANEL_BOTTOM" => IfcWindowStyleOperationEnum :: TriplePanelBottom , "TRIPLE_PANEL_TOP" => IfcWindowStyleOperationEnum :: TriplePanelTop , "TRIPLE_PANEL_LEFT" => IfcWindowStyleOperationEnum :: TriplePanelLeft , "TRIPLE_PANEL_RIGHT" => IfcWindowStyleOperationEnum :: TriplePanelRight , "TRIPLE_PANEL_HORIZONTAL" => IfcWindowStyleOperationEnum :: TriplePanelHorizontal , "USERDEFINED" => IfcWindowStyleOperationEnum :: Userdefined , "NOTDEFINED" => IfcWindowStyleOperationEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWindowStyleOperationEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWindowStyleOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWindowStyleOperationEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWindowTypeEnum { Window , Skylight , Lightdome , Userdefined , Notdefined , } impl Default for IfcWindowTypeEnum { fn default () -> Self { IfcWindowTypeEnum :: Window } } impl From < String > for IfcWindowTypeEnum { fn from (value : String) -> Self { match value . as_str () { "WINDOW" => IfcWindowTypeEnum :: Window , "SKYLIGHT" => IfcWindowTypeEnum :: Skylight , "LIGHTDOME" => IfcWindowTypeEnum :: Lightdome , "USERDEFINED" => IfcWindowTypeEnum :: Userdefined , "NOTDEFINED" => IfcWindowTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWindowTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWindowTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWindowTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWindowTypePartitioningEnum { SinglePanel , DoublePanelVertical , DoublePanelHorizontal , TriplePanelVertical , TriplePanelBottom , TriplePanelTop , TriplePanelLeft , TriplePanelRight , TriplePanelHorizontal , Userdefined , Notdefined , } impl Default for IfcWindowTypePartitioningEnum { fn default () -> Self { IfcWindowTypePartitioningEnum :: SinglePanel } } impl From < String > for IfcWindowTypePartitioningEnum { fn from (value : String) -> Self { match value . as_str () { "SINGLE_PANEL" => IfcWindowTypePartitioningEnum :: SinglePanel , "DOUBLE_PANEL_VERTICAL" => IfcWindowTypePartitioningEnum :: DoublePanelVertical , "DOUBLE_PANEL_HORIZONTAL" => IfcWindowTypePartitioningEnum :: DoublePanelHorizontal , "TRIPLE_PANEL_VERTICAL" => IfcWindowTypePartitioningEnum :: TriplePanelVertical , "TRIPLE_PANEL_BOTTOM" => IfcWindowTypePartitioningEnum :: TriplePanelBottom , "TRIPLE_PANEL_TOP" => IfcWindowTypePartitioningEnum :: TriplePanelTop , "TRIPLE_PANEL_LEFT" => IfcWindowTypePartitioningEnum :: TriplePanelLeft , "TRIPLE_PANEL_RIGHT" => IfcWindowTypePartitioningEnum :: TriplePanelRight , "TRIPLE_PANEL_HORIZONTAL" => IfcWindowTypePartitioningEnum :: TriplePanelHorizontal , "USERDEFINED" => IfcWindowTypePartitioningEnum :: Userdefined , "NOTDEFINED" => IfcWindowTypePartitioningEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWindowTypePartitioningEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWindowTypePartitioningEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWindowTypePartitioningEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWorkCalendarTypeEnum { Firstshift , Secondshift , Thirdshift , Userdefined , Notdefined , } impl Default for IfcWorkCalendarTypeEnum { fn default () -> Self { IfcWorkCalendarTypeEnum :: Firstshift } } impl From < String > for IfcWorkCalendarTypeEnum { fn from (value : String) -> Self { match value . as_str () { "FIRSTSHIFT" => IfcWorkCalendarTypeEnum :: Firstshift , "SECONDSHIFT" => IfcWorkCalendarTypeEnum :: Secondshift , "THIRDSHIFT" => IfcWorkCalendarTypeEnum :: Thirdshift , "USERDEFINED" => IfcWorkCalendarTypeEnum :: Userdefined , "NOTDEFINED" => IfcWorkCalendarTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWorkCalendarTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWorkCalendarTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWorkCalendarTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWorkPlanTypeEnum { Actual , Baseline , Planned , Userdefined , Notdefined , } impl Default for IfcWorkPlanTypeEnum { fn default () -> Self { IfcWorkPlanTypeEnum :: Actual } } impl From < String > for IfcWorkPlanTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ACTUAL" => IfcWorkPlanTypeEnum :: Actual , "BASELINE" => IfcWorkPlanTypeEnum :: Baseline , "PLANNED" => IfcWorkPlanTypeEnum :: Planned , "USERDEFINED" => IfcWorkPlanTypeEnum :: Userdefined , "NOTDEFINED" => IfcWorkPlanTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWorkPlanTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWorkPlanTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWorkPlanTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcWorkScheduleTypeEnum { Actual , Baseline , Planned , Userdefined , Notdefined , } impl Default for IfcWorkScheduleTypeEnum { fn default () -> Self { IfcWorkScheduleTypeEnum :: Actual } } impl From < String > for IfcWorkScheduleTypeEnum { fn from (value : String) -> Self { match value . as_str () { "ACTUAL" => IfcWorkScheduleTypeEnum :: Actual , "BASELINE" => IfcWorkScheduleTypeEnum :: Baseline , "PLANNED" => IfcWorkScheduleTypeEnum :: Planned , "USERDEFINED" => IfcWorkScheduleTypeEnum :: Userdefined , "NOTDEFINED" => IfcWorkScheduleTypeEnum :: Notdefined , _ => panic ! ("{} is not a valid value" , value) , } } } impl From < Parameter > for IfcWorkScheduleTypeEnum { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EnumValue (value) => value . into () , UnTypedParameter :: Null => IfcWorkScheduleTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } , Parameter :: OmittedParameter => IfcWorkScheduleTypeEnum :: default () , _ => panic ! ("parameter is not an enum value") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcActorSelect { EntityRef (i64) , IfcOrganization (EntityRef < IfcOrganization >) , IfcPerson (EntityRef < IfcPerson >) , IfcPersonAndOrganization (EntityRef < IfcPersonAndOrganization >) , } impl Default for IfcActorSelect { fn default () -> Self { IfcActorSelect :: IfcOrganization (EntityRef < IfcOrganization > :: default ()) } } impl From < Parameter > for IfcActorSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcActorSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcAppliedValueSelect { EntityRef (i64) , IfcMeasureWithUnit (EntityRef < IfcMeasureWithUnit >) , IfcReference (EntityRef < IfcReference >) , IfcValue (IfcValue) , } impl Default for IfcAppliedValueSelect { fn default () -> Self { IfcAppliedValueSelect :: IfcMeasureWithUnit (EntityRef < IfcMeasureWithUnit > :: default ()) } } impl From < Parameter > for IfcAppliedValueSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCDERIVEDMEASUREVALUE" | "IFCMEASUREVALUE" | "IFCSIMPLEVALUE" => { IfcAppliedValueSelect :: IfcValue (IfcValue :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcAppliedValueSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcAxis2Placement { EntityRef (i64) , IfcAxis2Placement2D (EntityRef < IfcAxis2Placement2D >) , IfcAxis2Placement3D (EntityRef < IfcAxis2Placement3D >) , } impl Default for IfcAxis2Placement { fn default () -> Self { IfcAxis2Placement :: IfcAxis2Placement2D (EntityRef < IfcAxis2Placement2D > :: default ()) } } impl From < Parameter > for IfcAxis2Placement { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcAxis2Placement :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcBendingParameterSelect { IfcLengthMeasure (IfcLengthMeasure) , IfcPlaneAngleMeasure (IfcPlaneAngleMeasure) , } impl Default for IfcBendingParameterSelect { fn default () -> Self { IfcBendingParameterSelect :: IfcLengthMeasure (IfcLengthMeasure :: default ()) } } impl From < Parameter > for IfcBendingParameterSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCLENGTHMEASURE" => IfcBendingParameterSelect :: IfcLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPLANEANGLEMEASURE" => IfcBendingParameterSelect :: IfcPlaneAngleMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcBooleanOperand { EntityRef (i64) , IfcBooleanResult (EntityRef < IfcBooleanResult >) , IfcCsgPrimitive3D (EntityRef < IfcCsgPrimitive3D >) , IfcHalfSpaceSolid (EntityRef < IfcHalfSpaceSolid >) , IfcSolidModel (EntityRef < IfcSolidModel >) , IfcTessellatedFaceSet (EntityRef < IfcTessellatedFaceSet >) , } impl Default for IfcBooleanOperand { fn default () -> Self { IfcBooleanOperand :: IfcBooleanResult (EntityRef < IfcBooleanResult > :: default ()) } } impl From < Parameter > for IfcBooleanOperand { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcBooleanOperand :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcClassificationReferenceSelect { EntityRef (i64) , IfcClassification (EntityRef < IfcClassification >) , IfcClassificationReference (EntityRef < IfcClassificationReference >) , } impl Default for IfcClassificationReferenceSelect { fn default () -> Self { IfcClassificationReferenceSelect :: IfcClassification (EntityRef < IfcClassification > :: default ()) } } impl From < Parameter > for IfcClassificationReferenceSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcClassificationReferenceSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcClassificationSelect { EntityRef (i64) , IfcClassification (EntityRef < IfcClassification >) , IfcClassificationReference (EntityRef < IfcClassificationReference >) , } impl Default for IfcClassificationSelect { fn default () -> Self { IfcClassificationSelect :: IfcClassification (EntityRef < IfcClassification > :: default ()) } } impl From < Parameter > for IfcClassificationSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcClassificationSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcColour { EntityRef (i64) , IfcColourSpecification (EntityRef < IfcColourSpecification >) , IfcPreDefinedColour (EntityRef < IfcPreDefinedColour >) , } impl Default for IfcColour { fn default () -> Self { IfcColour :: IfcColourSpecification (EntityRef < IfcColourSpecification > :: default ()) } } impl From < Parameter > for IfcColour { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcColour :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcColourOrFactor { IfcColourRgb (EntityRef < IfcColourRgb >) , IfcNormalisedRatioMeasure (IfcNormalisedRatioMeasure) , } impl Default for IfcColourOrFactor { fn default () -> Self { IfcColourOrFactor :: IfcColourRgb (EntityRef < IfcColourRgb > :: default ()) } } impl From < Parameter > for IfcColourOrFactor { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCNORMALISEDRATIOMEASURE" => IfcColourOrFactor :: IfcNormalisedRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcColourOrFactor :: IfcColourRgb (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcCoordinateReferenceSystemSelect { EntityRef (i64) , IfcCoordinateReferenceSystem (EntityRef < IfcCoordinateReferenceSystem >) , IfcGeometricRepresentationContext (EntityRef < IfcGeometricRepresentationContext >) , } impl Default for IfcCoordinateReferenceSystemSelect { fn default () -> Self { IfcCoordinateReferenceSystemSelect :: IfcCoordinateReferenceSystem (EntityRef < IfcCoordinateReferenceSystem > :: default ()) } } impl From < Parameter > for IfcCoordinateReferenceSystemSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcCoordinateReferenceSystemSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcCsgSelect { EntityRef (i64) , IfcBooleanResult (EntityRef < IfcBooleanResult >) , IfcCsgPrimitive3D (EntityRef < IfcCsgPrimitive3D >) , } impl Default for IfcCsgSelect { fn default () -> Self { IfcCsgSelect :: IfcBooleanResult (EntityRef < IfcBooleanResult > :: default ()) } } impl From < Parameter > for IfcCsgSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcCsgSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcCurveFontOrScaledCurveFontSelect { IfcCurveStyleFontAndScaling (EntityRef < IfcCurveStyleFontAndScaling >) , IfcCurveStyleFontSelect (IfcCurveStyleFontSelect) , } impl Default for IfcCurveFontOrScaledCurveFontSelect { fn default () -> Self { IfcCurveFontOrScaledCurveFontSelect :: IfcCurveStyleFontAndScaling (EntityRef < IfcCurveStyleFontAndScaling > :: default ()) } } impl From < Parameter > for IfcCurveFontOrScaledCurveFontSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCCURVESTYLEFONT" | "IFCPREDEFINEDCURVEFONT" => { IfcCurveFontOrScaledCurveFontSelect :: IfcCurveStyleFontSelect (IfcCurveStyleFontSelect :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcCurveFontOrScaledCurveFontSelect :: IfcCurveStyleFontAndScaling (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcCurveOnSurface { EntityRef (i64) , IfcCompositeCurveOnSurface (EntityRef < IfcCompositeCurveOnSurface >) , IfcPcurve (EntityRef < IfcPcurve >) , IfcSurfaceCurve (EntityRef < IfcSurfaceCurve >) , } impl Default for IfcCurveOnSurface { fn default () -> Self { IfcCurveOnSurface :: IfcCompositeCurveOnSurface (EntityRef < IfcCompositeCurveOnSurface > :: default ()) } } impl From < Parameter > for IfcCurveOnSurface { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcCurveOnSurface :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcCurveOrEdgeCurve { EntityRef (i64) , IfcBoundedCurve (EntityRef < IfcBoundedCurve >) , IfcEdgeCurve (EntityRef < IfcEdgeCurve >) , } impl Default for IfcCurveOrEdgeCurve { fn default () -> Self { IfcCurveOrEdgeCurve :: IfcBoundedCurve (EntityRef < IfcBoundedCurve > :: default ()) } } impl From < Parameter > for IfcCurveOrEdgeCurve { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcCurveOrEdgeCurve :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcCurveStyleFontSelect { EntityRef (i64) , IfcCurveStyleFont (EntityRef < IfcCurveStyleFont >) , IfcPreDefinedCurveFont (EntityRef < IfcPreDefinedCurveFont >) , } impl Default for IfcCurveStyleFontSelect { fn default () -> Self { IfcCurveStyleFontSelect :: IfcCurveStyleFont (EntityRef < IfcCurveStyleFont > :: default ()) } } impl From < Parameter > for IfcCurveStyleFontSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcCurveStyleFontSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcDefinitionSelect { EntityRef (i64) , IfcObjectDefinition (EntityRef < IfcObjectDefinition >) , IfcPropertyDefinition (EntityRef < IfcPropertyDefinition >) , } impl Default for IfcDefinitionSelect { fn default () -> Self { IfcDefinitionSelect :: IfcObjectDefinition (EntityRef < IfcObjectDefinition > :: default ()) } } impl From < Parameter > for IfcDefinitionSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcDefinitionSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcDerivedMeasureValue { IfcAbsorbedDoseMeasure (IfcAbsorbedDoseMeasure) , IfcAccelerationMeasure (IfcAccelerationMeasure) , IfcAngularVelocityMeasure (IfcAngularVelocityMeasure) , IfcAreaDensityMeasure (IfcAreaDensityMeasure) , IfcCompoundPlaneAngleMeasure (IfcCompoundPlaneAngleMeasure) , IfcCurvatureMeasure (IfcCurvatureMeasure) , IfcDoseEquivalentMeasure (IfcDoseEquivalentMeasure) , IfcDynamicViscosityMeasure (IfcDynamicViscosityMeasure) , IfcElectricCapacitanceMeasure (IfcElectricCapacitanceMeasure) , IfcElectricChargeMeasure (IfcElectricChargeMeasure) , IfcElectricConductanceMeasure (IfcElectricConductanceMeasure) , IfcElectricResistanceMeasure (IfcElectricResistanceMeasure) , IfcElectricVoltageMeasure (IfcElectricVoltageMeasure) , IfcEnergyMeasure (IfcEnergyMeasure) , IfcForceMeasure (IfcForceMeasure) , IfcFrequencyMeasure (IfcFrequencyMeasure) , IfcHeatFluxDensityMeasure (IfcHeatFluxDensityMeasure) , IfcHeatingValueMeasure (IfcHeatingValueMeasure) , IfcIlluminanceMeasure (IfcIlluminanceMeasure) , IfcInductanceMeasure (IfcInductanceMeasure) , IfcIntegerCountRateMeasure (IfcIntegerCountRateMeasure) , IfcIonConcentrationMeasure (IfcIonConcentrationMeasure) , IfcIsothermalMoistureCapacityMeasure (IfcIsothermalMoistureCapacityMeasure) , IfcKinematicViscosityMeasure (IfcKinematicViscosityMeasure) , IfcLinearForceMeasure (IfcLinearForceMeasure) , IfcLinearMomentMeasure (IfcLinearMomentMeasure) , IfcLinearStiffnessMeasure (IfcLinearStiffnessMeasure) , IfcLinearVelocityMeasure (IfcLinearVelocityMeasure) , IfcLuminousFluxMeasure (IfcLuminousFluxMeasure) , IfcLuminousIntensityDistributionMeasure (IfcLuminousIntensityDistributionMeasure) , IfcMagneticFluxDensityMeasure (IfcMagneticFluxDensityMeasure) , IfcMagneticFluxMeasure (IfcMagneticFluxMeasure) , IfcMassDensityMeasure (IfcMassDensityMeasure) , IfcMassFlowRateMeasure (IfcMassFlowRateMeasure) , IfcMassPerLengthMeasure (IfcMassPerLengthMeasure) , IfcModulusOfElasticityMeasure (IfcModulusOfElasticityMeasure) , IfcModulusOfLinearSubgradeReactionMeasure (IfcModulusOfLinearSubgradeReactionMeasure) , IfcModulusOfRotationalSubgradeReactionMeasure (IfcModulusOfRotationalSubgradeReactionMeasure) , IfcModulusOfSubgradeReactionMeasure (IfcModulusOfSubgradeReactionMeasure) , IfcMoistureDiffusivityMeasure (IfcMoistureDiffusivityMeasure) , IfcMolecularWeightMeasure (IfcMolecularWeightMeasure) , IfcMomentOfInertiaMeasure (IfcMomentOfInertiaMeasure) , IfcMonetaryMeasure (IfcMonetaryMeasure) , IfcPhMeasure (IfcPhMeasure) , IfcPlanarForceMeasure (IfcPlanarForceMeasure) , IfcPowerMeasure (IfcPowerMeasure) , IfcPressureMeasure (IfcPressureMeasure) , IfcRadioActivityMeasure (IfcRadioActivityMeasure) , IfcRotationalFrequencyMeasure (IfcRotationalFrequencyMeasure) , IfcRotationalMassMeasure (IfcRotationalMassMeasure) , IfcRotationalStiffnessMeasure (IfcRotationalStiffnessMeasure) , IfcSectionModulusMeasure (IfcSectionModulusMeasure) , IfcSectionalAreaIntegralMeasure (IfcSectionalAreaIntegralMeasure) , IfcShearModulusMeasure (IfcShearModulusMeasure) , IfcSoundPowerLevelMeasure (IfcSoundPowerLevelMeasure) , IfcSoundPowerMeasure (IfcSoundPowerMeasure) , IfcSoundPressureLevelMeasure (IfcSoundPressureLevelMeasure) , IfcSoundPressureMeasure (IfcSoundPressureMeasure) , IfcSpecificHeatCapacityMeasure (IfcSpecificHeatCapacityMeasure) , IfcTemperatureGradientMeasure (IfcTemperatureGradientMeasure) , IfcTemperatureRateOfChangeMeasure (IfcTemperatureRateOfChangeMeasure) , IfcThermalAdmittanceMeasure (IfcThermalAdmittanceMeasure) , IfcThermalConductivityMeasure (IfcThermalConductivityMeasure) , IfcThermalExpansionCoefficientMeasure (IfcThermalExpansionCoefficientMeasure) , IfcThermalResistanceMeasure (IfcThermalResistanceMeasure) , IfcThermalTransmittanceMeasure (IfcThermalTransmittanceMeasure) , IfcTorqueMeasure (IfcTorqueMeasure) , IfcVaporPermeabilityMeasure (IfcVaporPermeabilityMeasure) , IfcVolumetricFlowRateMeasure (IfcVolumetricFlowRateMeasure) , IfcWarpingConstantMeasure (IfcWarpingConstantMeasure) , IfcWarpingMomentMeasure (IfcWarpingMomentMeasure) , } impl Default for IfcDerivedMeasureValue { fn default () -> Self { IfcDerivedMeasureValue :: IfcAbsorbedDoseMeasure (IfcAbsorbedDoseMeasure :: default ()) } } impl From < Parameter > for IfcDerivedMeasureValue { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCABSORBEDDOSEMEASURE" => IfcDerivedMeasureValue :: IfcAbsorbedDoseMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCACCELERATIONMEASURE" => IfcDerivedMeasureValue :: IfcAccelerationMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCANGULARVELOCITYMEASURE" => IfcDerivedMeasureValue :: IfcAngularVelocityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCAREADENSITYMEASURE" => IfcDerivedMeasureValue :: IfcAreaDensityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCCOMPOUNDPLANEANGLEMEASURE" => IfcDerivedMeasureValue :: IfcCompoundPlaneAngleMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCCURVATUREMEASURE" => IfcDerivedMeasureValue :: IfcCurvatureMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCDOSEEQUIVALENTMEASURE" => IfcDerivedMeasureValue :: IfcDoseEquivalentMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCDYNAMICVISCOSITYMEASURE" => IfcDerivedMeasureValue :: IfcDynamicViscosityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCELECTRICCAPACITANCEMEASURE" => IfcDerivedMeasureValue :: IfcElectricCapacitanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCELECTRICCHARGEMEASURE" => IfcDerivedMeasureValue :: IfcElectricChargeMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCELECTRICCONDUCTANCEMEASURE" => IfcDerivedMeasureValue :: IfcElectricConductanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCELECTRICRESISTANCEMEASURE" => IfcDerivedMeasureValue :: IfcElectricResistanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCELECTRICVOLTAGEMEASURE" => IfcDerivedMeasureValue :: IfcElectricVoltageMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCENERGYMEASURE" => IfcDerivedMeasureValue :: IfcEnergyMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCFORCEMEASURE" => IfcDerivedMeasureValue :: IfcForceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCFREQUENCYMEASURE" => IfcDerivedMeasureValue :: IfcFrequencyMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCHEATFLUXDENSITYMEASURE" => IfcDerivedMeasureValue :: IfcHeatFluxDensityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCHEATINGVALUEMEASURE" => IfcDerivedMeasureValue :: IfcHeatingValueMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCILLUMINANCEMEASURE" => IfcDerivedMeasureValue :: IfcIlluminanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCINDUCTANCEMEASURE" => IfcDerivedMeasureValue :: IfcInductanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCINTEGERCOUNTRATEMEASURE" => IfcDerivedMeasureValue :: IfcIntegerCountRateMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCIONCONCENTRATIONMEASURE" => IfcDerivedMeasureValue :: IfcIonConcentrationMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCISOTHERMALMOISTURECAPACITYMEASURE" => IfcDerivedMeasureValue :: IfcIsothermalMoistureCapacityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCKINEMATICVISCOSITYMEASURE" => IfcDerivedMeasureValue :: IfcKinematicViscosityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLINEARFORCEMEASURE" => IfcDerivedMeasureValue :: IfcLinearForceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLINEARMOMENTMEASURE" => IfcDerivedMeasureValue :: IfcLinearMomentMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLINEARSTIFFNESSMEASURE" => IfcDerivedMeasureValue :: IfcLinearStiffnessMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLINEARVELOCITYMEASURE" => IfcDerivedMeasureValue :: IfcLinearVelocityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLUMINOUSFLUXMEASURE" => IfcDerivedMeasureValue :: IfcLuminousFluxMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE" => IfcDerivedMeasureValue :: IfcLuminousIntensityDistributionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMAGNETICFLUXDENSITYMEASURE" => IfcDerivedMeasureValue :: IfcMagneticFluxDensityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMAGNETICFLUXMEASURE" => IfcDerivedMeasureValue :: IfcMagneticFluxMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMASSDENSITYMEASURE" => IfcDerivedMeasureValue :: IfcMassDensityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMASSFLOWRATEMEASURE" => IfcDerivedMeasureValue :: IfcMassFlowRateMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMASSPERLENGTHMEASURE" => IfcDerivedMeasureValue :: IfcMassPerLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFELASTICITYMEASURE" => IfcDerivedMeasureValue :: IfcModulusOfElasticityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE" => IfcDerivedMeasureValue :: IfcModulusOfLinearSubgradeReactionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE" => IfcDerivedMeasureValue :: IfcModulusOfRotationalSubgradeReactionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFSUBGRADEREACTIONMEASURE" => IfcDerivedMeasureValue :: IfcModulusOfSubgradeReactionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMOISTUREDIFFUSIVITYMEASURE" => IfcDerivedMeasureValue :: IfcMoistureDiffusivityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMOLECULARWEIGHTMEASURE" => IfcDerivedMeasureValue :: IfcMolecularWeightMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMOMENTOFINERTIAMEASURE" => IfcDerivedMeasureValue :: IfcMomentOfInertiaMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMONETARYMEASURE" => IfcDerivedMeasureValue :: IfcMonetaryMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPHMEASURE" => IfcDerivedMeasureValue :: IfcPhMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPLANARFORCEMEASURE" => IfcDerivedMeasureValue :: IfcPlanarForceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOWERMEASURE" => IfcDerivedMeasureValue :: IfcPowerMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPRESSUREMEASURE" => IfcDerivedMeasureValue :: IfcPressureMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCRADIOACTIVITYMEASURE" => IfcDerivedMeasureValue :: IfcRadioActivityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCROTATIONALFREQUENCYMEASURE" => IfcDerivedMeasureValue :: IfcRotationalFrequencyMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCROTATIONALMASSMEASURE" => IfcDerivedMeasureValue :: IfcRotationalMassMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCROTATIONALSTIFFNESSMEASURE" => IfcDerivedMeasureValue :: IfcRotationalStiffnessMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSECTIONMODULUSMEASURE" => IfcDerivedMeasureValue :: IfcSectionModulusMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSECTIONALAREAINTEGRALMEASURE" => IfcDerivedMeasureValue :: IfcSectionalAreaIntegralMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSHEARMODULUSMEASURE" => IfcDerivedMeasureValue :: IfcShearModulusMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSOUNDPOWERLEVELMEASURE" => IfcDerivedMeasureValue :: IfcSoundPowerLevelMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSOUNDPOWERMEASURE" => IfcDerivedMeasureValue :: IfcSoundPowerMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSOUNDPRESSURELEVELMEASURE" => IfcDerivedMeasureValue :: IfcSoundPressureLevelMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSOUNDPRESSUREMEASURE" => IfcDerivedMeasureValue :: IfcSoundPressureMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSPECIFICHEATCAPACITYMEASURE" => IfcDerivedMeasureValue :: IfcSpecificHeatCapacityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTEMPERATUREGRADIENTMEASURE" => IfcDerivedMeasureValue :: IfcTemperatureGradientMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTEMPERATURERATEOFCHANGEMEASURE" => IfcDerivedMeasureValue :: IfcTemperatureRateOfChangeMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTHERMALADMITTANCEMEASURE" => IfcDerivedMeasureValue :: IfcThermalAdmittanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTHERMALCONDUCTIVITYMEASURE" => IfcDerivedMeasureValue :: IfcThermalConductivityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE" => IfcDerivedMeasureValue :: IfcThermalExpansionCoefficientMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTHERMALRESISTANCEMEASURE" => IfcDerivedMeasureValue :: IfcThermalResistanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTHERMALTRANSMITTANCEMEASURE" => IfcDerivedMeasureValue :: IfcThermalTransmittanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTORQUEMEASURE" => IfcDerivedMeasureValue :: IfcTorqueMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCVAPORPERMEABILITYMEASURE" => IfcDerivedMeasureValue :: IfcVaporPermeabilityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCVOLUMETRICFLOWRATEMEASURE" => IfcDerivedMeasureValue :: IfcVolumetricFlowRateMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCWARPINGCONSTANTMEASURE" => IfcDerivedMeasureValue :: IfcWarpingConstantMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCWARPINGMOMENTMEASURE" => IfcDerivedMeasureValue :: IfcWarpingMomentMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcDocumentSelect { EntityRef (i64) , IfcDocumentInformation (EntityRef < IfcDocumentInformation >) , IfcDocumentReference (EntityRef < IfcDocumentReference >) , } impl Default for IfcDocumentSelect { fn default () -> Self { IfcDocumentSelect :: IfcDocumentInformation (EntityRef < IfcDocumentInformation > :: default ()) } } impl From < Parameter > for IfcDocumentSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcDocumentSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcFillStyleSelect { EntityRef (i64) , IfcColour (IfcColour) , IfcExternallyDefinedHatchStyle (EntityRef < IfcExternallyDefinedHatchStyle >) , IfcFillAreaStyleHatching (EntityRef < IfcFillAreaStyleHatching >) , IfcFillAreaStyleTiles (EntityRef < IfcFillAreaStyleTiles >) , } impl Default for IfcFillStyleSelect { fn default () -> Self { IfcFillStyleSelect :: IfcColour (IfcColour :: default ()) } } impl From < Parameter > for IfcFillStyleSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCCOLOURSPECIFICATION" | "IFCPREDEFINEDCOLOUR" => { IfcFillStyleSelect :: IfcColour (IfcColour :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcFillStyleSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcGeometricSetSelect { EntityRef (i64) , IfcCurve (EntityRef < IfcCurve >) , IfcPoint (EntityRef < IfcPoint >) , IfcSurface (EntityRef < IfcSurface >) , } impl Default for IfcGeometricSetSelect { fn default () -> Self { IfcGeometricSetSelect :: IfcCurve (EntityRef < IfcCurve > :: default ()) } } impl From < Parameter > for IfcGeometricSetSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcGeometricSetSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcGridPlacementDirectionSelect { EntityRef (i64) , IfcDirection (EntityRef < IfcDirection >) , IfcVirtualGridIntersection (EntityRef < IfcVirtualGridIntersection >) , } impl Default for IfcGridPlacementDirectionSelect { fn default () -> Self { IfcGridPlacementDirectionSelect :: IfcDirection (EntityRef < IfcDirection > :: default ()) } } impl From < Parameter > for IfcGridPlacementDirectionSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcGridPlacementDirectionSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcHatchLineDistanceSelect { IfcPositiveLengthMeasure (IfcPositiveLengthMeasure) , IfcVector (EntityRef < IfcVector >) , } impl Default for IfcHatchLineDistanceSelect { fn default () -> Self { IfcHatchLineDistanceSelect :: IfcPositiveLengthMeasure (IfcPositiveLengthMeasure :: default ()) } } impl From < Parameter > for IfcHatchLineDistanceSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCPOSITIVELENGTHMEASURE" => IfcHatchLineDistanceSelect :: IfcPositiveLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcHatchLineDistanceSelect :: IfcVector (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcLayeredItem { EntityRef (i64) , IfcRepresentation (EntityRef < IfcRepresentation >) , IfcRepresentationItem (EntityRef < IfcRepresentationItem >) , } impl Default for IfcLayeredItem { fn default () -> Self { IfcLayeredItem :: IfcRepresentation (EntityRef < IfcRepresentation > :: default ()) } } impl From < Parameter > for IfcLayeredItem { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcLayeredItem :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcLibrarySelect { EntityRef (i64) , IfcLibraryInformation (EntityRef < IfcLibraryInformation >) , IfcLibraryReference (EntityRef < IfcLibraryReference >) , } impl Default for IfcLibrarySelect { fn default () -> Self { IfcLibrarySelect :: IfcLibraryInformation (EntityRef < IfcLibraryInformation > :: default ()) } } impl From < Parameter > for IfcLibrarySelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcLibrarySelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcLightDistributionDataSourceSelect { EntityRef (i64) , IfcExternalReference (EntityRef < IfcExternalReference >) , IfcLightIntensityDistribution (EntityRef < IfcLightIntensityDistribution >) , } impl Default for IfcLightDistributionDataSourceSelect { fn default () -> Self { IfcLightDistributionDataSourceSelect :: IfcExternalReference (EntityRef < IfcExternalReference > :: default ()) } } impl From < Parameter > for IfcLightDistributionDataSourceSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcLightDistributionDataSourceSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcMaterialSelect { EntityRef (i64) , IfcMaterialDefinition (EntityRef < IfcMaterialDefinition >) , IfcMaterialList (EntityRef < IfcMaterialList >) , IfcMaterialUsageDefinition (EntityRef < IfcMaterialUsageDefinition >) , } impl Default for IfcMaterialSelect { fn default () -> Self { IfcMaterialSelect :: IfcMaterialDefinition (EntityRef < IfcMaterialDefinition > :: default ()) } } impl From < Parameter > for IfcMaterialSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcMaterialSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcMeasureValue { IfcAmountOfSubstanceMeasure (IfcAmountOfSubstanceMeasure) , IfcAreaMeasure (IfcAreaMeasure) , IfcComplexNumber (IfcComplexNumber) , IfcContextDependentMeasure (IfcContextDependentMeasure) , IfcCountMeasure (IfcCountMeasure) , IfcDescriptiveMeasure (IfcDescriptiveMeasure) , IfcElectricCurrentMeasure (IfcElectricCurrentMeasure) , IfcLengthMeasure (IfcLengthMeasure) , IfcLuminousIntensityMeasure (IfcLuminousIntensityMeasure) , IfcMassMeasure (IfcMassMeasure) , IfcNonNegativeLengthMeasure (IfcNonNegativeLengthMeasure) , IfcNormalisedRatioMeasure (IfcNormalisedRatioMeasure) , IfcNumericMeasure (IfcNumericMeasure) , IfcParameterValue (IfcParameterValue) , IfcPlaneAngleMeasure (IfcPlaneAngleMeasure) , IfcPositiveLengthMeasure (IfcPositiveLengthMeasure) , IfcPositivePlaneAngleMeasure (IfcPositivePlaneAngleMeasure) , IfcPositiveRatioMeasure (IfcPositiveRatioMeasure) , IfcRatioMeasure (IfcRatioMeasure) , IfcSolidAngleMeasure (IfcSolidAngleMeasure) , IfcThermodynamicTemperatureMeasure (IfcThermodynamicTemperatureMeasure) , IfcTimeMeasure (IfcTimeMeasure) , IfcVolumeMeasure (IfcVolumeMeasure) , } impl Default for IfcMeasureValue { fn default () -> Self { IfcMeasureValue :: IfcAmountOfSubstanceMeasure (IfcAmountOfSubstanceMeasure :: default ()) } } impl From < Parameter > for IfcMeasureValue { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCAMOUNTOFSUBSTANCEMEASURE" => IfcMeasureValue :: IfcAmountOfSubstanceMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCAREAMEASURE" => IfcMeasureValue :: IfcAreaMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCCOMPLEXNUMBER" => IfcMeasureValue :: IfcComplexNumber (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCCONTEXTDEPENDENTMEASURE" => IfcMeasureValue :: IfcContextDependentMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCCOUNTMEASURE" => IfcMeasureValue :: IfcCountMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCDESCRIPTIVEMEASURE" => IfcMeasureValue :: IfcDescriptiveMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCELECTRICCURRENTMEASURE" => IfcMeasureValue :: IfcElectricCurrentMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLENGTHMEASURE" => IfcMeasureValue :: IfcLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLUMINOUSINTENSITYMEASURE" => IfcMeasureValue :: IfcLuminousIntensityMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMASSMEASURE" => IfcMeasureValue :: IfcMassMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCNONNEGATIVELENGTHMEASURE" => IfcMeasureValue :: IfcNonNegativeLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCNORMALISEDRATIOMEASURE" => IfcMeasureValue :: IfcNormalisedRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCNUMERICMEASURE" => IfcMeasureValue :: IfcNumericMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPARAMETERVALUE" => IfcMeasureValue :: IfcParameterValue (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPLANEANGLEMEASURE" => IfcMeasureValue :: IfcPlaneAngleMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOSITIVELENGTHMEASURE" => IfcMeasureValue :: IfcPositiveLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOSITIVEPLANEANGLEMEASURE" => IfcMeasureValue :: IfcPositivePlaneAngleMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOSITIVERATIOMEASURE" => IfcMeasureValue :: IfcPositiveRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCRATIOMEASURE" => IfcMeasureValue :: IfcRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSOLIDANGLEMEASURE" => IfcMeasureValue :: IfcSolidAngleMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTHERMODYNAMICTEMPERATUREMEASURE" => IfcMeasureValue :: IfcThermodynamicTemperatureMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTIMEMEASURE" => IfcMeasureValue :: IfcTimeMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCVOLUMEMEASURE" => IfcMeasureValue :: IfcVolumeMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcMetricValueSelect { EntityRef (i64) , IfcAppliedValue (EntityRef < IfcAppliedValue >) , IfcMeasureWithUnit (EntityRef < IfcMeasureWithUnit >) , IfcReference (EntityRef < IfcReference >) , IfcTable (EntityRef < IfcTable >) , IfcTimeSeries (EntityRef < IfcTimeSeries >) , IfcValue (IfcValue) , } impl Default for IfcMetricValueSelect { fn default () -> Self { IfcMetricValueSelect :: IfcAppliedValue (EntityRef < IfcAppliedValue > :: default ()) } } impl From < Parameter > for IfcMetricValueSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCDERIVEDMEASUREVALUE" | "IFCMEASUREVALUE" | "IFCSIMPLEVALUE" => { IfcMetricValueSelect :: IfcValue (IfcValue :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcMetricValueSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcModulusOfRotationalSubgradeReactionSelect { IfcBoolean (IfcBoolean) , IfcModulusOfRotationalSubgradeReactionMeasure (IfcModulusOfRotationalSubgradeReactionMeasure) , } impl Default for IfcModulusOfRotationalSubgradeReactionSelect { fn default () -> Self { IfcModulusOfRotationalSubgradeReactionSelect :: IfcBoolean (IfcBoolean :: default ()) } } impl From < Parameter > for IfcModulusOfRotationalSubgradeReactionSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBOOLEAN" => IfcModulusOfRotationalSubgradeReactionSelect :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE" => IfcModulusOfRotationalSubgradeReactionSelect :: IfcModulusOfRotationalSubgradeReactionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcModulusOfSubgradeReactionSelect { IfcBoolean (IfcBoolean) , IfcModulusOfSubgradeReactionMeasure (IfcModulusOfSubgradeReactionMeasure) , } impl Default for IfcModulusOfSubgradeReactionSelect { fn default () -> Self { IfcModulusOfSubgradeReactionSelect :: IfcBoolean (IfcBoolean :: default ()) } } impl From < Parameter > for IfcModulusOfSubgradeReactionSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBOOLEAN" => IfcModulusOfSubgradeReactionSelect :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFSUBGRADEREACTIONMEASURE" => IfcModulusOfSubgradeReactionSelect :: IfcModulusOfSubgradeReactionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcModulusOfTranslationalSubgradeReactionSelect { IfcBoolean (IfcBoolean) , IfcModulusOfLinearSubgradeReactionMeasure (IfcModulusOfLinearSubgradeReactionMeasure) , } impl Default for IfcModulusOfTranslationalSubgradeReactionSelect { fn default () -> Self { IfcModulusOfTranslationalSubgradeReactionSelect :: IfcBoolean (IfcBoolean :: default ()) } } impl From < Parameter > for IfcModulusOfTranslationalSubgradeReactionSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBOOLEAN" => IfcModulusOfTranslationalSubgradeReactionSelect :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE" => IfcModulusOfTranslationalSubgradeReactionSelect :: IfcModulusOfLinearSubgradeReactionMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcObjectReferenceSelect { EntityRef (i64) , IfcAddress (EntityRef < IfcAddress >) , IfcAppliedValue (EntityRef < IfcAppliedValue >) , IfcExternalReference (EntityRef < IfcExternalReference >) , IfcMaterialDefinition (EntityRef < IfcMaterialDefinition >) , IfcOrganization (EntityRef < IfcOrganization >) , IfcPerson (EntityRef < IfcPerson >) , IfcPersonAndOrganization (EntityRef < IfcPersonAndOrganization >) , IfcTable (EntityRef < IfcTable >) , IfcTimeSeries (EntityRef < IfcTimeSeries >) , } impl Default for IfcObjectReferenceSelect { fn default () -> Self { IfcObjectReferenceSelect :: IfcAddress (EntityRef < IfcAddress > :: default ()) } } impl From < Parameter > for IfcObjectReferenceSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcObjectReferenceSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcPointOrVertexPoint { EntityRef (i64) , IfcPoint (EntityRef < IfcPoint >) , IfcVertexPoint (EntityRef < IfcVertexPoint >) , } impl Default for IfcPointOrVertexPoint { fn default () -> Self { IfcPointOrVertexPoint :: IfcPoint (EntityRef < IfcPoint > :: default ()) } } impl From < Parameter > for IfcPointOrVertexPoint { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcPointOrVertexPoint :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcPresentationStyleSelect { EntityRef (i64) , IfcCurveStyle (EntityRef < IfcCurveStyle >) , IfcFillAreaStyle (EntityRef < IfcFillAreaStyle >) , IfcNullStyle (IfcNullStyle) , IfcSurfaceStyle (EntityRef < IfcSurfaceStyle >) , IfcTextStyle (EntityRef < IfcTextStyle >) , } impl Default for IfcPresentationStyleSelect { fn default () -> Self { IfcPresentationStyleSelect :: IfcCurveStyle (EntityRef < IfcCurveStyle > :: default ()) } } impl From < Parameter > for IfcPresentationStyleSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCNULLSTYLE" => IfcPresentationStyleSelect :: IfcNullStyle (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcPresentationStyleSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcProcessSelect { EntityRef (i64) , IfcProcess (EntityRef < IfcProcess >) , IfcTypeProcess (EntityRef < IfcTypeProcess >) , } impl Default for IfcProcessSelect { fn default () -> Self { IfcProcessSelect :: IfcProcess (EntityRef < IfcProcess > :: default ()) } } impl From < Parameter > for IfcProcessSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcProcessSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcProductRepresentationSelect { EntityRef (i64) , IfcProductDefinitionShape (EntityRef < IfcProductDefinitionShape >) , IfcRepresentationMap (EntityRef < IfcRepresentationMap >) , } impl Default for IfcProductRepresentationSelect { fn default () -> Self { IfcProductRepresentationSelect :: IfcProductDefinitionShape (EntityRef < IfcProductDefinitionShape > :: default ()) } } impl From < Parameter > for IfcProductRepresentationSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcProductRepresentationSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcProductSelect { EntityRef (i64) , IfcProduct (EntityRef < IfcProduct >) , IfcTypeProduct (EntityRef < IfcTypeProduct >) , } impl Default for IfcProductSelect { fn default () -> Self { IfcProductSelect :: IfcProduct (EntityRef < IfcProduct > :: default ()) } } impl From < Parameter > for IfcProductSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcProductSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcPropertySetDefinitionSelect { IfcPropertySetDefinition (EntityRef < IfcPropertySetDefinition >) , IfcPropertySetDefinitionSet (IfcPropertySetDefinitionSet) , } impl Default for IfcPropertySetDefinitionSelect { fn default () -> Self { IfcPropertySetDefinitionSelect :: IfcPropertySetDefinition (EntityRef < IfcPropertySetDefinition > :: default ()) } } impl From < Parameter > for IfcPropertySetDefinitionSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCPROPERTYSETDEFINITIONSET" => IfcPropertySetDefinitionSelect :: IfcPropertySetDefinitionSet (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcPropertySetDefinitionSelect :: IfcPropertySetDefinition (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcResourceObjectSelect { EntityRef (i64) , IfcActorRole (EntityRef < IfcActorRole >) , IfcAppliedValue (EntityRef < IfcAppliedValue >) , IfcApproval (EntityRef < IfcApproval >) , IfcConstraint (EntityRef < IfcConstraint >) , IfcContextDependentUnit (EntityRef < IfcContextDependentUnit >) , IfcConversionBasedUnit (EntityRef < IfcConversionBasedUnit >) , IfcExternalInformation (EntityRef < IfcExternalInformation >) , IfcExternalReference (EntityRef < IfcExternalReference >) , IfcMaterialDefinition (EntityRef < IfcMaterialDefinition >) , IfcOrganization (EntityRef < IfcOrganization >) , IfcPerson (EntityRef < IfcPerson >) , IfcPersonAndOrganization (EntityRef < IfcPersonAndOrganization >) , IfcPhysicalQuantity (EntityRef < IfcPhysicalQuantity >) , IfcProfileDef (EntityRef < IfcProfileDef >) , IfcPropertyAbstraction (EntityRef < IfcPropertyAbstraction >) , IfcTimeSeries (EntityRef < IfcTimeSeries >) , } impl Default for IfcResourceObjectSelect { fn default () -> Self { IfcResourceObjectSelect :: IfcActorRole (EntityRef < IfcActorRole > :: default ()) } } impl From < Parameter > for IfcResourceObjectSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcResourceObjectSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcResourceSelect { EntityRef (i64) , IfcResource (EntityRef < IfcResource >) , IfcTypeResource (EntityRef < IfcTypeResource >) , } impl Default for IfcResourceSelect { fn default () -> Self { IfcResourceSelect :: IfcResource (EntityRef < IfcResource > :: default ()) } } impl From < Parameter > for IfcResourceSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcResourceSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcRotationalStiffnessSelect { IfcBoolean (IfcBoolean) , IfcRotationalStiffnessMeasure (IfcRotationalStiffnessMeasure) , } impl Default for IfcRotationalStiffnessSelect { fn default () -> Self { IfcRotationalStiffnessSelect :: IfcBoolean (IfcBoolean :: default ()) } } impl From < Parameter > for IfcRotationalStiffnessSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBOOLEAN" => IfcRotationalStiffnessSelect :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCROTATIONALSTIFFNESSMEASURE" => IfcRotationalStiffnessSelect :: IfcRotationalStiffnessMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSegmentIndexSelect { IfcArcIndex (IfcArcIndex) , IfcLineIndex (IfcLineIndex) , } impl Default for IfcSegmentIndexSelect { fn default () -> Self { IfcSegmentIndexSelect :: IfcArcIndex (IfcArcIndex :: default ()) } } impl From < Parameter > for IfcSegmentIndexSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCARCINDEX" => IfcSegmentIndexSelect :: IfcArcIndex (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLINEINDEX" => IfcSegmentIndexSelect :: IfcLineIndex (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcShell { EntityRef (i64) , IfcClosedShell (EntityRef < IfcClosedShell >) , IfcOpenShell (EntityRef < IfcOpenShell >) , } impl Default for IfcShell { fn default () -> Self { IfcShell :: IfcClosedShell (EntityRef < IfcClosedShell > :: default ()) } } impl From < Parameter > for IfcShell { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcShell :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSimpleValue { IfcBinary (IfcBinary) , IfcBoolean (IfcBoolean) , IfcDate (IfcDate) , IfcDateTime (IfcDateTime) , IfcDuration (IfcDuration) , IfcIdentifier (IfcIdentifier) , IfcInteger (IfcInteger) , IfcLabel (IfcLabel) , IfcLogical (IfcLogical) , IfcPositiveInteger (IfcPositiveInteger) , IfcReal (IfcReal) , IfcText (IfcText) , IfcTime (IfcTime) , IfcTimeStamp (IfcTimeStamp) , } impl Default for IfcSimpleValue { fn default () -> Self { IfcSimpleValue :: IfcBinary (IfcBinary :: default ()) } } impl From < Parameter > for IfcSimpleValue { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBINARY" => IfcSimpleValue :: IfcBinary (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCBOOLEAN" => IfcSimpleValue :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCDATE" => IfcSimpleValue :: IfcDate (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCDATETIME" => IfcSimpleValue :: IfcDateTime (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCDURATION" => IfcSimpleValue :: IfcDuration (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCIDENTIFIER" => IfcSimpleValue :: IfcIdentifier (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCINTEGER" => IfcSimpleValue :: IfcInteger (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLABEL" => IfcSimpleValue :: IfcLabel (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLOGICAL" => IfcSimpleValue :: IfcLogical (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOSITIVEINTEGER" => IfcSimpleValue :: IfcPositiveInteger (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCREAL" => IfcSimpleValue :: IfcReal (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTEXT" => IfcSimpleValue :: IfcText (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTIME" => IfcSimpleValue :: IfcTime (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCTIMESTAMP" => IfcSimpleValue :: IfcTimeStamp (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSizeSelect { IfcDescriptiveMeasure (IfcDescriptiveMeasure) , IfcLengthMeasure (IfcLengthMeasure) , IfcNormalisedRatioMeasure (IfcNormalisedRatioMeasure) , IfcPositiveLengthMeasure (IfcPositiveLengthMeasure) , IfcPositiveRatioMeasure (IfcPositiveRatioMeasure) , IfcRatioMeasure (IfcRatioMeasure) , } impl Default for IfcSizeSelect { fn default () -> Self { IfcSizeSelect :: IfcDescriptiveMeasure (IfcDescriptiveMeasure :: default ()) } } impl From < Parameter > for IfcSizeSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCDESCRIPTIVEMEASURE" => IfcSizeSelect :: IfcDescriptiveMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLENGTHMEASURE" => IfcSizeSelect :: IfcLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCNORMALISEDRATIOMEASURE" => IfcSizeSelect :: IfcNormalisedRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOSITIVELENGTHMEASURE" => IfcSizeSelect :: IfcPositiveLengthMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCPOSITIVERATIOMEASURE" => IfcSizeSelect :: IfcPositiveRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCRATIOMEASURE" => IfcSizeSelect :: IfcRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSolidOrShell { EntityRef (i64) , IfcClosedShell (EntityRef < IfcClosedShell >) , IfcSolidModel (EntityRef < IfcSolidModel >) , } impl Default for IfcSolidOrShell { fn default () -> Self { IfcSolidOrShell :: IfcClosedShell (EntityRef < IfcClosedShell > :: default ()) } } impl From < Parameter > for IfcSolidOrShell { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcSolidOrShell :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSpaceBoundarySelect { EntityRef (i64) , IfcExternalSpatialElement (EntityRef < IfcExternalSpatialElement >) , IfcSpace (EntityRef < IfcSpace >) , } impl Default for IfcSpaceBoundarySelect { fn default () -> Self { IfcSpaceBoundarySelect :: IfcExternalSpatialElement (EntityRef < IfcExternalSpatialElement > :: default ()) } } impl From < Parameter > for IfcSpaceBoundarySelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcSpaceBoundarySelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSpecularHighlightSelect { IfcSpecularExponent (IfcSpecularExponent) , IfcSpecularRoughness (IfcSpecularRoughness) , } impl Default for IfcSpecularHighlightSelect { fn default () -> Self { IfcSpecularHighlightSelect :: IfcSpecularExponent (IfcSpecularExponent :: default ()) } } impl From < Parameter > for IfcSpecularHighlightSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCSPECULAREXPONENT" => IfcSpecularHighlightSelect :: IfcSpecularExponent (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCSPECULARROUGHNESS" => IfcSpecularHighlightSelect :: IfcSpecularRoughness (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcStructuralActivityAssignmentSelect { EntityRef (i64) , IfcElement (EntityRef < IfcElement >) , IfcStructuralItem (EntityRef < IfcStructuralItem >) , } impl Default for IfcStructuralActivityAssignmentSelect { fn default () -> Self { IfcStructuralActivityAssignmentSelect :: IfcElement (EntityRef < IfcElement > :: default ()) } } impl From < Parameter > for IfcStructuralActivityAssignmentSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcStructuralActivityAssignmentSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcStyleAssignmentSelect { EntityRef (i64) , IfcPresentationStyle (EntityRef < IfcPresentationStyle >) , IfcPresentationStyleAssignment (EntityRef < IfcPresentationStyleAssignment >) , } impl Default for IfcStyleAssignmentSelect { fn default () -> Self { IfcStyleAssignmentSelect :: IfcPresentationStyle (EntityRef < IfcPresentationStyle > :: default ()) } } impl From < Parameter > for IfcStyleAssignmentSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcStyleAssignmentSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcSurfaceOrFaceSurface { EntityRef (i64) , IfcFaceBasedSurfaceModel (EntityRef < IfcFaceBasedSurfaceModel >) , IfcFaceSurface (EntityRef < IfcFaceSurface >) , IfcSurface (EntityRef < IfcSurface >) , } impl Default for IfcSurfaceOrFaceSurface { fn default () -> Self { IfcSurfaceOrFaceSurface :: IfcFaceBasedSurfaceModel (EntityRef < IfcFaceBasedSurfaceModel > :: default ()) } } impl From < Parameter > for IfcSurfaceOrFaceSurface { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcSurfaceOrFaceSurface :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcSurfaceStyleElementSelect { EntityRef (i64) , IfcExternallyDefinedSurfaceStyle (EntityRef < IfcExternallyDefinedSurfaceStyle >) , IfcSurfaceStyleLighting (EntityRef < IfcSurfaceStyleLighting >) , IfcSurfaceStyleRefraction (EntityRef < IfcSurfaceStyleRefraction >) , IfcSurfaceStyleShading (EntityRef < IfcSurfaceStyleShading >) , IfcSurfaceStyleWithTextures (EntityRef < IfcSurfaceStyleWithTextures >) , } impl Default for IfcSurfaceStyleElementSelect { fn default () -> Self { IfcSurfaceStyleElementSelect :: IfcExternallyDefinedSurfaceStyle (EntityRef < IfcExternallyDefinedSurfaceStyle > :: default ()) } } impl From < Parameter > for IfcSurfaceStyleElementSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcSurfaceStyleElementSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcTextFontSelect { EntityRef (i64) , IfcExternallyDefinedTextFont (EntityRef < IfcExternallyDefinedTextFont >) , IfcPreDefinedTextFont (EntityRef < IfcPreDefinedTextFont >) , } impl Default for IfcTextFontSelect { fn default () -> Self { IfcTextFontSelect :: IfcExternallyDefinedTextFont (EntityRef < IfcExternallyDefinedTextFont > :: default ()) } } impl From < Parameter > for IfcTextFontSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcTextFontSelect :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcTimeOrRatioSelect { IfcDuration (IfcDuration) , IfcRatioMeasure (IfcRatioMeasure) , } impl Default for IfcTimeOrRatioSelect { fn default () -> Self { IfcTimeOrRatioSelect :: IfcDuration (IfcDuration :: default ()) } } impl From < Parameter > for IfcTimeOrRatioSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCDURATION" => IfcTimeOrRatioSelect :: IfcDuration (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCRATIOMEASURE" => IfcTimeOrRatioSelect :: IfcRatioMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcTranslationalStiffnessSelect { IfcBoolean (IfcBoolean) , IfcLinearStiffnessMeasure (IfcLinearStiffnessMeasure) , } impl Default for IfcTranslationalStiffnessSelect { fn default () -> Self { IfcTranslationalStiffnessSelect :: IfcBoolean (IfcBoolean :: default ()) } } impl From < Parameter > for IfcTranslationalStiffnessSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBOOLEAN" => IfcTranslationalStiffnessSelect :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCLINEARSTIFFNESSMEASURE" => IfcTranslationalStiffnessSelect :: IfcLinearStiffnessMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcTrimmingSelect { IfcCartesianPoint (EntityRef < IfcCartesianPoint >) , IfcParameterValue (IfcParameterValue) , } impl Default for IfcTrimmingSelect { fn default () -> Self { IfcTrimmingSelect :: IfcCartesianPoint (EntityRef < IfcCartesianPoint > :: default ()) } } impl From < Parameter > for IfcTrimmingSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCPARAMETERVALUE" => IfcTrimmingSelect :: IfcParameterValue (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcTrimmingSelect :: IfcCartesianPoint (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Eq , PartialEq , Hash , Debug)] pub enum IfcUnit { EntityRef (i64) , IfcDerivedUnit (EntityRef < IfcDerivedUnit >) , IfcMonetaryUnit (EntityRef < IfcMonetaryUnit >) , IfcNamedUnit (EntityRef < IfcNamedUnit >) , } impl Default for IfcUnit { fn default () -> Self { IfcUnit :: IfcDerivedUnit (EntityRef < IfcDerivedUnit > :: default ()) } } impl From < Parameter > for IfcUnit { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcUnit :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcValue { IfcDerivedMeasureValue (IfcDerivedMeasureValue) , IfcMeasureValue (IfcMeasureValue) , IfcSimpleValue (IfcSimpleValue) , } impl Default for IfcValue { fn default () -> Self { IfcValue :: IfcDerivedMeasureValue (IfcDerivedMeasureValue :: default ()) } } impl From < Parameter > for IfcValue { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCABSORBEDDOSEMEASURE" | "IFCACCELERATIONMEASURE" | "IFCANGULARVELOCITYMEASURE" | "IFCAREADENSITYMEASURE" | "IFCCOMPOUNDPLANEANGLEMEASURE" | "IFCCURVATUREMEASURE" | "IFCDOSEEQUIVALENTMEASURE" | "IFCDYNAMICVISCOSITYMEASURE" | "IFCELECTRICCAPACITANCEMEASURE" | "IFCELECTRICCHARGEMEASURE" | "IFCELECTRICCONDUCTANCEMEASURE" | "IFCELECTRICRESISTANCEMEASURE" | "IFCELECTRICVOLTAGEMEASURE" | "IFCENERGYMEASURE" | "IFCFORCEMEASURE" | "IFCFREQUENCYMEASURE" | "IFCHEATFLUXDENSITYMEASURE" | "IFCHEATINGVALUEMEASURE" | "IFCILLUMINANCEMEASURE" | "IFCINDUCTANCEMEASURE" | "IFCINTEGERCOUNTRATEMEASURE" | "IFCIONCONCENTRATIONMEASURE" | "IFCISOTHERMALMOISTURECAPACITYMEASURE" | "IFCKINEMATICVISCOSITYMEASURE" | "IFCLINEARFORCEMEASURE" | "IFCLINEARMOMENTMEASURE" | "IFCLINEARSTIFFNESSMEASURE" | "IFCLINEARVELOCITYMEASURE" | "IFCLUMINOUSFLUXMEASURE" | "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE" | "IFCMAGNETICFLUXDENSITYMEASURE" | "IFCMAGNETICFLUXMEASURE" | "IFCMASSDENSITYMEASURE" | "IFCMASSFLOWRATEMEASURE" | "IFCMASSPERLENGTHMEASURE" | "IFCMODULUSOFELASTICITYMEASURE" | "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE" | "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE" | "IFCMODULUSOFSUBGRADEREACTIONMEASURE" | "IFCMOISTUREDIFFUSIVITYMEASURE" | "IFCMOLECULARWEIGHTMEASURE" | "IFCMOMENTOFINERTIAMEASURE" | "IFCMONETARYMEASURE" | "IFCPHMEASURE" | "IFCPLANARFORCEMEASURE" | "IFCPOWERMEASURE" | "IFCPRESSUREMEASURE" | "IFCRADIOACTIVITYMEASURE" | "IFCROTATIONALFREQUENCYMEASURE" | "IFCROTATIONALMASSMEASURE" | "IFCROTATIONALSTIFFNESSMEASURE" | "IFCSECTIONMODULUSMEASURE" | "IFCSECTIONALAREAINTEGRALMEASURE" | "IFCSHEARMODULUSMEASURE" | "IFCSOUNDPOWERLEVELMEASURE" | "IFCSOUNDPOWERMEASURE" | "IFCSOUNDPRESSURELEVELMEASURE" | "IFCSOUNDPRESSUREMEASURE" | "IFCSPECIFICHEATCAPACITYMEASURE" | "IFCTEMPERATUREGRADIENTMEASURE" | "IFCTEMPERATURERATEOFCHANGEMEASURE" | "IFCTHERMALADMITTANCEMEASURE" | "IFCTHERMALCONDUCTIVITYMEASURE" | "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE" | "IFCTHERMALRESISTANCEMEASURE" | "IFCTHERMALTRANSMITTANCEMEASURE" | "IFCTORQUEMEASURE" | "IFCVAPORPERMEABILITYMEASURE" | "IFCVOLUMETRICFLOWRATEMEASURE" | "IFCWARPINGCONSTANTMEASURE" | "IFCWARPINGMOMENTMEASURE" => { IfcValue :: IfcDerivedMeasureValue (IfcDerivedMeasureValue :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , "IFCAMOUNTOFSUBSTANCEMEASURE" | "IFCAREAMEASURE" | "IFCCOMPLEXNUMBER" | "IFCCONTEXTDEPENDENTMEASURE" | "IFCCOUNTMEASURE" | "IFCDESCRIPTIVEMEASURE" | "IFCELECTRICCURRENTMEASURE" | "IFCLENGTHMEASURE" | "IFCLUMINOUSINTENSITYMEASURE" | "IFCMASSMEASURE" | "IFCNONNEGATIVELENGTHMEASURE" | "IFCNORMALISEDRATIOMEASURE" | "IFCNUMERICMEASURE" | "IFCPARAMETERVALUE" | "IFCPLANEANGLEMEASURE" | "IFCPOSITIVELENGTHMEASURE" | "IFCPOSITIVEPLANEANGLEMEASURE" | "IFCPOSITIVERATIOMEASURE" | "IFCRATIOMEASURE" | "IFCSOLIDANGLEMEASURE" | "IFCTHERMODYNAMICTEMPERATUREMEASURE" | "IFCTIMEMEASURE" | "IFCVOLUMEMEASURE" => { IfcValue :: IfcMeasureValue (IfcMeasureValue :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , "IFCBINARY" | "IFCBOOLEAN" | "IFCDATE" | "IFCDATETIME" | "IFCDURATION" | "IFCIDENTIFIER" | "IFCINTEGER" | "IFCLABEL" | "IFCLOGICAL" | "IFCPOSITIVEINTEGER" | "IFCREAL" | "IFCTEXT" | "IFCTIME" | "IFCTIMESTAMP" => { IfcValue :: IfcSimpleValue (IfcSimpleValue :: from (Parameter :: TypedParameter (TypedParameter { type_name : typed_parameter . type_name , parameters : typed_parameter . parameters , }))) } , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcVectorOrDirection { EntityRef (i64) , IfcDirection (EntityRef < IfcDirection >) , IfcVector (EntityRef < IfcVector >) , } impl Default for IfcVectorOrDirection { fn default () -> Self { IfcVectorOrDirection :: IfcDirection (EntityRef < IfcDirection > :: default ()) } } impl From < Parameter > for IfcVectorOrDirection { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: UnTypedParameter (untyped_parameter) => match untyped_parameter { UnTypedParameter :: EntityRef (id) => IfcVectorOrDirection :: EntityRef (EntityRef :: new (id)) , _ => panic ! ("parameter is not an instance") , } _ => panic ! ("parameter is not recognized") , } } } # [derive (Debug)] pub enum IfcWarpingStiffnessSelect { IfcBoolean (IfcBoolean) , IfcWarpingMomentMeasure (IfcWarpingMomentMeasure) , } impl Default for IfcWarpingStiffnessSelect { fn default () -> Self { IfcWarpingStiffnessSelect :: IfcBoolean (IfcBoolean :: default ()) } } impl From < Parameter > for IfcWarpingStiffnessSelect { fn from (parameter : Parameter) -> Self { match parameter { Parameter :: TypedParameter (typed_parameter) => match typed_parameter . type_name . as_str () { "IFCBOOLEAN" => IfcWarpingStiffnessSelect :: IfcBoolean (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , "IFCWARPINGMOMENTMEASURE" => IfcWarpingStiffnessSelect :: IfcWarpingMomentMeasure (typed_parameter . parameters . into_iter () . next () . unwrap () . into ()) , _ => panic ! ("parameter type is not recognized: {}" , typed_parameter . type_name) , } _ => panic ! ("parameter is not recognized") , } } } pub trait IIfcActionRequest : IIfcControl { pub fn predefined_type (& self) -> & Option < IfcActionRequestTypeEnum > ; pub fn status (& self) -> & Option < IfcLabel > ; pub fn long_description (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcActionRequest { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , predefined_type : Option < IfcActionRequestTypeEnum > , status : Option < IfcLabel > , long_description : Option < IfcText > , } impl IIfcRoot for IfcActionRequest { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcActionRequest { } impl IIfcObject for IfcActionRequest { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcActionRequest { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcActionRequest for IfcActionRequest { fn predefined_type (& self) -> & Option < IfcActionRequestTypeEnum > { & self . predefined_type } fn status (& self) -> & Option < IfcLabel > { & self . status } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IfcActionRequest { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcActionRequest :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcActor : IIfcObject { pub fn the_actor (& self) -> & EntityRef < IfcActorSelect > ; } # [derive (Default , Debug)] pub struct IfcActor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , the_actor : EntityRef < IfcActorSelect > , } impl IIfcRoot for IfcActor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcActor { } impl IIfcObject for IfcActor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcActor for IfcActor { fn the_actor (& self) -> & EntityRef < IfcActorSelect > { & self . the_actor } } impl IfcActor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcActor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . the_actor = parameter . into () , _ => { } } } entity } } pub trait IIfcActorRole : { pub fn role (& self) -> & IfcRoleEnum ; pub fn user_defined_role (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcActorRole { role : IfcRoleEnum , user_defined_role : Option < IfcLabel > , description : Option < IfcText > , } impl IIfcActorRole for IfcActorRole { fn role (& self) -> & IfcRoleEnum { & self . role } fn user_defined_role (& self) -> & Option < IfcLabel > { & self . user_defined_role } fn description (& self) -> & Option < IfcText > { & self . description } } impl IfcActorRole { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcActorRole :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . role = parameter . into () , 1usize => entity . user_defined_role = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcActuator : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcActuatorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcActuator { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcActuatorTypeEnum > , } impl IIfcRoot for IfcActuator { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcActuator { } impl IIfcObject for IfcActuator { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcActuator { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcActuator { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcActuator { } impl IIfcDistributionControlElement for IfcActuator { } impl IIfcActuator for IfcActuator { fn predefined_type (& self) -> & Option < IfcActuatorTypeEnum > { & self . predefined_type } } impl IfcActuator { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcActuator :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcActuatorType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcActuatorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcActuatorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcActuatorTypeEnum , } impl IIfcRoot for IfcActuatorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcActuatorType { } impl IIfcTypeObject for IfcActuatorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcActuatorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcActuatorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcActuatorType { } impl IIfcDistributionControlElementType for IfcActuatorType { } impl IIfcActuatorType for IfcActuatorType { fn predefined_type (& self) -> & IfcActuatorTypeEnum { & self . predefined_type } } impl IfcActuatorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcActuatorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcAddress : { pub fn purpose (& self) -> & Option < IfcAddressTypeEnum > ; pub fn description (& self) -> & Option < IfcText > ; pub fn user_defined_purpose (& self) -> & Option < IfcLabel > ; } pub trait IIfcAdvancedBrep : IIfcManifoldSolidBrep { } # [derive (Default , Debug)] pub struct IfcAdvancedBrep { outer : EntityRef < IfcClosedShell > , } impl IIfcRepresentationItem for IfcAdvancedBrep { } impl IIfcGeometricRepresentationItem for IfcAdvancedBrep { } impl IIfcSolidModel for IfcAdvancedBrep { } impl IIfcManifoldSolidBrep for IfcAdvancedBrep { fn outer (& self) -> & EntityRef < IfcClosedShell > { & self . outer } } impl IIfcAdvancedBrep for IfcAdvancedBrep { } impl IfcAdvancedBrep { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAdvancedBrep :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . outer = parameter . into () , _ => { } } } entity } } pub trait IIfcAdvancedBrepWithVoids : IIfcAdvancedBrep { pub fn voids (& self) -> & HashSet < EntityRef < IfcClosedShell > > ; } # [derive (Default , Debug)] pub struct IfcAdvancedBrepWithVoids { outer : EntityRef < IfcClosedShell > , voids : HashSet < EntityRef < IfcClosedShell > > , } impl IIfcRepresentationItem for IfcAdvancedBrepWithVoids { } impl IIfcGeometricRepresentationItem for IfcAdvancedBrepWithVoids { } impl IIfcSolidModel for IfcAdvancedBrepWithVoids { } impl IIfcManifoldSolidBrep for IfcAdvancedBrepWithVoids { fn outer (& self) -> & EntityRef < IfcClosedShell > { & self . outer } } impl IIfcAdvancedBrep for IfcAdvancedBrepWithVoids { } impl IIfcAdvancedBrepWithVoids for IfcAdvancedBrepWithVoids { fn voids (& self) -> & HashSet < EntityRef < IfcClosedShell > > { & self . voids } } impl IfcAdvancedBrepWithVoids { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAdvancedBrepWithVoids :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . outer = parameter . into () , 1usize => entity . voids = parameter . into () , _ => { } } } entity } } pub trait IIfcAdvancedFace : IIfcFaceSurface { } # [derive (Default , Debug)] pub struct IfcAdvancedFace { bounds : HashSet < EntityRef < IfcFaceBound > > , face_surface : EntityRef < IfcSurface > , same_sense : IfcBoolean , } impl IIfcRepresentationItem for IfcAdvancedFace { } impl IIfcTopologicalRepresentationItem for IfcAdvancedFace { } impl IIfcFace for IfcAdvancedFace { fn bounds (& self) -> & HashSet < EntityRef < IfcFaceBound > > { & self . bounds } } impl IIfcFaceSurface for IfcAdvancedFace { fn face_surface (& self) -> & EntityRef < IfcSurface > { & self . face_surface } fn same_sense (& self) -> & IfcBoolean { & self . same_sense } } impl IIfcAdvancedFace for IfcAdvancedFace { } impl IfcAdvancedFace { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAdvancedFace :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . bounds = parameter . into () , 1usize => entity . face_surface = parameter . into () , 2usize => entity . same_sense = parameter . into () , _ => { } } } entity } } pub trait IIfcAirTerminal : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcAirTerminalTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcAirTerminal { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcAirTerminalTypeEnum > , } impl IIfcRoot for IfcAirTerminal { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAirTerminal { } impl IIfcObject for IfcAirTerminal { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcAirTerminal { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcAirTerminal { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcAirTerminal { } impl IIfcDistributionFlowElement for IfcAirTerminal { } impl IIfcFlowTerminal for IfcAirTerminal { } impl IIfcAirTerminal for IfcAirTerminal { fn predefined_type (& self) -> & Option < IfcAirTerminalTypeEnum > { & self . predefined_type } } impl IfcAirTerminal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAirTerminal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAirTerminalBox : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcAirTerminalBoxTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcAirTerminalBox { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcAirTerminalBoxTypeEnum > , } impl IIfcRoot for IfcAirTerminalBox { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAirTerminalBox { } impl IIfcObject for IfcAirTerminalBox { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcAirTerminalBox { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcAirTerminalBox { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcAirTerminalBox { } impl IIfcDistributionFlowElement for IfcAirTerminalBox { } impl IIfcFlowController for IfcAirTerminalBox { } impl IIfcAirTerminalBox for IfcAirTerminalBox { fn predefined_type (& self) -> & Option < IfcAirTerminalBoxTypeEnum > { & self . predefined_type } } impl IfcAirTerminalBox { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAirTerminalBox :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAirTerminalBoxType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcAirTerminalBoxTypeEnum ; } # [derive (Default , Debug)] pub struct IfcAirTerminalBoxType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcAirTerminalBoxTypeEnum , } impl IIfcRoot for IfcAirTerminalBoxType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAirTerminalBoxType { } impl IIfcTypeObject for IfcAirTerminalBoxType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcAirTerminalBoxType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcAirTerminalBoxType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcAirTerminalBoxType { } impl IIfcDistributionFlowElementType for IfcAirTerminalBoxType { } impl IIfcFlowControllerType for IfcAirTerminalBoxType { } impl IIfcAirTerminalBoxType for IfcAirTerminalBoxType { fn predefined_type (& self) -> & IfcAirTerminalBoxTypeEnum { & self . predefined_type } } impl IfcAirTerminalBoxType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAirTerminalBoxType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcAirTerminalType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcAirTerminalTypeEnum ; } # [derive (Default , Debug)] pub struct IfcAirTerminalType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcAirTerminalTypeEnum , } impl IIfcRoot for IfcAirTerminalType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAirTerminalType { } impl IIfcTypeObject for IfcAirTerminalType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcAirTerminalType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcAirTerminalType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcAirTerminalType { } impl IIfcDistributionFlowElementType for IfcAirTerminalType { } impl IIfcFlowTerminalType for IfcAirTerminalType { } impl IIfcAirTerminalType for IfcAirTerminalType { fn predefined_type (& self) -> & IfcAirTerminalTypeEnum { & self . predefined_type } } impl IfcAirTerminalType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAirTerminalType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcAirToAirHeatRecovery : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcAirToAirHeatRecoveryTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcAirToAirHeatRecovery { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcAirToAirHeatRecoveryTypeEnum > , } impl IIfcRoot for IfcAirToAirHeatRecovery { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAirToAirHeatRecovery { } impl IIfcObject for IfcAirToAirHeatRecovery { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcAirToAirHeatRecovery { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcAirToAirHeatRecovery { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcAirToAirHeatRecovery { } impl IIfcDistributionFlowElement for IfcAirToAirHeatRecovery { } impl IIfcEnergyConversionDevice for IfcAirToAirHeatRecovery { } impl IIfcAirToAirHeatRecovery for IfcAirToAirHeatRecovery { fn predefined_type (& self) -> & Option < IfcAirToAirHeatRecoveryTypeEnum > { & self . predefined_type } } impl IfcAirToAirHeatRecovery { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAirToAirHeatRecovery :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAirToAirHeatRecoveryType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcAirToAirHeatRecoveryTypeEnum ; } # [derive (Default , Debug)] pub struct IfcAirToAirHeatRecoveryType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcAirToAirHeatRecoveryTypeEnum , } impl IIfcRoot for IfcAirToAirHeatRecoveryType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAirToAirHeatRecoveryType { } impl IIfcTypeObject for IfcAirToAirHeatRecoveryType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcAirToAirHeatRecoveryType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcAirToAirHeatRecoveryType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcAirToAirHeatRecoveryType { } impl IIfcDistributionFlowElementType for IfcAirToAirHeatRecoveryType { } impl IIfcEnergyConversionDeviceType for IfcAirToAirHeatRecoveryType { } impl IIfcAirToAirHeatRecoveryType for IfcAirToAirHeatRecoveryType { fn predefined_type (& self) -> & IfcAirToAirHeatRecoveryTypeEnum { & self . predefined_type } } impl IfcAirToAirHeatRecoveryType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAirToAirHeatRecoveryType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcAlarm : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcAlarmTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcAlarm { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcAlarmTypeEnum > , } impl IIfcRoot for IfcAlarm { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAlarm { } impl IIfcObject for IfcAlarm { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcAlarm { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcAlarm { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcAlarm { } impl IIfcDistributionControlElement for IfcAlarm { } impl IIfcAlarm for IfcAlarm { fn predefined_type (& self) -> & Option < IfcAlarmTypeEnum > { & self . predefined_type } } impl IfcAlarm { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAlarm :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAlarmType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcAlarmTypeEnum ; } # [derive (Default , Debug)] pub struct IfcAlarmType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcAlarmTypeEnum , } impl IIfcRoot for IfcAlarmType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAlarmType { } impl IIfcTypeObject for IfcAlarmType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcAlarmType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcAlarmType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcAlarmType { } impl IIfcDistributionControlElementType for IfcAlarmType { } impl IIfcAlarmType for IfcAlarmType { fn predefined_type (& self) -> & IfcAlarmTypeEnum { & self . predefined_type } } impl IfcAlarmType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAlarmType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcAnnotation : IIfcProduct { } # [derive (Default , Debug)] pub struct IfcAnnotation { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , } impl IIfcRoot for IfcAnnotation { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAnnotation { } impl IIfcObject for IfcAnnotation { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcAnnotation { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcAnnotation for IfcAnnotation { } impl IfcAnnotation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAnnotation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAnnotationFillArea : IIfcGeometricRepresentationItem { pub fn outer_boundary (& self) -> & EntityRef < IfcCurve > ; pub fn inner_boundaries (& self) -> & Option < HashSet < EntityRef < IfcCurve > > > ; } # [derive (Default , Debug)] pub struct IfcAnnotationFillArea { outer_boundary : EntityRef < IfcCurve > , inner_boundaries : Option < HashSet < EntityRef < IfcCurve > > > , } impl IIfcRepresentationItem for IfcAnnotationFillArea { } impl IIfcGeometricRepresentationItem for IfcAnnotationFillArea { } impl IIfcAnnotationFillArea for IfcAnnotationFillArea { fn outer_boundary (& self) -> & EntityRef < IfcCurve > { & self . outer_boundary } fn inner_boundaries (& self) -> & Option < HashSet < EntityRef < IfcCurve > > > { & self . inner_boundaries } } impl IfcAnnotationFillArea { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAnnotationFillArea :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . outer_boundary = parameter . into () , 1usize => entity . inner_boundaries = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcApplication : { pub fn application_developer (& self) -> & EntityRef < IfcOrganization > ; pub fn version (& self) -> & IfcLabel ; pub fn application_full_name (& self) -> & IfcLabel ; pub fn application_identifier (& self) -> & IfcIdentifier ; } # [derive (Default , Debug)] pub struct IfcApplication { application_developer : EntityRef < IfcOrganization > , version : IfcLabel , application_full_name : IfcLabel , application_identifier : IfcIdentifier , } impl IIfcApplication for IfcApplication { fn application_developer (& self) -> & EntityRef < IfcOrganization > { & self . application_developer } fn version (& self) -> & IfcLabel { & self . version } fn application_full_name (& self) -> & IfcLabel { & self . application_full_name } fn application_identifier (& self) -> & IfcIdentifier { & self . application_identifier } } impl IfcApplication { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcApplication :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . application_developer = parameter . into () , 1usize => entity . version = parameter . into () , 2usize => entity . application_full_name = parameter . into () , 3usize => entity . application_identifier = parameter . into () , _ => { } } } entity } } pub trait IIfcAppliedValue : { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn applied_value (& self) -> & Option < IfcAppliedValueSelect > ; pub fn unit_basis (& self) -> & Option < EntityRef < IfcMeasureWithUnit > > ; pub fn applicable_date (& self) -> & Option < IfcDate > ; pub fn fixed_until_date (& self) -> & Option < IfcDate > ; pub fn category (& self) -> & Option < IfcLabel > ; pub fn condition (& self) -> & Option < IfcLabel > ; pub fn arithmetic_operator (& self) -> & Option < IfcArithmeticOperatorEnum > ; pub fn components (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > ; } # [derive (Default , Debug)] pub struct IfcAppliedValue { name : Option < IfcLabel > , description : Option < IfcText > , applied_value : Option < IfcAppliedValueSelect > , unit_basis : Option < EntityRef < IfcMeasureWithUnit > > , applicable_date : Option < IfcDate > , fixed_until_date : Option < IfcDate > , category : Option < IfcLabel > , condition : Option < IfcLabel > , arithmetic_operator : Option < IfcArithmeticOperatorEnum > , components : Option < Vec < EntityRef < IfcAppliedValue > > > , } impl IIfcAppliedValue for IfcAppliedValue { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn applied_value (& self) -> & Option < IfcAppliedValueSelect > { & self . applied_value } fn unit_basis (& self) -> & Option < EntityRef < IfcMeasureWithUnit > > { & self . unit_basis } fn applicable_date (& self) -> & Option < IfcDate > { & self . applicable_date } fn fixed_until_date (& self) -> & Option < IfcDate > { & self . fixed_until_date } fn category (& self) -> & Option < IfcLabel > { & self . category } fn condition (& self) -> & Option < IfcLabel > { & self . condition } fn arithmetic_operator (& self) -> & Option < IfcArithmeticOperatorEnum > { & self . arithmetic_operator } fn components (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . components } } impl IfcAppliedValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAppliedValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . applied_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . unit_basis = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . fixed_until_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . arithmetic_operator = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . components = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcApproval : { pub fn identifier (& self) -> & Option < IfcIdentifier > ; pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn time_of_approval (& self) -> & Option < IfcDateTime > ; pub fn status (& self) -> & Option < IfcLabel > ; pub fn level (& self) -> & Option < IfcLabel > ; pub fn qualifier (& self) -> & Option < IfcText > ; pub fn requesting_approval (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn giving_approval (& self) -> & Option < EntityRef < IfcActorSelect > > ; } # [derive (Default , Debug)] pub struct IfcApproval { identifier : Option < IfcIdentifier > , name : Option < IfcLabel > , description : Option < IfcText > , time_of_approval : Option < IfcDateTime > , status : Option < IfcLabel > , level : Option < IfcLabel > , qualifier : Option < IfcText > , requesting_approval : Option < EntityRef < IfcActorSelect > > , giving_approval : Option < EntityRef < IfcActorSelect > > , } impl IIfcApproval for IfcApproval { fn identifier (& self) -> & Option < IfcIdentifier > { & self . identifier } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn time_of_approval (& self) -> & Option < IfcDateTime > { & self . time_of_approval } fn status (& self) -> & Option < IfcLabel > { & self . status } fn level (& self) -> & Option < IfcLabel > { & self . level } fn qualifier (& self) -> & Option < IfcText > { & self . qualifier } fn requesting_approval (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . requesting_approval } fn giving_approval (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . giving_approval } } impl IfcApproval { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcApproval :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . time_of_approval = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . level = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . qualifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . requesting_approval = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . giving_approval = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcApprovalRelationship : IIfcResourceLevelRelationship { pub fn relating_approval (& self) -> & EntityRef < IfcApproval > ; pub fn related_approvals (& self) -> & HashSet < EntityRef < IfcApproval > > ; } # [derive (Default , Debug)] pub struct IfcApprovalRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_approval : EntityRef < IfcApproval > , related_approvals : HashSet < EntityRef < IfcApproval > > , } impl IIfcResourceLevelRelationship for IfcApprovalRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcApprovalRelationship for IfcApprovalRelationship { fn relating_approval (& self) -> & EntityRef < IfcApproval > { & self . relating_approval } fn related_approvals (& self) -> & HashSet < EntityRef < IfcApproval > > { & self . related_approvals } } impl IfcApprovalRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcApprovalRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_approval = parameter . into () , 3usize => entity . related_approvals = parameter . into () , _ => { } } } entity } } pub trait IIfcArbitraryClosedProfileDef : IIfcProfileDef { pub fn outer_curve (& self) -> & EntityRef < IfcCurve > ; } # [derive (Default , Debug)] pub struct IfcArbitraryClosedProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , outer_curve : EntityRef < IfcCurve > , } impl IIfcProfileDef for IfcArbitraryClosedProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcArbitraryClosedProfileDef for IfcArbitraryClosedProfileDef { fn outer_curve (& self) -> & EntityRef < IfcCurve > { & self . outer_curve } } impl IfcArbitraryClosedProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcArbitraryClosedProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . outer_curve = parameter . into () , _ => { } } } entity } } pub trait IIfcArbitraryOpenProfileDef : IIfcProfileDef { pub fn curve (& self) -> & EntityRef < IfcBoundedCurve > ; } # [derive (Default , Debug)] pub struct IfcArbitraryOpenProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , curve : EntityRef < IfcBoundedCurve > , } impl IIfcProfileDef for IfcArbitraryOpenProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcArbitraryOpenProfileDef for IfcArbitraryOpenProfileDef { fn curve (& self) -> & EntityRef < IfcBoundedCurve > { & self . curve } } impl IfcArbitraryOpenProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcArbitraryOpenProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . curve = parameter . into () , _ => { } } } entity } } pub trait IIfcArbitraryProfileDefWithVoids : IIfcArbitraryClosedProfileDef { pub fn inner_curves (& self) -> & HashSet < EntityRef < IfcCurve > > ; } # [derive (Default , Debug)] pub struct IfcArbitraryProfileDefWithVoids { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , outer_curve : EntityRef < IfcCurve > , inner_curves : HashSet < EntityRef < IfcCurve > > , } impl IIfcProfileDef for IfcArbitraryProfileDefWithVoids { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcArbitraryClosedProfileDef for IfcArbitraryProfileDefWithVoids { fn outer_curve (& self) -> & EntityRef < IfcCurve > { & self . outer_curve } } impl IIfcArbitraryProfileDefWithVoids for IfcArbitraryProfileDefWithVoids { fn inner_curves (& self) -> & HashSet < EntityRef < IfcCurve > > { & self . inner_curves } } impl IfcArbitraryProfileDefWithVoids { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcArbitraryProfileDefWithVoids :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . outer_curve = parameter . into () , 3usize => entity . inner_curves = parameter . into () , _ => { } } } entity } } pub trait IIfcAsset : IIfcGroup { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn original_value (& self) -> & Option < EntityRef < IfcCostValue > > ; pub fn current_value (& self) -> & Option < EntityRef < IfcCostValue > > ; pub fn total_replacement_cost (& self) -> & Option < EntityRef < IfcCostValue > > ; pub fn owner (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn user (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn responsible_person (& self) -> & Option < EntityRef < IfcPerson > > ; pub fn incorporation_date (& self) -> & Option < IfcDate > ; pub fn depreciated_value (& self) -> & Option < EntityRef < IfcCostValue > > ; } # [derive (Default , Debug)] pub struct IfcAsset { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , original_value : Option < EntityRef < IfcCostValue > > , current_value : Option < EntityRef < IfcCostValue > > , total_replacement_cost : Option < EntityRef < IfcCostValue > > , owner : Option < EntityRef < IfcActorSelect > > , user : Option < EntityRef < IfcActorSelect > > , responsible_person : Option < EntityRef < IfcPerson > > , incorporation_date : Option < IfcDate > , depreciated_value : Option < EntityRef < IfcCostValue > > , } impl IIfcRoot for IfcAsset { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAsset { } impl IIfcObject for IfcAsset { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcAsset { } impl IIfcAsset for IfcAsset { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn original_value (& self) -> & Option < EntityRef < IfcCostValue > > { & self . original_value } fn current_value (& self) -> & Option < EntityRef < IfcCostValue > > { & self . current_value } fn total_replacement_cost (& self) -> & Option < EntityRef < IfcCostValue > > { & self . total_replacement_cost } fn owner (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . owner } fn user (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . user } fn responsible_person (& self) -> & Option < EntityRef < IfcPerson > > { & self . responsible_person } fn incorporation_date (& self) -> & Option < IfcDate > { & self . incorporation_date } fn depreciated_value (& self) -> & Option < EntityRef < IfcCostValue > > { & self . depreciated_value } } impl IfcAsset { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAsset :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . original_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . current_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . total_replacement_cost = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . owner = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . user = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . responsible_person = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . incorporation_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . depreciated_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAsymmetricIShapeProfileDef : IIfcParameterizedProfileDef { pub fn bottom_flange_width (& self) -> & IfcPositiveLengthMeasure ; pub fn overall_depth (& self) -> & IfcPositiveLengthMeasure ; pub fn web_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn bottom_flange_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn bottom_flange_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn top_flange_width (& self) -> & IfcPositiveLengthMeasure ; pub fn top_flange_thickness (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn top_flange_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn bottom_flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn bottom_flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; pub fn top_flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn top_flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; } # [derive (Default , Debug)] pub struct IfcAsymmetricIShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , bottom_flange_width : IfcPositiveLengthMeasure , overall_depth : IfcPositiveLengthMeasure , web_thickness : IfcPositiveLengthMeasure , bottom_flange_thickness : IfcPositiveLengthMeasure , bottom_flange_fillet_radius : Option < IfcNonNegativeLengthMeasure > , top_flange_width : IfcPositiveLengthMeasure , top_flange_thickness : Option < IfcPositiveLengthMeasure > , top_flange_fillet_radius : Option < IfcNonNegativeLengthMeasure > , bottom_flange_edge_radius : Option < IfcNonNegativeLengthMeasure > , bottom_flange_slope : Option < IfcPlaneAngleMeasure > , top_flange_edge_radius : Option < IfcNonNegativeLengthMeasure > , top_flange_slope : Option < IfcPlaneAngleMeasure > , } impl IIfcProfileDef for IfcAsymmetricIShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcAsymmetricIShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcAsymmetricIShapeProfileDef for IfcAsymmetricIShapeProfileDef { fn bottom_flange_width (& self) -> & IfcPositiveLengthMeasure { & self . bottom_flange_width } fn overall_depth (& self) -> & IfcPositiveLengthMeasure { & self . overall_depth } fn web_thickness (& self) -> & IfcPositiveLengthMeasure { & self . web_thickness } fn bottom_flange_thickness (& self) -> & IfcPositiveLengthMeasure { & self . bottom_flange_thickness } fn bottom_flange_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . bottom_flange_fillet_radius } fn top_flange_width (& self) -> & IfcPositiveLengthMeasure { & self . top_flange_width } fn top_flange_thickness (& self) -> & Option < IfcPositiveLengthMeasure > { & self . top_flange_thickness } fn top_flange_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . top_flange_fillet_radius } fn bottom_flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . bottom_flange_edge_radius } fn bottom_flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . bottom_flange_slope } fn top_flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . top_flange_edge_radius } fn top_flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . top_flange_slope } } impl IfcAsymmetricIShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAsymmetricIShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . bottom_flange_width = parameter . into () , 4usize => entity . overall_depth = parameter . into () , 5usize => entity . web_thickness = parameter . into () , 6usize => entity . bottom_flange_thickness = parameter . into () , 7usize => entity . bottom_flange_fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . top_flange_width = parameter . into () , 9usize => entity . top_flange_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . top_flange_fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . bottom_flange_edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . bottom_flange_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . top_flange_edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . top_flange_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAudioVisualAppliance : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcAudioVisualApplianceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcAudioVisualAppliance { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcAudioVisualApplianceTypeEnum > , } impl IIfcRoot for IfcAudioVisualAppliance { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAudioVisualAppliance { } impl IIfcObject for IfcAudioVisualAppliance { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcAudioVisualAppliance { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcAudioVisualAppliance { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcAudioVisualAppliance { } impl IIfcDistributionFlowElement for IfcAudioVisualAppliance { } impl IIfcFlowTerminal for IfcAudioVisualAppliance { } impl IIfcAudioVisualAppliance for IfcAudioVisualAppliance { fn predefined_type (& self) -> & Option < IfcAudioVisualApplianceTypeEnum > { & self . predefined_type } } impl IfcAudioVisualAppliance { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAudioVisualAppliance :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAudioVisualApplianceType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcAudioVisualApplianceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcAudioVisualApplianceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcAudioVisualApplianceTypeEnum , } impl IIfcRoot for IfcAudioVisualApplianceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcAudioVisualApplianceType { } impl IIfcTypeObject for IfcAudioVisualApplianceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcAudioVisualApplianceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcAudioVisualApplianceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcAudioVisualApplianceType { } impl IIfcDistributionFlowElementType for IfcAudioVisualApplianceType { } impl IIfcFlowTerminalType for IfcAudioVisualApplianceType { } impl IIfcAudioVisualApplianceType for IfcAudioVisualApplianceType { fn predefined_type (& self) -> & IfcAudioVisualApplianceTypeEnum { & self . predefined_type } } impl IfcAudioVisualApplianceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAudioVisualApplianceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcAxis1Placement : IIfcPlacement { pub fn axis (& self) -> & Option < EntityRef < IfcDirection > > ; } # [derive (Default , Debug)] pub struct IfcAxis1Placement { location : EntityRef < IfcCartesianPoint > , axis : Option < EntityRef < IfcDirection > > , } impl IIfcRepresentationItem for IfcAxis1Placement { } impl IIfcGeometricRepresentationItem for IfcAxis1Placement { } impl IIfcPlacement for IfcAxis1Placement { fn location (& self) -> & EntityRef < IfcCartesianPoint > { & self . location } } impl IIfcAxis1Placement for IfcAxis1Placement { fn axis (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis } } impl IfcAxis1Placement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAxis1Placement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = parameter . into () , 1usize => entity . axis = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAxis2Placement2D : IIfcPlacement { pub fn ref_direction (& self) -> & Option < EntityRef < IfcDirection > > ; } # [derive (Default , Debug)] pub struct IfcAxis2Placement2D { location : EntityRef < IfcCartesianPoint > , ref_direction : Option < EntityRef < IfcDirection > > , } impl IIfcRepresentationItem for IfcAxis2Placement2D { } impl IIfcGeometricRepresentationItem for IfcAxis2Placement2D { } impl IIfcPlacement for IfcAxis2Placement2D { fn location (& self) -> & EntityRef < IfcCartesianPoint > { & self . location } } impl IIfcAxis2Placement2D for IfcAxis2Placement2D { fn ref_direction (& self) -> & Option < EntityRef < IfcDirection > > { & self . ref_direction } } impl IfcAxis2Placement2D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAxis2Placement2D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = parameter . into () , 1usize => entity . ref_direction = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcAxis2Placement3D : IIfcPlacement { pub fn axis (& self) -> & Option < EntityRef < IfcDirection > > ; pub fn ref_direction (& self) -> & Option < EntityRef < IfcDirection > > ; } # [derive (Default , Debug)] pub struct IfcAxis2Placement3D { location : EntityRef < IfcCartesianPoint > , axis : Option < EntityRef < IfcDirection > > , ref_direction : Option < EntityRef < IfcDirection > > , } impl IIfcRepresentationItem for IfcAxis2Placement3D { } impl IIfcGeometricRepresentationItem for IfcAxis2Placement3D { } impl IIfcPlacement for IfcAxis2Placement3D { fn location (& self) -> & EntityRef < IfcCartesianPoint > { & self . location } } impl IIfcAxis2Placement3D for IfcAxis2Placement3D { fn axis (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis } fn ref_direction (& self) -> & Option < EntityRef < IfcDirection > > { & self . ref_direction } } impl IfcAxis2Placement3D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcAxis2Placement3D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = parameter . into () , 1usize => entity . axis = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . ref_direction = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBSplineCurve : IIfcBoundedCurve { pub fn degree (& self) -> & IfcInteger ; pub fn control_points_list (& self) -> & Vec < EntityRef < IfcCartesianPoint > > ; pub fn curve_form (& self) -> & IfcBSplineCurveForm ; pub fn closed_curve (& self) -> & IfcLogical ; pub fn self_intersect (& self) -> & IfcLogical ; } pub trait IIfcBSplineCurveWithKnots : IIfcBSplineCurve { pub fn knot_multiplicities (& self) -> & Vec < IfcInteger > ; pub fn knots (& self) -> & Vec < IfcParameterValue > ; pub fn knot_spec (& self) -> & IfcKnotType ; } # [derive (Default , Debug)] pub struct IfcBSplineCurveWithKnots { degree : IfcInteger , control_points_list : Vec < EntityRef < IfcCartesianPoint > > , curve_form : IfcBSplineCurveForm , closed_curve : IfcLogical , self_intersect : IfcLogical , knot_multiplicities : Vec < IfcInteger > , knots : Vec < IfcParameterValue > , knot_spec : IfcKnotType , } impl IIfcRepresentationItem for IfcBSplineCurveWithKnots { } impl IIfcGeometricRepresentationItem for IfcBSplineCurveWithKnots { } impl IIfcCurve for IfcBSplineCurveWithKnots { } impl IIfcBoundedCurve for IfcBSplineCurveWithKnots { } impl IIfcBSplineCurve for IfcBSplineCurveWithKnots { fn degree (& self) -> & IfcInteger { & self . degree } fn control_points_list (& self) -> & Vec < EntityRef < IfcCartesianPoint > > { & self . control_points_list } fn curve_form (& self) -> & IfcBSplineCurveForm { & self . curve_form } fn closed_curve (& self) -> & IfcLogical { & self . closed_curve } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcBSplineCurveWithKnots for IfcBSplineCurveWithKnots { fn knot_multiplicities (& self) -> & Vec < IfcInteger > { & self . knot_multiplicities } fn knots (& self) -> & Vec < IfcParameterValue > { & self . knots } fn knot_spec (& self) -> & IfcKnotType { & self . knot_spec } } impl IfcBSplineCurveWithKnots { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBSplineCurveWithKnots :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . degree = parameter . into () , 1usize => entity . control_points_list = parameter . into () , 2usize => entity . curve_form = parameter . into () , 3usize => entity . closed_curve = parameter . into () , 4usize => entity . self_intersect = parameter . into () , 5usize => entity . knot_multiplicities = parameter . into () , 6usize => entity . knots = parameter . into () , 7usize => entity . knot_spec = parameter . into () , _ => { } } } entity } } pub trait IIfcBSplineSurface : IIfcBoundedSurface { pub fn u_degree (& self) -> & IfcInteger ; pub fn v_degree (& self) -> & IfcInteger ; pub fn control_points_list (& self) -> & Vec < Vec < EntityRef < IfcCartesianPoint > > > ; pub fn surface_form (& self) -> & IfcBSplineSurfaceForm ; pub fn u_closed (& self) -> & IfcLogical ; pub fn v_closed (& self) -> & IfcLogical ; pub fn self_intersect (& self) -> & IfcLogical ; } pub trait IIfcBSplineSurfaceWithKnots : IIfcBSplineSurface { pub fn u_multiplicities (& self) -> & Vec < IfcInteger > ; pub fn v_multiplicities (& self) -> & Vec < IfcInteger > ; pub fn u_knots (& self) -> & Vec < IfcParameterValue > ; pub fn v_knots (& self) -> & Vec < IfcParameterValue > ; pub fn knot_spec (& self) -> & IfcKnotType ; } # [derive (Default , Debug)] pub struct IfcBSplineSurfaceWithKnots { u_degree : IfcInteger , v_degree : IfcInteger , control_points_list : Vec < Vec < EntityRef < IfcCartesianPoint > > > , surface_form : IfcBSplineSurfaceForm , u_closed : IfcLogical , v_closed : IfcLogical , self_intersect : IfcLogical , u_multiplicities : Vec < IfcInteger > , v_multiplicities : Vec < IfcInteger > , u_knots : Vec < IfcParameterValue > , v_knots : Vec < IfcParameterValue > , knot_spec : IfcKnotType , } impl IIfcRepresentationItem for IfcBSplineSurfaceWithKnots { } impl IIfcGeometricRepresentationItem for IfcBSplineSurfaceWithKnots { } impl IIfcSurface for IfcBSplineSurfaceWithKnots { } impl IIfcBoundedSurface for IfcBSplineSurfaceWithKnots { } impl IIfcBSplineSurface for IfcBSplineSurfaceWithKnots { fn u_degree (& self) -> & IfcInteger { & self . u_degree } fn v_degree (& self) -> & IfcInteger { & self . v_degree } fn control_points_list (& self) -> & Vec < Vec < EntityRef < IfcCartesianPoint > > > { & self . control_points_list } fn surface_form (& self) -> & IfcBSplineSurfaceForm { & self . surface_form } fn u_closed (& self) -> & IfcLogical { & self . u_closed } fn v_closed (& self) -> & IfcLogical { & self . v_closed } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcBSplineSurfaceWithKnots for IfcBSplineSurfaceWithKnots { fn u_multiplicities (& self) -> & Vec < IfcInteger > { & self . u_multiplicities } fn v_multiplicities (& self) -> & Vec < IfcInteger > { & self . v_multiplicities } fn u_knots (& self) -> & Vec < IfcParameterValue > { & self . u_knots } fn v_knots (& self) -> & Vec < IfcParameterValue > { & self . v_knots } fn knot_spec (& self) -> & IfcKnotType { & self . knot_spec } } impl IfcBSplineSurfaceWithKnots { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBSplineSurfaceWithKnots :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . u_degree = parameter . into () , 1usize => entity . v_degree = parameter . into () , 2usize => entity . control_points_list = parameter . into () , 3usize => entity . surface_form = parameter . into () , 4usize => entity . u_closed = parameter . into () , 5usize => entity . v_closed = parameter . into () , 6usize => entity . self_intersect = parameter . into () , 7usize => entity . u_multiplicities = parameter . into () , 8usize => entity . v_multiplicities = parameter . into () , 9usize => entity . u_knots = parameter . into () , 10usize => entity . v_knots = parameter . into () , 11usize => entity . knot_spec = parameter . into () , _ => { } } } entity } } pub trait IIfcBeam : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcBeamTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcBeam { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcBeamTypeEnum > , } impl IIfcRoot for IfcBeam { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBeam { } impl IIfcObject for IfcBeam { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBeam { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcBeam { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcBeam { } impl IIfcBeam for IfcBeam { fn predefined_type (& self) -> & Option < IfcBeamTypeEnum > { & self . predefined_type } } impl IfcBeam { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBeam :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBeamStandardCase : IIfcBeam { } # [derive (Default , Debug)] pub struct IfcBeamStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcBeamTypeEnum > , } impl IIfcRoot for IfcBeamStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBeamStandardCase { } impl IIfcObject for IfcBeamStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBeamStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcBeamStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcBeamStandardCase { } impl IIfcBeam for IfcBeamStandardCase { fn predefined_type (& self) -> & Option < IfcBeamTypeEnum > { & self . predefined_type } } impl IIfcBeamStandardCase for IfcBeamStandardCase { } impl IfcBeamStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBeamStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBeamType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcBeamTypeEnum ; } # [derive (Default , Debug)] pub struct IfcBeamType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcBeamTypeEnum , } impl IIfcRoot for IfcBeamType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBeamType { } impl IIfcTypeObject for IfcBeamType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcBeamType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcBeamType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcBeamType { } impl IIfcBeamType for IfcBeamType { fn predefined_type (& self) -> & IfcBeamTypeEnum { & self . predefined_type } } impl IfcBeamType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBeamType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcBlobTexture : IIfcSurfaceTexture { pub fn raster_format (& self) -> & IfcIdentifier ; pub fn raster_code (& self) -> & IfcBinary ; } # [derive (Default , Debug)] pub struct IfcBlobTexture { repeat_s : IfcBoolean , repeat_t : IfcBoolean , mode : Option < IfcIdentifier > , texture_transform : Option < EntityRef < IfcCartesianTransformationOperator2D > > , parameter : Option < Vec < IfcIdentifier > > , raster_format : IfcIdentifier , raster_code : IfcBinary , } impl IIfcPresentationItem for IfcBlobTexture { } impl IIfcSurfaceTexture for IfcBlobTexture { fn repeat_s (& self) -> & IfcBoolean { & self . repeat_s } fn repeat_t (& self) -> & IfcBoolean { & self . repeat_t } fn mode (& self) -> & Option < IfcIdentifier > { & self . mode } fn texture_transform (& self) -> & Option < EntityRef < IfcCartesianTransformationOperator2D > > { & self . texture_transform } fn parameter (& self) -> & Option < Vec < IfcIdentifier > > { & self . parameter } } impl IIfcBlobTexture for IfcBlobTexture { fn raster_format (& self) -> & IfcIdentifier { & self . raster_format } fn raster_code (& self) -> & IfcBinary { & self . raster_code } } impl IfcBlobTexture { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBlobTexture :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . repeat_s = parameter . into () , 1usize => entity . repeat_t = parameter . into () , 2usize => entity . mode = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . texture_transform = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . parameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . raster_format = parameter . into () , 6usize => entity . raster_code = parameter . into () , _ => { } } } entity } } pub trait IIfcBlock : IIfcCsgPrimitive3D { pub fn x_length (& self) -> & IfcPositiveLengthMeasure ; pub fn y_length (& self) -> & IfcPositiveLengthMeasure ; pub fn z_length (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcBlock { position : EntityRef < IfcAxis2Placement3D > , x_length : IfcPositiveLengthMeasure , y_length : IfcPositiveLengthMeasure , z_length : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcBlock { } impl IIfcGeometricRepresentationItem for IfcBlock { } impl IIfcCsgPrimitive3D for IfcBlock { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcBlock for IfcBlock { fn x_length (& self) -> & IfcPositiveLengthMeasure { & self . x_length } fn y_length (& self) -> & IfcPositiveLengthMeasure { & self . y_length } fn z_length (& self) -> & IfcPositiveLengthMeasure { & self . z_length } } impl IfcBlock { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBlock :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . x_length = parameter . into () , 2usize => entity . y_length = parameter . into () , 3usize => entity . z_length = parameter . into () , _ => { } } } entity } } pub trait IIfcBoiler : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcBoilerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcBoiler { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcBoilerTypeEnum > , } impl IIfcRoot for IfcBoiler { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBoiler { } impl IIfcObject for IfcBoiler { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBoiler { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcBoiler { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcBoiler { } impl IIfcDistributionFlowElement for IfcBoiler { } impl IIfcEnergyConversionDevice for IfcBoiler { } impl IIfcBoiler for IfcBoiler { fn predefined_type (& self) -> & Option < IfcBoilerTypeEnum > { & self . predefined_type } } impl IfcBoiler { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoiler :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBoilerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcBoilerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcBoilerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcBoilerTypeEnum , } impl IIfcRoot for IfcBoilerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBoilerType { } impl IIfcTypeObject for IfcBoilerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcBoilerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcBoilerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcBoilerType { } impl IIfcDistributionFlowElementType for IfcBoilerType { } impl IIfcEnergyConversionDeviceType for IfcBoilerType { } impl IIfcBoilerType for IfcBoilerType { fn predefined_type (& self) -> & IfcBoilerTypeEnum { & self . predefined_type } } impl IfcBoilerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoilerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcBooleanClippingResult : IIfcBooleanResult { } # [derive (Default , Debug)] pub struct IfcBooleanClippingResult { operator : IfcBooleanOperator , first_operand : EntityRef < IfcBooleanOperand > , second_operand : EntityRef < IfcBooleanOperand > , } impl IIfcRepresentationItem for IfcBooleanClippingResult { } impl IIfcGeometricRepresentationItem for IfcBooleanClippingResult { } impl IIfcBooleanResult for IfcBooleanClippingResult { fn operator (& self) -> & IfcBooleanOperator { & self . operator } fn first_operand (& self) -> & EntityRef < IfcBooleanOperand > { & self . first_operand } fn second_operand (& self) -> & EntityRef < IfcBooleanOperand > { & self . second_operand } } impl IIfcBooleanClippingResult for IfcBooleanClippingResult { } impl IfcBooleanClippingResult { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBooleanClippingResult :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . operator = parameter . into () , 1usize => entity . first_operand = parameter . into () , 2usize => entity . second_operand = parameter . into () , _ => { } } } entity } } pub trait IIfcBooleanResult : IIfcGeometricRepresentationItem { pub fn operator (& self) -> & IfcBooleanOperator ; pub fn first_operand (& self) -> & EntityRef < IfcBooleanOperand > ; pub fn second_operand (& self) -> & EntityRef < IfcBooleanOperand > ; } # [derive (Default , Debug)] pub struct IfcBooleanResult { operator : IfcBooleanOperator , first_operand : EntityRef < IfcBooleanOperand > , second_operand : EntityRef < IfcBooleanOperand > , } impl IIfcRepresentationItem for IfcBooleanResult { } impl IIfcGeometricRepresentationItem for IfcBooleanResult { } impl IIfcBooleanResult for IfcBooleanResult { fn operator (& self) -> & IfcBooleanOperator { & self . operator } fn first_operand (& self) -> & EntityRef < IfcBooleanOperand > { & self . first_operand } fn second_operand (& self) -> & EntityRef < IfcBooleanOperand > { & self . second_operand } } impl IfcBooleanResult { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBooleanResult :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . operator = parameter . into () , 1usize => entity . first_operand = parameter . into () , 2usize => entity . second_operand = parameter . into () , _ => { } } } entity } } pub trait IIfcBoundaryCondition : { pub fn name (& self) -> & Option < IfcLabel > ; } pub trait IIfcBoundaryCurve : IIfcCompositeCurveOnSurface { } # [derive (Default , Debug)] pub struct IfcBoundaryCurve { segments : Vec < EntityRef < IfcCompositeCurveSegment > > , self_intersect : IfcLogical , } impl IIfcRepresentationItem for IfcBoundaryCurve { } impl IIfcGeometricRepresentationItem for IfcBoundaryCurve { } impl IIfcCurve for IfcBoundaryCurve { } impl IIfcBoundedCurve for IfcBoundaryCurve { } impl IIfcCompositeCurve for IfcBoundaryCurve { fn segments (& self) -> & Vec < EntityRef < IfcCompositeCurveSegment > > { & self . segments } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcCompositeCurveOnSurface for IfcBoundaryCurve { } impl IIfcBoundaryCurve for IfcBoundaryCurve { } impl IfcBoundaryCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoundaryCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . segments = parameter . into () , 1usize => entity . self_intersect = parameter . into () , _ => { } } } entity } } pub trait IIfcBoundaryEdgeCondition : IIfcBoundaryCondition { pub fn translational_stiffness_by_length_x (& self) -> & Option < IfcModulusOfTranslationalSubgradeReactionSelect > ; pub fn translational_stiffness_by_length_y (& self) -> & Option < IfcModulusOfTranslationalSubgradeReactionSelect > ; pub fn translational_stiffness_by_length_z (& self) -> & Option < IfcModulusOfTranslationalSubgradeReactionSelect > ; pub fn rotational_stiffness_by_length_x (& self) -> & Option < IfcModulusOfRotationalSubgradeReactionSelect > ; pub fn rotational_stiffness_by_length_y (& self) -> & Option < IfcModulusOfRotationalSubgradeReactionSelect > ; pub fn rotational_stiffness_by_length_z (& self) -> & Option < IfcModulusOfRotationalSubgradeReactionSelect > ; } # [derive (Default , Debug)] pub struct IfcBoundaryEdgeCondition { name : Option < IfcLabel > , translational_stiffness_by_length_x : Option < IfcModulusOfTranslationalSubgradeReactionSelect > , translational_stiffness_by_length_y : Option < IfcModulusOfTranslationalSubgradeReactionSelect > , translational_stiffness_by_length_z : Option < IfcModulusOfTranslationalSubgradeReactionSelect > , rotational_stiffness_by_length_x : Option < IfcModulusOfRotationalSubgradeReactionSelect > , rotational_stiffness_by_length_y : Option < IfcModulusOfRotationalSubgradeReactionSelect > , rotational_stiffness_by_length_z : Option < IfcModulusOfRotationalSubgradeReactionSelect > , } impl IIfcBoundaryCondition for IfcBoundaryEdgeCondition { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcBoundaryEdgeCondition for IfcBoundaryEdgeCondition { fn translational_stiffness_by_length_x (& self) -> & Option < IfcModulusOfTranslationalSubgradeReactionSelect > { & self . translational_stiffness_by_length_x } fn translational_stiffness_by_length_y (& self) -> & Option < IfcModulusOfTranslationalSubgradeReactionSelect > { & self . translational_stiffness_by_length_y } fn translational_stiffness_by_length_z (& self) -> & Option < IfcModulusOfTranslationalSubgradeReactionSelect > { & self . translational_stiffness_by_length_z } fn rotational_stiffness_by_length_x (& self) -> & Option < IfcModulusOfRotationalSubgradeReactionSelect > { & self . rotational_stiffness_by_length_x } fn rotational_stiffness_by_length_y (& self) -> & Option < IfcModulusOfRotationalSubgradeReactionSelect > { & self . rotational_stiffness_by_length_y } fn rotational_stiffness_by_length_z (& self) -> & Option < IfcModulusOfRotationalSubgradeReactionSelect > { & self . rotational_stiffness_by_length_z } } impl IfcBoundaryEdgeCondition { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoundaryEdgeCondition :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . translational_stiffness_by_length_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . translational_stiffness_by_length_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . translational_stiffness_by_length_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . rotational_stiffness_by_length_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . rotational_stiffness_by_length_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . rotational_stiffness_by_length_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBoundaryFaceCondition : IIfcBoundaryCondition { pub fn translational_stiffness_by_area_x (& self) -> & Option < IfcModulusOfSubgradeReactionSelect > ; pub fn translational_stiffness_by_area_y (& self) -> & Option < IfcModulusOfSubgradeReactionSelect > ; pub fn translational_stiffness_by_area_z (& self) -> & Option < IfcModulusOfSubgradeReactionSelect > ; } # [derive (Default , Debug)] pub struct IfcBoundaryFaceCondition { name : Option < IfcLabel > , translational_stiffness_by_area_x : Option < IfcModulusOfSubgradeReactionSelect > , translational_stiffness_by_area_y : Option < IfcModulusOfSubgradeReactionSelect > , translational_stiffness_by_area_z : Option < IfcModulusOfSubgradeReactionSelect > , } impl IIfcBoundaryCondition for IfcBoundaryFaceCondition { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcBoundaryFaceCondition for IfcBoundaryFaceCondition { fn translational_stiffness_by_area_x (& self) -> & Option < IfcModulusOfSubgradeReactionSelect > { & self . translational_stiffness_by_area_x } fn translational_stiffness_by_area_y (& self) -> & Option < IfcModulusOfSubgradeReactionSelect > { & self . translational_stiffness_by_area_y } fn translational_stiffness_by_area_z (& self) -> & Option < IfcModulusOfSubgradeReactionSelect > { & self . translational_stiffness_by_area_z } } impl IfcBoundaryFaceCondition { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoundaryFaceCondition :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . translational_stiffness_by_area_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . translational_stiffness_by_area_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . translational_stiffness_by_area_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBoundaryNodeCondition : IIfcBoundaryCondition { pub fn translational_stiffness_x (& self) -> & Option < IfcTranslationalStiffnessSelect > ; pub fn translational_stiffness_y (& self) -> & Option < IfcTranslationalStiffnessSelect > ; pub fn translational_stiffness_z (& self) -> & Option < IfcTranslationalStiffnessSelect > ; pub fn rotational_stiffness_x (& self) -> & Option < IfcRotationalStiffnessSelect > ; pub fn rotational_stiffness_y (& self) -> & Option < IfcRotationalStiffnessSelect > ; pub fn rotational_stiffness_z (& self) -> & Option < IfcRotationalStiffnessSelect > ; } # [derive (Default , Debug)] pub struct IfcBoundaryNodeCondition { name : Option < IfcLabel > , translational_stiffness_x : Option < IfcTranslationalStiffnessSelect > , translational_stiffness_y : Option < IfcTranslationalStiffnessSelect > , translational_stiffness_z : Option < IfcTranslationalStiffnessSelect > , rotational_stiffness_x : Option < IfcRotationalStiffnessSelect > , rotational_stiffness_y : Option < IfcRotationalStiffnessSelect > , rotational_stiffness_z : Option < IfcRotationalStiffnessSelect > , } impl IIfcBoundaryCondition for IfcBoundaryNodeCondition { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcBoundaryNodeCondition for IfcBoundaryNodeCondition { fn translational_stiffness_x (& self) -> & Option < IfcTranslationalStiffnessSelect > { & self . translational_stiffness_x } fn translational_stiffness_y (& self) -> & Option < IfcTranslationalStiffnessSelect > { & self . translational_stiffness_y } fn translational_stiffness_z (& self) -> & Option < IfcTranslationalStiffnessSelect > { & self . translational_stiffness_z } fn rotational_stiffness_x (& self) -> & Option < IfcRotationalStiffnessSelect > { & self . rotational_stiffness_x } fn rotational_stiffness_y (& self) -> & Option < IfcRotationalStiffnessSelect > { & self . rotational_stiffness_y } fn rotational_stiffness_z (& self) -> & Option < IfcRotationalStiffnessSelect > { & self . rotational_stiffness_z } } impl IfcBoundaryNodeCondition { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoundaryNodeCondition :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . translational_stiffness_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . translational_stiffness_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . translational_stiffness_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . rotational_stiffness_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . rotational_stiffness_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . rotational_stiffness_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBoundaryNodeConditionWarping : IIfcBoundaryNodeCondition { pub fn warping_stiffness (& self) -> & Option < IfcWarpingStiffnessSelect > ; } # [derive (Default , Debug)] pub struct IfcBoundaryNodeConditionWarping { name : Option < IfcLabel > , translational_stiffness_x : Option < IfcTranslationalStiffnessSelect > , translational_stiffness_y : Option < IfcTranslationalStiffnessSelect > , translational_stiffness_z : Option < IfcTranslationalStiffnessSelect > , rotational_stiffness_x : Option < IfcRotationalStiffnessSelect > , rotational_stiffness_y : Option < IfcRotationalStiffnessSelect > , rotational_stiffness_z : Option < IfcRotationalStiffnessSelect > , warping_stiffness : Option < IfcWarpingStiffnessSelect > , } impl IIfcBoundaryCondition for IfcBoundaryNodeConditionWarping { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcBoundaryNodeCondition for IfcBoundaryNodeConditionWarping { fn translational_stiffness_x (& self) -> & Option < IfcTranslationalStiffnessSelect > { & self . translational_stiffness_x } fn translational_stiffness_y (& self) -> & Option < IfcTranslationalStiffnessSelect > { & self . translational_stiffness_y } fn translational_stiffness_z (& self) -> & Option < IfcTranslationalStiffnessSelect > { & self . translational_stiffness_z } fn rotational_stiffness_x (& self) -> & Option < IfcRotationalStiffnessSelect > { & self . rotational_stiffness_x } fn rotational_stiffness_y (& self) -> & Option < IfcRotationalStiffnessSelect > { & self . rotational_stiffness_y } fn rotational_stiffness_z (& self) -> & Option < IfcRotationalStiffnessSelect > { & self . rotational_stiffness_z } } impl IIfcBoundaryNodeConditionWarping for IfcBoundaryNodeConditionWarping { fn warping_stiffness (& self) -> & Option < IfcWarpingStiffnessSelect > { & self . warping_stiffness } } impl IfcBoundaryNodeConditionWarping { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoundaryNodeConditionWarping :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . translational_stiffness_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . translational_stiffness_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . translational_stiffness_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . rotational_stiffness_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . rotational_stiffness_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . rotational_stiffness_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . warping_stiffness = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBoundedCurve : IIfcCurve { } pub trait IIfcBoundedSurface : IIfcSurface { } pub trait IIfcBoundingBox : IIfcGeometricRepresentationItem { pub fn corner (& self) -> & EntityRef < IfcCartesianPoint > ; pub fn x_dim (& self) -> & IfcPositiveLengthMeasure ; pub fn y_dim (& self) -> & IfcPositiveLengthMeasure ; pub fn z_dim (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcBoundingBox { corner : EntityRef < IfcCartesianPoint > , x_dim : IfcPositiveLengthMeasure , y_dim : IfcPositiveLengthMeasure , z_dim : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcBoundingBox { } impl IIfcGeometricRepresentationItem for IfcBoundingBox { } impl IIfcBoundingBox for IfcBoundingBox { fn corner (& self) -> & EntityRef < IfcCartesianPoint > { & self . corner } fn x_dim (& self) -> & IfcPositiveLengthMeasure { & self . x_dim } fn y_dim (& self) -> & IfcPositiveLengthMeasure { & self . y_dim } fn z_dim (& self) -> & IfcPositiveLengthMeasure { & self . z_dim } } impl IfcBoundingBox { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoundingBox :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . corner = parameter . into () , 1usize => entity . x_dim = parameter . into () , 2usize => entity . y_dim = parameter . into () , 3usize => entity . z_dim = parameter . into () , _ => { } } } entity } } pub trait IIfcBoxedHalfSpace : IIfcHalfSpaceSolid { pub fn enclosure (& self) -> & EntityRef < IfcBoundingBox > ; } # [derive (Default , Debug)] pub struct IfcBoxedHalfSpace { base_surface : EntityRef < IfcSurface > , agreement_flag : IfcBoolean , enclosure : EntityRef < IfcBoundingBox > , } impl IIfcRepresentationItem for IfcBoxedHalfSpace { } impl IIfcGeometricRepresentationItem for IfcBoxedHalfSpace { } impl IIfcHalfSpaceSolid for IfcBoxedHalfSpace { fn base_surface (& self) -> & EntityRef < IfcSurface > { & self . base_surface } fn agreement_flag (& self) -> & IfcBoolean { & self . agreement_flag } } impl IIfcBoxedHalfSpace for IfcBoxedHalfSpace { fn enclosure (& self) -> & EntityRef < IfcBoundingBox > { & self . enclosure } } impl IfcBoxedHalfSpace { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBoxedHalfSpace :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . base_surface = parameter . into () , 1usize => entity . agreement_flag = parameter . into () , 2usize => entity . enclosure = parameter . into () , _ => { } } } entity } } pub trait IIfcBuilding : IIfcSpatialStructureElement { pub fn elevation_of_ref_height (& self) -> & Option < IfcLengthMeasure > ; pub fn elevation_of_terrain (& self) -> & Option < IfcLengthMeasure > ; pub fn building_address (& self) -> & Option < EntityRef < IfcPostalAddress > > ; } # [derive (Default , Debug)] pub struct IfcBuilding { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , long_name : Option < IfcLabel > , composition_type : Option < IfcElementCompositionEnum > , elevation_of_ref_height : Option < IfcLengthMeasure > , elevation_of_terrain : Option < IfcLengthMeasure > , building_address : Option < EntityRef < IfcPostalAddress > > , } impl IIfcRoot for IfcBuilding { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuilding { } impl IIfcObject for IfcBuilding { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBuilding { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcSpatialElement for IfcBuilding { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IIfcSpatialStructureElement for IfcBuilding { fn composition_type (& self) -> & Option < IfcElementCompositionEnum > { & self . composition_type } } impl IIfcBuilding for IfcBuilding { fn elevation_of_ref_height (& self) -> & Option < IfcLengthMeasure > { & self . elevation_of_ref_height } fn elevation_of_terrain (& self) -> & Option < IfcLengthMeasure > { & self . elevation_of_terrain } fn building_address (& self) -> & Option < EntityRef < IfcPostalAddress > > { & self . building_address } } impl IfcBuilding { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuilding :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . composition_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . elevation_of_ref_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . elevation_of_terrain = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . building_address = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBuildingElement : IIfcElement { } pub trait IIfcBuildingElementPart : IIfcElementComponent { pub fn predefined_type (& self) -> & Option < IfcBuildingElementPartTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcBuildingElementPart { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcBuildingElementPartTypeEnum > , } impl IIfcRoot for IfcBuildingElementPart { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuildingElementPart { } impl IIfcObject for IfcBuildingElementPart { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBuildingElementPart { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcBuildingElementPart { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcBuildingElementPart { } impl IIfcBuildingElementPart for IfcBuildingElementPart { fn predefined_type (& self) -> & Option < IfcBuildingElementPartTypeEnum > { & self . predefined_type } } impl IfcBuildingElementPart { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuildingElementPart :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBuildingElementPartType : IIfcElementComponentType { pub fn predefined_type (& self) -> & IfcBuildingElementPartTypeEnum ; } # [derive (Default , Debug)] pub struct IfcBuildingElementPartType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcBuildingElementPartTypeEnum , } impl IIfcRoot for IfcBuildingElementPartType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuildingElementPartType { } impl IIfcTypeObject for IfcBuildingElementPartType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcBuildingElementPartType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcBuildingElementPartType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcBuildingElementPartType { } impl IIfcBuildingElementPartType for IfcBuildingElementPartType { fn predefined_type (& self) -> & IfcBuildingElementPartTypeEnum { & self . predefined_type } } impl IfcBuildingElementPartType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuildingElementPartType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcBuildingElementProxy : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcBuildingElementProxyTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcBuildingElementProxy { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcBuildingElementProxyTypeEnum > , } impl IIfcRoot for IfcBuildingElementProxy { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuildingElementProxy { } impl IIfcObject for IfcBuildingElementProxy { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBuildingElementProxy { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcBuildingElementProxy { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcBuildingElementProxy { } impl IIfcBuildingElementProxy for IfcBuildingElementProxy { fn predefined_type (& self) -> & Option < IfcBuildingElementProxyTypeEnum > { & self . predefined_type } } impl IfcBuildingElementProxy { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuildingElementProxy :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBuildingElementProxyType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcBuildingElementProxyTypeEnum ; } # [derive (Default , Debug)] pub struct IfcBuildingElementProxyType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcBuildingElementProxyTypeEnum , } impl IIfcRoot for IfcBuildingElementProxyType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuildingElementProxyType { } impl IIfcTypeObject for IfcBuildingElementProxyType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcBuildingElementProxyType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcBuildingElementProxyType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcBuildingElementProxyType { } impl IIfcBuildingElementProxyType for IfcBuildingElementProxyType { fn predefined_type (& self) -> & IfcBuildingElementProxyTypeEnum { & self . predefined_type } } impl IfcBuildingElementProxyType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuildingElementProxyType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcBuildingElementType : IIfcElementType { } pub trait IIfcBuildingStorey : IIfcSpatialStructureElement { pub fn elevation (& self) -> & Option < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcBuildingStorey { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , long_name : Option < IfcLabel > , composition_type : Option < IfcElementCompositionEnum > , elevation : Option < IfcLengthMeasure > , } impl IIfcRoot for IfcBuildingStorey { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuildingStorey { } impl IIfcObject for IfcBuildingStorey { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBuildingStorey { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcSpatialElement for IfcBuildingStorey { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IIfcSpatialStructureElement for IfcBuildingStorey { fn composition_type (& self) -> & Option < IfcElementCompositionEnum > { & self . composition_type } } impl IIfcBuildingStorey for IfcBuildingStorey { fn elevation (& self) -> & Option < IfcLengthMeasure > { & self . elevation } } impl IfcBuildingStorey { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuildingStorey :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . composition_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . elevation = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBuildingSystem : IIfcSystem { pub fn predefined_type (& self) -> & Option < IfcBuildingSystemTypeEnum > ; pub fn long_name (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcBuildingSystem { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , predefined_type : Option < IfcBuildingSystemTypeEnum > , long_name : Option < IfcLabel > , } impl IIfcRoot for IfcBuildingSystem { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBuildingSystem { } impl IIfcObject for IfcBuildingSystem { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcBuildingSystem { } impl IIfcSystem for IfcBuildingSystem { } impl IIfcBuildingSystem for IfcBuildingSystem { fn predefined_type (& self) -> & Option < IfcBuildingSystemTypeEnum > { & self . predefined_type } fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IfcBuildingSystem { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBuildingSystem :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBurner : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcBurnerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcBurner { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcBurnerTypeEnum > , } impl IIfcRoot for IfcBurner { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBurner { } impl IIfcObject for IfcBurner { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcBurner { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcBurner { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcBurner { } impl IIfcDistributionFlowElement for IfcBurner { } impl IIfcEnergyConversionDevice for IfcBurner { } impl IIfcBurner for IfcBurner { fn predefined_type (& self) -> & Option < IfcBurnerTypeEnum > { & self . predefined_type } } impl IfcBurner { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBurner :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcBurnerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcBurnerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcBurnerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcBurnerTypeEnum , } impl IIfcRoot for IfcBurnerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcBurnerType { } impl IIfcTypeObject for IfcBurnerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcBurnerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcBurnerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcBurnerType { } impl IIfcDistributionFlowElementType for IfcBurnerType { } impl IIfcEnergyConversionDeviceType for IfcBurnerType { } impl IIfcBurnerType for IfcBurnerType { fn predefined_type (& self) -> & IfcBurnerTypeEnum { & self . predefined_type } } impl IfcBurnerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcBurnerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCShapeProfileDef : IIfcParameterizedProfileDef { pub fn depth (& self) -> & IfcPositiveLengthMeasure ; pub fn width (& self) -> & IfcPositiveLengthMeasure ; pub fn wall_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn girth (& self) -> & IfcPositiveLengthMeasure ; pub fn internal_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcCShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , depth : IfcPositiveLengthMeasure , width : IfcPositiveLengthMeasure , wall_thickness : IfcPositiveLengthMeasure , girth : IfcPositiveLengthMeasure , internal_fillet_radius : Option < IfcNonNegativeLengthMeasure > , } impl IIfcProfileDef for IfcCShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcCShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcCShapeProfileDef for IfcCShapeProfileDef { fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } fn width (& self) -> & IfcPositiveLengthMeasure { & self . width } fn wall_thickness (& self) -> & IfcPositiveLengthMeasure { & self . wall_thickness } fn girth (& self) -> & IfcPositiveLengthMeasure { & self . girth } fn internal_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . internal_fillet_radius } } impl IfcCShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . depth = parameter . into () , 4usize => entity . width = parameter . into () , 5usize => entity . wall_thickness = parameter . into () , 6usize => entity . girth = parameter . into () , 7usize => entity . internal_fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCableCarrierFitting : IIfcFlowFitting { pub fn predefined_type (& self) -> & Option < IfcCableCarrierFittingTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCableCarrierFitting { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCableCarrierFittingTypeEnum > , } impl IIfcRoot for IfcCableCarrierFitting { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableCarrierFitting { } impl IIfcObject for IfcCableCarrierFitting { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCableCarrierFitting { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCableCarrierFitting { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCableCarrierFitting { } impl IIfcDistributionFlowElement for IfcCableCarrierFitting { } impl IIfcFlowFitting for IfcCableCarrierFitting { } impl IIfcCableCarrierFitting for IfcCableCarrierFitting { fn predefined_type (& self) -> & Option < IfcCableCarrierFittingTypeEnum > { & self . predefined_type } } impl IfcCableCarrierFitting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableCarrierFitting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCableCarrierFittingType : IIfcFlowFittingType { pub fn predefined_type (& self) -> & IfcCableCarrierFittingTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCableCarrierFittingType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCableCarrierFittingTypeEnum , } impl IIfcRoot for IfcCableCarrierFittingType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableCarrierFittingType { } impl IIfcTypeObject for IfcCableCarrierFittingType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCableCarrierFittingType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCableCarrierFittingType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCableCarrierFittingType { } impl IIfcDistributionFlowElementType for IfcCableCarrierFittingType { } impl IIfcFlowFittingType for IfcCableCarrierFittingType { } impl IIfcCableCarrierFittingType for IfcCableCarrierFittingType { fn predefined_type (& self) -> & IfcCableCarrierFittingTypeEnum { & self . predefined_type } } impl IfcCableCarrierFittingType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableCarrierFittingType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCableCarrierSegment : IIfcFlowSegment { pub fn predefined_type (& self) -> & Option < IfcCableCarrierSegmentTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCableCarrierSegment { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCableCarrierSegmentTypeEnum > , } impl IIfcRoot for IfcCableCarrierSegment { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableCarrierSegment { } impl IIfcObject for IfcCableCarrierSegment { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCableCarrierSegment { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCableCarrierSegment { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCableCarrierSegment { } impl IIfcDistributionFlowElement for IfcCableCarrierSegment { } impl IIfcFlowSegment for IfcCableCarrierSegment { } impl IIfcCableCarrierSegment for IfcCableCarrierSegment { fn predefined_type (& self) -> & Option < IfcCableCarrierSegmentTypeEnum > { & self . predefined_type } } impl IfcCableCarrierSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableCarrierSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCableCarrierSegmentType : IIfcFlowSegmentType { pub fn predefined_type (& self) -> & IfcCableCarrierSegmentTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCableCarrierSegmentType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCableCarrierSegmentTypeEnum , } impl IIfcRoot for IfcCableCarrierSegmentType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableCarrierSegmentType { } impl IIfcTypeObject for IfcCableCarrierSegmentType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCableCarrierSegmentType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCableCarrierSegmentType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCableCarrierSegmentType { } impl IIfcDistributionFlowElementType for IfcCableCarrierSegmentType { } impl IIfcFlowSegmentType for IfcCableCarrierSegmentType { } impl IIfcCableCarrierSegmentType for IfcCableCarrierSegmentType { fn predefined_type (& self) -> & IfcCableCarrierSegmentTypeEnum { & self . predefined_type } } impl IfcCableCarrierSegmentType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableCarrierSegmentType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCableFitting : IIfcFlowFitting { pub fn predefined_type (& self) -> & Option < IfcCableFittingTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCableFitting { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCableFittingTypeEnum > , } impl IIfcRoot for IfcCableFitting { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableFitting { } impl IIfcObject for IfcCableFitting { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCableFitting { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCableFitting { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCableFitting { } impl IIfcDistributionFlowElement for IfcCableFitting { } impl IIfcFlowFitting for IfcCableFitting { } impl IIfcCableFitting for IfcCableFitting { fn predefined_type (& self) -> & Option < IfcCableFittingTypeEnum > { & self . predefined_type } } impl IfcCableFitting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableFitting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCableFittingType : IIfcFlowFittingType { pub fn predefined_type (& self) -> & IfcCableFittingTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCableFittingType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCableFittingTypeEnum , } impl IIfcRoot for IfcCableFittingType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableFittingType { } impl IIfcTypeObject for IfcCableFittingType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCableFittingType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCableFittingType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCableFittingType { } impl IIfcDistributionFlowElementType for IfcCableFittingType { } impl IIfcFlowFittingType for IfcCableFittingType { } impl IIfcCableFittingType for IfcCableFittingType { fn predefined_type (& self) -> & IfcCableFittingTypeEnum { & self . predefined_type } } impl IfcCableFittingType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableFittingType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCableSegment : IIfcFlowSegment { pub fn predefined_type (& self) -> & Option < IfcCableSegmentTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCableSegment { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCableSegmentTypeEnum > , } impl IIfcRoot for IfcCableSegment { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableSegment { } impl IIfcObject for IfcCableSegment { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCableSegment { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCableSegment { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCableSegment { } impl IIfcDistributionFlowElement for IfcCableSegment { } impl IIfcFlowSegment for IfcCableSegment { } impl IIfcCableSegment for IfcCableSegment { fn predefined_type (& self) -> & Option < IfcCableSegmentTypeEnum > { & self . predefined_type } } impl IfcCableSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCableSegmentType : IIfcFlowSegmentType { pub fn predefined_type (& self) -> & IfcCableSegmentTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCableSegmentType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCableSegmentTypeEnum , } impl IIfcRoot for IfcCableSegmentType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCableSegmentType { } impl IIfcTypeObject for IfcCableSegmentType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCableSegmentType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCableSegmentType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCableSegmentType { } impl IIfcDistributionFlowElementType for IfcCableSegmentType { } impl IIfcFlowSegmentType for IfcCableSegmentType { } impl IIfcCableSegmentType for IfcCableSegmentType { fn predefined_type (& self) -> & IfcCableSegmentTypeEnum { & self . predefined_type } } impl IfcCableSegmentType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCableSegmentType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCartesianPoint : IIfcPoint { pub fn coordinates (& self) -> & Vec < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcCartesianPoint { coordinates : Vec < IfcLengthMeasure > , } impl IIfcRepresentationItem for IfcCartesianPoint { } impl IIfcGeometricRepresentationItem for IfcCartesianPoint { } impl IIfcPoint for IfcCartesianPoint { } impl IIfcCartesianPoint for IfcCartesianPoint { fn coordinates (& self) -> & Vec < IfcLengthMeasure > { & self . coordinates } } impl IfcCartesianPoint { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianPoint :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coordinates = parameter . into () , _ => { } } } entity } } pub trait IIfcCartesianPointList : IIfcGeometricRepresentationItem { } pub trait IIfcCartesianPointList2D : IIfcCartesianPointList { pub fn coord_list (& self) -> & Vec < Vec < IfcLengthMeasure > > ; } # [derive (Default , Debug)] pub struct IfcCartesianPointList2D { coord_list : Vec < Vec < IfcLengthMeasure > > , } impl IIfcRepresentationItem for IfcCartesianPointList2D { } impl IIfcGeometricRepresentationItem for IfcCartesianPointList2D { } impl IIfcCartesianPointList for IfcCartesianPointList2D { } impl IIfcCartesianPointList2D for IfcCartesianPointList2D { fn coord_list (& self) -> & Vec < Vec < IfcLengthMeasure > > { & self . coord_list } } impl IfcCartesianPointList2D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianPointList2D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coord_list = parameter . into () , _ => { } } } entity } } pub trait IIfcCartesianPointList3D : IIfcCartesianPointList { pub fn coord_list (& self) -> & Vec < Vec < IfcLengthMeasure > > ; } # [derive (Default , Debug)] pub struct IfcCartesianPointList3D { coord_list : Vec < Vec < IfcLengthMeasure > > , } impl IIfcRepresentationItem for IfcCartesianPointList3D { } impl IIfcGeometricRepresentationItem for IfcCartesianPointList3D { } impl IIfcCartesianPointList for IfcCartesianPointList3D { } impl IIfcCartesianPointList3D for IfcCartesianPointList3D { fn coord_list (& self) -> & Vec < Vec < IfcLengthMeasure > > { & self . coord_list } } impl IfcCartesianPointList3D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianPointList3D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coord_list = parameter . into () , _ => { } } } entity } } pub trait IIfcCartesianTransformationOperator : IIfcGeometricRepresentationItem { pub fn axis1 (& self) -> & Option < EntityRef < IfcDirection > > ; pub fn axis2 (& self) -> & Option < EntityRef < IfcDirection > > ; pub fn local_origin (& self) -> & EntityRef < IfcCartesianPoint > ; pub fn scale (& self) -> & Option < IfcReal > ; } pub trait IIfcCartesianTransformationOperator2D : IIfcCartesianTransformationOperator { } # [derive (Default , Debug)] pub struct IfcCartesianTransformationOperator2D { axis1 : Option < EntityRef < IfcDirection > > , axis2 : Option < EntityRef < IfcDirection > > , local_origin : EntityRef < IfcCartesianPoint > , scale : Option < IfcReal > , } impl IIfcRepresentationItem for IfcCartesianTransformationOperator2D { } impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator2D { } impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator2D { fn axis1 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis1 } fn axis2 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis2 } fn local_origin (& self) -> & EntityRef < IfcCartesianPoint > { & self . local_origin } fn scale (& self) -> & Option < IfcReal > { & self . scale } } impl IIfcCartesianTransformationOperator2D for IfcCartesianTransformationOperator2D { } impl IfcCartesianTransformationOperator2D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianTransformationOperator2D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . axis1 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . axis2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . local_origin = parameter . into () , 3usize => entity . scale = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCartesianTransformationOperator2DnonUniform : IIfcCartesianTransformationOperator2D { pub fn scale2 (& self) -> & Option < IfcReal > ; } # [derive (Default , Debug)] pub struct IfcCartesianTransformationOperator2DnonUniform { axis1 : Option < EntityRef < IfcDirection > > , axis2 : Option < EntityRef < IfcDirection > > , local_origin : EntityRef < IfcCartesianPoint > , scale : Option < IfcReal > , scale2 : Option < IfcReal > , } impl IIfcRepresentationItem for IfcCartesianTransformationOperator2DnonUniform { } impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator2DnonUniform { } impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator2DnonUniform { fn axis1 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis1 } fn axis2 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis2 } fn local_origin (& self) -> & EntityRef < IfcCartesianPoint > { & self . local_origin } fn scale (& self) -> & Option < IfcReal > { & self . scale } } impl IIfcCartesianTransformationOperator2D for IfcCartesianTransformationOperator2DnonUniform { } impl IIfcCartesianTransformationOperator2DnonUniform for IfcCartesianTransformationOperator2DnonUniform { fn scale2 (& self) -> & Option < IfcReal > { & self . scale2 } } impl IfcCartesianTransformationOperator2DnonUniform { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianTransformationOperator2DnonUniform :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . axis1 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . axis2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . local_origin = parameter . into () , 3usize => entity . scale = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . scale2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCartesianTransformationOperator3D : IIfcCartesianTransformationOperator { pub fn axis3 (& self) -> & Option < EntityRef < IfcDirection > > ; } # [derive (Default , Debug)] pub struct IfcCartesianTransformationOperator3D { axis1 : Option < EntityRef < IfcDirection > > , axis2 : Option < EntityRef < IfcDirection > > , local_origin : EntityRef < IfcCartesianPoint > , scale : Option < IfcReal > , axis3 : Option < EntityRef < IfcDirection > > , } impl IIfcRepresentationItem for IfcCartesianTransformationOperator3D { } impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator3D { } impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator3D { fn axis1 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis1 } fn axis2 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis2 } fn local_origin (& self) -> & EntityRef < IfcCartesianPoint > { & self . local_origin } fn scale (& self) -> & Option < IfcReal > { & self . scale } } impl IIfcCartesianTransformationOperator3D for IfcCartesianTransformationOperator3D { fn axis3 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis3 } } impl IfcCartesianTransformationOperator3D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianTransformationOperator3D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . axis1 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . axis2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . local_origin = parameter . into () , 3usize => entity . scale = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . axis3 = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCartesianTransformationOperator3DnonUniform : IIfcCartesianTransformationOperator3D { pub fn scale2 (& self) -> & Option < IfcReal > ; pub fn scale3 (& self) -> & Option < IfcReal > ; } # [derive (Default , Debug)] pub struct IfcCartesianTransformationOperator3DnonUniform { axis1 : Option < EntityRef < IfcDirection > > , axis2 : Option < EntityRef < IfcDirection > > , local_origin : EntityRef < IfcCartesianPoint > , scale : Option < IfcReal > , axis3 : Option < EntityRef < IfcDirection > > , scale2 : Option < IfcReal > , scale3 : Option < IfcReal > , } impl IIfcRepresentationItem for IfcCartesianTransformationOperator3DnonUniform { } impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator3DnonUniform { } impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator3DnonUniform { fn axis1 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis1 } fn axis2 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis2 } fn local_origin (& self) -> & EntityRef < IfcCartesianPoint > { & self . local_origin } fn scale (& self) -> & Option < IfcReal > { & self . scale } } impl IIfcCartesianTransformationOperator3D for IfcCartesianTransformationOperator3DnonUniform { fn axis3 (& self) -> & Option < EntityRef < IfcDirection > > { & self . axis3 } } impl IIfcCartesianTransformationOperator3DnonUniform for IfcCartesianTransformationOperator3DnonUniform { fn scale2 (& self) -> & Option < IfcReal > { & self . scale2 } fn scale3 (& self) -> & Option < IfcReal > { & self . scale3 } } impl IfcCartesianTransformationOperator3DnonUniform { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCartesianTransformationOperator3DnonUniform :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . axis1 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . axis2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . local_origin = parameter . into () , 3usize => entity . scale = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . axis3 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . scale2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . scale3 = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCenterLineProfileDef : IIfcArbitraryOpenProfileDef { pub fn thickness (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcCenterLineProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , curve : EntityRef < IfcBoundedCurve > , thickness : IfcPositiveLengthMeasure , } impl IIfcProfileDef for IfcCenterLineProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcArbitraryOpenProfileDef for IfcCenterLineProfileDef { fn curve (& self) -> & EntityRef < IfcBoundedCurve > { & self . curve } } impl IIfcCenterLineProfileDef for IfcCenterLineProfileDef { fn thickness (& self) -> & IfcPositiveLengthMeasure { & self . thickness } } impl IfcCenterLineProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCenterLineProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . curve = parameter . into () , 3usize => entity . thickness = parameter . into () , _ => { } } } entity } } pub trait IIfcChiller : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcChillerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcChiller { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcChillerTypeEnum > , } impl IIfcRoot for IfcChiller { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcChiller { } impl IIfcObject for IfcChiller { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcChiller { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcChiller { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcChiller { } impl IIfcDistributionFlowElement for IfcChiller { } impl IIfcEnergyConversionDevice for IfcChiller { } impl IIfcChiller for IfcChiller { fn predefined_type (& self) -> & Option < IfcChillerTypeEnum > { & self . predefined_type } } impl IfcChiller { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcChiller :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcChillerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcChillerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcChillerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcChillerTypeEnum , } impl IIfcRoot for IfcChillerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcChillerType { } impl IIfcTypeObject for IfcChillerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcChillerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcChillerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcChillerType { } impl IIfcDistributionFlowElementType for IfcChillerType { } impl IIfcEnergyConversionDeviceType for IfcChillerType { } impl IIfcChillerType for IfcChillerType { fn predefined_type (& self) -> & IfcChillerTypeEnum { & self . predefined_type } } impl IfcChillerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcChillerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcChimney : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcChimneyTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcChimney { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcChimneyTypeEnum > , } impl IIfcRoot for IfcChimney { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcChimney { } impl IIfcObject for IfcChimney { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcChimney { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcChimney { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcChimney { } impl IIfcChimney for IfcChimney { fn predefined_type (& self) -> & Option < IfcChimneyTypeEnum > { & self . predefined_type } } impl IfcChimney { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcChimney :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcChimneyType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcChimneyTypeEnum ; } # [derive (Default , Debug)] pub struct IfcChimneyType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcChimneyTypeEnum , } impl IIfcRoot for IfcChimneyType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcChimneyType { } impl IIfcTypeObject for IfcChimneyType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcChimneyType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcChimneyType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcChimneyType { } impl IIfcChimneyType for IfcChimneyType { fn predefined_type (& self) -> & IfcChimneyTypeEnum { & self . predefined_type } } impl IfcChimneyType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcChimneyType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCircle : IIfcConic { pub fn radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcCircle { position : EntityRef < IfcAxis2Placement > , radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcCircle { } impl IIfcGeometricRepresentationItem for IfcCircle { } impl IIfcCurve for IfcCircle { } impl IIfcConic for IfcCircle { fn position (& self) -> & EntityRef < IfcAxis2Placement > { & self . position } } impl IIfcCircle for IfcCircle { fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IfcCircle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCircle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . radius = parameter . into () , _ => { } } } entity } } pub trait IIfcCircleHollowProfileDef : IIfcCircleProfileDef { pub fn wall_thickness (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcCircleHollowProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , radius : IfcPositiveLengthMeasure , wall_thickness : IfcPositiveLengthMeasure , } impl IIfcProfileDef for IfcCircleHollowProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcCircleHollowProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcCircleProfileDef for IfcCircleHollowProfileDef { fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IIfcCircleHollowProfileDef for IfcCircleHollowProfileDef { fn wall_thickness (& self) -> & IfcPositiveLengthMeasure { & self . wall_thickness } } impl IfcCircleHollowProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCircleHollowProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . radius = parameter . into () , 4usize => entity . wall_thickness = parameter . into () , _ => { } } } entity } } pub trait IIfcCircleProfileDef : IIfcParameterizedProfileDef { pub fn radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcCircleProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , radius : IfcPositiveLengthMeasure , } impl IIfcProfileDef for IfcCircleProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcCircleProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcCircleProfileDef for IfcCircleProfileDef { fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IfcCircleProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCircleProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . radius = parameter . into () , _ => { } } } entity } } pub trait IIfcCivilElement : IIfcElement { } # [derive (Default , Debug)] pub struct IfcCivilElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcCivilElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCivilElement { } impl IIfcObject for IfcCivilElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCivilElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCivilElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcCivilElement for IfcCivilElement { } impl IfcCivilElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCivilElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCivilElementType : IIfcElementType { } # [derive (Default , Debug)] pub struct IfcCivilElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , } impl IIfcRoot for IfcCivilElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCivilElementType { } impl IIfcTypeObject for IfcCivilElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCivilElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCivilElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcCivilElementType for IfcCivilElementType { } impl IfcCivilElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCivilElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcClassification : IIfcExternalInformation { pub fn source (& self) -> & Option < IfcLabel > ; pub fn edition (& self) -> & Option < IfcLabel > ; pub fn edition_date (& self) -> & Option < IfcDate > ; pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn location (& self) -> & Option < IfcUriReference > ; pub fn reference_tokens (& self) -> & Option < Vec < IfcIdentifier > > ; } # [derive (Default , Debug)] pub struct IfcClassification { source : Option < IfcLabel > , edition : Option < IfcLabel > , edition_date : Option < IfcDate > , name : IfcLabel , description : Option < IfcText > , location : Option < IfcUriReference > , reference_tokens : Option < Vec < IfcIdentifier > > , } impl IIfcExternalInformation for IfcClassification { } impl IIfcClassification for IfcClassification { fn source (& self) -> & Option < IfcLabel > { & self . source } fn edition (& self) -> & Option < IfcLabel > { & self . edition } fn edition_date (& self) -> & Option < IfcDate > { & self . edition_date } fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn location (& self) -> & Option < IfcUriReference > { & self . location } fn reference_tokens (& self) -> & Option < Vec < IfcIdentifier > > { & self . reference_tokens } } impl IfcClassification { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcClassification :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . source = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . edition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . edition_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . name = parameter . into () , 4usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . reference_tokens = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcClassificationReference : IIfcExternalReference { pub fn referenced_source (& self) -> & Option < EntityRef < IfcClassificationReferenceSelect > > ; pub fn description (& self) -> & Option < IfcText > ; pub fn sort (& self) -> & Option < IfcIdentifier > ; } # [derive (Default , Debug)] pub struct IfcClassificationReference { location : Option < IfcUriReference > , identification : Option < IfcIdentifier > , name : Option < IfcLabel > , referenced_source : Option < EntityRef < IfcClassificationReferenceSelect > > , description : Option < IfcText > , sort : Option < IfcIdentifier > , } impl IIfcExternalReference for IfcClassificationReference { fn location (& self) -> & Option < IfcUriReference > { & self . location } fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcClassificationReference for IfcClassificationReference { fn referenced_source (& self) -> & Option < EntityRef < IfcClassificationReferenceSelect > > { & self . referenced_source } fn description (& self) -> & Option < IfcText > { & self . description } fn sort (& self) -> & Option < IfcIdentifier > { & self . sort } } impl IfcClassificationReference { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcClassificationReference :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . referenced_source = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . sort = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcClosedShell : IIfcConnectedFaceSet { } # [derive (Default , Debug)] pub struct IfcClosedShell { cfs_faces : HashSet < EntityRef < IfcFace > > , } impl IIfcRepresentationItem for IfcClosedShell { } impl IIfcTopologicalRepresentationItem for IfcClosedShell { } impl IIfcConnectedFaceSet for IfcClosedShell { fn cfs_faces (& self) -> & HashSet < EntityRef < IfcFace > > { & self . cfs_faces } } impl IIfcClosedShell for IfcClosedShell { } impl IfcClosedShell { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcClosedShell :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . cfs_faces = parameter . into () , _ => { } } } entity } } pub trait IIfcCoil : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcCoilTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCoil { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCoilTypeEnum > , } impl IIfcRoot for IfcCoil { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCoil { } impl IIfcObject for IfcCoil { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCoil { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCoil { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCoil { } impl IIfcDistributionFlowElement for IfcCoil { } impl IIfcEnergyConversionDevice for IfcCoil { } impl IIfcCoil for IfcCoil { fn predefined_type (& self) -> & Option < IfcCoilTypeEnum > { & self . predefined_type } } impl IfcCoil { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCoil :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCoilType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcCoilTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCoilType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCoilTypeEnum , } impl IIfcRoot for IfcCoilType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCoilType { } impl IIfcTypeObject for IfcCoilType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCoilType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCoilType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCoilType { } impl IIfcDistributionFlowElementType for IfcCoilType { } impl IIfcEnergyConversionDeviceType for IfcCoilType { } impl IIfcCoilType for IfcCoilType { fn predefined_type (& self) -> & IfcCoilTypeEnum { & self . predefined_type } } impl IfcCoilType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCoilType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcColourRgb : IIfcColourSpecification { pub fn red (& self) -> & IfcNormalisedRatioMeasure ; pub fn green (& self) -> & IfcNormalisedRatioMeasure ; pub fn blue (& self) -> & IfcNormalisedRatioMeasure ; } # [derive (Default , Debug)] pub struct IfcColourRgb { name : Option < IfcLabel > , red : IfcNormalisedRatioMeasure , green : IfcNormalisedRatioMeasure , blue : IfcNormalisedRatioMeasure , } impl IIfcPresentationItem for IfcColourRgb { } impl IIfcColourSpecification for IfcColourRgb { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcColourRgb for IfcColourRgb { fn red (& self) -> & IfcNormalisedRatioMeasure { & self . red } fn green (& self) -> & IfcNormalisedRatioMeasure { & self . green } fn blue (& self) -> & IfcNormalisedRatioMeasure { & self . blue } } impl IfcColourRgb { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcColourRgb :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . red = parameter . into () , 2usize => entity . green = parameter . into () , 3usize => entity . blue = parameter . into () , _ => { } } } entity } } pub trait IIfcColourRgbList : IIfcPresentationItem { pub fn colour_list (& self) -> & Vec < Vec < IfcNormalisedRatioMeasure > > ; } # [derive (Default , Debug)] pub struct IfcColourRgbList { colour_list : Vec < Vec < IfcNormalisedRatioMeasure > > , } impl IIfcPresentationItem for IfcColourRgbList { } impl IIfcColourRgbList for IfcColourRgbList { fn colour_list (& self) -> & Vec < Vec < IfcNormalisedRatioMeasure > > { & self . colour_list } } impl IfcColourRgbList { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcColourRgbList :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . colour_list = parameter . into () , _ => { } } } entity } } pub trait IIfcColourSpecification : IIfcPresentationItem { pub fn name (& self) -> & Option < IfcLabel > ; } pub trait IIfcColumn : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcColumnTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcColumn { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcColumnTypeEnum > , } impl IIfcRoot for IfcColumn { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcColumn { } impl IIfcObject for IfcColumn { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcColumn { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcColumn { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcColumn { } impl IIfcColumn for IfcColumn { fn predefined_type (& self) -> & Option < IfcColumnTypeEnum > { & self . predefined_type } } impl IfcColumn { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcColumn :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcColumnStandardCase : IIfcColumn { } # [derive (Default , Debug)] pub struct IfcColumnStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcColumnTypeEnum > , } impl IIfcRoot for IfcColumnStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcColumnStandardCase { } impl IIfcObject for IfcColumnStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcColumnStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcColumnStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcColumnStandardCase { } impl IIfcColumn for IfcColumnStandardCase { fn predefined_type (& self) -> & Option < IfcColumnTypeEnum > { & self . predefined_type } } impl IIfcColumnStandardCase for IfcColumnStandardCase { } impl IfcColumnStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcColumnStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcColumnType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcColumnTypeEnum ; } # [derive (Default , Debug)] pub struct IfcColumnType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcColumnTypeEnum , } impl IIfcRoot for IfcColumnType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcColumnType { } impl IIfcTypeObject for IfcColumnType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcColumnType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcColumnType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcColumnType { } impl IIfcColumnType for IfcColumnType { fn predefined_type (& self) -> & IfcColumnTypeEnum { & self . predefined_type } } impl IfcColumnType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcColumnType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCommunicationsAppliance : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcCommunicationsApplianceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCommunicationsAppliance { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCommunicationsApplianceTypeEnum > , } impl IIfcRoot for IfcCommunicationsAppliance { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCommunicationsAppliance { } impl IIfcObject for IfcCommunicationsAppliance { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCommunicationsAppliance { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCommunicationsAppliance { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCommunicationsAppliance { } impl IIfcDistributionFlowElement for IfcCommunicationsAppliance { } impl IIfcFlowTerminal for IfcCommunicationsAppliance { } impl IIfcCommunicationsAppliance for IfcCommunicationsAppliance { fn predefined_type (& self) -> & Option < IfcCommunicationsApplianceTypeEnum > { & self . predefined_type } } impl IfcCommunicationsAppliance { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCommunicationsAppliance :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCommunicationsApplianceType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcCommunicationsApplianceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCommunicationsApplianceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCommunicationsApplianceTypeEnum , } impl IIfcRoot for IfcCommunicationsApplianceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCommunicationsApplianceType { } impl IIfcTypeObject for IfcCommunicationsApplianceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCommunicationsApplianceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCommunicationsApplianceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCommunicationsApplianceType { } impl IIfcDistributionFlowElementType for IfcCommunicationsApplianceType { } impl IIfcFlowTerminalType for IfcCommunicationsApplianceType { } impl IIfcCommunicationsApplianceType for IfcCommunicationsApplianceType { fn predefined_type (& self) -> & IfcCommunicationsApplianceTypeEnum { & self . predefined_type } } impl IfcCommunicationsApplianceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCommunicationsApplianceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcComplexProperty : IIfcProperty { pub fn usage_name (& self) -> & IfcIdentifier ; pub fn has_properties (& self) -> & HashSet < EntityRef < IfcProperty > > ; } # [derive (Default , Debug)] pub struct IfcComplexProperty { name : IfcIdentifier , description : Option < IfcText > , usage_name : IfcIdentifier , has_properties : HashSet < EntityRef < IfcProperty > > , } impl IIfcPropertyAbstraction for IfcComplexProperty { } impl IIfcProperty for IfcComplexProperty { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcComplexProperty for IfcComplexProperty { fn usage_name (& self) -> & IfcIdentifier { & self . usage_name } fn has_properties (& self) -> & HashSet < EntityRef < IfcProperty > > { & self . has_properties } } impl IfcComplexProperty { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcComplexProperty :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . usage_name = parameter . into () , 3usize => entity . has_properties = parameter . into () , _ => { } } } entity } } pub trait IIfcComplexPropertyTemplate : IIfcPropertyTemplate { pub fn usage_name (& self) -> & Option < IfcLabel > ; pub fn template_type (& self) -> & Option < IfcComplexPropertyTemplateTypeEnum > ; pub fn has_property_templates (& self) -> & Option < HashSet < EntityRef < IfcPropertyTemplate > > > ; } # [derive (Default , Debug)] pub struct IfcComplexPropertyTemplate { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , usage_name : Option < IfcLabel > , template_type : Option < IfcComplexPropertyTemplateTypeEnum > , has_property_templates : Option < HashSet < EntityRef < IfcPropertyTemplate > > > , } impl IIfcRoot for IfcComplexPropertyTemplate { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcComplexPropertyTemplate { } impl IIfcPropertyTemplateDefinition for IfcComplexPropertyTemplate { } impl IIfcPropertyTemplate for IfcComplexPropertyTemplate { } impl IIfcComplexPropertyTemplate for IfcComplexPropertyTemplate { fn usage_name (& self) -> & Option < IfcLabel > { & self . usage_name } fn template_type (& self) -> & Option < IfcComplexPropertyTemplateTypeEnum > { & self . template_type } fn has_property_templates (& self) -> & Option < HashSet < EntityRef < IfcPropertyTemplate > > > { & self . has_property_templates } } impl IfcComplexPropertyTemplate { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcComplexPropertyTemplate :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . usage_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . template_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . has_property_templates = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCompositeCurve : IIfcBoundedCurve { pub fn segments (& self) -> & Vec < EntityRef < IfcCompositeCurveSegment > > ; pub fn self_intersect (& self) -> & IfcLogical ; } # [derive (Default , Debug)] pub struct IfcCompositeCurve { segments : Vec < EntityRef < IfcCompositeCurveSegment > > , self_intersect : IfcLogical , } impl IIfcRepresentationItem for IfcCompositeCurve { } impl IIfcGeometricRepresentationItem for IfcCompositeCurve { } impl IIfcCurve for IfcCompositeCurve { } impl IIfcBoundedCurve for IfcCompositeCurve { } impl IIfcCompositeCurve for IfcCompositeCurve { fn segments (& self) -> & Vec < EntityRef < IfcCompositeCurveSegment > > { & self . segments } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IfcCompositeCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCompositeCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . segments = parameter . into () , 1usize => entity . self_intersect = parameter . into () , _ => { } } } entity } } pub trait IIfcCompositeCurveOnSurface : IIfcCompositeCurve { } # [derive (Default , Debug)] pub struct IfcCompositeCurveOnSurface { segments : Vec < EntityRef < IfcCompositeCurveSegment > > , self_intersect : IfcLogical , } impl IIfcRepresentationItem for IfcCompositeCurveOnSurface { } impl IIfcGeometricRepresentationItem for IfcCompositeCurveOnSurface { } impl IIfcCurve for IfcCompositeCurveOnSurface { } impl IIfcBoundedCurve for IfcCompositeCurveOnSurface { } impl IIfcCompositeCurve for IfcCompositeCurveOnSurface { fn segments (& self) -> & Vec < EntityRef < IfcCompositeCurveSegment > > { & self . segments } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcCompositeCurveOnSurface for IfcCompositeCurveOnSurface { } impl IfcCompositeCurveOnSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCompositeCurveOnSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . segments = parameter . into () , 1usize => entity . self_intersect = parameter . into () , _ => { } } } entity } } pub trait IIfcCompositeCurveSegment : IIfcGeometricRepresentationItem { pub fn transition (& self) -> & IfcTransitionCode ; pub fn same_sense (& self) -> & IfcBoolean ; pub fn parent_curve (& self) -> & EntityRef < IfcCurve > ; } # [derive (Default , Debug)] pub struct IfcCompositeCurveSegment { transition : IfcTransitionCode , same_sense : IfcBoolean , parent_curve : EntityRef < IfcCurve > , } impl IIfcRepresentationItem for IfcCompositeCurveSegment { } impl IIfcGeometricRepresentationItem for IfcCompositeCurveSegment { } impl IIfcCompositeCurveSegment for IfcCompositeCurveSegment { fn transition (& self) -> & IfcTransitionCode { & self . transition } fn same_sense (& self) -> & IfcBoolean { & self . same_sense } fn parent_curve (& self) -> & EntityRef < IfcCurve > { & self . parent_curve } } impl IfcCompositeCurveSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCompositeCurveSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . transition = parameter . into () , 1usize => entity . same_sense = parameter . into () , 2usize => entity . parent_curve = parameter . into () , _ => { } } } entity } } pub trait IIfcCompositeProfileDef : IIfcProfileDef { pub fn profiles (& self) -> & HashSet < EntityRef < IfcProfileDef > > ; pub fn label (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcCompositeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , profiles : HashSet < EntityRef < IfcProfileDef > > , label : Option < IfcLabel > , } impl IIfcProfileDef for IfcCompositeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcCompositeProfileDef for IfcCompositeProfileDef { fn profiles (& self) -> & HashSet < EntityRef < IfcProfileDef > > { & self . profiles } fn label (& self) -> & Option < IfcLabel > { & self . label } } impl IfcCompositeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCompositeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . profiles = parameter . into () , 3usize => entity . label = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCompressor : IIfcFlowMovingDevice { pub fn predefined_type (& self) -> & Option < IfcCompressorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCompressor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCompressorTypeEnum > , } impl IIfcRoot for IfcCompressor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCompressor { } impl IIfcObject for IfcCompressor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCompressor { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCompressor { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCompressor { } impl IIfcDistributionFlowElement for IfcCompressor { } impl IIfcFlowMovingDevice for IfcCompressor { } impl IIfcCompressor for IfcCompressor { fn predefined_type (& self) -> & Option < IfcCompressorTypeEnum > { & self . predefined_type } } impl IfcCompressor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCompressor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCompressorType : IIfcFlowMovingDeviceType { pub fn predefined_type (& self) -> & IfcCompressorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCompressorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCompressorTypeEnum , } impl IIfcRoot for IfcCompressorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCompressorType { } impl IIfcTypeObject for IfcCompressorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCompressorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCompressorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCompressorType { } impl IIfcDistributionFlowElementType for IfcCompressorType { } impl IIfcFlowMovingDeviceType for IfcCompressorType { } impl IIfcCompressorType for IfcCompressorType { fn predefined_type (& self) -> & IfcCompressorTypeEnum { & self . predefined_type } } impl IfcCompressorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCompressorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCondenser : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcCondenserTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCondenser { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCondenserTypeEnum > , } impl IIfcRoot for IfcCondenser { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCondenser { } impl IIfcObject for IfcCondenser { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCondenser { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCondenser { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCondenser { } impl IIfcDistributionFlowElement for IfcCondenser { } impl IIfcEnergyConversionDevice for IfcCondenser { } impl IIfcCondenser for IfcCondenser { fn predefined_type (& self) -> & Option < IfcCondenserTypeEnum > { & self . predefined_type } } impl IfcCondenser { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCondenser :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCondenserType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcCondenserTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCondenserType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCondenserTypeEnum , } impl IIfcRoot for IfcCondenserType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCondenserType { } impl IIfcTypeObject for IfcCondenserType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCondenserType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCondenserType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCondenserType { } impl IIfcDistributionFlowElementType for IfcCondenserType { } impl IIfcEnergyConversionDeviceType for IfcCondenserType { } impl IIfcCondenserType for IfcCondenserType { fn predefined_type (& self) -> & IfcCondenserTypeEnum { & self . predefined_type } } impl IfcCondenserType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCondenserType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcConic : IIfcCurve { pub fn position (& self) -> & EntityRef < IfcAxis2Placement > ; } pub trait IIfcConnectedFaceSet : IIfcTopologicalRepresentationItem { pub fn cfs_faces (& self) -> & HashSet < EntityRef < IfcFace > > ; } # [derive (Default , Debug)] pub struct IfcConnectedFaceSet { cfs_faces : HashSet < EntityRef < IfcFace > > , } impl IIfcRepresentationItem for IfcConnectedFaceSet { } impl IIfcTopologicalRepresentationItem for IfcConnectedFaceSet { } impl IIfcConnectedFaceSet for IfcConnectedFaceSet { fn cfs_faces (& self) -> & HashSet < EntityRef < IfcFace > > { & self . cfs_faces } } impl IfcConnectedFaceSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConnectedFaceSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . cfs_faces = parameter . into () , _ => { } } } entity } } pub trait IIfcConnectionCurveGeometry : IIfcConnectionGeometry { pub fn curve_on_relating_element (& self) -> & EntityRef < IfcCurveOrEdgeCurve > ; pub fn curve_on_related_element (& self) -> & Option < EntityRef < IfcCurveOrEdgeCurve > > ; } # [derive (Default , Debug)] pub struct IfcConnectionCurveGeometry { curve_on_relating_element : EntityRef < IfcCurveOrEdgeCurve > , curve_on_related_element : Option < EntityRef < IfcCurveOrEdgeCurve > > , } impl IIfcConnectionGeometry for IfcConnectionCurveGeometry { } impl IIfcConnectionCurveGeometry for IfcConnectionCurveGeometry { fn curve_on_relating_element (& self) -> & EntityRef < IfcCurveOrEdgeCurve > { & self . curve_on_relating_element } fn curve_on_related_element (& self) -> & Option < EntityRef < IfcCurveOrEdgeCurve > > { & self . curve_on_related_element } } impl IfcConnectionCurveGeometry { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConnectionCurveGeometry :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . curve_on_relating_element = parameter . into () , 1usize => entity . curve_on_related_element = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConnectionGeometry : { } pub trait IIfcConnectionPointEccentricity : IIfcConnectionPointGeometry { pub fn eccentricity_in_x (& self) -> & Option < IfcLengthMeasure > ; pub fn eccentricity_in_y (& self) -> & Option < IfcLengthMeasure > ; pub fn eccentricity_in_z (& self) -> & Option < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcConnectionPointEccentricity { point_on_relating_element : EntityRef < IfcPointOrVertexPoint > , point_on_related_element : Option < EntityRef < IfcPointOrVertexPoint > > , eccentricity_in_x : Option < IfcLengthMeasure > , eccentricity_in_y : Option < IfcLengthMeasure > , eccentricity_in_z : Option < IfcLengthMeasure > , } impl IIfcConnectionGeometry for IfcConnectionPointEccentricity { } impl IIfcConnectionPointGeometry for IfcConnectionPointEccentricity { fn point_on_relating_element (& self) -> & EntityRef < IfcPointOrVertexPoint > { & self . point_on_relating_element } fn point_on_related_element (& self) -> & Option < EntityRef < IfcPointOrVertexPoint > > { & self . point_on_related_element } } impl IIfcConnectionPointEccentricity for IfcConnectionPointEccentricity { fn eccentricity_in_x (& self) -> & Option < IfcLengthMeasure > { & self . eccentricity_in_x } fn eccentricity_in_y (& self) -> & Option < IfcLengthMeasure > { & self . eccentricity_in_y } fn eccentricity_in_z (& self) -> & Option < IfcLengthMeasure > { & self . eccentricity_in_z } } impl IfcConnectionPointEccentricity { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConnectionPointEccentricity :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . point_on_relating_element = parameter . into () , 1usize => entity . point_on_related_element = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . eccentricity_in_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . eccentricity_in_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . eccentricity_in_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConnectionPointGeometry : IIfcConnectionGeometry { pub fn point_on_relating_element (& self) -> & EntityRef < IfcPointOrVertexPoint > ; pub fn point_on_related_element (& self) -> & Option < EntityRef < IfcPointOrVertexPoint > > ; } # [derive (Default , Debug)] pub struct IfcConnectionPointGeometry { point_on_relating_element : EntityRef < IfcPointOrVertexPoint > , point_on_related_element : Option < EntityRef < IfcPointOrVertexPoint > > , } impl IIfcConnectionGeometry for IfcConnectionPointGeometry { } impl IIfcConnectionPointGeometry for IfcConnectionPointGeometry { fn point_on_relating_element (& self) -> & EntityRef < IfcPointOrVertexPoint > { & self . point_on_relating_element } fn point_on_related_element (& self) -> & Option < EntityRef < IfcPointOrVertexPoint > > { & self . point_on_related_element } } impl IfcConnectionPointGeometry { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConnectionPointGeometry :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . point_on_relating_element = parameter . into () , 1usize => entity . point_on_related_element = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConnectionSurfaceGeometry : IIfcConnectionGeometry { pub fn surface_on_relating_element (& self) -> & EntityRef < IfcSurfaceOrFaceSurface > ; pub fn surface_on_related_element (& self) -> & Option < EntityRef < IfcSurfaceOrFaceSurface > > ; } # [derive (Default , Debug)] pub struct IfcConnectionSurfaceGeometry { surface_on_relating_element : EntityRef < IfcSurfaceOrFaceSurface > , surface_on_related_element : Option < EntityRef < IfcSurfaceOrFaceSurface > > , } impl IIfcConnectionGeometry for IfcConnectionSurfaceGeometry { } impl IIfcConnectionSurfaceGeometry for IfcConnectionSurfaceGeometry { fn surface_on_relating_element (& self) -> & EntityRef < IfcSurfaceOrFaceSurface > { & self . surface_on_relating_element } fn surface_on_related_element (& self) -> & Option < EntityRef < IfcSurfaceOrFaceSurface > > { & self . surface_on_related_element } } impl IfcConnectionSurfaceGeometry { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConnectionSurfaceGeometry :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . surface_on_relating_element = parameter . into () , 1usize => entity . surface_on_related_element = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConnectionVolumeGeometry : IIfcConnectionGeometry { pub fn volume_on_relating_element (& self) -> & EntityRef < IfcSolidOrShell > ; pub fn volume_on_related_element (& self) -> & Option < EntityRef < IfcSolidOrShell > > ; } # [derive (Default , Debug)] pub struct IfcConnectionVolumeGeometry { volume_on_relating_element : EntityRef < IfcSolidOrShell > , volume_on_related_element : Option < EntityRef < IfcSolidOrShell > > , } impl IIfcConnectionGeometry for IfcConnectionVolumeGeometry { } impl IIfcConnectionVolumeGeometry for IfcConnectionVolumeGeometry { fn volume_on_relating_element (& self) -> & EntityRef < IfcSolidOrShell > { & self . volume_on_relating_element } fn volume_on_related_element (& self) -> & Option < EntityRef < IfcSolidOrShell > > { & self . volume_on_related_element } } impl IfcConnectionVolumeGeometry { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConnectionVolumeGeometry :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . volume_on_relating_element = parameter . into () , 1usize => entity . volume_on_related_element = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConstraint : { pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn constraint_grade (& self) -> & IfcConstraintEnum ; pub fn constraint_source (& self) -> & Option < IfcLabel > ; pub fn creating_actor (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn creation_time (& self) -> & Option < IfcDateTime > ; pub fn user_defined_grade (& self) -> & Option < IfcLabel > ; } pub trait IIfcConstructionEquipmentResource : IIfcConstructionResource { pub fn predefined_type (& self) -> & Option < IfcConstructionEquipmentResourceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcConstructionEquipmentResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , usage : Option < EntityRef < IfcResourceTime > > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : Option < IfcConstructionEquipmentResourceTypeEnum > , } impl IIfcRoot for IfcConstructionEquipmentResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcConstructionEquipmentResource { } impl IIfcObject for IfcConstructionEquipmentResource { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcResource for IfcConstructionEquipmentResource { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcConstructionResource for IfcConstructionEquipmentResource { fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > { & self . usage } fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcConstructionEquipmentResource for IfcConstructionEquipmentResource { fn predefined_type (& self) -> & Option < IfcConstructionEquipmentResourceTypeEnum > { & self . predefined_type } } impl IfcConstructionEquipmentResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConstructionEquipmentResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConstructionEquipmentResourceType : IIfcConstructionResourceType { pub fn predefined_type (& self) -> & IfcConstructionEquipmentResourceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcConstructionEquipmentResourceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , resource_type : Option < IfcLabel > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : IfcConstructionEquipmentResourceTypeEnum , } impl IIfcRoot for IfcConstructionEquipmentResourceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcConstructionEquipmentResourceType { } impl IIfcTypeObject for IfcConstructionEquipmentResourceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeResource for IfcConstructionEquipmentResourceType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn resource_type (& self) -> & Option < IfcLabel > { & self . resource_type } } impl IIfcConstructionResourceType for IfcConstructionEquipmentResourceType { fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcConstructionEquipmentResourceType for IfcConstructionEquipmentResourceType { fn predefined_type (& self) -> & IfcConstructionEquipmentResourceTypeEnum { & self . predefined_type } } impl IfcConstructionEquipmentResourceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConstructionEquipmentResourceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . resource_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcConstructionMaterialResource : IIfcConstructionResource { pub fn predefined_type (& self) -> & Option < IfcConstructionMaterialResourceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcConstructionMaterialResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , usage : Option < EntityRef < IfcResourceTime > > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : Option < IfcConstructionMaterialResourceTypeEnum > , } impl IIfcRoot for IfcConstructionMaterialResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcConstructionMaterialResource { } impl IIfcObject for IfcConstructionMaterialResource { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcResource for IfcConstructionMaterialResource { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcConstructionResource for IfcConstructionMaterialResource { fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > { & self . usage } fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcConstructionMaterialResource for IfcConstructionMaterialResource { fn predefined_type (& self) -> & Option < IfcConstructionMaterialResourceTypeEnum > { & self . predefined_type } } impl IfcConstructionMaterialResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConstructionMaterialResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConstructionMaterialResourceType : IIfcConstructionResourceType { pub fn predefined_type (& self) -> & IfcConstructionMaterialResourceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcConstructionMaterialResourceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , resource_type : Option < IfcLabel > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : IfcConstructionMaterialResourceTypeEnum , } impl IIfcRoot for IfcConstructionMaterialResourceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcConstructionMaterialResourceType { } impl IIfcTypeObject for IfcConstructionMaterialResourceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeResource for IfcConstructionMaterialResourceType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn resource_type (& self) -> & Option < IfcLabel > { & self . resource_type } } impl IIfcConstructionResourceType for IfcConstructionMaterialResourceType { fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcConstructionMaterialResourceType for IfcConstructionMaterialResourceType { fn predefined_type (& self) -> & IfcConstructionMaterialResourceTypeEnum { & self . predefined_type } } impl IfcConstructionMaterialResourceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConstructionMaterialResourceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . resource_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcConstructionProductResource : IIfcConstructionResource { pub fn predefined_type (& self) -> & Option < IfcConstructionProductResourceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcConstructionProductResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , usage : Option < EntityRef < IfcResourceTime > > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : Option < IfcConstructionProductResourceTypeEnum > , } impl IIfcRoot for IfcConstructionProductResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcConstructionProductResource { } impl IIfcObject for IfcConstructionProductResource { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcResource for IfcConstructionProductResource { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcConstructionResource for IfcConstructionProductResource { fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > { & self . usage } fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcConstructionProductResource for IfcConstructionProductResource { fn predefined_type (& self) -> & Option < IfcConstructionProductResourceTypeEnum > { & self . predefined_type } } impl IfcConstructionProductResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConstructionProductResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcConstructionProductResourceType : IIfcConstructionResourceType { pub fn predefined_type (& self) -> & IfcConstructionProductResourceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcConstructionProductResourceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , resource_type : Option < IfcLabel > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : IfcConstructionProductResourceTypeEnum , } impl IIfcRoot for IfcConstructionProductResourceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcConstructionProductResourceType { } impl IIfcTypeObject for IfcConstructionProductResourceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeResource for IfcConstructionProductResourceType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn resource_type (& self) -> & Option < IfcLabel > { & self . resource_type } } impl IIfcConstructionResourceType for IfcConstructionProductResourceType { fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcConstructionProductResourceType for IfcConstructionProductResourceType { fn predefined_type (& self) -> & IfcConstructionProductResourceTypeEnum { & self . predefined_type } } impl IfcConstructionProductResourceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConstructionProductResourceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . resource_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcConstructionResource : IIfcResource { pub fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > ; pub fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > ; pub fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > ; } pub trait IIfcConstructionResourceType : IIfcTypeResource { pub fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > ; pub fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > ; } pub trait IIfcContext : IIfcObjectDefinition { pub fn object_type (& self) -> & Option < IfcLabel > ; pub fn long_name (& self) -> & Option < IfcLabel > ; pub fn phase (& self) -> & Option < IfcLabel > ; pub fn representation_contexts (& self) -> & Option < HashSet < EntityRef < IfcRepresentationContext > > > ; pub fn units_in_context (& self) -> & Option < EntityRef < IfcUnitAssignment > > ; } pub trait IIfcContextDependentUnit : IIfcNamedUnit { pub fn name (& self) -> & IfcLabel ; } # [derive (Default , Debug)] pub struct IfcContextDependentUnit { dimensions : EntityRef < IfcDimensionalExponents > , unit_type : IfcUnitEnum , name : IfcLabel , } impl IIfcNamedUnit for IfcContextDependentUnit { fn dimensions (& self) -> & EntityRef < IfcDimensionalExponents > { & self . dimensions } fn unit_type (& self) -> & IfcUnitEnum { & self . unit_type } } impl IIfcContextDependentUnit for IfcContextDependentUnit { fn name (& self) -> & IfcLabel { & self . name } } impl IfcContextDependentUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcContextDependentUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . dimensions = parameter . into () , 1usize => entity . unit_type = parameter . into () , 2usize => entity . name = parameter . into () , _ => { } } } entity } } pub trait IIfcControl : IIfcObject { pub fn identification (& self) -> & Option < IfcIdentifier > ; } pub trait IIfcController : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcControllerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcController { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcControllerTypeEnum > , } impl IIfcRoot for IfcController { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcController { } impl IIfcObject for IfcController { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcController { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcController { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcController { } impl IIfcDistributionControlElement for IfcController { } impl IIfcController for IfcController { fn predefined_type (& self) -> & Option < IfcControllerTypeEnum > { & self . predefined_type } } impl IfcController { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcController :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcControllerType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcControllerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcControllerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcControllerTypeEnum , } impl IIfcRoot for IfcControllerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcControllerType { } impl IIfcTypeObject for IfcControllerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcControllerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcControllerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcControllerType { } impl IIfcDistributionControlElementType for IfcControllerType { } impl IIfcControllerType for IfcControllerType { fn predefined_type (& self) -> & IfcControllerTypeEnum { & self . predefined_type } } impl IfcControllerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcControllerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcConversionBasedUnit : IIfcNamedUnit { pub fn name (& self) -> & IfcLabel ; pub fn conversion_factor (& self) -> & EntityRef < IfcMeasureWithUnit > ; } # [derive (Default , Debug)] pub struct IfcConversionBasedUnit { dimensions : EntityRef < IfcDimensionalExponents > , unit_type : IfcUnitEnum , name : IfcLabel , conversion_factor : EntityRef < IfcMeasureWithUnit > , } impl IIfcNamedUnit for IfcConversionBasedUnit { fn dimensions (& self) -> & EntityRef < IfcDimensionalExponents > { & self . dimensions } fn unit_type (& self) -> & IfcUnitEnum { & self . unit_type } } impl IIfcConversionBasedUnit for IfcConversionBasedUnit { fn name (& self) -> & IfcLabel { & self . name } fn conversion_factor (& self) -> & EntityRef < IfcMeasureWithUnit > { & self . conversion_factor } } impl IfcConversionBasedUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConversionBasedUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . dimensions = parameter . into () , 1usize => entity . unit_type = parameter . into () , 2usize => entity . name = parameter . into () , 3usize => entity . conversion_factor = parameter . into () , _ => { } } } entity } } pub trait IIfcConversionBasedUnitWithOffset : IIfcConversionBasedUnit { pub fn conversion_offset (& self) -> & IfcReal ; } # [derive (Default , Debug)] pub struct IfcConversionBasedUnitWithOffset { dimensions : EntityRef < IfcDimensionalExponents > , unit_type : IfcUnitEnum , name : IfcLabel , conversion_factor : EntityRef < IfcMeasureWithUnit > , conversion_offset : IfcReal , } impl IIfcNamedUnit for IfcConversionBasedUnitWithOffset { fn dimensions (& self) -> & EntityRef < IfcDimensionalExponents > { & self . dimensions } fn unit_type (& self) -> & IfcUnitEnum { & self . unit_type } } impl IIfcConversionBasedUnit for IfcConversionBasedUnitWithOffset { fn name (& self) -> & IfcLabel { & self . name } fn conversion_factor (& self) -> & EntityRef < IfcMeasureWithUnit > { & self . conversion_factor } } impl IIfcConversionBasedUnitWithOffset for IfcConversionBasedUnitWithOffset { fn conversion_offset (& self) -> & IfcReal { & self . conversion_offset } } impl IfcConversionBasedUnitWithOffset { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcConversionBasedUnitWithOffset :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . dimensions = parameter . into () , 1usize => entity . unit_type = parameter . into () , 2usize => entity . name = parameter . into () , 3usize => entity . conversion_factor = parameter . into () , 4usize => entity . conversion_offset = parameter . into () , _ => { } } } entity } } pub trait IIfcCooledBeam : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcCooledBeamTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCooledBeam { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCooledBeamTypeEnum > , } impl IIfcRoot for IfcCooledBeam { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCooledBeam { } impl IIfcObject for IfcCooledBeam { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCooledBeam { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCooledBeam { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCooledBeam { } impl IIfcDistributionFlowElement for IfcCooledBeam { } impl IIfcEnergyConversionDevice for IfcCooledBeam { } impl IIfcCooledBeam for IfcCooledBeam { fn predefined_type (& self) -> & Option < IfcCooledBeamTypeEnum > { & self . predefined_type } } impl IfcCooledBeam { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCooledBeam :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCooledBeamType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcCooledBeamTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCooledBeamType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCooledBeamTypeEnum , } impl IIfcRoot for IfcCooledBeamType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCooledBeamType { } impl IIfcTypeObject for IfcCooledBeamType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCooledBeamType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCooledBeamType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCooledBeamType { } impl IIfcDistributionFlowElementType for IfcCooledBeamType { } impl IIfcEnergyConversionDeviceType for IfcCooledBeamType { } impl IIfcCooledBeamType for IfcCooledBeamType { fn predefined_type (& self) -> & IfcCooledBeamTypeEnum { & self . predefined_type } } impl IfcCooledBeamType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCooledBeamType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCoolingTower : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcCoolingTowerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCoolingTower { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCoolingTowerTypeEnum > , } impl IIfcRoot for IfcCoolingTower { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCoolingTower { } impl IIfcObject for IfcCoolingTower { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCoolingTower { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCoolingTower { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcCoolingTower { } impl IIfcDistributionFlowElement for IfcCoolingTower { } impl IIfcEnergyConversionDevice for IfcCoolingTower { } impl IIfcCoolingTower for IfcCoolingTower { fn predefined_type (& self) -> & Option < IfcCoolingTowerTypeEnum > { & self . predefined_type } } impl IfcCoolingTower { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCoolingTower :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCoolingTowerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcCoolingTowerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCoolingTowerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCoolingTowerTypeEnum , } impl IIfcRoot for IfcCoolingTowerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCoolingTowerType { } impl IIfcTypeObject for IfcCoolingTowerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCoolingTowerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCoolingTowerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcCoolingTowerType { } impl IIfcDistributionFlowElementType for IfcCoolingTowerType { } impl IIfcEnergyConversionDeviceType for IfcCoolingTowerType { } impl IIfcCoolingTowerType for IfcCoolingTowerType { fn predefined_type (& self) -> & IfcCoolingTowerTypeEnum { & self . predefined_type } } impl IfcCoolingTowerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCoolingTowerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCoordinateOperation : { pub fn source_crs (& self) -> & EntityRef < IfcCoordinateReferenceSystemSelect > ; pub fn target_crs (& self) -> & EntityRef < IfcCoordinateReferenceSystem > ; } pub trait IIfcCoordinateReferenceSystem : { pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn geodetic_datum (& self) -> & Option < IfcIdentifier > ; pub fn vertical_datum (& self) -> & Option < IfcIdentifier > ; } pub trait IIfcCostItem : IIfcControl { pub fn predefined_type (& self) -> & Option < IfcCostItemTypeEnum > ; pub fn cost_values (& self) -> & Option < Vec < EntityRef < IfcCostValue > > > ; pub fn cost_quantities (& self) -> & Option < Vec < EntityRef < IfcPhysicalQuantity > > > ; } # [derive (Default , Debug)] pub struct IfcCostItem { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , predefined_type : Option < IfcCostItemTypeEnum > , cost_values : Option < Vec < EntityRef < IfcCostValue > > > , cost_quantities : Option < Vec < EntityRef < IfcPhysicalQuantity > > > , } impl IIfcRoot for IfcCostItem { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCostItem { } impl IIfcObject for IfcCostItem { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcCostItem { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcCostItem for IfcCostItem { fn predefined_type (& self) -> & Option < IfcCostItemTypeEnum > { & self . predefined_type } fn cost_values (& self) -> & Option < Vec < EntityRef < IfcCostValue > > > { & self . cost_values } fn cost_quantities (& self) -> & Option < Vec < EntityRef < IfcPhysicalQuantity > > > { & self . cost_quantities } } impl IfcCostItem { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCostItem :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . cost_values = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . cost_quantities = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCostSchedule : IIfcControl { pub fn predefined_type (& self) -> & Option < IfcCostScheduleTypeEnum > ; pub fn status (& self) -> & Option < IfcLabel > ; pub fn submitted_on (& self) -> & Option < IfcDateTime > ; pub fn update_date (& self) -> & Option < IfcDateTime > ; } # [derive (Default , Debug)] pub struct IfcCostSchedule { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , predefined_type : Option < IfcCostScheduleTypeEnum > , status : Option < IfcLabel > , submitted_on : Option < IfcDateTime > , update_date : Option < IfcDateTime > , } impl IIfcRoot for IfcCostSchedule { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCostSchedule { } impl IIfcObject for IfcCostSchedule { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcCostSchedule { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcCostSchedule for IfcCostSchedule { fn predefined_type (& self) -> & Option < IfcCostScheduleTypeEnum > { & self . predefined_type } fn status (& self) -> & Option < IfcLabel > { & self . status } fn submitted_on (& self) -> & Option < IfcDateTime > { & self . submitted_on } fn update_date (& self) -> & Option < IfcDateTime > { & self . update_date } } impl IfcCostSchedule { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCostSchedule :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . submitted_on = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . update_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCostValue : IIfcAppliedValue { } # [derive (Default , Debug)] pub struct IfcCostValue { name : Option < IfcLabel > , description : Option < IfcText > , applied_value : Option < IfcAppliedValueSelect > , unit_basis : Option < EntityRef < IfcMeasureWithUnit > > , applicable_date : Option < IfcDate > , fixed_until_date : Option < IfcDate > , category : Option < IfcLabel > , condition : Option < IfcLabel > , arithmetic_operator : Option < IfcArithmeticOperatorEnum > , components : Option < Vec < EntityRef < IfcAppliedValue > > > , } impl IIfcAppliedValue for IfcCostValue { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn applied_value (& self) -> & Option < IfcAppliedValueSelect > { & self . applied_value } fn unit_basis (& self) -> & Option < EntityRef < IfcMeasureWithUnit > > { & self . unit_basis } fn applicable_date (& self) -> & Option < IfcDate > { & self . applicable_date } fn fixed_until_date (& self) -> & Option < IfcDate > { & self . fixed_until_date } fn category (& self) -> & Option < IfcLabel > { & self . category } fn condition (& self) -> & Option < IfcLabel > { & self . condition } fn arithmetic_operator (& self) -> & Option < IfcArithmeticOperatorEnum > { & self . arithmetic_operator } fn components (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . components } } impl IIfcCostValue for IfcCostValue { } impl IfcCostValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCostValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . applied_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . unit_basis = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . fixed_until_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . arithmetic_operator = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . components = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCovering : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcCoveringTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCovering { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCoveringTypeEnum > , } impl IIfcRoot for IfcCovering { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCovering { } impl IIfcObject for IfcCovering { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCovering { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCovering { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcCovering { } impl IIfcCovering for IfcCovering { fn predefined_type (& self) -> & Option < IfcCoveringTypeEnum > { & self . predefined_type } } impl IfcCovering { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCovering :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCoveringType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcCoveringTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCoveringType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCoveringTypeEnum , } impl IIfcRoot for IfcCoveringType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCoveringType { } impl IIfcTypeObject for IfcCoveringType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCoveringType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCoveringType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcCoveringType { } impl IIfcCoveringType for IfcCoveringType { fn predefined_type (& self) -> & IfcCoveringTypeEnum { & self . predefined_type } } impl IfcCoveringType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCoveringType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCrewResource : IIfcConstructionResource { pub fn predefined_type (& self) -> & Option < IfcCrewResourceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCrewResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , usage : Option < EntityRef < IfcResourceTime > > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : Option < IfcCrewResourceTypeEnum > , } impl IIfcRoot for IfcCrewResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCrewResource { } impl IIfcObject for IfcCrewResource { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcResource for IfcCrewResource { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcConstructionResource for IfcCrewResource { fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > { & self . usage } fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcCrewResource for IfcCrewResource { fn predefined_type (& self) -> & Option < IfcCrewResourceTypeEnum > { & self . predefined_type } } impl IfcCrewResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCrewResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCrewResourceType : IIfcConstructionResourceType { pub fn predefined_type (& self) -> & IfcCrewResourceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCrewResourceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , resource_type : Option < IfcLabel > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : IfcCrewResourceTypeEnum , } impl IIfcRoot for IfcCrewResourceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCrewResourceType { } impl IIfcTypeObject for IfcCrewResourceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeResource for IfcCrewResourceType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn resource_type (& self) -> & Option < IfcLabel > { & self . resource_type } } impl IIfcConstructionResourceType for IfcCrewResourceType { fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcCrewResourceType for IfcCrewResourceType { fn predefined_type (& self) -> & IfcCrewResourceTypeEnum { & self . predefined_type } } impl IfcCrewResourceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCrewResourceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . resource_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCsgPrimitive3D : IIfcGeometricRepresentationItem { pub fn position (& self) -> & EntityRef < IfcAxis2Placement3D > ; } pub trait IIfcCsgSolid : IIfcSolidModel { pub fn tree_root_expression (& self) -> & EntityRef < IfcCsgSelect > ; } # [derive (Default , Debug)] pub struct IfcCsgSolid { tree_root_expression : EntityRef < IfcCsgSelect > , } impl IIfcRepresentationItem for IfcCsgSolid { } impl IIfcGeometricRepresentationItem for IfcCsgSolid { } impl IIfcSolidModel for IfcCsgSolid { } impl IIfcCsgSolid for IfcCsgSolid { fn tree_root_expression (& self) -> & EntityRef < IfcCsgSelect > { & self . tree_root_expression } } impl IfcCsgSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCsgSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . tree_root_expression = parameter . into () , _ => { } } } entity } } pub trait IIfcCurrencyRelationship : IIfcResourceLevelRelationship { pub fn relating_monetary_unit (& self) -> & EntityRef < IfcMonetaryUnit > ; pub fn related_monetary_unit (& self) -> & EntityRef < IfcMonetaryUnit > ; pub fn exchange_rate (& self) -> & IfcPositiveRatioMeasure ; pub fn rate_date_time (& self) -> & Option < IfcDateTime > ; pub fn rate_source (& self) -> & Option < EntityRef < IfcLibraryInformation > > ; } # [derive (Default , Debug)] pub struct IfcCurrencyRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_monetary_unit : EntityRef < IfcMonetaryUnit > , related_monetary_unit : EntityRef < IfcMonetaryUnit > , exchange_rate : IfcPositiveRatioMeasure , rate_date_time : Option < IfcDateTime > , rate_source : Option < EntityRef < IfcLibraryInformation > > , } impl IIfcResourceLevelRelationship for IfcCurrencyRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcCurrencyRelationship for IfcCurrencyRelationship { fn relating_monetary_unit (& self) -> & EntityRef < IfcMonetaryUnit > { & self . relating_monetary_unit } fn related_monetary_unit (& self) -> & EntityRef < IfcMonetaryUnit > { & self . related_monetary_unit } fn exchange_rate (& self) -> & IfcPositiveRatioMeasure { & self . exchange_rate } fn rate_date_time (& self) -> & Option < IfcDateTime > { & self . rate_date_time } fn rate_source (& self) -> & Option < EntityRef < IfcLibraryInformation > > { & self . rate_source } } impl IfcCurrencyRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurrencyRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_monetary_unit = parameter . into () , 3usize => entity . related_monetary_unit = parameter . into () , 4usize => entity . exchange_rate = parameter . into () , 5usize => entity . rate_date_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . rate_source = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCurtainWall : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcCurtainWallTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcCurtainWall { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcCurtainWallTypeEnum > , } impl IIfcRoot for IfcCurtainWall { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCurtainWall { } impl IIfcObject for IfcCurtainWall { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcCurtainWall { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcCurtainWall { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcCurtainWall { } impl IIfcCurtainWall for IfcCurtainWall { fn predefined_type (& self) -> & Option < IfcCurtainWallTypeEnum > { & self . predefined_type } } impl IfcCurtainWall { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurtainWall :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCurtainWallType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcCurtainWallTypeEnum ; } # [derive (Default , Debug)] pub struct IfcCurtainWallType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcCurtainWallTypeEnum , } impl IIfcRoot for IfcCurtainWallType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcCurtainWallType { } impl IIfcTypeObject for IfcCurtainWallType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcCurtainWallType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcCurtainWallType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcCurtainWallType { } impl IIfcCurtainWallType for IfcCurtainWallType { fn predefined_type (& self) -> & IfcCurtainWallTypeEnum { & self . predefined_type } } impl IfcCurtainWallType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurtainWallType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcCurve : IIfcGeometricRepresentationItem { } pub trait IIfcCurveBoundedPlane : IIfcBoundedSurface { pub fn basis_surface (& self) -> & EntityRef < IfcPlane > ; pub fn outer_boundary (& self) -> & EntityRef < IfcCurve > ; pub fn inner_boundaries (& self) -> & HashSet < EntityRef < IfcCurve > > ; } # [derive (Default , Debug)] pub struct IfcCurveBoundedPlane { basis_surface : EntityRef < IfcPlane > , outer_boundary : EntityRef < IfcCurve > , inner_boundaries : HashSet < EntityRef < IfcCurve > > , } impl IIfcRepresentationItem for IfcCurveBoundedPlane { } impl IIfcGeometricRepresentationItem for IfcCurveBoundedPlane { } impl IIfcSurface for IfcCurveBoundedPlane { } impl IIfcBoundedSurface for IfcCurveBoundedPlane { } impl IIfcCurveBoundedPlane for IfcCurveBoundedPlane { fn basis_surface (& self) -> & EntityRef < IfcPlane > { & self . basis_surface } fn outer_boundary (& self) -> & EntityRef < IfcCurve > { & self . outer_boundary } fn inner_boundaries (& self) -> & HashSet < EntityRef < IfcCurve > > { & self . inner_boundaries } } impl IfcCurveBoundedPlane { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurveBoundedPlane :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_surface = parameter . into () , 1usize => entity . outer_boundary = parameter . into () , 2usize => entity . inner_boundaries = parameter . into () , _ => { } } } entity } } pub trait IIfcCurveBoundedSurface : IIfcBoundedSurface { pub fn basis_surface (& self) -> & EntityRef < IfcSurface > ; pub fn boundaries (& self) -> & HashSet < EntityRef < IfcBoundaryCurve > > ; pub fn implicit_outer (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcCurveBoundedSurface { basis_surface : EntityRef < IfcSurface > , boundaries : HashSet < EntityRef < IfcBoundaryCurve > > , implicit_outer : IfcBoolean , } impl IIfcRepresentationItem for IfcCurveBoundedSurface { } impl IIfcGeometricRepresentationItem for IfcCurveBoundedSurface { } impl IIfcSurface for IfcCurveBoundedSurface { } impl IIfcBoundedSurface for IfcCurveBoundedSurface { } impl IIfcCurveBoundedSurface for IfcCurveBoundedSurface { fn basis_surface (& self) -> & EntityRef < IfcSurface > { & self . basis_surface } fn boundaries (& self) -> & HashSet < EntityRef < IfcBoundaryCurve > > { & self . boundaries } fn implicit_outer (& self) -> & IfcBoolean { & self . implicit_outer } } impl IfcCurveBoundedSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurveBoundedSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_surface = parameter . into () , 1usize => entity . boundaries = parameter . into () , 2usize => entity . implicit_outer = parameter . into () , _ => { } } } entity } } pub trait IIfcCurveStyle : IIfcPresentationStyle { pub fn curve_font (& self) -> & Option < EntityRef < IfcCurveFontOrScaledCurveFontSelect > > ; pub fn curve_width (& self) -> & Option < IfcSizeSelect > ; pub fn curve_colour (& self) -> & Option < EntityRef < IfcColour > > ; pub fn model_or_draughting (& self) -> & Option < IfcBoolean > ; } # [derive (Default , Debug)] pub struct IfcCurveStyle { name : Option < IfcLabel > , curve_font : Option < EntityRef < IfcCurveFontOrScaledCurveFontSelect > > , curve_width : Option < IfcSizeSelect > , curve_colour : Option < EntityRef < IfcColour > > , model_or_draughting : Option < IfcBoolean > , } impl IIfcPresentationStyle for IfcCurveStyle { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcCurveStyle for IfcCurveStyle { fn curve_font (& self) -> & Option < EntityRef < IfcCurveFontOrScaledCurveFontSelect > > { & self . curve_font } fn curve_width (& self) -> & Option < IfcSizeSelect > { & self . curve_width } fn curve_colour (& self) -> & Option < EntityRef < IfcColour > > { & self . curve_colour } fn model_or_draughting (& self) -> & Option < IfcBoolean > { & self . model_or_draughting } } impl IfcCurveStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurveStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . curve_font = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . curve_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . curve_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . model_or_draughting = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcCurveStyleFont : IIfcPresentationItem { pub fn name (& self) -> & Option < IfcLabel > ; pub fn pattern_list (& self) -> & Vec < EntityRef < IfcCurveStyleFontPattern > > ; } # [derive (Default , Debug)] pub struct IfcCurveStyleFont { name : Option < IfcLabel > , pattern_list : Vec < EntityRef < IfcCurveStyleFontPattern > > , } impl IIfcPresentationItem for IfcCurveStyleFont { } impl IIfcCurveStyleFont for IfcCurveStyleFont { fn name (& self) -> & Option < IfcLabel > { & self . name } fn pattern_list (& self) -> & Vec < EntityRef < IfcCurveStyleFontPattern > > { & self . pattern_list } } impl IfcCurveStyleFont { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurveStyleFont :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . pattern_list = parameter . into () , _ => { } } } entity } } pub trait IIfcCurveStyleFontAndScaling : IIfcPresentationItem { pub fn name (& self) -> & Option < IfcLabel > ; pub fn curve_font (& self) -> & EntityRef < IfcCurveStyleFontSelect > ; pub fn curve_font_scaling (& self) -> & IfcPositiveRatioMeasure ; } # [derive (Default , Debug)] pub struct IfcCurveStyleFontAndScaling { name : Option < IfcLabel > , curve_font : EntityRef < IfcCurveStyleFontSelect > , curve_font_scaling : IfcPositiveRatioMeasure , } impl IIfcPresentationItem for IfcCurveStyleFontAndScaling { } impl IIfcCurveStyleFontAndScaling for IfcCurveStyleFontAndScaling { fn name (& self) -> & Option < IfcLabel > { & self . name } fn curve_font (& self) -> & EntityRef < IfcCurveStyleFontSelect > { & self . curve_font } fn curve_font_scaling (& self) -> & IfcPositiveRatioMeasure { & self . curve_font_scaling } } impl IfcCurveStyleFontAndScaling { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurveStyleFontAndScaling :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . curve_font = parameter . into () , 2usize => entity . curve_font_scaling = parameter . into () , _ => { } } } entity } } pub trait IIfcCurveStyleFontPattern : IIfcPresentationItem { pub fn visible_segment_length (& self) -> & IfcLengthMeasure ; pub fn invisible_segment_length (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcCurveStyleFontPattern { visible_segment_length : IfcLengthMeasure , invisible_segment_length : IfcPositiveLengthMeasure , } impl IIfcPresentationItem for IfcCurveStyleFontPattern { } impl IIfcCurveStyleFontPattern for IfcCurveStyleFontPattern { fn visible_segment_length (& self) -> & IfcLengthMeasure { & self . visible_segment_length } fn invisible_segment_length (& self) -> & IfcPositiveLengthMeasure { & self . invisible_segment_length } } impl IfcCurveStyleFontPattern { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCurveStyleFontPattern :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . visible_segment_length = parameter . into () , 1usize => entity . invisible_segment_length = parameter . into () , _ => { } } } entity } } pub trait IIfcCylindricalSurface : IIfcElementarySurface { pub fn radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcCylindricalSurface { position : EntityRef < IfcAxis2Placement3D > , radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcCylindricalSurface { } impl IIfcGeometricRepresentationItem for IfcCylindricalSurface { } impl IIfcSurface for IfcCylindricalSurface { } impl IIfcElementarySurface for IfcCylindricalSurface { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcCylindricalSurface for IfcCylindricalSurface { fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IfcCylindricalSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcCylindricalSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . radius = parameter . into () , _ => { } } } entity } } pub trait IIfcDamper : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcDamperTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcDamper { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcDamperTypeEnum > , } impl IIfcRoot for IfcDamper { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDamper { } impl IIfcObject for IfcDamper { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDamper { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDamper { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDamper { } impl IIfcDistributionFlowElement for IfcDamper { } impl IIfcFlowController for IfcDamper { } impl IIfcDamper for IfcDamper { fn predefined_type (& self) -> & Option < IfcDamperTypeEnum > { & self . predefined_type } } impl IfcDamper { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDamper :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDamperType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcDamperTypeEnum ; } # [derive (Default , Debug)] pub struct IfcDamperType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDamperTypeEnum , } impl IIfcRoot for IfcDamperType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDamperType { } impl IIfcTypeObject for IfcDamperType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDamperType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDamperType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcDamperType { } impl IIfcDistributionFlowElementType for IfcDamperType { } impl IIfcFlowControllerType for IfcDamperType { } impl IIfcDamperType for IfcDamperType { fn predefined_type (& self) -> & IfcDamperTypeEnum { & self . predefined_type } } impl IfcDamperType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDamperType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcDerivedProfileDef : IIfcProfileDef { pub fn parent_profile (& self) -> & EntityRef < IfcProfileDef > ; pub fn operator (& self) -> & EntityRef < IfcCartesianTransformationOperator2D > ; pub fn label (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcDerivedProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , parent_profile : EntityRef < IfcProfileDef > , operator : EntityRef < IfcCartesianTransformationOperator2D > , label : Option < IfcLabel > , } impl IIfcProfileDef for IfcDerivedProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcDerivedProfileDef for IfcDerivedProfileDef { fn parent_profile (& self) -> & EntityRef < IfcProfileDef > { & self . parent_profile } fn operator (& self) -> & EntityRef < IfcCartesianTransformationOperator2D > { & self . operator } fn label (& self) -> & Option < IfcLabel > { & self . label } } impl IfcDerivedProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDerivedProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . parent_profile = parameter . into () , 3usize => entity . operator = parameter . into () , 4usize => entity . label = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDerivedUnit : { pub fn elements (& self) -> & HashSet < EntityRef < IfcDerivedUnitElement > > ; pub fn unit_type (& self) -> & IfcDerivedUnitEnum ; pub fn user_defined_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcDerivedUnit { elements : HashSet < EntityRef < IfcDerivedUnitElement > > , unit_type : IfcDerivedUnitEnum , user_defined_type : Option < IfcLabel > , } impl IIfcDerivedUnit for IfcDerivedUnit { fn elements (& self) -> & HashSet < EntityRef < IfcDerivedUnitElement > > { & self . elements } fn unit_type (& self) -> & IfcDerivedUnitEnum { & self . unit_type } fn user_defined_type (& self) -> & Option < IfcLabel > { & self . user_defined_type } } impl IfcDerivedUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDerivedUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . elements = parameter . into () , 1usize => entity . unit_type = parameter . into () , 2usize => entity . user_defined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDerivedUnitElement : { pub fn unit (& self) -> & EntityRef < IfcNamedUnit > ; pub fn exponent (& self) -> i64 ; } # [derive (Default , Debug)] pub struct IfcDerivedUnitElement { unit : EntityRef < IfcNamedUnit > , exponent : i64 , } impl IIfcDerivedUnitElement for IfcDerivedUnitElement { fn unit (& self) -> & EntityRef < IfcNamedUnit > { & self . unit } fn exponent (& self) -> i64 { self . exponent } } impl IfcDerivedUnitElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDerivedUnitElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . unit = parameter . into () , 1usize => entity . exponent = parameter . into () , _ => { } } } entity } } pub trait IIfcDimensionalExponents : { pub fn length_exponent (& self) -> i64 ; pub fn mass_exponent (& self) -> i64 ; pub fn time_exponent (& self) -> i64 ; pub fn electric_current_exponent (& self) -> i64 ; pub fn thermodynamic_temperature_exponent (& self) -> i64 ; pub fn amount_of_substance_exponent (& self) -> i64 ; pub fn luminous_intensity_exponent (& self) -> i64 ; } # [derive (Default , Debug)] pub struct IfcDimensionalExponents { length_exponent : i64 , mass_exponent : i64 , time_exponent : i64 , electric_current_exponent : i64 , thermodynamic_temperature_exponent : i64 , amount_of_substance_exponent : i64 , luminous_intensity_exponent : i64 , } impl IIfcDimensionalExponents for IfcDimensionalExponents { fn length_exponent (& self) -> i64 { self . length_exponent } fn mass_exponent (& self) -> i64 { self . mass_exponent } fn time_exponent (& self) -> i64 { self . time_exponent } fn electric_current_exponent (& self) -> i64 { self . electric_current_exponent } fn thermodynamic_temperature_exponent (& self) -> i64 { self . thermodynamic_temperature_exponent } fn amount_of_substance_exponent (& self) -> i64 { self . amount_of_substance_exponent } fn luminous_intensity_exponent (& self) -> i64 { self . luminous_intensity_exponent } } impl IfcDimensionalExponents { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDimensionalExponents :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . length_exponent = parameter . into () , 1usize => entity . mass_exponent = parameter . into () , 2usize => entity . time_exponent = parameter . into () , 3usize => entity . electric_current_exponent = parameter . into () , 4usize => entity . thermodynamic_temperature_exponent = parameter . into () , 5usize => entity . amount_of_substance_exponent = parameter . into () , 6usize => entity . luminous_intensity_exponent = parameter . into () , _ => { } } } entity } } pub trait IIfcDirection : IIfcGeometricRepresentationItem { pub fn direction_ratios (& self) -> & Vec < IfcReal > ; } # [derive (Default , Debug)] pub struct IfcDirection { direction_ratios : Vec < IfcReal > , } impl IIfcRepresentationItem for IfcDirection { } impl IIfcGeometricRepresentationItem for IfcDirection { } impl IIfcDirection for IfcDirection { fn direction_ratios (& self) -> & Vec < IfcReal > { & self . direction_ratios } } impl IfcDirection { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDirection :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . direction_ratios = parameter . into () , _ => { } } } entity } } pub trait IIfcDiscreteAccessory : IIfcElementComponent { pub fn predefined_type (& self) -> & Option < IfcDiscreteAccessoryTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcDiscreteAccessory { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcDiscreteAccessoryTypeEnum > , } impl IIfcRoot for IfcDiscreteAccessory { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDiscreteAccessory { } impl IIfcObject for IfcDiscreteAccessory { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDiscreteAccessory { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDiscreteAccessory { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcDiscreteAccessory { } impl IIfcDiscreteAccessory for IfcDiscreteAccessory { fn predefined_type (& self) -> & Option < IfcDiscreteAccessoryTypeEnum > { & self . predefined_type } } impl IfcDiscreteAccessory { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDiscreteAccessory :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDiscreteAccessoryType : IIfcElementComponentType { pub fn predefined_type (& self) -> & IfcDiscreteAccessoryTypeEnum ; } # [derive (Default , Debug)] pub struct IfcDiscreteAccessoryType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDiscreteAccessoryTypeEnum , } impl IIfcRoot for IfcDiscreteAccessoryType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDiscreteAccessoryType { } impl IIfcTypeObject for IfcDiscreteAccessoryType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDiscreteAccessoryType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDiscreteAccessoryType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcDiscreteAccessoryType { } impl IIfcDiscreteAccessoryType for IfcDiscreteAccessoryType { fn predefined_type (& self) -> & IfcDiscreteAccessoryTypeEnum { & self . predefined_type } } impl IfcDiscreteAccessoryType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDiscreteAccessoryType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcDistributionChamberElement : IIfcDistributionFlowElement { pub fn predefined_type (& self) -> & Option < IfcDistributionChamberElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcDistributionChamberElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcDistributionChamberElementTypeEnum > , } impl IIfcRoot for IfcDistributionChamberElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionChamberElement { } impl IIfcObject for IfcDistributionChamberElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDistributionChamberElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDistributionChamberElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDistributionChamberElement { } impl IIfcDistributionFlowElement for IfcDistributionChamberElement { } impl IIfcDistributionChamberElement for IfcDistributionChamberElement { fn predefined_type (& self) -> & Option < IfcDistributionChamberElementTypeEnum > { & self . predefined_type } } impl IfcDistributionChamberElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionChamberElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionChamberElementType : IIfcDistributionFlowElementType { pub fn predefined_type (& self) -> & IfcDistributionChamberElementTypeEnum ; } # [derive (Default , Debug)] pub struct IfcDistributionChamberElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDistributionChamberElementTypeEnum , } impl IIfcRoot for IfcDistributionChamberElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionChamberElementType { } impl IIfcTypeObject for IfcDistributionChamberElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDistributionChamberElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDistributionChamberElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcDistributionChamberElementType { } impl IIfcDistributionFlowElementType for IfcDistributionChamberElementType { } impl IIfcDistributionChamberElementType for IfcDistributionChamberElementType { fn predefined_type (& self) -> & IfcDistributionChamberElementTypeEnum { & self . predefined_type } } impl IfcDistributionChamberElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionChamberElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcDistributionCircuit : IIfcDistributionSystem { } # [derive (Default , Debug)] pub struct IfcDistributionCircuit { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , long_name : Option < IfcLabel > , predefined_type : Option < IfcDistributionSystemEnum > , } impl IIfcRoot for IfcDistributionCircuit { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionCircuit { } impl IIfcObject for IfcDistributionCircuit { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcDistributionCircuit { } impl IIfcSystem for IfcDistributionCircuit { } impl IIfcDistributionSystem for IfcDistributionCircuit { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } fn predefined_type (& self) -> & Option < IfcDistributionSystemEnum > { & self . predefined_type } } impl IIfcDistributionCircuit for IfcDistributionCircuit { } impl IfcDistributionCircuit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionCircuit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionControlElement : IIfcDistributionElement { } # [derive (Default , Debug)] pub struct IfcDistributionControlElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcDistributionControlElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionControlElement { } impl IIfcObject for IfcDistributionControlElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDistributionControlElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDistributionControlElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDistributionControlElement { } impl IIfcDistributionControlElement for IfcDistributionControlElement { } impl IfcDistributionControlElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionControlElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionControlElementType : IIfcDistributionElementType { } pub trait IIfcDistributionElement : IIfcElement { } # [derive (Default , Debug)] pub struct IfcDistributionElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcDistributionElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionElement { } impl IIfcObject for IfcDistributionElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDistributionElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDistributionElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDistributionElement { } impl IfcDistributionElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionElementType : IIfcElementType { } # [derive (Default , Debug)] pub struct IfcDistributionElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , } impl IIfcRoot for IfcDistributionElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionElementType { } impl IIfcTypeObject for IfcDistributionElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDistributionElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDistributionElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcDistributionElementType { } impl IfcDistributionElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionFlowElement : IIfcDistributionElement { } # [derive (Default , Debug)] pub struct IfcDistributionFlowElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcDistributionFlowElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionFlowElement { } impl IIfcObject for IfcDistributionFlowElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDistributionFlowElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDistributionFlowElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDistributionFlowElement { } impl IIfcDistributionFlowElement for IfcDistributionFlowElement { } impl IfcDistributionFlowElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionFlowElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionFlowElementType : IIfcDistributionElementType { } pub trait IIfcDistributionPort : IIfcPort { pub fn flow_direction (& self) -> & Option < IfcFlowDirectionEnum > ; pub fn predefined_type (& self) -> & Option < IfcDistributionPortTypeEnum > ; pub fn system_type (& self) -> & Option < IfcDistributionSystemEnum > ; } # [derive (Default , Debug)] pub struct IfcDistributionPort { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , flow_direction : Option < IfcFlowDirectionEnum > , predefined_type : Option < IfcDistributionPortTypeEnum > , system_type : Option < IfcDistributionSystemEnum > , } impl IIfcRoot for IfcDistributionPort { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionPort { } impl IIfcObject for IfcDistributionPort { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDistributionPort { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcPort for IfcDistributionPort { } impl IIfcDistributionPort for IfcDistributionPort { fn flow_direction (& self) -> & Option < IfcFlowDirectionEnum > { & self . flow_direction } fn predefined_type (& self) -> & Option < IfcDistributionPortTypeEnum > { & self . predefined_type } fn system_type (& self) -> & Option < IfcDistributionSystemEnum > { & self . system_type } } impl IfcDistributionPort { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionPort :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . flow_direction = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . system_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDistributionSystem : IIfcSystem { pub fn long_name (& self) -> & Option < IfcLabel > ; pub fn predefined_type (& self) -> & Option < IfcDistributionSystemEnum > ; } # [derive (Default , Debug)] pub struct IfcDistributionSystem { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , long_name : Option < IfcLabel > , predefined_type : Option < IfcDistributionSystemEnum > , } impl IIfcRoot for IfcDistributionSystem { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDistributionSystem { } impl IIfcObject for IfcDistributionSystem { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcDistributionSystem { } impl IIfcSystem for IfcDistributionSystem { } impl IIfcDistributionSystem for IfcDistributionSystem { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } fn predefined_type (& self) -> & Option < IfcDistributionSystemEnum > { & self . predefined_type } } impl IfcDistributionSystem { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDistributionSystem :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDocumentInformation : IIfcExternalInformation { pub fn identification (& self) -> & IfcIdentifier ; pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn location (& self) -> & Option < IfcUriReference > ; pub fn purpose (& self) -> & Option < IfcText > ; pub fn intended_use (& self) -> & Option < IfcText > ; pub fn scope (& self) -> & Option < IfcText > ; pub fn revision (& self) -> & Option < IfcLabel > ; pub fn document_owner (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn editors (& self) -> & Option < HashSet < EntityRef < IfcActorSelect > > > ; pub fn creation_time (& self) -> & Option < IfcDateTime > ; pub fn last_revision_time (& self) -> & Option < IfcDateTime > ; pub fn electronic_format (& self) -> & Option < IfcIdentifier > ; pub fn valid_from (& self) -> & Option < IfcDate > ; pub fn valid_until (& self) -> & Option < IfcDate > ; pub fn confidentiality (& self) -> & Option < IfcDocumentConfidentialityEnum > ; pub fn status (& self) -> & Option < IfcDocumentStatusEnum > ; } # [derive (Default , Debug)] pub struct IfcDocumentInformation { identification : IfcIdentifier , name : IfcLabel , description : Option < IfcText > , location : Option < IfcUriReference > , purpose : Option < IfcText > , intended_use : Option < IfcText > , scope : Option < IfcText > , revision : Option < IfcLabel > , document_owner : Option < EntityRef < IfcActorSelect > > , editors : Option < HashSet < EntityRef < IfcActorSelect > > > , creation_time : Option < IfcDateTime > , last_revision_time : Option < IfcDateTime > , electronic_format : Option < IfcIdentifier > , valid_from : Option < IfcDate > , valid_until : Option < IfcDate > , confidentiality : Option < IfcDocumentConfidentialityEnum > , status : Option < IfcDocumentStatusEnum > , } impl IIfcExternalInformation for IfcDocumentInformation { } impl IIfcDocumentInformation for IfcDocumentInformation { fn identification (& self) -> & IfcIdentifier { & self . identification } fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn location (& self) -> & Option < IfcUriReference > { & self . location } fn purpose (& self) -> & Option < IfcText > { & self . purpose } fn intended_use (& self) -> & Option < IfcText > { & self . intended_use } fn scope (& self) -> & Option < IfcText > { & self . scope } fn revision (& self) -> & Option < IfcLabel > { & self . revision } fn document_owner (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . document_owner } fn editors (& self) -> & Option < HashSet < EntityRef < IfcActorSelect > > > { & self . editors } fn creation_time (& self) -> & Option < IfcDateTime > { & self . creation_time } fn last_revision_time (& self) -> & Option < IfcDateTime > { & self . last_revision_time } fn electronic_format (& self) -> & Option < IfcIdentifier > { & self . electronic_format } fn valid_from (& self) -> & Option < IfcDate > { & self . valid_from } fn valid_until (& self) -> & Option < IfcDate > { & self . valid_until } fn confidentiality (& self) -> & Option < IfcDocumentConfidentialityEnum > { & self . confidentiality } fn status (& self) -> & Option < IfcDocumentStatusEnum > { & self . status } } impl IfcDocumentInformation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDocumentInformation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . identification = parameter . into () , 1usize => entity . name = parameter . into () , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . intended_use = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . scope = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . revision = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . document_owner = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . editors = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . creation_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . last_revision_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . electronic_format = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . valid_from = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . valid_until = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . confidentiality = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDocumentInformationRelationship : IIfcResourceLevelRelationship { pub fn relating_document (& self) -> & EntityRef < IfcDocumentInformation > ; pub fn related_documents (& self) -> & HashSet < EntityRef < IfcDocumentInformation > > ; pub fn relationship_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcDocumentInformationRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_document : EntityRef < IfcDocumentInformation > , related_documents : HashSet < EntityRef < IfcDocumentInformation > > , relationship_type : Option < IfcLabel > , } impl IIfcResourceLevelRelationship for IfcDocumentInformationRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcDocumentInformationRelationship for IfcDocumentInformationRelationship { fn relating_document (& self) -> & EntityRef < IfcDocumentInformation > { & self . relating_document } fn related_documents (& self) -> & HashSet < EntityRef < IfcDocumentInformation > > { & self . related_documents } fn relationship_type (& self) -> & Option < IfcLabel > { & self . relationship_type } } impl IfcDocumentInformationRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDocumentInformationRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_document = parameter . into () , 3usize => entity . related_documents = parameter . into () , 4usize => entity . relationship_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDocumentReference : IIfcExternalReference { pub fn description (& self) -> & Option < IfcText > ; pub fn referenced_document (& self) -> & Option < EntityRef < IfcDocumentInformation > > ; } # [derive (Default , Debug)] pub struct IfcDocumentReference { location : Option < IfcUriReference > , identification : Option < IfcIdentifier > , name : Option < IfcLabel > , description : Option < IfcText > , referenced_document : Option < EntityRef < IfcDocumentInformation > > , } impl IIfcExternalReference for IfcDocumentReference { fn location (& self) -> & Option < IfcUriReference > { & self . location } fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcDocumentReference for IfcDocumentReference { fn description (& self) -> & Option < IfcText > { & self . description } fn referenced_document (& self) -> & Option < EntityRef < IfcDocumentInformation > > { & self . referenced_document } } impl IfcDocumentReference { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDocumentReference :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . referenced_document = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDoor : IIfcBuildingElement { pub fn overall_height (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn overall_width (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn predefined_type (& self) -> & Option < IfcDoorTypeEnum > ; pub fn operation_type (& self) -> & Option < IfcDoorTypeOperationEnum > ; pub fn user_defined_operation_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcDoor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , overall_height : Option < IfcPositiveLengthMeasure > , overall_width : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcDoorTypeEnum > , operation_type : Option < IfcDoorTypeOperationEnum > , user_defined_operation_type : Option < IfcLabel > , } impl IIfcRoot for IfcDoor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDoor { } impl IIfcObject for IfcDoor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDoor { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDoor { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcDoor { } impl IIfcDoor for IfcDoor { fn overall_height (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_height } fn overall_width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_width } fn predefined_type (& self) -> & Option < IfcDoorTypeEnum > { & self . predefined_type } fn operation_type (& self) -> & Option < IfcDoorTypeOperationEnum > { & self . operation_type } fn user_defined_operation_type (& self) -> & Option < IfcLabel > { & self . user_defined_operation_type } } impl IfcDoor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDoor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . overall_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . overall_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . operation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . user_defined_operation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDoorLiningProperties : IIfcPreDefinedPropertySet { pub fn lining_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn lining_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn threshold_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn threshold_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn transom_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn transom_offset (& self) -> & Option < IfcLengthMeasure > ; pub fn lining_offset (& self) -> & Option < IfcLengthMeasure > ; pub fn threshold_offset (& self) -> & Option < IfcLengthMeasure > ; pub fn casing_thickness (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn casing_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > ; pub fn lining_to_panel_offset_x (& self) -> & Option < IfcLengthMeasure > ; pub fn lining_to_panel_offset_y (& self) -> & Option < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcDoorLiningProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , lining_depth : Option < IfcPositiveLengthMeasure > , lining_thickness : Option < IfcNonNegativeLengthMeasure > , threshold_depth : Option < IfcPositiveLengthMeasure > , threshold_thickness : Option < IfcNonNegativeLengthMeasure > , transom_thickness : Option < IfcNonNegativeLengthMeasure > , transom_offset : Option < IfcLengthMeasure > , lining_offset : Option < IfcLengthMeasure > , threshold_offset : Option < IfcLengthMeasure > , casing_thickness : Option < IfcPositiveLengthMeasure > , casing_depth : Option < IfcPositiveLengthMeasure > , shape_aspect_style : Option < EntityRef < IfcShapeAspect > > , lining_to_panel_offset_x : Option < IfcLengthMeasure > , lining_to_panel_offset_y : Option < IfcLengthMeasure > , } impl IIfcRoot for IfcDoorLiningProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcDoorLiningProperties { } impl IIfcPropertySetDefinition for IfcDoorLiningProperties { } impl IIfcPreDefinedPropertySet for IfcDoorLiningProperties { } impl IIfcDoorLiningProperties for IfcDoorLiningProperties { fn lining_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . lining_depth } fn lining_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . lining_thickness } fn threshold_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . threshold_depth } fn threshold_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . threshold_thickness } fn transom_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . transom_thickness } fn transom_offset (& self) -> & Option < IfcLengthMeasure > { & self . transom_offset } fn lining_offset (& self) -> & Option < IfcLengthMeasure > { & self . lining_offset } fn threshold_offset (& self) -> & Option < IfcLengthMeasure > { & self . threshold_offset } fn casing_thickness (& self) -> & Option < IfcPositiveLengthMeasure > { & self . casing_thickness } fn casing_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . casing_depth } fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > { & self . shape_aspect_style } fn lining_to_panel_offset_x (& self) -> & Option < IfcLengthMeasure > { & self . lining_to_panel_offset_x } fn lining_to_panel_offset_y (& self) -> & Option < IfcLengthMeasure > { & self . lining_to_panel_offset_y } } impl IfcDoorLiningProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDoorLiningProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . lining_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . lining_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . threshold_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . threshold_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . transom_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . transom_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . lining_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . threshold_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . casing_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . casing_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . shape_aspect_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . lining_to_panel_offset_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . lining_to_panel_offset_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDoorPanelProperties : IIfcPreDefinedPropertySet { pub fn panel_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn panel_operation (& self) -> & IfcDoorPanelOperationEnum ; pub fn panel_width (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn panel_position (& self) -> & IfcDoorPanelPositionEnum ; pub fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > ; } # [derive (Default , Debug)] pub struct IfcDoorPanelProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , panel_depth : Option < IfcPositiveLengthMeasure > , panel_operation : IfcDoorPanelOperationEnum , panel_width : Option < IfcNormalisedRatioMeasure > , panel_position : IfcDoorPanelPositionEnum , shape_aspect_style : Option < EntityRef < IfcShapeAspect > > , } impl IIfcRoot for IfcDoorPanelProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcDoorPanelProperties { } impl IIfcPropertySetDefinition for IfcDoorPanelProperties { } impl IIfcPreDefinedPropertySet for IfcDoorPanelProperties { } impl IIfcDoorPanelProperties for IfcDoorPanelProperties { fn panel_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . panel_depth } fn panel_operation (& self) -> & IfcDoorPanelOperationEnum { & self . panel_operation } fn panel_width (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . panel_width } fn panel_position (& self) -> & IfcDoorPanelPositionEnum { & self . panel_position } fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > { & self . shape_aspect_style } } impl IfcDoorPanelProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDoorPanelProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . panel_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . panel_operation = parameter . into () , 6usize => entity . panel_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . panel_position = parameter . into () , 8usize => entity . shape_aspect_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDoorStandardCase : IIfcDoor { } # [derive (Default , Debug)] pub struct IfcDoorStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , overall_height : Option < IfcPositiveLengthMeasure > , overall_width : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcDoorTypeEnum > , operation_type : Option < IfcDoorTypeOperationEnum > , user_defined_operation_type : Option < IfcLabel > , } impl IIfcRoot for IfcDoorStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDoorStandardCase { } impl IIfcObject for IfcDoorStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDoorStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDoorStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcDoorStandardCase { } impl IIfcDoor for IfcDoorStandardCase { fn overall_height (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_height } fn overall_width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_width } fn predefined_type (& self) -> & Option < IfcDoorTypeEnum > { & self . predefined_type } fn operation_type (& self) -> & Option < IfcDoorTypeOperationEnum > { & self . operation_type } fn user_defined_operation_type (& self) -> & Option < IfcLabel > { & self . user_defined_operation_type } } impl IIfcDoorStandardCase for IfcDoorStandardCase { } impl IfcDoorStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDoorStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . overall_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . overall_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . operation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . user_defined_operation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDoorStyle : IIfcTypeProduct { pub fn operation_type (& self) -> & IfcDoorStyleOperationEnum ; pub fn construction_type (& self) -> & IfcDoorStyleConstructionEnum ; pub fn parameter_takes_precedence (& self) -> & IfcBoolean ; pub fn sizeable (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcDoorStyle { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , operation_type : IfcDoorStyleOperationEnum , construction_type : IfcDoorStyleConstructionEnum , parameter_takes_precedence : IfcBoolean , sizeable : IfcBoolean , } impl IIfcRoot for IfcDoorStyle { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDoorStyle { } impl IIfcTypeObject for IfcDoorStyle { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDoorStyle { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcDoorStyle for IfcDoorStyle { fn operation_type (& self) -> & IfcDoorStyleOperationEnum { & self . operation_type } fn construction_type (& self) -> & IfcDoorStyleConstructionEnum { & self . construction_type } fn parameter_takes_precedence (& self) -> & IfcBoolean { & self . parameter_takes_precedence } fn sizeable (& self) -> & IfcBoolean { & self . sizeable } } impl IfcDoorStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDoorStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . operation_type = parameter . into () , 9usize => entity . construction_type = parameter . into () , 10usize => entity . parameter_takes_precedence = parameter . into () , 11usize => entity . sizeable = parameter . into () , _ => { } } } entity } } pub trait IIfcDoorType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcDoorTypeEnum ; pub fn operation_type (& self) -> & IfcDoorTypeOperationEnum ; pub fn parameter_takes_precedence (& self) -> & Option < IfcBoolean > ; pub fn user_defined_operation_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcDoorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDoorTypeEnum , operation_type : IfcDoorTypeOperationEnum , parameter_takes_precedence : Option < IfcBoolean > , user_defined_operation_type : Option < IfcLabel > , } impl IIfcRoot for IfcDoorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDoorType { } impl IIfcTypeObject for IfcDoorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDoorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDoorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcDoorType { } impl IIfcDoorType for IfcDoorType { fn predefined_type (& self) -> & IfcDoorTypeEnum { & self . predefined_type } fn operation_type (& self) -> & IfcDoorTypeOperationEnum { & self . operation_type } fn parameter_takes_precedence (& self) -> & Option < IfcBoolean > { & self . parameter_takes_precedence } fn user_defined_operation_type (& self) -> & Option < IfcLabel > { & self . user_defined_operation_type } } impl IfcDoorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDoorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . operation_type = parameter . into () , 11usize => entity . parameter_takes_precedence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . user_defined_operation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDraughtingPreDefinedColour : IIfcPreDefinedColour { } # [derive (Default , Debug)] pub struct IfcDraughtingPreDefinedColour { name : IfcLabel , } impl IIfcPresentationItem for IfcDraughtingPreDefinedColour { } impl IIfcPreDefinedItem for IfcDraughtingPreDefinedColour { fn name (& self) -> & IfcLabel { & self . name } } impl IIfcPreDefinedColour for IfcDraughtingPreDefinedColour { } impl IIfcDraughtingPreDefinedColour for IfcDraughtingPreDefinedColour { } impl IfcDraughtingPreDefinedColour { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDraughtingPreDefinedColour :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , _ => { } } } entity } } pub trait IIfcDraughtingPreDefinedCurveFont : IIfcPreDefinedCurveFont { } # [derive (Default , Debug)] pub struct IfcDraughtingPreDefinedCurveFont { name : IfcLabel , } impl IIfcPresentationItem for IfcDraughtingPreDefinedCurveFont { } impl IIfcPreDefinedItem for IfcDraughtingPreDefinedCurveFont { fn name (& self) -> & IfcLabel { & self . name } } impl IIfcPreDefinedCurveFont for IfcDraughtingPreDefinedCurveFont { } impl IIfcDraughtingPreDefinedCurveFont for IfcDraughtingPreDefinedCurveFont { } impl IfcDraughtingPreDefinedCurveFont { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDraughtingPreDefinedCurveFont :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , _ => { } } } entity } } pub trait IIfcDuctFitting : IIfcFlowFitting { pub fn predefined_type (& self) -> & Option < IfcDuctFittingTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcDuctFitting { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcDuctFittingTypeEnum > , } impl IIfcRoot for IfcDuctFitting { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDuctFitting { } impl IIfcObject for IfcDuctFitting { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDuctFitting { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDuctFitting { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDuctFitting { } impl IIfcDistributionFlowElement for IfcDuctFitting { } impl IIfcFlowFitting for IfcDuctFitting { } impl IIfcDuctFitting for IfcDuctFitting { fn predefined_type (& self) -> & Option < IfcDuctFittingTypeEnum > { & self . predefined_type } } impl IfcDuctFitting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDuctFitting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDuctFittingType : IIfcFlowFittingType { pub fn predefined_type (& self) -> & IfcDuctFittingTypeEnum ; } # [derive (Default , Debug)] pub struct IfcDuctFittingType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDuctFittingTypeEnum , } impl IIfcRoot for IfcDuctFittingType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDuctFittingType { } impl IIfcTypeObject for IfcDuctFittingType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDuctFittingType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDuctFittingType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcDuctFittingType { } impl IIfcDistributionFlowElementType for IfcDuctFittingType { } impl IIfcFlowFittingType for IfcDuctFittingType { } impl IIfcDuctFittingType for IfcDuctFittingType { fn predefined_type (& self) -> & IfcDuctFittingTypeEnum { & self . predefined_type } } impl IfcDuctFittingType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDuctFittingType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcDuctSegment : IIfcFlowSegment { pub fn predefined_type (& self) -> & Option < IfcDuctSegmentTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcDuctSegment { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcDuctSegmentTypeEnum > , } impl IIfcRoot for IfcDuctSegment { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDuctSegment { } impl IIfcObject for IfcDuctSegment { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDuctSegment { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDuctSegment { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDuctSegment { } impl IIfcDistributionFlowElement for IfcDuctSegment { } impl IIfcFlowSegment for IfcDuctSegment { } impl IIfcDuctSegment for IfcDuctSegment { fn predefined_type (& self) -> & Option < IfcDuctSegmentTypeEnum > { & self . predefined_type } } impl IfcDuctSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDuctSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDuctSegmentType : IIfcFlowSegmentType { pub fn predefined_type (& self) -> & IfcDuctSegmentTypeEnum ; } # [derive (Default , Debug)] pub struct IfcDuctSegmentType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDuctSegmentTypeEnum , } impl IIfcRoot for IfcDuctSegmentType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDuctSegmentType { } impl IIfcTypeObject for IfcDuctSegmentType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDuctSegmentType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDuctSegmentType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcDuctSegmentType { } impl IIfcDistributionFlowElementType for IfcDuctSegmentType { } impl IIfcFlowSegmentType for IfcDuctSegmentType { } impl IIfcDuctSegmentType for IfcDuctSegmentType { fn predefined_type (& self) -> & IfcDuctSegmentTypeEnum { & self . predefined_type } } impl IfcDuctSegmentType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDuctSegmentType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcDuctSilencer : IIfcFlowTreatmentDevice { pub fn predefined_type (& self) -> & Option < IfcDuctSilencerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcDuctSilencer { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcDuctSilencerTypeEnum > , } impl IIfcRoot for IfcDuctSilencer { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDuctSilencer { } impl IIfcObject for IfcDuctSilencer { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcDuctSilencer { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcDuctSilencer { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcDuctSilencer { } impl IIfcDistributionFlowElement for IfcDuctSilencer { } impl IIfcFlowTreatmentDevice for IfcDuctSilencer { } impl IIfcDuctSilencer for IfcDuctSilencer { fn predefined_type (& self) -> & Option < IfcDuctSilencerTypeEnum > { & self . predefined_type } } impl IfcDuctSilencer { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDuctSilencer :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcDuctSilencerType : IIfcFlowTreatmentDeviceType { pub fn predefined_type (& self) -> & IfcDuctSilencerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcDuctSilencerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcDuctSilencerTypeEnum , } impl IIfcRoot for IfcDuctSilencerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcDuctSilencerType { } impl IIfcTypeObject for IfcDuctSilencerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcDuctSilencerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcDuctSilencerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcDuctSilencerType { } impl IIfcDistributionFlowElementType for IfcDuctSilencerType { } impl IIfcFlowTreatmentDeviceType for IfcDuctSilencerType { } impl IIfcDuctSilencerType for IfcDuctSilencerType { fn predefined_type (& self) -> & IfcDuctSilencerTypeEnum { & self . predefined_type } } impl IfcDuctSilencerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcDuctSilencerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcEdge : IIfcTopologicalRepresentationItem { pub fn edge_start (& self) -> & EntityRef < IfcVertex > ; pub fn edge_end (& self) -> & EntityRef < IfcVertex > ; } # [derive (Default , Debug)] pub struct IfcEdge { edge_start : EntityRef < IfcVertex > , edge_end : EntityRef < IfcVertex > , } impl IIfcRepresentationItem for IfcEdge { } impl IIfcTopologicalRepresentationItem for IfcEdge { } impl IIfcEdge for IfcEdge { fn edge_start (& self) -> & EntityRef < IfcVertex > { & self . edge_start } fn edge_end (& self) -> & EntityRef < IfcVertex > { & self . edge_end } } impl IfcEdge { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEdge :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . edge_start = parameter . into () , 1usize => entity . edge_end = parameter . into () , _ => { } } } entity } } pub trait IIfcEdgeCurve : IIfcEdge { pub fn edge_geometry (& self) -> & EntityRef < IfcCurve > ; pub fn same_sense (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcEdgeCurve { edge_start : EntityRef < IfcVertex > , edge_end : EntityRef < IfcVertex > , edge_geometry : EntityRef < IfcCurve > , same_sense : IfcBoolean , } impl IIfcRepresentationItem for IfcEdgeCurve { } impl IIfcTopologicalRepresentationItem for IfcEdgeCurve { } impl IIfcEdge for IfcEdgeCurve { fn edge_start (& self) -> & EntityRef < IfcVertex > { & self . edge_start } fn edge_end (& self) -> & EntityRef < IfcVertex > { & self . edge_end } } impl IIfcEdgeCurve for IfcEdgeCurve { fn edge_geometry (& self) -> & EntityRef < IfcCurve > { & self . edge_geometry } fn same_sense (& self) -> & IfcBoolean { & self . same_sense } } impl IfcEdgeCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEdgeCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . edge_start = parameter . into () , 1usize => entity . edge_end = parameter . into () , 2usize => entity . edge_geometry = parameter . into () , 3usize => entity . same_sense = parameter . into () , _ => { } } } entity } } pub trait IIfcEdgeLoop : IIfcLoop { pub fn edge_list (& self) -> & Vec < EntityRef < IfcOrientedEdge > > ; } # [derive (Default , Debug)] pub struct IfcEdgeLoop { edge_list : Vec < EntityRef < IfcOrientedEdge > > , } impl IIfcRepresentationItem for IfcEdgeLoop { } impl IIfcTopologicalRepresentationItem for IfcEdgeLoop { } impl IIfcLoop for IfcEdgeLoop { } impl IIfcEdgeLoop for IfcEdgeLoop { fn edge_list (& self) -> & Vec < EntityRef < IfcOrientedEdge > > { & self . edge_list } } impl IfcEdgeLoop { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEdgeLoop :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . edge_list = parameter . into () , _ => { } } } entity } } pub trait IIfcElectricAppliance : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcElectricApplianceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElectricAppliance { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcElectricApplianceTypeEnum > , } impl IIfcRoot for IfcElectricAppliance { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricAppliance { } impl IIfcObject for IfcElectricAppliance { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElectricAppliance { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElectricAppliance { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcElectricAppliance { } impl IIfcDistributionFlowElement for IfcElectricAppliance { } impl IIfcFlowTerminal for IfcElectricAppliance { } impl IIfcElectricAppliance for IfcElectricAppliance { fn predefined_type (& self) -> & Option < IfcElectricApplianceTypeEnum > { & self . predefined_type } } impl IfcElectricAppliance { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricAppliance :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElectricApplianceType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcElectricApplianceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElectricApplianceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElectricApplianceTypeEnum , } impl IIfcRoot for IfcElectricApplianceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricApplianceType { } impl IIfcTypeObject for IfcElectricApplianceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElectricApplianceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElectricApplianceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcElectricApplianceType { } impl IIfcDistributionFlowElementType for IfcElectricApplianceType { } impl IIfcFlowTerminalType for IfcElectricApplianceType { } impl IIfcElectricApplianceType for IfcElectricApplianceType { fn predefined_type (& self) -> & IfcElectricApplianceTypeEnum { & self . predefined_type } } impl IfcElectricApplianceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricApplianceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElectricDistributionBoard : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcElectricDistributionBoardTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElectricDistributionBoard { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcElectricDistributionBoardTypeEnum > , } impl IIfcRoot for IfcElectricDistributionBoard { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricDistributionBoard { } impl IIfcObject for IfcElectricDistributionBoard { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElectricDistributionBoard { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElectricDistributionBoard { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcElectricDistributionBoard { } impl IIfcDistributionFlowElement for IfcElectricDistributionBoard { } impl IIfcFlowController for IfcElectricDistributionBoard { } impl IIfcElectricDistributionBoard for IfcElectricDistributionBoard { fn predefined_type (& self) -> & Option < IfcElectricDistributionBoardTypeEnum > { & self . predefined_type } } impl IfcElectricDistributionBoard { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricDistributionBoard :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElectricDistributionBoardType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcElectricDistributionBoardTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElectricDistributionBoardType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElectricDistributionBoardTypeEnum , } impl IIfcRoot for IfcElectricDistributionBoardType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricDistributionBoardType { } impl IIfcTypeObject for IfcElectricDistributionBoardType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElectricDistributionBoardType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElectricDistributionBoardType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcElectricDistributionBoardType { } impl IIfcDistributionFlowElementType for IfcElectricDistributionBoardType { } impl IIfcFlowControllerType for IfcElectricDistributionBoardType { } impl IIfcElectricDistributionBoardType for IfcElectricDistributionBoardType { fn predefined_type (& self) -> & IfcElectricDistributionBoardTypeEnum { & self . predefined_type } } impl IfcElectricDistributionBoardType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricDistributionBoardType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElectricFlowStorageDevice : IIfcFlowStorageDevice { pub fn predefined_type (& self) -> & Option < IfcElectricFlowStorageDeviceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElectricFlowStorageDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcElectricFlowStorageDeviceTypeEnum > , } impl IIfcRoot for IfcElectricFlowStorageDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricFlowStorageDevice { } impl IIfcObject for IfcElectricFlowStorageDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElectricFlowStorageDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElectricFlowStorageDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcElectricFlowStorageDevice { } impl IIfcDistributionFlowElement for IfcElectricFlowStorageDevice { } impl IIfcFlowStorageDevice for IfcElectricFlowStorageDevice { } impl IIfcElectricFlowStorageDevice for IfcElectricFlowStorageDevice { fn predefined_type (& self) -> & Option < IfcElectricFlowStorageDeviceTypeEnum > { & self . predefined_type } } impl IfcElectricFlowStorageDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricFlowStorageDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElectricFlowStorageDeviceType : IIfcFlowStorageDeviceType { pub fn predefined_type (& self) -> & IfcElectricFlowStorageDeviceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElectricFlowStorageDeviceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElectricFlowStorageDeviceTypeEnum , } impl IIfcRoot for IfcElectricFlowStorageDeviceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricFlowStorageDeviceType { } impl IIfcTypeObject for IfcElectricFlowStorageDeviceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElectricFlowStorageDeviceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElectricFlowStorageDeviceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcElectricFlowStorageDeviceType { } impl IIfcDistributionFlowElementType for IfcElectricFlowStorageDeviceType { } impl IIfcFlowStorageDeviceType for IfcElectricFlowStorageDeviceType { } impl IIfcElectricFlowStorageDeviceType for IfcElectricFlowStorageDeviceType { fn predefined_type (& self) -> & IfcElectricFlowStorageDeviceTypeEnum { & self . predefined_type } } impl IfcElectricFlowStorageDeviceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricFlowStorageDeviceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElectricGenerator : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcElectricGeneratorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElectricGenerator { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcElectricGeneratorTypeEnum > , } impl IIfcRoot for IfcElectricGenerator { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricGenerator { } impl IIfcObject for IfcElectricGenerator { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElectricGenerator { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElectricGenerator { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcElectricGenerator { } impl IIfcDistributionFlowElement for IfcElectricGenerator { } impl IIfcEnergyConversionDevice for IfcElectricGenerator { } impl IIfcElectricGenerator for IfcElectricGenerator { fn predefined_type (& self) -> & Option < IfcElectricGeneratorTypeEnum > { & self . predefined_type } } impl IfcElectricGenerator { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricGenerator :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElectricGeneratorType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcElectricGeneratorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElectricGeneratorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElectricGeneratorTypeEnum , } impl IIfcRoot for IfcElectricGeneratorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricGeneratorType { } impl IIfcTypeObject for IfcElectricGeneratorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElectricGeneratorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElectricGeneratorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcElectricGeneratorType { } impl IIfcDistributionFlowElementType for IfcElectricGeneratorType { } impl IIfcEnergyConversionDeviceType for IfcElectricGeneratorType { } impl IIfcElectricGeneratorType for IfcElectricGeneratorType { fn predefined_type (& self) -> & IfcElectricGeneratorTypeEnum { & self . predefined_type } } impl IfcElectricGeneratorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricGeneratorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElectricMotor : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcElectricMotorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElectricMotor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcElectricMotorTypeEnum > , } impl IIfcRoot for IfcElectricMotor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricMotor { } impl IIfcObject for IfcElectricMotor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElectricMotor { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElectricMotor { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcElectricMotor { } impl IIfcDistributionFlowElement for IfcElectricMotor { } impl IIfcEnergyConversionDevice for IfcElectricMotor { } impl IIfcElectricMotor for IfcElectricMotor { fn predefined_type (& self) -> & Option < IfcElectricMotorTypeEnum > { & self . predefined_type } } impl IfcElectricMotor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricMotor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElectricMotorType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcElectricMotorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElectricMotorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElectricMotorTypeEnum , } impl IIfcRoot for IfcElectricMotorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricMotorType { } impl IIfcTypeObject for IfcElectricMotorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElectricMotorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElectricMotorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcElectricMotorType { } impl IIfcDistributionFlowElementType for IfcElectricMotorType { } impl IIfcEnergyConversionDeviceType for IfcElectricMotorType { } impl IIfcElectricMotorType for IfcElectricMotorType { fn predefined_type (& self) -> & IfcElectricMotorTypeEnum { & self . predefined_type } } impl IfcElectricMotorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricMotorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElectricTimeControl : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcElectricTimeControlTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElectricTimeControl { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcElectricTimeControlTypeEnum > , } impl IIfcRoot for IfcElectricTimeControl { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricTimeControl { } impl IIfcObject for IfcElectricTimeControl { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElectricTimeControl { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElectricTimeControl { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcElectricTimeControl { } impl IIfcDistributionFlowElement for IfcElectricTimeControl { } impl IIfcFlowController for IfcElectricTimeControl { } impl IIfcElectricTimeControl for IfcElectricTimeControl { fn predefined_type (& self) -> & Option < IfcElectricTimeControlTypeEnum > { & self . predefined_type } } impl IfcElectricTimeControl { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricTimeControl :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElectricTimeControlType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcElectricTimeControlTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElectricTimeControlType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElectricTimeControlTypeEnum , } impl IIfcRoot for IfcElectricTimeControlType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElectricTimeControlType { } impl IIfcTypeObject for IfcElectricTimeControlType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElectricTimeControlType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElectricTimeControlType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcElectricTimeControlType { } impl IIfcDistributionFlowElementType for IfcElectricTimeControlType { } impl IIfcFlowControllerType for IfcElectricTimeControlType { } impl IIfcElectricTimeControlType for IfcElectricTimeControlType { fn predefined_type (& self) -> & IfcElectricTimeControlTypeEnum { & self . predefined_type } } impl IfcElectricTimeControlType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElectricTimeControlType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElement : IIfcProduct { pub fn tag (& self) -> & Option < IfcIdentifier > ; } pub trait IIfcElementAssembly : IIfcElement { pub fn assembly_place (& self) -> & Option < IfcAssemblyPlaceEnum > ; pub fn predefined_type (& self) -> & Option < IfcElementAssemblyTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcElementAssembly { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , assembly_place : Option < IfcAssemblyPlaceEnum > , predefined_type : Option < IfcElementAssemblyTypeEnum > , } impl IIfcRoot for IfcElementAssembly { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElementAssembly { } impl IIfcObject for IfcElementAssembly { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcElementAssembly { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcElementAssembly { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementAssembly for IfcElementAssembly { fn assembly_place (& self) -> & Option < IfcAssemblyPlaceEnum > { & self . assembly_place } fn predefined_type (& self) -> & Option < IfcElementAssemblyTypeEnum > { & self . predefined_type } } impl IfcElementAssembly { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElementAssembly :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . assembly_place = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcElementAssemblyType : IIfcElementType { pub fn predefined_type (& self) -> & IfcElementAssemblyTypeEnum ; } # [derive (Default , Debug)] pub struct IfcElementAssemblyType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcElementAssemblyTypeEnum , } impl IIfcRoot for IfcElementAssemblyType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcElementAssemblyType { } impl IIfcTypeObject for IfcElementAssemblyType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcElementAssemblyType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcElementAssemblyType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementAssemblyType for IfcElementAssemblyType { fn predefined_type (& self) -> & IfcElementAssemblyTypeEnum { & self . predefined_type } } impl IfcElementAssemblyType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElementAssemblyType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcElementComponent : IIfcElement { } pub trait IIfcElementComponentType : IIfcElementType { } pub trait IIfcElementQuantity : IIfcQuantitySet { pub fn method_of_measurement (& self) -> & Option < IfcLabel > ; pub fn quantities (& self) -> & HashSet < EntityRef < IfcPhysicalQuantity > > ; } # [derive (Default , Debug)] pub struct IfcElementQuantity { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , method_of_measurement : Option < IfcLabel > , quantities : HashSet < EntityRef < IfcPhysicalQuantity > > , } impl IIfcRoot for IfcElementQuantity { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcElementQuantity { } impl IIfcPropertySetDefinition for IfcElementQuantity { } impl IIfcQuantitySet for IfcElementQuantity { } impl IIfcElementQuantity for IfcElementQuantity { fn method_of_measurement (& self) -> & Option < IfcLabel > { & self . method_of_measurement } fn quantities (& self) -> & HashSet < EntityRef < IfcPhysicalQuantity > > { & self . quantities } } impl IfcElementQuantity { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcElementQuantity :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . method_of_measurement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . quantities = parameter . into () , _ => { } } } entity } } pub trait IIfcElementType : IIfcTypeProduct { pub fn element_type (& self) -> & Option < IfcLabel > ; } pub trait IIfcElementarySurface : IIfcSurface { pub fn position (& self) -> & EntityRef < IfcAxis2Placement3D > ; } pub trait IIfcEllipse : IIfcConic { pub fn semi_axis1 (& self) -> & IfcPositiveLengthMeasure ; pub fn semi_axis2 (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcEllipse { position : EntityRef < IfcAxis2Placement > , semi_axis1 : IfcPositiveLengthMeasure , semi_axis2 : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcEllipse { } impl IIfcGeometricRepresentationItem for IfcEllipse { } impl IIfcCurve for IfcEllipse { } impl IIfcConic for IfcEllipse { fn position (& self) -> & EntityRef < IfcAxis2Placement > { & self . position } } impl IIfcEllipse for IfcEllipse { fn semi_axis1 (& self) -> & IfcPositiveLengthMeasure { & self . semi_axis1 } fn semi_axis2 (& self) -> & IfcPositiveLengthMeasure { & self . semi_axis2 } } impl IfcEllipse { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEllipse :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . semi_axis1 = parameter . into () , 2usize => entity . semi_axis2 = parameter . into () , _ => { } } } entity } } pub trait IIfcEllipseProfileDef : IIfcParameterizedProfileDef { pub fn semi_axis1 (& self) -> & IfcPositiveLengthMeasure ; pub fn semi_axis2 (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcEllipseProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , semi_axis1 : IfcPositiveLengthMeasure , semi_axis2 : IfcPositiveLengthMeasure , } impl IIfcProfileDef for IfcEllipseProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcEllipseProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcEllipseProfileDef for IfcEllipseProfileDef { fn semi_axis1 (& self) -> & IfcPositiveLengthMeasure { & self . semi_axis1 } fn semi_axis2 (& self) -> & IfcPositiveLengthMeasure { & self . semi_axis2 } } impl IfcEllipseProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEllipseProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . semi_axis1 = parameter . into () , 4usize => entity . semi_axis2 = parameter . into () , _ => { } } } entity } } pub trait IIfcEnergyConversionDevice : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcEnergyConversionDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcEnergyConversionDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEnergyConversionDevice { } impl IIfcObject for IfcEnergyConversionDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcEnergyConversionDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcEnergyConversionDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcEnergyConversionDevice { } impl IIfcDistributionFlowElement for IfcEnergyConversionDevice { } impl IIfcEnergyConversionDevice for IfcEnergyConversionDevice { } impl IfcEnergyConversionDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEnergyConversionDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcEnergyConversionDeviceType : IIfcDistributionFlowElementType { } pub trait IIfcEngine : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcEngineTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcEngine { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcEngineTypeEnum > , } impl IIfcRoot for IfcEngine { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEngine { } impl IIfcObject for IfcEngine { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcEngine { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcEngine { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcEngine { } impl IIfcDistributionFlowElement for IfcEngine { } impl IIfcEnergyConversionDevice for IfcEngine { } impl IIfcEngine for IfcEngine { fn predefined_type (& self) -> & Option < IfcEngineTypeEnum > { & self . predefined_type } } impl IfcEngine { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEngine :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcEngineType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcEngineTypeEnum ; } # [derive (Default , Debug)] pub struct IfcEngineType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcEngineTypeEnum , } impl IIfcRoot for IfcEngineType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEngineType { } impl IIfcTypeObject for IfcEngineType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcEngineType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcEngineType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcEngineType { } impl IIfcDistributionFlowElementType for IfcEngineType { } impl IIfcEnergyConversionDeviceType for IfcEngineType { } impl IIfcEngineType for IfcEngineType { fn predefined_type (& self) -> & IfcEngineTypeEnum { & self . predefined_type } } impl IfcEngineType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEngineType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcEvaporativeCooler : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcEvaporativeCoolerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcEvaporativeCooler { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcEvaporativeCoolerTypeEnum > , } impl IIfcRoot for IfcEvaporativeCooler { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEvaporativeCooler { } impl IIfcObject for IfcEvaporativeCooler { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcEvaporativeCooler { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcEvaporativeCooler { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcEvaporativeCooler { } impl IIfcDistributionFlowElement for IfcEvaporativeCooler { } impl IIfcEnergyConversionDevice for IfcEvaporativeCooler { } impl IIfcEvaporativeCooler for IfcEvaporativeCooler { fn predefined_type (& self) -> & Option < IfcEvaporativeCoolerTypeEnum > { & self . predefined_type } } impl IfcEvaporativeCooler { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEvaporativeCooler :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcEvaporativeCoolerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcEvaporativeCoolerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcEvaporativeCoolerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcEvaporativeCoolerTypeEnum , } impl IIfcRoot for IfcEvaporativeCoolerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEvaporativeCoolerType { } impl IIfcTypeObject for IfcEvaporativeCoolerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcEvaporativeCoolerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcEvaporativeCoolerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcEvaporativeCoolerType { } impl IIfcDistributionFlowElementType for IfcEvaporativeCoolerType { } impl IIfcEnergyConversionDeviceType for IfcEvaporativeCoolerType { } impl IIfcEvaporativeCoolerType for IfcEvaporativeCoolerType { fn predefined_type (& self) -> & IfcEvaporativeCoolerTypeEnum { & self . predefined_type } } impl IfcEvaporativeCoolerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEvaporativeCoolerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcEvaporator : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcEvaporatorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcEvaporator { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcEvaporatorTypeEnum > , } impl IIfcRoot for IfcEvaporator { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEvaporator { } impl IIfcObject for IfcEvaporator { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcEvaporator { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcEvaporator { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcEvaporator { } impl IIfcDistributionFlowElement for IfcEvaporator { } impl IIfcEnergyConversionDevice for IfcEvaporator { } impl IIfcEvaporator for IfcEvaporator { fn predefined_type (& self) -> & Option < IfcEvaporatorTypeEnum > { & self . predefined_type } } impl IfcEvaporator { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEvaporator :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcEvaporatorType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcEvaporatorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcEvaporatorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcEvaporatorTypeEnum , } impl IIfcRoot for IfcEvaporatorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEvaporatorType { } impl IIfcTypeObject for IfcEvaporatorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcEvaporatorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcEvaporatorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcEvaporatorType { } impl IIfcDistributionFlowElementType for IfcEvaporatorType { } impl IIfcEnergyConversionDeviceType for IfcEvaporatorType { } impl IIfcEvaporatorType for IfcEvaporatorType { fn predefined_type (& self) -> & IfcEvaporatorTypeEnum { & self . predefined_type } } impl IfcEvaporatorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEvaporatorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcEvent : IIfcProcess { pub fn predefined_type (& self) -> & Option < IfcEventTypeEnum > ; pub fn event_trigger_type (& self) -> & Option < IfcEventTriggerTypeEnum > ; pub fn user_defined_event_trigger_type (& self) -> & Option < IfcLabel > ; pub fn event_occurence_time (& self) -> & Option < EntityRef < IfcEventTime > > ; } # [derive (Default , Debug)] pub struct IfcEvent { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , predefined_type : Option < IfcEventTypeEnum > , event_trigger_type : Option < IfcEventTriggerTypeEnum > , user_defined_event_trigger_type : Option < IfcLabel > , event_occurence_time : Option < EntityRef < IfcEventTime > > , } impl IIfcRoot for IfcEvent { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEvent { } impl IIfcObject for IfcEvent { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProcess for IfcEvent { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcEvent for IfcEvent { fn predefined_type (& self) -> & Option < IfcEventTypeEnum > { & self . predefined_type } fn event_trigger_type (& self) -> & Option < IfcEventTriggerTypeEnum > { & self . event_trigger_type } fn user_defined_event_trigger_type (& self) -> & Option < IfcLabel > { & self . user_defined_event_trigger_type } fn event_occurence_time (& self) -> & Option < EntityRef < IfcEventTime > > { & self . event_occurence_time } } impl IfcEvent { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEvent :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . event_trigger_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . user_defined_event_trigger_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . event_occurence_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcEventTime : IIfcSchedulingTime { pub fn actual_date (& self) -> & Option < IfcDateTime > ; pub fn early_date (& self) -> & Option < IfcDateTime > ; pub fn late_date (& self) -> & Option < IfcDateTime > ; pub fn schedule_date (& self) -> & Option < IfcDateTime > ; } # [derive (Default , Debug)] pub struct IfcEventTime { name : Option < IfcLabel > , data_origin : Option < IfcDataOriginEnum > , user_defined_data_origin : Option < IfcLabel > , actual_date : Option < IfcDateTime > , early_date : Option < IfcDateTime > , late_date : Option < IfcDateTime > , schedule_date : Option < IfcDateTime > , } impl IIfcSchedulingTime for IfcEventTime { fn name (& self) -> & Option < IfcLabel > { & self . name } fn data_origin (& self) -> & Option < IfcDataOriginEnum > { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } } impl IIfcEventTime for IfcEventTime { fn actual_date (& self) -> & Option < IfcDateTime > { & self . actual_date } fn early_date (& self) -> & Option < IfcDateTime > { & self . early_date } fn late_date (& self) -> & Option < IfcDateTime > { & self . late_date } fn schedule_date (& self) -> & Option < IfcDateTime > { & self . schedule_date } } impl IfcEventTime { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEventTime :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . actual_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . early_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . late_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . schedule_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcEventType : IIfcTypeProcess { pub fn predefined_type (& self) -> & IfcEventTypeEnum ; pub fn event_trigger_type (& self) -> & IfcEventTriggerTypeEnum ; pub fn user_defined_event_trigger_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcEventType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , process_type : Option < IfcLabel > , predefined_type : IfcEventTypeEnum , event_trigger_type : IfcEventTriggerTypeEnum , user_defined_event_trigger_type : Option < IfcLabel > , } impl IIfcRoot for IfcEventType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcEventType { } impl IIfcTypeObject for IfcEventType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProcess for IfcEventType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn process_type (& self) -> & Option < IfcLabel > { & self . process_type } } impl IIfcEventType for IfcEventType { fn predefined_type (& self) -> & IfcEventTypeEnum { & self . predefined_type } fn event_trigger_type (& self) -> & IfcEventTriggerTypeEnum { & self . event_trigger_type } fn user_defined_event_trigger_type (& self) -> & Option < IfcLabel > { & self . user_defined_event_trigger_type } } impl IfcEventType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcEventType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . process_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . event_trigger_type = parameter . into () , 11usize => entity . user_defined_event_trigger_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcExtendedProperties : IIfcPropertyAbstraction { pub fn name (& self) -> & Option < IfcIdentifier > ; pub fn description (& self) -> & Option < IfcText > ; pub fn properties (& self) -> & HashSet < EntityRef < IfcProperty > > ; } pub trait IIfcExternalInformation : { } pub trait IIfcExternalReference : { pub fn location (& self) -> & Option < IfcUriReference > ; pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn name (& self) -> & Option < IfcLabel > ; } pub trait IIfcExternalReferenceRelationship : IIfcResourceLevelRelationship { pub fn relating_reference (& self) -> & EntityRef < IfcExternalReference > ; pub fn related_resource_objects (& self) -> & HashSet < EntityRef < IfcResourceObjectSelect > > ; } # [derive (Default , Debug)] pub struct IfcExternalReferenceRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_reference : EntityRef < IfcExternalReference > , related_resource_objects : HashSet < EntityRef < IfcResourceObjectSelect > > , } impl IIfcResourceLevelRelationship for IfcExternalReferenceRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcExternalReferenceRelationship for IfcExternalReferenceRelationship { fn relating_reference (& self) -> & EntityRef < IfcExternalReference > { & self . relating_reference } fn related_resource_objects (& self) -> & HashSet < EntityRef < IfcResourceObjectSelect > > { & self . related_resource_objects } } impl IfcExternalReferenceRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExternalReferenceRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_reference = parameter . into () , 3usize => entity . related_resource_objects = parameter . into () , _ => { } } } entity } } pub trait IIfcExternalSpatialElement : IIfcExternalSpatialStructureElement { pub fn predefined_type (& self) -> & Option < IfcExternalSpatialElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcExternalSpatialElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , long_name : Option < IfcLabel > , predefined_type : Option < IfcExternalSpatialElementTypeEnum > , } impl IIfcRoot for IfcExternalSpatialElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcExternalSpatialElement { } impl IIfcObject for IfcExternalSpatialElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcExternalSpatialElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcSpatialElement for IfcExternalSpatialElement { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IIfcExternalSpatialStructureElement for IfcExternalSpatialElement { } impl IIfcExternalSpatialElement for IfcExternalSpatialElement { fn predefined_type (& self) -> & Option < IfcExternalSpatialElementTypeEnum > { & self . predefined_type } } impl IfcExternalSpatialElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExternalSpatialElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcExternalSpatialStructureElement : IIfcSpatialElement { } pub trait IIfcExternallyDefinedHatchStyle : IIfcExternalReference { } # [derive (Default , Debug)] pub struct IfcExternallyDefinedHatchStyle { location : Option < IfcUriReference > , identification : Option < IfcIdentifier > , name : Option < IfcLabel > , } impl IIfcExternalReference for IfcExternallyDefinedHatchStyle { fn location (& self) -> & Option < IfcUriReference > { & self . location } fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcExternallyDefinedHatchStyle for IfcExternallyDefinedHatchStyle { } impl IfcExternallyDefinedHatchStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExternallyDefinedHatchStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcExternallyDefinedSurfaceStyle : IIfcExternalReference { } # [derive (Default , Debug)] pub struct IfcExternallyDefinedSurfaceStyle { location : Option < IfcUriReference > , identification : Option < IfcIdentifier > , name : Option < IfcLabel > , } impl IIfcExternalReference for IfcExternallyDefinedSurfaceStyle { fn location (& self) -> & Option < IfcUriReference > { & self . location } fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcExternallyDefinedSurfaceStyle for IfcExternallyDefinedSurfaceStyle { } impl IfcExternallyDefinedSurfaceStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExternallyDefinedSurfaceStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcExternallyDefinedTextFont : IIfcExternalReference { } # [derive (Default , Debug)] pub struct IfcExternallyDefinedTextFont { location : Option < IfcUriReference > , identification : Option < IfcIdentifier > , name : Option < IfcLabel > , } impl IIfcExternalReference for IfcExternallyDefinedTextFont { fn location (& self) -> & Option < IfcUriReference > { & self . location } fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcExternallyDefinedTextFont for IfcExternallyDefinedTextFont { } impl IfcExternallyDefinedTextFont { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExternallyDefinedTextFont :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcExtrudedAreaSolid : IIfcSweptAreaSolid { pub fn extruded_direction (& self) -> & EntityRef < IfcDirection > ; pub fn depth (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcExtrudedAreaSolid { swept_area : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , extruded_direction : EntityRef < IfcDirection > , depth : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcExtrudedAreaSolid { } impl IIfcGeometricRepresentationItem for IfcExtrudedAreaSolid { } impl IIfcSolidModel for IfcExtrudedAreaSolid { } impl IIfcSweptAreaSolid for IfcExtrudedAreaSolid { fn swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . swept_area } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcExtrudedAreaSolid for IfcExtrudedAreaSolid { fn extruded_direction (& self) -> & EntityRef < IfcDirection > { & self . extruded_direction } fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } } impl IfcExtrudedAreaSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExtrudedAreaSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_area = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . extruded_direction = parameter . into () , 3usize => entity . depth = parameter . into () , _ => { } } } entity } } pub trait IIfcExtrudedAreaSolidTapered : IIfcExtrudedAreaSolid { pub fn end_swept_area (& self) -> & EntityRef < IfcProfileDef > ; } # [derive (Default , Debug)] pub struct IfcExtrudedAreaSolidTapered { swept_area : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , extruded_direction : EntityRef < IfcDirection > , depth : IfcPositiveLengthMeasure , end_swept_area : EntityRef < IfcProfileDef > , } impl IIfcRepresentationItem for IfcExtrudedAreaSolidTapered { } impl IIfcGeometricRepresentationItem for IfcExtrudedAreaSolidTapered { } impl IIfcSolidModel for IfcExtrudedAreaSolidTapered { } impl IIfcSweptAreaSolid for IfcExtrudedAreaSolidTapered { fn swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . swept_area } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcExtrudedAreaSolid for IfcExtrudedAreaSolidTapered { fn extruded_direction (& self) -> & EntityRef < IfcDirection > { & self . extruded_direction } fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } } impl IIfcExtrudedAreaSolidTapered for IfcExtrudedAreaSolidTapered { fn end_swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . end_swept_area } } impl IfcExtrudedAreaSolidTapered { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcExtrudedAreaSolidTapered :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_area = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . extruded_direction = parameter . into () , 3usize => entity . depth = parameter . into () , 4usize => entity . end_swept_area = parameter . into () , _ => { } } } entity } } pub trait IIfcFace : IIfcTopologicalRepresentationItem { pub fn bounds (& self) -> & HashSet < EntityRef < IfcFaceBound > > ; } # [derive (Default , Debug)] pub struct IfcFace { bounds : HashSet < EntityRef < IfcFaceBound > > , } impl IIfcRepresentationItem for IfcFace { } impl IIfcTopologicalRepresentationItem for IfcFace { } impl IIfcFace for IfcFace { fn bounds (& self) -> & HashSet < EntityRef < IfcFaceBound > > { & self . bounds } } impl IfcFace { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFace :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . bounds = parameter . into () , _ => { } } } entity } } pub trait IIfcFaceBasedSurfaceModel : IIfcGeometricRepresentationItem { pub fn fbsm_faces (& self) -> & HashSet < EntityRef < IfcConnectedFaceSet > > ; } # [derive (Default , Debug)] pub struct IfcFaceBasedSurfaceModel { fbsm_faces : HashSet < EntityRef < IfcConnectedFaceSet > > , } impl IIfcRepresentationItem for IfcFaceBasedSurfaceModel { } impl IIfcGeometricRepresentationItem for IfcFaceBasedSurfaceModel { } impl IIfcFaceBasedSurfaceModel for IfcFaceBasedSurfaceModel { fn fbsm_faces (& self) -> & HashSet < EntityRef < IfcConnectedFaceSet > > { & self . fbsm_faces } } impl IfcFaceBasedSurfaceModel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFaceBasedSurfaceModel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . fbsm_faces = parameter . into () , _ => { } } } entity } } pub trait IIfcFaceBound : IIfcTopologicalRepresentationItem { pub fn bound (& self) -> & EntityRef < IfcLoop > ; pub fn orientation (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcFaceBound { bound : EntityRef < IfcLoop > , orientation : IfcBoolean , } impl IIfcRepresentationItem for IfcFaceBound { } impl IIfcTopologicalRepresentationItem for IfcFaceBound { } impl IIfcFaceBound for IfcFaceBound { fn bound (& self) -> & EntityRef < IfcLoop > { & self . bound } fn orientation (& self) -> & IfcBoolean { & self . orientation } } impl IfcFaceBound { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFaceBound :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . bound = parameter . into () , 1usize => entity . orientation = parameter . into () , _ => { } } } entity } } pub trait IIfcFaceOuterBound : IIfcFaceBound { } # [derive (Default , Debug)] pub struct IfcFaceOuterBound { bound : EntityRef < IfcLoop > , orientation : IfcBoolean , } impl IIfcRepresentationItem for IfcFaceOuterBound { } impl IIfcTopologicalRepresentationItem for IfcFaceOuterBound { } impl IIfcFaceBound for IfcFaceOuterBound { fn bound (& self) -> & EntityRef < IfcLoop > { & self . bound } fn orientation (& self) -> & IfcBoolean { & self . orientation } } impl IIfcFaceOuterBound for IfcFaceOuterBound { } impl IfcFaceOuterBound { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFaceOuterBound :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . bound = parameter . into () , 1usize => entity . orientation = parameter . into () , _ => { } } } entity } } pub trait IIfcFaceSurface : IIfcFace { pub fn face_surface (& self) -> & EntityRef < IfcSurface > ; pub fn same_sense (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcFaceSurface { bounds : HashSet < EntityRef < IfcFaceBound > > , face_surface : EntityRef < IfcSurface > , same_sense : IfcBoolean , } impl IIfcRepresentationItem for IfcFaceSurface { } impl IIfcTopologicalRepresentationItem for IfcFaceSurface { } impl IIfcFace for IfcFaceSurface { fn bounds (& self) -> & HashSet < EntityRef < IfcFaceBound > > { & self . bounds } } impl IIfcFaceSurface for IfcFaceSurface { fn face_surface (& self) -> & EntityRef < IfcSurface > { & self . face_surface } fn same_sense (& self) -> & IfcBoolean { & self . same_sense } } impl IfcFaceSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFaceSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . bounds = parameter . into () , 1usize => entity . face_surface = parameter . into () , 2usize => entity . same_sense = parameter . into () , _ => { } } } entity } } pub trait IIfcFacetedBrep : IIfcManifoldSolidBrep { } # [derive (Default , Debug)] pub struct IfcFacetedBrep { outer : EntityRef < IfcClosedShell > , } impl IIfcRepresentationItem for IfcFacetedBrep { } impl IIfcGeometricRepresentationItem for IfcFacetedBrep { } impl IIfcSolidModel for IfcFacetedBrep { } impl IIfcManifoldSolidBrep for IfcFacetedBrep { fn outer (& self) -> & EntityRef < IfcClosedShell > { & self . outer } } impl IIfcFacetedBrep for IfcFacetedBrep { } impl IfcFacetedBrep { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFacetedBrep :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . outer = parameter . into () , _ => { } } } entity } } pub trait IIfcFacetedBrepWithVoids : IIfcFacetedBrep { pub fn voids (& self) -> & HashSet < EntityRef < IfcClosedShell > > ; } # [derive (Default , Debug)] pub struct IfcFacetedBrepWithVoids { outer : EntityRef < IfcClosedShell > , voids : HashSet < EntityRef < IfcClosedShell > > , } impl IIfcRepresentationItem for IfcFacetedBrepWithVoids { } impl IIfcGeometricRepresentationItem for IfcFacetedBrepWithVoids { } impl IIfcSolidModel for IfcFacetedBrepWithVoids { } impl IIfcManifoldSolidBrep for IfcFacetedBrepWithVoids { fn outer (& self) -> & EntityRef < IfcClosedShell > { & self . outer } } impl IIfcFacetedBrep for IfcFacetedBrepWithVoids { } impl IIfcFacetedBrepWithVoids for IfcFacetedBrepWithVoids { fn voids (& self) -> & HashSet < EntityRef < IfcClosedShell > > { & self . voids } } impl IfcFacetedBrepWithVoids { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFacetedBrepWithVoids :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . outer = parameter . into () , 1usize => entity . voids = parameter . into () , _ => { } } } entity } } pub trait IIfcFailureConnectionCondition : IIfcStructuralConnectionCondition { pub fn tension_failure_x (& self) -> & Option < IfcForceMeasure > ; pub fn tension_failure_y (& self) -> & Option < IfcForceMeasure > ; pub fn tension_failure_z (& self) -> & Option < IfcForceMeasure > ; pub fn compression_failure_x (& self) -> & Option < IfcForceMeasure > ; pub fn compression_failure_y (& self) -> & Option < IfcForceMeasure > ; pub fn compression_failure_z (& self) -> & Option < IfcForceMeasure > ; } # [derive (Default , Debug)] pub struct IfcFailureConnectionCondition { name : Option < IfcLabel > , tension_failure_x : Option < IfcForceMeasure > , tension_failure_y : Option < IfcForceMeasure > , tension_failure_z : Option < IfcForceMeasure > , compression_failure_x : Option < IfcForceMeasure > , compression_failure_y : Option < IfcForceMeasure > , compression_failure_z : Option < IfcForceMeasure > , } impl IIfcStructuralConnectionCondition for IfcFailureConnectionCondition { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcFailureConnectionCondition for IfcFailureConnectionCondition { fn tension_failure_x (& self) -> & Option < IfcForceMeasure > { & self . tension_failure_x } fn tension_failure_y (& self) -> & Option < IfcForceMeasure > { & self . tension_failure_y } fn tension_failure_z (& self) -> & Option < IfcForceMeasure > { & self . tension_failure_z } fn compression_failure_x (& self) -> & Option < IfcForceMeasure > { & self . compression_failure_x } fn compression_failure_y (& self) -> & Option < IfcForceMeasure > { & self . compression_failure_y } fn compression_failure_z (& self) -> & Option < IfcForceMeasure > { & self . compression_failure_z } } impl IfcFailureConnectionCondition { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFailureConnectionCondition :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . tension_failure_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . tension_failure_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . tension_failure_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . compression_failure_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . compression_failure_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . compression_failure_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFan : IIfcFlowMovingDevice { pub fn predefined_type (& self) -> & Option < IfcFanTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFan { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFanTypeEnum > , } impl IIfcRoot for IfcFan { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFan { } impl IIfcObject for IfcFan { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFan { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFan { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFan { } impl IIfcDistributionFlowElement for IfcFan { } impl IIfcFlowMovingDevice for IfcFan { } impl IIfcFan for IfcFan { fn predefined_type (& self) -> & Option < IfcFanTypeEnum > { & self . predefined_type } } impl IfcFan { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFan :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFanType : IIfcFlowMovingDeviceType { pub fn predefined_type (& self) -> & IfcFanTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFanType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFanTypeEnum , } impl IIfcRoot for IfcFanType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFanType { } impl IIfcTypeObject for IfcFanType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFanType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFanType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcFanType { } impl IIfcDistributionFlowElementType for IfcFanType { } impl IIfcFlowMovingDeviceType for IfcFanType { } impl IIfcFanType for IfcFanType { fn predefined_type (& self) -> & IfcFanTypeEnum { & self . predefined_type } } impl IfcFanType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFanType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFastener : IIfcElementComponent { pub fn predefined_type (& self) -> & Option < IfcFastenerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFastener { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFastenerTypeEnum > , } impl IIfcRoot for IfcFastener { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFastener { } impl IIfcObject for IfcFastener { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFastener { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFastener { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcFastener { } impl IIfcFastener for IfcFastener { fn predefined_type (& self) -> & Option < IfcFastenerTypeEnum > { & self . predefined_type } } impl IfcFastener { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFastener :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFastenerType : IIfcElementComponentType { pub fn predefined_type (& self) -> & IfcFastenerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFastenerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFastenerTypeEnum , } impl IIfcRoot for IfcFastenerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFastenerType { } impl IIfcTypeObject for IfcFastenerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFastenerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFastenerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcFastenerType { } impl IIfcFastenerType for IfcFastenerType { fn predefined_type (& self) -> & IfcFastenerTypeEnum { & self . predefined_type } } impl IfcFastenerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFastenerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFeatureElement : IIfcElement { } pub trait IIfcFeatureElementAddition : IIfcFeatureElement { } pub trait IIfcFeatureElementSubtraction : IIfcFeatureElement { } pub trait IIfcFillAreaStyle : IIfcPresentationStyle { pub fn fill_styles (& self) -> & HashSet < EntityRef < IfcFillStyleSelect > > ; pub fn modelor_draughting (& self) -> & Option < IfcBoolean > ; } # [derive (Default , Debug)] pub struct IfcFillAreaStyle { name : Option < IfcLabel > , fill_styles : HashSet < EntityRef < IfcFillStyleSelect > > , modelor_draughting : Option < IfcBoolean > , } impl IIfcPresentationStyle for IfcFillAreaStyle { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcFillAreaStyle for IfcFillAreaStyle { fn fill_styles (& self) -> & HashSet < EntityRef < IfcFillStyleSelect > > { & self . fill_styles } fn modelor_draughting (& self) -> & Option < IfcBoolean > { & self . modelor_draughting } } impl IfcFillAreaStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFillAreaStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . fill_styles = parameter . into () , 2usize => entity . modelor_draughting = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFillAreaStyleHatching : IIfcGeometricRepresentationItem { pub fn hatch_line_appearance (& self) -> & EntityRef < IfcCurveStyle > ; pub fn start_of_next_hatch_line (& self) -> & IfcHatchLineDistanceSelect ; pub fn point_of_reference_hatch_line (& self) -> & Option < EntityRef < IfcCartesianPoint > > ; pub fn pattern_start (& self) -> & Option < EntityRef < IfcCartesianPoint > > ; pub fn hatch_line_angle (& self) -> & IfcPlaneAngleMeasure ; } # [derive (Default , Debug)] pub struct IfcFillAreaStyleHatching { hatch_line_appearance : EntityRef < IfcCurveStyle > , start_of_next_hatch_line : IfcHatchLineDistanceSelect , point_of_reference_hatch_line : Option < EntityRef < IfcCartesianPoint > > , pattern_start : Option < EntityRef < IfcCartesianPoint > > , hatch_line_angle : IfcPlaneAngleMeasure , } impl IIfcRepresentationItem for IfcFillAreaStyleHatching { } impl IIfcGeometricRepresentationItem for IfcFillAreaStyleHatching { } impl IIfcFillAreaStyleHatching for IfcFillAreaStyleHatching { fn hatch_line_appearance (& self) -> & EntityRef < IfcCurveStyle > { & self . hatch_line_appearance } fn start_of_next_hatch_line (& self) -> & IfcHatchLineDistanceSelect { & self . start_of_next_hatch_line } fn point_of_reference_hatch_line (& self) -> & Option < EntityRef < IfcCartesianPoint > > { & self . point_of_reference_hatch_line } fn pattern_start (& self) -> & Option < EntityRef < IfcCartesianPoint > > { & self . pattern_start } fn hatch_line_angle (& self) -> & IfcPlaneAngleMeasure { & self . hatch_line_angle } } impl IfcFillAreaStyleHatching { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFillAreaStyleHatching :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . hatch_line_appearance = parameter . into () , 1usize => entity . start_of_next_hatch_line = parameter . into () , 2usize => entity . point_of_reference_hatch_line = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . pattern_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . hatch_line_angle = parameter . into () , _ => { } } } entity } } pub trait IIfcFillAreaStyleTiles : IIfcGeometricRepresentationItem { pub fn tiling_pattern (& self) -> & Vec < EntityRef < IfcVector > > ; pub fn tiles (& self) -> & HashSet < EntityRef < IfcStyledItem > > ; pub fn tiling_scale (& self) -> & IfcPositiveRatioMeasure ; } # [derive (Default , Debug)] pub struct IfcFillAreaStyleTiles { tiling_pattern : Vec < EntityRef < IfcVector > > , tiles : HashSet < EntityRef < IfcStyledItem > > , tiling_scale : IfcPositiveRatioMeasure , } impl IIfcRepresentationItem for IfcFillAreaStyleTiles { } impl IIfcGeometricRepresentationItem for IfcFillAreaStyleTiles { } impl IIfcFillAreaStyleTiles for IfcFillAreaStyleTiles { fn tiling_pattern (& self) -> & Vec < EntityRef < IfcVector > > { & self . tiling_pattern } fn tiles (& self) -> & HashSet < EntityRef < IfcStyledItem > > { & self . tiles } fn tiling_scale (& self) -> & IfcPositiveRatioMeasure { & self . tiling_scale } } impl IfcFillAreaStyleTiles { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFillAreaStyleTiles :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . tiling_pattern = parameter . into () , 1usize => entity . tiles = parameter . into () , 2usize => entity . tiling_scale = parameter . into () , _ => { } } } entity } } pub trait IIfcFilter : IIfcFlowTreatmentDevice { pub fn predefined_type (& self) -> & Option < IfcFilterTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFilter { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFilterTypeEnum > , } impl IIfcRoot for IfcFilter { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFilter { } impl IIfcObject for IfcFilter { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFilter { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFilter { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFilter { } impl IIfcDistributionFlowElement for IfcFilter { } impl IIfcFlowTreatmentDevice for IfcFilter { } impl IIfcFilter for IfcFilter { fn predefined_type (& self) -> & Option < IfcFilterTypeEnum > { & self . predefined_type } } impl IfcFilter { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFilter :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFilterType : IIfcFlowTreatmentDeviceType { pub fn predefined_type (& self) -> & IfcFilterTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFilterType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFilterTypeEnum , } impl IIfcRoot for IfcFilterType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFilterType { } impl IIfcTypeObject for IfcFilterType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFilterType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFilterType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcFilterType { } impl IIfcDistributionFlowElementType for IfcFilterType { } impl IIfcFlowTreatmentDeviceType for IfcFilterType { } impl IIfcFilterType for IfcFilterType { fn predefined_type (& self) -> & IfcFilterTypeEnum { & self . predefined_type } } impl IfcFilterType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFilterType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFireSuppressionTerminal : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcFireSuppressionTerminalTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFireSuppressionTerminal { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFireSuppressionTerminalTypeEnum > , } impl IIfcRoot for IfcFireSuppressionTerminal { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFireSuppressionTerminal { } impl IIfcObject for IfcFireSuppressionTerminal { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFireSuppressionTerminal { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFireSuppressionTerminal { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFireSuppressionTerminal { } impl IIfcDistributionFlowElement for IfcFireSuppressionTerminal { } impl IIfcFlowTerminal for IfcFireSuppressionTerminal { } impl IIfcFireSuppressionTerminal for IfcFireSuppressionTerminal { fn predefined_type (& self) -> & Option < IfcFireSuppressionTerminalTypeEnum > { & self . predefined_type } } impl IfcFireSuppressionTerminal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFireSuppressionTerminal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFireSuppressionTerminalType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcFireSuppressionTerminalTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFireSuppressionTerminalType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFireSuppressionTerminalTypeEnum , } impl IIfcRoot for IfcFireSuppressionTerminalType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFireSuppressionTerminalType { } impl IIfcTypeObject for IfcFireSuppressionTerminalType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFireSuppressionTerminalType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFireSuppressionTerminalType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcFireSuppressionTerminalType { } impl IIfcDistributionFlowElementType for IfcFireSuppressionTerminalType { } impl IIfcFlowTerminalType for IfcFireSuppressionTerminalType { } impl IIfcFireSuppressionTerminalType for IfcFireSuppressionTerminalType { fn predefined_type (& self) -> & IfcFireSuppressionTerminalTypeEnum { & self . predefined_type } } impl IfcFireSuppressionTerminalType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFireSuppressionTerminalType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFixedReferenceSweptAreaSolid : IIfcSweptAreaSolid { pub fn directrix (& self) -> & EntityRef < IfcCurve > ; pub fn start_param (& self) -> & Option < IfcParameterValue > ; pub fn end_param (& self) -> & Option < IfcParameterValue > ; pub fn fixed_reference (& self) -> & EntityRef < IfcDirection > ; } # [derive (Default , Debug)] pub struct IfcFixedReferenceSweptAreaSolid { swept_area : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , directrix : EntityRef < IfcCurve > , start_param : Option < IfcParameterValue > , end_param : Option < IfcParameterValue > , fixed_reference : EntityRef < IfcDirection > , } impl IIfcRepresentationItem for IfcFixedReferenceSweptAreaSolid { } impl IIfcGeometricRepresentationItem for IfcFixedReferenceSweptAreaSolid { } impl IIfcSolidModel for IfcFixedReferenceSweptAreaSolid { } impl IIfcSweptAreaSolid for IfcFixedReferenceSweptAreaSolid { fn swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . swept_area } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcFixedReferenceSweptAreaSolid for IfcFixedReferenceSweptAreaSolid { fn directrix (& self) -> & EntityRef < IfcCurve > { & self . directrix } fn start_param (& self) -> & Option < IfcParameterValue > { & self . start_param } fn end_param (& self) -> & Option < IfcParameterValue > { & self . end_param } fn fixed_reference (& self) -> & EntityRef < IfcDirection > { & self . fixed_reference } } impl IfcFixedReferenceSweptAreaSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFixedReferenceSweptAreaSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_area = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . directrix = parameter . into () , 3usize => entity . start_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . end_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . fixed_reference = parameter . into () , _ => { } } } entity } } pub trait IIfcFlowController : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowController { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowController { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowController { } impl IIfcObject for IfcFlowController { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowController { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowController { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowController { } impl IIfcDistributionFlowElement for IfcFlowController { } impl IIfcFlowController for IfcFlowController { } impl IfcFlowController { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowController :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowControllerType : IIfcDistributionFlowElementType { } pub trait IIfcFlowFitting : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowFitting { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowFitting { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowFitting { } impl IIfcObject for IfcFlowFitting { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowFitting { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowFitting { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowFitting { } impl IIfcDistributionFlowElement for IfcFlowFitting { } impl IIfcFlowFitting for IfcFlowFitting { } impl IfcFlowFitting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowFitting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowFittingType : IIfcDistributionFlowElementType { } pub trait IIfcFlowInstrument : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcFlowInstrumentTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFlowInstrument { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFlowInstrumentTypeEnum > , } impl IIfcRoot for IfcFlowInstrument { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowInstrument { } impl IIfcObject for IfcFlowInstrument { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowInstrument { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowInstrument { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowInstrument { } impl IIfcDistributionControlElement for IfcFlowInstrument { } impl IIfcFlowInstrument for IfcFlowInstrument { fn predefined_type (& self) -> & Option < IfcFlowInstrumentTypeEnum > { & self . predefined_type } } impl IfcFlowInstrument { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowInstrument :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowInstrumentType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcFlowInstrumentTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFlowInstrumentType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFlowInstrumentTypeEnum , } impl IIfcRoot for IfcFlowInstrumentType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowInstrumentType { } impl IIfcTypeObject for IfcFlowInstrumentType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFlowInstrumentType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFlowInstrumentType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcFlowInstrumentType { } impl IIfcDistributionControlElementType for IfcFlowInstrumentType { } impl IIfcFlowInstrumentType for IfcFlowInstrumentType { fn predefined_type (& self) -> & IfcFlowInstrumentTypeEnum { & self . predefined_type } } impl IfcFlowInstrumentType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowInstrumentType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFlowMeter : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcFlowMeterTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFlowMeter { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFlowMeterTypeEnum > , } impl IIfcRoot for IfcFlowMeter { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowMeter { } impl IIfcObject for IfcFlowMeter { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowMeter { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowMeter { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowMeter { } impl IIfcDistributionFlowElement for IfcFlowMeter { } impl IIfcFlowController for IfcFlowMeter { } impl IIfcFlowMeter for IfcFlowMeter { fn predefined_type (& self) -> & Option < IfcFlowMeterTypeEnum > { & self . predefined_type } } impl IfcFlowMeter { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowMeter :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowMeterType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcFlowMeterTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFlowMeterType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFlowMeterTypeEnum , } impl IIfcRoot for IfcFlowMeterType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowMeterType { } impl IIfcTypeObject for IfcFlowMeterType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFlowMeterType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFlowMeterType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcFlowMeterType { } impl IIfcDistributionFlowElementType for IfcFlowMeterType { } impl IIfcFlowControllerType for IfcFlowMeterType { } impl IIfcFlowMeterType for IfcFlowMeterType { fn predefined_type (& self) -> & IfcFlowMeterTypeEnum { & self . predefined_type } } impl IfcFlowMeterType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowMeterType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFlowMovingDevice : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowMovingDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowMovingDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowMovingDevice { } impl IIfcObject for IfcFlowMovingDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowMovingDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowMovingDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowMovingDevice { } impl IIfcDistributionFlowElement for IfcFlowMovingDevice { } impl IIfcFlowMovingDevice for IfcFlowMovingDevice { } impl IfcFlowMovingDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowMovingDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowMovingDeviceType : IIfcDistributionFlowElementType { } pub trait IIfcFlowSegment : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowSegment { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowSegment { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowSegment { } impl IIfcObject for IfcFlowSegment { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowSegment { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowSegment { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowSegment { } impl IIfcDistributionFlowElement for IfcFlowSegment { } impl IIfcFlowSegment for IfcFlowSegment { } impl IfcFlowSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowSegmentType : IIfcDistributionFlowElementType { } pub trait IIfcFlowStorageDevice : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowStorageDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowStorageDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowStorageDevice { } impl IIfcObject for IfcFlowStorageDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowStorageDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowStorageDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowStorageDevice { } impl IIfcDistributionFlowElement for IfcFlowStorageDevice { } impl IIfcFlowStorageDevice for IfcFlowStorageDevice { } impl IfcFlowStorageDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowStorageDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowStorageDeviceType : IIfcDistributionFlowElementType { } pub trait IIfcFlowTerminal : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowTerminal { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowTerminal { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowTerminal { } impl IIfcObject for IfcFlowTerminal { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowTerminal { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowTerminal { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowTerminal { } impl IIfcDistributionFlowElement for IfcFlowTerminal { } impl IIfcFlowTerminal for IfcFlowTerminal { } impl IfcFlowTerminal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowTerminal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowTerminalType : IIfcDistributionFlowElementType { } pub trait IIfcFlowTreatmentDevice : IIfcDistributionFlowElement { } # [derive (Default , Debug)] pub struct IfcFlowTreatmentDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFlowTreatmentDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFlowTreatmentDevice { } impl IIfcObject for IfcFlowTreatmentDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFlowTreatmentDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFlowTreatmentDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcFlowTreatmentDevice { } impl IIfcDistributionFlowElement for IfcFlowTreatmentDevice { } impl IIfcFlowTreatmentDevice for IfcFlowTreatmentDevice { } impl IfcFlowTreatmentDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFlowTreatmentDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFlowTreatmentDeviceType : IIfcDistributionFlowElementType { } pub trait IIfcFooting : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcFootingTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFooting { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFootingTypeEnum > , } impl IIfcRoot for IfcFooting { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFooting { } impl IIfcObject for IfcFooting { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFooting { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFooting { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcFooting { } impl IIfcFooting for IfcFooting { fn predefined_type (& self) -> & Option < IfcFootingTypeEnum > { & self . predefined_type } } impl IfcFooting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFooting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFootingType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcFootingTypeEnum ; } # [derive (Default , Debug)] pub struct IfcFootingType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcFootingTypeEnum , } impl IIfcRoot for IfcFootingType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFootingType { } impl IIfcTypeObject for IfcFootingType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFootingType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFootingType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcFootingType { } impl IIfcFootingType for IfcFootingType { fn predefined_type (& self) -> & IfcFootingTypeEnum { & self . predefined_type } } impl IfcFootingType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFootingType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcFurnishingElement : IIfcElement { } # [derive (Default , Debug)] pub struct IfcFurnishingElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcFurnishingElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFurnishingElement { } impl IIfcObject for IfcFurnishingElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFurnishingElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFurnishingElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFurnishingElement for IfcFurnishingElement { } impl IfcFurnishingElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFurnishingElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFurnishingElementType : IIfcElementType { } # [derive (Default , Debug)] pub struct IfcFurnishingElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , } impl IIfcRoot for IfcFurnishingElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFurnishingElementType { } impl IIfcTypeObject for IfcFurnishingElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFurnishingElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFurnishingElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcFurnishingElementType for IfcFurnishingElementType { } impl IfcFurnishingElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFurnishingElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFurniture : IIfcFurnishingElement { pub fn predefined_type (& self) -> & Option < IfcFurnitureTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFurniture { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcFurnitureTypeEnum > , } impl IIfcRoot for IfcFurniture { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFurniture { } impl IIfcObject for IfcFurniture { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcFurniture { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcFurniture { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFurnishingElement for IfcFurniture { } impl IIfcFurniture for IfcFurniture { fn predefined_type (& self) -> & Option < IfcFurnitureTypeEnum > { & self . predefined_type } } impl IfcFurniture { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFurniture :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcFurnitureType : IIfcFurnishingElementType { pub fn assembly_place (& self) -> & IfcAssemblyPlaceEnum ; pub fn predefined_type (& self) -> & Option < IfcFurnitureTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcFurnitureType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , assembly_place : IfcAssemblyPlaceEnum , predefined_type : Option < IfcFurnitureTypeEnum > , } impl IIfcRoot for IfcFurnitureType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcFurnitureType { } impl IIfcTypeObject for IfcFurnitureType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcFurnitureType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcFurnitureType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcFurnishingElementType for IfcFurnitureType { } impl IIfcFurnitureType for IfcFurnitureType { fn assembly_place (& self) -> & IfcAssemblyPlaceEnum { & self . assembly_place } fn predefined_type (& self) -> & Option < IfcFurnitureTypeEnum > { & self . predefined_type } } impl IfcFurnitureType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcFurnitureType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . assembly_place = parameter . into () , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcGeographicElement : IIfcElement { pub fn predefined_type (& self) -> & Option < IfcGeographicElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcGeographicElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcGeographicElementTypeEnum > , } impl IIfcRoot for IfcGeographicElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcGeographicElement { } impl IIfcObject for IfcGeographicElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcGeographicElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcGeographicElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcGeographicElement for IfcGeographicElement { fn predefined_type (& self) -> & Option < IfcGeographicElementTypeEnum > { & self . predefined_type } } impl IfcGeographicElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGeographicElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcGeographicElementType : IIfcElementType { pub fn predefined_type (& self) -> & IfcGeographicElementTypeEnum ; } # [derive (Default , Debug)] pub struct IfcGeographicElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcGeographicElementTypeEnum , } impl IIfcRoot for IfcGeographicElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcGeographicElementType { } impl IIfcTypeObject for IfcGeographicElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcGeographicElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcGeographicElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcGeographicElementType for IfcGeographicElementType { fn predefined_type (& self) -> & IfcGeographicElementTypeEnum { & self . predefined_type } } impl IfcGeographicElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGeographicElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcGeometricCurveSet : IIfcGeometricSet { } # [derive (Default , Debug)] pub struct IfcGeometricCurveSet { elements : HashSet < EntityRef < IfcGeometricSetSelect > > , } impl IIfcRepresentationItem for IfcGeometricCurveSet { } impl IIfcGeometricRepresentationItem for IfcGeometricCurveSet { } impl IIfcGeometricSet for IfcGeometricCurveSet { fn elements (& self) -> & HashSet < EntityRef < IfcGeometricSetSelect > > { & self . elements } } impl IIfcGeometricCurveSet for IfcGeometricCurveSet { } impl IfcGeometricCurveSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGeometricCurveSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . elements = parameter . into () , _ => { } } } entity } } pub trait IIfcGeometricRepresentationContext : IIfcRepresentationContext { pub fn coordinate_space_dimension (& self) -> & IfcDimensionCount ; pub fn precision (& self) -> & Option < IfcReal > ; pub fn world_coordinate_system (& self) -> & EntityRef < IfcAxis2Placement > ; pub fn true_north (& self) -> & Option < EntityRef < IfcDirection > > ; } # [derive (Default , Debug)] pub struct IfcGeometricRepresentationContext { context_identifier : Option < IfcLabel > , context_type : Option < IfcLabel > , coordinate_space_dimension : IfcDimensionCount , precision : Option < IfcReal > , world_coordinate_system : EntityRef < IfcAxis2Placement > , true_north : Option < EntityRef < IfcDirection > > , } impl IIfcRepresentationContext for IfcGeometricRepresentationContext { fn context_identifier (& self) -> & Option < IfcLabel > { & self . context_identifier } fn context_type (& self) -> & Option < IfcLabel > { & self . context_type } } impl IIfcGeometricRepresentationContext for IfcGeometricRepresentationContext { fn coordinate_space_dimension (& self) -> & IfcDimensionCount { & self . coordinate_space_dimension } fn precision (& self) -> & Option < IfcReal > { & self . precision } fn world_coordinate_system (& self) -> & EntityRef < IfcAxis2Placement > { & self . world_coordinate_system } fn true_north (& self) -> & Option < EntityRef < IfcDirection > > { & self . true_north } } impl IfcGeometricRepresentationContext { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGeometricRepresentationContext :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . context_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . context_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . coordinate_space_dimension = parameter . into () , 3usize => entity . precision = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . world_coordinate_system = parameter . into () , 5usize => entity . true_north = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcGeometricRepresentationItem : IIfcRepresentationItem { } pub trait IIfcGeometricRepresentationSubContext : IIfcGeometricRepresentationContext { pub fn parent_context (& self) -> & EntityRef < IfcGeometricRepresentationContext > ; pub fn target_scale (& self) -> & Option < IfcPositiveRatioMeasure > ; pub fn target_view (& self) -> & IfcGeometricProjectionEnum ; pub fn user_defined_target_view (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcGeometricRepresentationSubContext { context_identifier : Option < IfcLabel > , context_type : Option < IfcLabel > , coordinate_space_dimension : IfcDimensionCount , precision : Option < IfcReal > , world_coordinate_system : EntityRef < IfcAxis2Placement > , true_north : Option < EntityRef < IfcDirection > > , parent_context : EntityRef < IfcGeometricRepresentationContext > , target_scale : Option < IfcPositiveRatioMeasure > , target_view : IfcGeometricProjectionEnum , user_defined_target_view : Option < IfcLabel > , } impl IIfcRepresentationContext for IfcGeometricRepresentationSubContext { fn context_identifier (& self) -> & Option < IfcLabel > { & self . context_identifier } fn context_type (& self) -> & Option < IfcLabel > { & self . context_type } } impl IIfcGeometricRepresentationContext for IfcGeometricRepresentationSubContext { fn coordinate_space_dimension (& self) -> & IfcDimensionCount { & self . coordinate_space_dimension } fn precision (& self) -> & Option < IfcReal > { & self . precision } fn world_coordinate_system (& self) -> & EntityRef < IfcAxis2Placement > { & self . world_coordinate_system } fn true_north (& self) -> & Option < EntityRef < IfcDirection > > { & self . true_north } } impl IIfcGeometricRepresentationSubContext for IfcGeometricRepresentationSubContext { fn parent_context (& self) -> & EntityRef < IfcGeometricRepresentationContext > { & self . parent_context } fn target_scale (& self) -> & Option < IfcPositiveRatioMeasure > { & self . target_scale } fn target_view (& self) -> & IfcGeometricProjectionEnum { & self . target_view } fn user_defined_target_view (& self) -> & Option < IfcLabel > { & self . user_defined_target_view } } impl IfcGeometricRepresentationSubContext { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGeometricRepresentationSubContext :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . context_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . context_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . coordinate_space_dimension = parameter . into () , 3usize => entity . precision = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . world_coordinate_system = parameter . into () , 5usize => entity . true_north = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . parent_context = parameter . into () , 7usize => entity . target_scale = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . target_view = parameter . into () , 9usize => entity . user_defined_target_view = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcGeometricSet : IIfcGeometricRepresentationItem { pub fn elements (& self) -> & HashSet < EntityRef < IfcGeometricSetSelect > > ; } # [derive (Default , Debug)] pub struct IfcGeometricSet { elements : HashSet < EntityRef < IfcGeometricSetSelect > > , } impl IIfcRepresentationItem for IfcGeometricSet { } impl IIfcGeometricRepresentationItem for IfcGeometricSet { } impl IIfcGeometricSet for IfcGeometricSet { fn elements (& self) -> & HashSet < EntityRef < IfcGeometricSetSelect > > { & self . elements } } impl IfcGeometricSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGeometricSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . elements = parameter . into () , _ => { } } } entity } } pub trait IIfcGrid : IIfcProduct { pub fn u_axes (& self) -> & Vec < EntityRef < IfcGridAxis > > ; pub fn v_axes (& self) -> & Vec < EntityRef < IfcGridAxis > > ; pub fn w_axes (& self) -> & Option < Vec < EntityRef < IfcGridAxis > > > ; pub fn predefined_type (& self) -> & Option < IfcGridTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcGrid { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , u_axes : Vec < EntityRef < IfcGridAxis > > , v_axes : Vec < EntityRef < IfcGridAxis > > , w_axes : Option < Vec < EntityRef < IfcGridAxis > > > , predefined_type : Option < IfcGridTypeEnum > , } impl IIfcRoot for IfcGrid { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcGrid { } impl IIfcObject for IfcGrid { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcGrid { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcGrid for IfcGrid { fn u_axes (& self) -> & Vec < EntityRef < IfcGridAxis > > { & self . u_axes } fn v_axes (& self) -> & Vec < EntityRef < IfcGridAxis > > { & self . v_axes } fn w_axes (& self) -> & Option < Vec < EntityRef < IfcGridAxis > > > { & self . w_axes } fn predefined_type (& self) -> & Option < IfcGridTypeEnum > { & self . predefined_type } } impl IfcGrid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGrid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . u_axes = parameter . into () , 8usize => entity . v_axes = parameter . into () , 9usize => entity . w_axes = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcGridAxis : { pub fn axis_tag (& self) -> & Option < IfcLabel > ; pub fn axis_curve (& self) -> & EntityRef < IfcCurve > ; pub fn same_sense (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcGridAxis { axis_tag : Option < IfcLabel > , axis_curve : EntityRef < IfcCurve > , same_sense : IfcBoolean , } impl IIfcGridAxis for IfcGridAxis { fn axis_tag (& self) -> & Option < IfcLabel > { & self . axis_tag } fn axis_curve (& self) -> & EntityRef < IfcCurve > { & self . axis_curve } fn same_sense (& self) -> & IfcBoolean { & self . same_sense } } impl IfcGridAxis { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGridAxis :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . axis_tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . axis_curve = parameter . into () , 2usize => entity . same_sense = parameter . into () , _ => { } } } entity } } pub trait IIfcGridPlacement : IIfcObjectPlacement { pub fn placement_location (& self) -> & EntityRef < IfcVirtualGridIntersection > ; pub fn placement_ref_direction (& self) -> & Option < EntityRef < IfcGridPlacementDirectionSelect > > ; } # [derive (Default , Debug)] pub struct IfcGridPlacement { placement_location : EntityRef < IfcVirtualGridIntersection > , placement_ref_direction : Option < EntityRef < IfcGridPlacementDirectionSelect > > , } impl IIfcObjectPlacement for IfcGridPlacement { } impl IIfcGridPlacement for IfcGridPlacement { fn placement_location (& self) -> & EntityRef < IfcVirtualGridIntersection > { & self . placement_location } fn placement_ref_direction (& self) -> & Option < EntityRef < IfcGridPlacementDirectionSelect > > { & self . placement_ref_direction } } impl IfcGridPlacement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGridPlacement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . placement_location = parameter . into () , 1usize => entity . placement_ref_direction = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcGroup : IIfcObject { } # [derive (Default , Debug)] pub struct IfcGroup { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , } impl IIfcRoot for IfcGroup { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcGroup { } impl IIfcObject for IfcGroup { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcGroup { } impl IfcGroup { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcGroup :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcHalfSpaceSolid : IIfcGeometricRepresentationItem { pub fn base_surface (& self) -> & EntityRef < IfcSurface > ; pub fn agreement_flag (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcHalfSpaceSolid { base_surface : EntityRef < IfcSurface > , agreement_flag : IfcBoolean , } impl IIfcRepresentationItem for IfcHalfSpaceSolid { } impl IIfcGeometricRepresentationItem for IfcHalfSpaceSolid { } impl IIfcHalfSpaceSolid for IfcHalfSpaceSolid { fn base_surface (& self) -> & EntityRef < IfcSurface > { & self . base_surface } fn agreement_flag (& self) -> & IfcBoolean { & self . agreement_flag } } impl IfcHalfSpaceSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcHalfSpaceSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . base_surface = parameter . into () , 1usize => entity . agreement_flag = parameter . into () , _ => { } } } entity } } pub trait IIfcHeatExchanger : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcHeatExchangerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcHeatExchanger { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcHeatExchangerTypeEnum > , } impl IIfcRoot for IfcHeatExchanger { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcHeatExchanger { } impl IIfcObject for IfcHeatExchanger { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcHeatExchanger { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcHeatExchanger { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcHeatExchanger { } impl IIfcDistributionFlowElement for IfcHeatExchanger { } impl IIfcEnergyConversionDevice for IfcHeatExchanger { } impl IIfcHeatExchanger for IfcHeatExchanger { fn predefined_type (& self) -> & Option < IfcHeatExchangerTypeEnum > { & self . predefined_type } } impl IfcHeatExchanger { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcHeatExchanger :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcHeatExchangerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcHeatExchangerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcHeatExchangerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcHeatExchangerTypeEnum , } impl IIfcRoot for IfcHeatExchangerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcHeatExchangerType { } impl IIfcTypeObject for IfcHeatExchangerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcHeatExchangerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcHeatExchangerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcHeatExchangerType { } impl IIfcDistributionFlowElementType for IfcHeatExchangerType { } impl IIfcEnergyConversionDeviceType for IfcHeatExchangerType { } impl IIfcHeatExchangerType for IfcHeatExchangerType { fn predefined_type (& self) -> & IfcHeatExchangerTypeEnum { & self . predefined_type } } impl IfcHeatExchangerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcHeatExchangerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcHumidifier : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcHumidifierTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcHumidifier { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcHumidifierTypeEnum > , } impl IIfcRoot for IfcHumidifier { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcHumidifier { } impl IIfcObject for IfcHumidifier { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcHumidifier { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcHumidifier { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcHumidifier { } impl IIfcDistributionFlowElement for IfcHumidifier { } impl IIfcEnergyConversionDevice for IfcHumidifier { } impl IIfcHumidifier for IfcHumidifier { fn predefined_type (& self) -> & Option < IfcHumidifierTypeEnum > { & self . predefined_type } } impl IfcHumidifier { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcHumidifier :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcHumidifierType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcHumidifierTypeEnum ; } # [derive (Default , Debug)] pub struct IfcHumidifierType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcHumidifierTypeEnum , } impl IIfcRoot for IfcHumidifierType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcHumidifierType { } impl IIfcTypeObject for IfcHumidifierType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcHumidifierType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcHumidifierType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcHumidifierType { } impl IIfcDistributionFlowElementType for IfcHumidifierType { } impl IIfcEnergyConversionDeviceType for IfcHumidifierType { } impl IIfcHumidifierType for IfcHumidifierType { fn predefined_type (& self) -> & IfcHumidifierTypeEnum { & self . predefined_type } } impl IfcHumidifierType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcHumidifierType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcIShapeProfileDef : IIfcParameterizedProfileDef { pub fn overall_width (& self) -> & IfcPositiveLengthMeasure ; pub fn overall_depth (& self) -> & IfcPositiveLengthMeasure ; pub fn web_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; } # [derive (Default , Debug)] pub struct IfcIShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , overall_width : IfcPositiveLengthMeasure , overall_depth : IfcPositiveLengthMeasure , web_thickness : IfcPositiveLengthMeasure , flange_thickness : IfcPositiveLengthMeasure , fillet_radius : Option < IfcNonNegativeLengthMeasure > , flange_edge_radius : Option < IfcNonNegativeLengthMeasure > , flange_slope : Option < IfcPlaneAngleMeasure > , } impl IIfcProfileDef for IfcIShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcIShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcIShapeProfileDef for IfcIShapeProfileDef { fn overall_width (& self) -> & IfcPositiveLengthMeasure { & self . overall_width } fn overall_depth (& self) -> & IfcPositiveLengthMeasure { & self . overall_depth } fn web_thickness (& self) -> & IfcPositiveLengthMeasure { & self . web_thickness } fn flange_thickness (& self) -> & IfcPositiveLengthMeasure { & self . flange_thickness } fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . fillet_radius } fn flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . flange_edge_radius } fn flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . flange_slope } } impl IfcIShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . overall_width = parameter . into () , 4usize => entity . overall_depth = parameter . into () , 5usize => entity . web_thickness = parameter . into () , 6usize => entity . flange_thickness = parameter . into () , 7usize => entity . fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . flange_edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . flange_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcImageTexture : IIfcSurfaceTexture { pub fn url_reference (& self) -> & IfcUriReference ; } # [derive (Default , Debug)] pub struct IfcImageTexture { repeat_s : IfcBoolean , repeat_t : IfcBoolean , mode : Option < IfcIdentifier > , texture_transform : Option < EntityRef < IfcCartesianTransformationOperator2D > > , parameter : Option < Vec < IfcIdentifier > > , url_reference : IfcUriReference , } impl IIfcPresentationItem for IfcImageTexture { } impl IIfcSurfaceTexture for IfcImageTexture { fn repeat_s (& self) -> & IfcBoolean { & self . repeat_s } fn repeat_t (& self) -> & IfcBoolean { & self . repeat_t } fn mode (& self) -> & Option < IfcIdentifier > { & self . mode } fn texture_transform (& self) -> & Option < EntityRef < IfcCartesianTransformationOperator2D > > { & self . texture_transform } fn parameter (& self) -> & Option < Vec < IfcIdentifier > > { & self . parameter } } impl IIfcImageTexture for IfcImageTexture { fn url_reference (& self) -> & IfcUriReference { & self . url_reference } } impl IfcImageTexture { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcImageTexture :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . repeat_s = parameter . into () , 1usize => entity . repeat_t = parameter . into () , 2usize => entity . mode = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . texture_transform = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . parameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . url_reference = parameter . into () , _ => { } } } entity } } pub trait IIfcIndexedColourMap : IIfcPresentationItem { pub fn mapped_to (& self) -> & EntityRef < IfcTessellatedFaceSet > ; pub fn opacity (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn colours (& self) -> & EntityRef < IfcColourRgbList > ; pub fn colour_index (& self) -> & Vec < IfcPositiveInteger > ; } # [derive (Default , Debug)] pub struct IfcIndexedColourMap { mapped_to : EntityRef < IfcTessellatedFaceSet > , opacity : Option < IfcNormalisedRatioMeasure > , colours : EntityRef < IfcColourRgbList > , colour_index : Vec < IfcPositiveInteger > , } impl IIfcPresentationItem for IfcIndexedColourMap { } impl IIfcIndexedColourMap for IfcIndexedColourMap { fn mapped_to (& self) -> & EntityRef < IfcTessellatedFaceSet > { & self . mapped_to } fn opacity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . opacity } fn colours (& self) -> & EntityRef < IfcColourRgbList > { & self . colours } fn colour_index (& self) -> & Vec < IfcPositiveInteger > { & self . colour_index } } impl IfcIndexedColourMap { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIndexedColourMap :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . mapped_to = parameter . into () , 1usize => entity . opacity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . colours = parameter . into () , 3usize => entity . colour_index = parameter . into () , _ => { } } } entity } } pub trait IIfcIndexedPolyCurve : IIfcBoundedCurve { pub fn points (& self) -> & EntityRef < IfcCartesianPointList > ; pub fn segments (& self) -> & Option < Vec < IfcSegmentIndexSelect > > ; pub fn self_intersect (& self) -> & Option < IfcBoolean > ; } # [derive (Default , Debug)] pub struct IfcIndexedPolyCurve { points : EntityRef < IfcCartesianPointList > , segments : Option < Vec < IfcSegmentIndexSelect > > , self_intersect : Option < IfcBoolean > , } impl IIfcRepresentationItem for IfcIndexedPolyCurve { } impl IIfcGeometricRepresentationItem for IfcIndexedPolyCurve { } impl IIfcCurve for IfcIndexedPolyCurve { } impl IIfcBoundedCurve for IfcIndexedPolyCurve { } impl IIfcIndexedPolyCurve for IfcIndexedPolyCurve { fn points (& self) -> & EntityRef < IfcCartesianPointList > { & self . points } fn segments (& self) -> & Option < Vec < IfcSegmentIndexSelect > > { & self . segments } fn self_intersect (& self) -> & Option < IfcBoolean > { & self . self_intersect } } impl IfcIndexedPolyCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIndexedPolyCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . points = parameter . into () , 1usize => entity . segments = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . self_intersect = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcIndexedPolygonalFace : IIfcTessellatedItem { pub fn coord_index (& self) -> & Vec < IfcPositiveInteger > ; } # [derive (Default , Debug)] pub struct IfcIndexedPolygonalFace { coord_index : Vec < IfcPositiveInteger > , } impl IIfcRepresentationItem for IfcIndexedPolygonalFace { } impl IIfcGeometricRepresentationItem for IfcIndexedPolygonalFace { } impl IIfcTessellatedItem for IfcIndexedPolygonalFace { } impl IIfcIndexedPolygonalFace for IfcIndexedPolygonalFace { fn coord_index (& self) -> & Vec < IfcPositiveInteger > { & self . coord_index } } impl IfcIndexedPolygonalFace { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIndexedPolygonalFace :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coord_index = parameter . into () , _ => { } } } entity } } pub trait IIfcIndexedPolygonalFaceWithVoids : IIfcIndexedPolygonalFace { pub fn inner_coord_indices (& self) -> & Vec < Vec < IfcPositiveInteger > > ; } # [derive (Default , Debug)] pub struct IfcIndexedPolygonalFaceWithVoids { coord_index : Vec < IfcPositiveInteger > , inner_coord_indices : Vec < Vec < IfcPositiveInteger > > , } impl IIfcRepresentationItem for IfcIndexedPolygonalFaceWithVoids { } impl IIfcGeometricRepresentationItem for IfcIndexedPolygonalFaceWithVoids { } impl IIfcTessellatedItem for IfcIndexedPolygonalFaceWithVoids { } impl IIfcIndexedPolygonalFace for IfcIndexedPolygonalFaceWithVoids { fn coord_index (& self) -> & Vec < IfcPositiveInteger > { & self . coord_index } } impl IIfcIndexedPolygonalFaceWithVoids for IfcIndexedPolygonalFaceWithVoids { fn inner_coord_indices (& self) -> & Vec < Vec < IfcPositiveInteger > > { & self . inner_coord_indices } } impl IfcIndexedPolygonalFaceWithVoids { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIndexedPolygonalFaceWithVoids :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coord_index = parameter . into () , 1usize => entity . inner_coord_indices = parameter . into () , _ => { } } } entity } } pub trait IIfcIndexedTextureMap : IIfcTextureCoordinate { pub fn mapped_to (& self) -> & EntityRef < IfcTessellatedFaceSet > ; pub fn tex_coords (& self) -> & EntityRef < IfcTextureVertexList > ; } pub trait IIfcIndexedTriangleTextureMap : IIfcIndexedTextureMap { pub fn tex_coord_index (& self) -> & Option < Vec < Vec < IfcPositiveInteger > > > ; } # [derive (Default , Debug)] pub struct IfcIndexedTriangleTextureMap { maps : Vec < EntityRef < IfcSurfaceTexture > > , mapped_to : EntityRef < IfcTessellatedFaceSet > , tex_coords : EntityRef < IfcTextureVertexList > , tex_coord_index : Option < Vec < Vec < IfcPositiveInteger > > > , } impl IIfcPresentationItem for IfcIndexedTriangleTextureMap { } impl IIfcTextureCoordinate for IfcIndexedTriangleTextureMap { fn maps (& self) -> & Vec < EntityRef < IfcSurfaceTexture > > { & self . maps } } impl IIfcIndexedTextureMap for IfcIndexedTriangleTextureMap { fn mapped_to (& self) -> & EntityRef < IfcTessellatedFaceSet > { & self . mapped_to } fn tex_coords (& self) -> & EntityRef < IfcTextureVertexList > { & self . tex_coords } } impl IIfcIndexedTriangleTextureMap for IfcIndexedTriangleTextureMap { fn tex_coord_index (& self) -> & Option < Vec < Vec < IfcPositiveInteger > > > { & self . tex_coord_index } } impl IfcIndexedTriangleTextureMap { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIndexedTriangleTextureMap :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . maps = parameter . into () , 1usize => entity . mapped_to = parameter . into () , 2usize => entity . tex_coords = parameter . into () , 3usize => entity . tex_coord_index = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcInterceptor : IIfcFlowTreatmentDevice { pub fn predefined_type (& self) -> & Option < IfcInterceptorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcInterceptor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcInterceptorTypeEnum > , } impl IIfcRoot for IfcInterceptor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcInterceptor { } impl IIfcObject for IfcInterceptor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcInterceptor { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcInterceptor { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcInterceptor { } impl IIfcDistributionFlowElement for IfcInterceptor { } impl IIfcFlowTreatmentDevice for IfcInterceptor { } impl IIfcInterceptor for IfcInterceptor { fn predefined_type (& self) -> & Option < IfcInterceptorTypeEnum > { & self . predefined_type } } impl IfcInterceptor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcInterceptor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcInterceptorType : IIfcFlowTreatmentDeviceType { pub fn predefined_type (& self) -> & IfcInterceptorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcInterceptorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcInterceptorTypeEnum , } impl IIfcRoot for IfcInterceptorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcInterceptorType { } impl IIfcTypeObject for IfcInterceptorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcInterceptorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcInterceptorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcInterceptorType { } impl IIfcDistributionFlowElementType for IfcInterceptorType { } impl IIfcFlowTreatmentDeviceType for IfcInterceptorType { } impl IIfcInterceptorType for IfcInterceptorType { fn predefined_type (& self) -> & IfcInterceptorTypeEnum { & self . predefined_type } } impl IfcInterceptorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcInterceptorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcIntersectionCurve : IIfcSurfaceCurve { } # [derive (Default , Debug)] pub struct IfcIntersectionCurve { curve3_d : EntityRef < IfcCurve > , associated_geometry : Vec < EntityRef < IfcPcurve > > , master_representation : IfcPreferredSurfaceCurveRepresentation , } impl IIfcRepresentationItem for IfcIntersectionCurve { } impl IIfcGeometricRepresentationItem for IfcIntersectionCurve { } impl IIfcCurve for IfcIntersectionCurve { } impl IIfcSurfaceCurve for IfcIntersectionCurve { fn curve3_d (& self) -> & EntityRef < IfcCurve > { & self . curve3_d } fn associated_geometry (& self) -> & Vec < EntityRef < IfcPcurve > > { & self . associated_geometry } fn master_representation (& self) -> & IfcPreferredSurfaceCurveRepresentation { & self . master_representation } } impl IIfcIntersectionCurve for IfcIntersectionCurve { } impl IfcIntersectionCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIntersectionCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . curve3_d = parameter . into () , 1usize => entity . associated_geometry = parameter . into () , 2usize => entity . master_representation = parameter . into () , _ => { } } } entity } } pub trait IIfcInventory : IIfcGroup { pub fn predefined_type (& self) -> & Option < IfcInventoryTypeEnum > ; pub fn jurisdiction (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn responsible_persons (& self) -> & Option < HashSet < EntityRef < IfcPerson > > > ; pub fn last_update_date (& self) -> & Option < IfcDate > ; pub fn current_value (& self) -> & Option < EntityRef < IfcCostValue > > ; pub fn original_value (& self) -> & Option < EntityRef < IfcCostValue > > ; } # [derive (Default , Debug)] pub struct IfcInventory { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , predefined_type : Option < IfcInventoryTypeEnum > , jurisdiction : Option < EntityRef < IfcActorSelect > > , responsible_persons : Option < HashSet < EntityRef < IfcPerson > > > , last_update_date : Option < IfcDate > , current_value : Option < EntityRef < IfcCostValue > > , original_value : Option < EntityRef < IfcCostValue > > , } impl IIfcRoot for IfcInventory { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcInventory { } impl IIfcObject for IfcInventory { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcInventory { } impl IIfcInventory for IfcInventory { fn predefined_type (& self) -> & Option < IfcInventoryTypeEnum > { & self . predefined_type } fn jurisdiction (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . jurisdiction } fn responsible_persons (& self) -> & Option < HashSet < EntityRef < IfcPerson > > > { & self . responsible_persons } fn last_update_date (& self) -> & Option < IfcDate > { & self . last_update_date } fn current_value (& self) -> & Option < EntityRef < IfcCostValue > > { & self . current_value } fn original_value (& self) -> & Option < EntityRef < IfcCostValue > > { & self . original_value } } impl IfcInventory { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcInventory :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . jurisdiction = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . responsible_persons = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . last_update_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . current_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . original_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcIrregularTimeSeries : IIfcTimeSeries { pub fn values (& self) -> & Vec < EntityRef < IfcIrregularTimeSeriesValue > > ; } # [derive (Default , Debug)] pub struct IfcIrregularTimeSeries { name : IfcLabel , description : Option < IfcText > , start_time : IfcDateTime , end_time : IfcDateTime , time_series_data_type : IfcTimeSeriesDataTypeEnum , data_origin : IfcDataOriginEnum , user_defined_data_origin : Option < IfcLabel > , unit : Option < EntityRef < IfcUnit > > , values : Vec < EntityRef < IfcIrregularTimeSeriesValue > > , } impl IIfcTimeSeries for IfcIrregularTimeSeries { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn start_time (& self) -> & IfcDateTime { & self . start_time } fn end_time (& self) -> & IfcDateTime { & self . end_time } fn time_series_data_type (& self) -> & IfcTimeSeriesDataTypeEnum { & self . time_series_data_type } fn data_origin (& self) -> & IfcDataOriginEnum { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } } impl IIfcIrregularTimeSeries for IfcIrregularTimeSeries { fn values (& self) -> & Vec < EntityRef < IfcIrregularTimeSeriesValue > > { & self . values } } impl IfcIrregularTimeSeries { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIrregularTimeSeries :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . start_time = parameter . into () , 3usize => entity . end_time = parameter . into () , 4usize => entity . time_series_data_type = parameter . into () , 5usize => entity . data_origin = parameter . into () , 6usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . values = parameter . into () , _ => { } } } entity } } pub trait IIfcIrregularTimeSeriesValue : { pub fn time_stamp (& self) -> & IfcDateTime ; pub fn list_values (& self) -> & Vec < IfcValue > ; } # [derive (Default , Debug)] pub struct IfcIrregularTimeSeriesValue { time_stamp : IfcDateTime , list_values : Vec < IfcValue > , } impl IIfcIrregularTimeSeriesValue for IfcIrregularTimeSeriesValue { fn time_stamp (& self) -> & IfcDateTime { & self . time_stamp } fn list_values (& self) -> & Vec < IfcValue > { & self . list_values } } impl IfcIrregularTimeSeriesValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcIrregularTimeSeriesValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . time_stamp = parameter . into () , 1usize => entity . list_values = parameter . into () , _ => { } } } entity } } pub trait IIfcJunctionBox : IIfcFlowFitting { pub fn predefined_type (& self) -> & Option < IfcJunctionBoxTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcJunctionBox { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcJunctionBoxTypeEnum > , } impl IIfcRoot for IfcJunctionBox { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcJunctionBox { } impl IIfcObject for IfcJunctionBox { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcJunctionBox { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcJunctionBox { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcJunctionBox { } impl IIfcDistributionFlowElement for IfcJunctionBox { } impl IIfcFlowFitting for IfcJunctionBox { } impl IIfcJunctionBox for IfcJunctionBox { fn predefined_type (& self) -> & Option < IfcJunctionBoxTypeEnum > { & self . predefined_type } } impl IfcJunctionBox { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcJunctionBox :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcJunctionBoxType : IIfcFlowFittingType { pub fn predefined_type (& self) -> & IfcJunctionBoxTypeEnum ; } # [derive (Default , Debug)] pub struct IfcJunctionBoxType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcJunctionBoxTypeEnum , } impl IIfcRoot for IfcJunctionBoxType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcJunctionBoxType { } impl IIfcTypeObject for IfcJunctionBoxType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcJunctionBoxType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcJunctionBoxType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcJunctionBoxType { } impl IIfcDistributionFlowElementType for IfcJunctionBoxType { } impl IIfcFlowFittingType for IfcJunctionBoxType { } impl IIfcJunctionBoxType for IfcJunctionBoxType { fn predefined_type (& self) -> & IfcJunctionBoxTypeEnum { & self . predefined_type } } impl IfcJunctionBoxType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcJunctionBoxType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcLShapeProfileDef : IIfcParameterizedProfileDef { pub fn depth (& self) -> & IfcPositiveLengthMeasure ; pub fn width (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn leg_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; } # [derive (Default , Debug)] pub struct IfcLShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , depth : IfcPositiveLengthMeasure , width : Option < IfcPositiveLengthMeasure > , thickness : IfcPositiveLengthMeasure , fillet_radius : Option < IfcNonNegativeLengthMeasure > , edge_radius : Option < IfcNonNegativeLengthMeasure > , leg_slope : Option < IfcPlaneAngleMeasure > , } impl IIfcProfileDef for IfcLShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcLShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcLShapeProfileDef for IfcLShapeProfileDef { fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } fn width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . width } fn thickness (& self) -> & IfcPositiveLengthMeasure { & self . thickness } fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . fillet_radius } fn edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . edge_radius } fn leg_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . leg_slope } } impl IfcLShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . depth = parameter . into () , 4usize => entity . width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . thickness = parameter . into () , 6usize => entity . fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . leg_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLaborResource : IIfcConstructionResource { pub fn predefined_type (& self) -> & Option < IfcLaborResourceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcLaborResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , usage : Option < EntityRef < IfcResourceTime > > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : Option < IfcLaborResourceTypeEnum > , } impl IIfcRoot for IfcLaborResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcLaborResource { } impl IIfcObject for IfcLaborResource { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcResource for IfcLaborResource { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcConstructionResource for IfcLaborResource { fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > { & self . usage } fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcLaborResource for IfcLaborResource { fn predefined_type (& self) -> & Option < IfcLaborResourceTypeEnum > { & self . predefined_type } } impl IfcLaborResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLaborResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLaborResourceType : IIfcConstructionResourceType { pub fn predefined_type (& self) -> & IfcLaborResourceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcLaborResourceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , resource_type : Option < IfcLabel > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : IfcLaborResourceTypeEnum , } impl IIfcRoot for IfcLaborResourceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcLaborResourceType { } impl IIfcTypeObject for IfcLaborResourceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeResource for IfcLaborResourceType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn resource_type (& self) -> & Option < IfcLabel > { & self . resource_type } } impl IIfcConstructionResourceType for IfcLaborResourceType { fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcLaborResourceType for IfcLaborResourceType { fn predefined_type (& self) -> & IfcLaborResourceTypeEnum { & self . predefined_type } } impl IfcLaborResourceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLaborResourceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . resource_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcLagTime : IIfcSchedulingTime { pub fn lag_value (& self) -> & IfcTimeOrRatioSelect ; pub fn duration_type (& self) -> & IfcTaskDurationEnum ; } # [derive (Default , Debug)] pub struct IfcLagTime { name : Option < IfcLabel > , data_origin : Option < IfcDataOriginEnum > , user_defined_data_origin : Option < IfcLabel > , lag_value : IfcTimeOrRatioSelect , duration_type : IfcTaskDurationEnum , } impl IIfcSchedulingTime for IfcLagTime { fn name (& self) -> & Option < IfcLabel > { & self . name } fn data_origin (& self) -> & Option < IfcDataOriginEnum > { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } } impl IIfcLagTime for IfcLagTime { fn lag_value (& self) -> & IfcTimeOrRatioSelect { & self . lag_value } fn duration_type (& self) -> & IfcTaskDurationEnum { & self . duration_type } } impl IfcLagTime { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLagTime :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . lag_value = parameter . into () , 4usize => entity . duration_type = parameter . into () , _ => { } } } entity } } pub trait IIfcLamp : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcLampTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcLamp { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcLampTypeEnum > , } impl IIfcRoot for IfcLamp { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcLamp { } impl IIfcObject for IfcLamp { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcLamp { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcLamp { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcLamp { } impl IIfcDistributionFlowElement for IfcLamp { } impl IIfcFlowTerminal for IfcLamp { } impl IIfcLamp for IfcLamp { fn predefined_type (& self) -> & Option < IfcLampTypeEnum > { & self . predefined_type } } impl IfcLamp { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLamp :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLampType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcLampTypeEnum ; } # [derive (Default , Debug)] pub struct IfcLampType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcLampTypeEnum , } impl IIfcRoot for IfcLampType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcLampType { } impl IIfcTypeObject for IfcLampType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcLampType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcLampType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcLampType { } impl IIfcDistributionFlowElementType for IfcLampType { } impl IIfcFlowTerminalType for IfcLampType { } impl IIfcLampType for IfcLampType { fn predefined_type (& self) -> & IfcLampTypeEnum { & self . predefined_type } } impl IfcLampType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLampType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcLibraryInformation : IIfcExternalInformation { pub fn name (& self) -> & IfcLabel ; pub fn version (& self) -> & Option < IfcLabel > ; pub fn publisher (& self) -> & Option < EntityRef < IfcActorSelect > > ; pub fn version_date (& self) -> & Option < IfcDateTime > ; pub fn location (& self) -> & Option < IfcUriReference > ; pub fn description (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcLibraryInformation { name : IfcLabel , version : Option < IfcLabel > , publisher : Option < EntityRef < IfcActorSelect > > , version_date : Option < IfcDateTime > , location : Option < IfcUriReference > , description : Option < IfcText > , } impl IIfcExternalInformation for IfcLibraryInformation { } impl IIfcLibraryInformation for IfcLibraryInformation { fn name (& self) -> & IfcLabel { & self . name } fn version (& self) -> & Option < IfcLabel > { & self . version } fn publisher (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . publisher } fn version_date (& self) -> & Option < IfcDateTime > { & self . version_date } fn location (& self) -> & Option < IfcUriReference > { & self . location } fn description (& self) -> & Option < IfcText > { & self . description } } impl IfcLibraryInformation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLibraryInformation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . version = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . publisher = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . version_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLibraryReference : IIfcExternalReference { pub fn description (& self) -> & Option < IfcText > ; pub fn language (& self) -> & Option < IfcLanguageId > ; pub fn referenced_library (& self) -> & Option < EntityRef < IfcLibraryInformation > > ; } # [derive (Default , Debug)] pub struct IfcLibraryReference { location : Option < IfcUriReference > , identification : Option < IfcIdentifier > , name : Option < IfcLabel > , description : Option < IfcText > , language : Option < IfcLanguageId > , referenced_library : Option < EntityRef < IfcLibraryInformation > > , } impl IIfcExternalReference for IfcLibraryReference { fn location (& self) -> & Option < IfcUriReference > { & self . location } fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcLibraryReference for IfcLibraryReference { fn description (& self) -> & Option < IfcText > { & self . description } fn language (& self) -> & Option < IfcLanguageId > { & self . language } fn referenced_library (& self) -> & Option < EntityRef < IfcLibraryInformation > > { & self . referenced_library } } impl IfcLibraryReference { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLibraryReference :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . language = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . referenced_library = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLightDistributionData : { pub fn main_plane_angle (& self) -> & IfcPlaneAngleMeasure ; pub fn secondary_plane_angle (& self) -> & Vec < IfcPlaneAngleMeasure > ; pub fn luminous_intensity (& self) -> & Vec < IfcLuminousIntensityDistributionMeasure > ; } # [derive (Default , Debug)] pub struct IfcLightDistributionData { main_plane_angle : IfcPlaneAngleMeasure , secondary_plane_angle : Vec < IfcPlaneAngleMeasure > , luminous_intensity : Vec < IfcLuminousIntensityDistributionMeasure > , } impl IIfcLightDistributionData for IfcLightDistributionData { fn main_plane_angle (& self) -> & IfcPlaneAngleMeasure { & self . main_plane_angle } fn secondary_plane_angle (& self) -> & Vec < IfcPlaneAngleMeasure > { & self . secondary_plane_angle } fn luminous_intensity (& self) -> & Vec < IfcLuminousIntensityDistributionMeasure > { & self . luminous_intensity } } impl IfcLightDistributionData { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightDistributionData :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . main_plane_angle = parameter . into () , 1usize => entity . secondary_plane_angle = parameter . into () , 2usize => entity . luminous_intensity = parameter . into () , _ => { } } } entity } } pub trait IIfcLightFixture : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcLightFixtureTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcLightFixture { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcLightFixtureTypeEnum > , } impl IIfcRoot for IfcLightFixture { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcLightFixture { } impl IIfcObject for IfcLightFixture { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcLightFixture { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcLightFixture { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcLightFixture { } impl IIfcDistributionFlowElement for IfcLightFixture { } impl IIfcFlowTerminal for IfcLightFixture { } impl IIfcLightFixture for IfcLightFixture { fn predefined_type (& self) -> & Option < IfcLightFixtureTypeEnum > { & self . predefined_type } } impl IfcLightFixture { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightFixture :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLightFixtureType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcLightFixtureTypeEnum ; } # [derive (Default , Debug)] pub struct IfcLightFixtureType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcLightFixtureTypeEnum , } impl IIfcRoot for IfcLightFixtureType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcLightFixtureType { } impl IIfcTypeObject for IfcLightFixtureType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcLightFixtureType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcLightFixtureType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcLightFixtureType { } impl IIfcDistributionFlowElementType for IfcLightFixtureType { } impl IIfcFlowTerminalType for IfcLightFixtureType { } impl IIfcLightFixtureType for IfcLightFixtureType { fn predefined_type (& self) -> & IfcLightFixtureTypeEnum { & self . predefined_type } } impl IfcLightFixtureType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightFixtureType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcLightIntensityDistribution : { pub fn light_distribution_curve (& self) -> & IfcLightDistributionCurveEnum ; pub fn distribution_data (& self) -> & Vec < EntityRef < IfcLightDistributionData > > ; } # [derive (Default , Debug)] pub struct IfcLightIntensityDistribution { light_distribution_curve : IfcLightDistributionCurveEnum , distribution_data : Vec < EntityRef < IfcLightDistributionData > > , } impl IIfcLightIntensityDistribution for IfcLightIntensityDistribution { fn light_distribution_curve (& self) -> & IfcLightDistributionCurveEnum { & self . light_distribution_curve } fn distribution_data (& self) -> & Vec < EntityRef < IfcLightDistributionData > > { & self . distribution_data } } impl IfcLightIntensityDistribution { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightIntensityDistribution :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . light_distribution_curve = parameter . into () , 1usize => entity . distribution_data = parameter . into () , _ => { } } } entity } } pub trait IIfcLightSource : IIfcGeometricRepresentationItem { pub fn name (& self) -> & Option < IfcLabel > ; pub fn light_colour (& self) -> & EntityRef < IfcColourRgb > ; pub fn ambient_intensity (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn intensity (& self) -> & Option < IfcNormalisedRatioMeasure > ; } pub trait IIfcLightSourceAmbient : IIfcLightSource { } # [derive (Default , Debug)] pub struct IfcLightSourceAmbient { name : Option < IfcLabel > , light_colour : EntityRef < IfcColourRgb > , ambient_intensity : Option < IfcNormalisedRatioMeasure > , intensity : Option < IfcNormalisedRatioMeasure > , } impl IIfcRepresentationItem for IfcLightSourceAmbient { } impl IIfcGeometricRepresentationItem for IfcLightSourceAmbient { } impl IIfcLightSource for IfcLightSourceAmbient { fn name (& self) -> & Option < IfcLabel > { & self . name } fn light_colour (& self) -> & EntityRef < IfcColourRgb > { & self . light_colour } fn ambient_intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . ambient_intensity } fn intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . intensity } } impl IIfcLightSourceAmbient for IfcLightSourceAmbient { } impl IfcLightSourceAmbient { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightSourceAmbient :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . light_colour = parameter . into () , 2usize => entity . ambient_intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcLightSourceDirectional : IIfcLightSource { pub fn orientation (& self) -> & EntityRef < IfcDirection > ; } # [derive (Default , Debug)] pub struct IfcLightSourceDirectional { name : Option < IfcLabel > , light_colour : EntityRef < IfcColourRgb > , ambient_intensity : Option < IfcNormalisedRatioMeasure > , intensity : Option < IfcNormalisedRatioMeasure > , orientation : EntityRef < IfcDirection > , } impl IIfcRepresentationItem for IfcLightSourceDirectional { } impl IIfcGeometricRepresentationItem for IfcLightSourceDirectional { } impl IIfcLightSource for IfcLightSourceDirectional { fn name (& self) -> & Option < IfcLabel > { & self . name } fn light_colour (& self) -> & EntityRef < IfcColourRgb > { & self . light_colour } fn ambient_intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . ambient_intensity } fn intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . intensity } } impl IIfcLightSourceDirectional for IfcLightSourceDirectional { fn orientation (& self) -> & EntityRef < IfcDirection > { & self . orientation } } impl IfcLightSourceDirectional { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightSourceDirectional :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . light_colour = parameter . into () , 2usize => entity . ambient_intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . orientation = parameter . into () , _ => { } } } entity } } pub trait IIfcLightSourceGoniometric : IIfcLightSource { pub fn position (& self) -> & EntityRef < IfcAxis2Placement3D > ; pub fn colour_appearance (& self) -> & Option < EntityRef < IfcColourRgb > > ; pub fn colour_temperature (& self) -> & IfcThermodynamicTemperatureMeasure ; pub fn luminous_flux (& self) -> & IfcLuminousFluxMeasure ; pub fn light_emission_source (& self) -> & IfcLightEmissionSourceEnum ; pub fn light_distribution_data_source (& self) -> & EntityRef < IfcLightDistributionDataSourceSelect > ; } # [derive (Default , Debug)] pub struct IfcLightSourceGoniometric { name : Option < IfcLabel > , light_colour : EntityRef < IfcColourRgb > , ambient_intensity : Option < IfcNormalisedRatioMeasure > , intensity : Option < IfcNormalisedRatioMeasure > , position : EntityRef < IfcAxis2Placement3D > , colour_appearance : Option < EntityRef < IfcColourRgb > > , colour_temperature : IfcThermodynamicTemperatureMeasure , luminous_flux : IfcLuminousFluxMeasure , light_emission_source : IfcLightEmissionSourceEnum , light_distribution_data_source : EntityRef < IfcLightDistributionDataSourceSelect > , } impl IIfcRepresentationItem for IfcLightSourceGoniometric { } impl IIfcGeometricRepresentationItem for IfcLightSourceGoniometric { } impl IIfcLightSource for IfcLightSourceGoniometric { fn name (& self) -> & Option < IfcLabel > { & self . name } fn light_colour (& self) -> & EntityRef < IfcColourRgb > { & self . light_colour } fn ambient_intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . ambient_intensity } fn intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . intensity } } impl IIfcLightSourceGoniometric for IfcLightSourceGoniometric { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } fn colour_appearance (& self) -> & Option < EntityRef < IfcColourRgb > > { & self . colour_appearance } fn colour_temperature (& self) -> & IfcThermodynamicTemperatureMeasure { & self . colour_temperature } fn luminous_flux (& self) -> & IfcLuminousFluxMeasure { & self . luminous_flux } fn light_emission_source (& self) -> & IfcLightEmissionSourceEnum { & self . light_emission_source } fn light_distribution_data_source (& self) -> & EntityRef < IfcLightDistributionDataSourceSelect > { & self . light_distribution_data_source } } impl IfcLightSourceGoniometric { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightSourceGoniometric :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . light_colour = parameter . into () , 2usize => entity . ambient_intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . position = parameter . into () , 5usize => entity . colour_appearance = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . colour_temperature = parameter . into () , 7usize => entity . luminous_flux = parameter . into () , 8usize => entity . light_emission_source = parameter . into () , 9usize => entity . light_distribution_data_source = parameter . into () , _ => { } } } entity } } pub trait IIfcLightSourcePositional : IIfcLightSource { pub fn position (& self) -> & EntityRef < IfcCartesianPoint > ; pub fn radius (& self) -> & IfcPositiveLengthMeasure ; pub fn constant_attenuation (& self) -> & IfcReal ; pub fn distance_attenuation (& self) -> & IfcReal ; pub fn quadric_attenuation (& self) -> & IfcReal ; } # [derive (Default , Debug)] pub struct IfcLightSourcePositional { name : Option < IfcLabel > , light_colour : EntityRef < IfcColourRgb > , ambient_intensity : Option < IfcNormalisedRatioMeasure > , intensity : Option < IfcNormalisedRatioMeasure > , position : EntityRef < IfcCartesianPoint > , radius : IfcPositiveLengthMeasure , constant_attenuation : IfcReal , distance_attenuation : IfcReal , quadric_attenuation : IfcReal , } impl IIfcRepresentationItem for IfcLightSourcePositional { } impl IIfcGeometricRepresentationItem for IfcLightSourcePositional { } impl IIfcLightSource for IfcLightSourcePositional { fn name (& self) -> & Option < IfcLabel > { & self . name } fn light_colour (& self) -> & EntityRef < IfcColourRgb > { & self . light_colour } fn ambient_intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . ambient_intensity } fn intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . intensity } } impl IIfcLightSourcePositional for IfcLightSourcePositional { fn position (& self) -> & EntityRef < IfcCartesianPoint > { & self . position } fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } fn constant_attenuation (& self) -> & IfcReal { & self . constant_attenuation } fn distance_attenuation (& self) -> & IfcReal { & self . distance_attenuation } fn quadric_attenuation (& self) -> & IfcReal { & self . quadric_attenuation } } impl IfcLightSourcePositional { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightSourcePositional :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . light_colour = parameter . into () , 2usize => entity . ambient_intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . position = parameter . into () , 5usize => entity . radius = parameter . into () , 6usize => entity . constant_attenuation = parameter . into () , 7usize => entity . distance_attenuation = parameter . into () , 8usize => entity . quadric_attenuation = parameter . into () , _ => { } } } entity } } pub trait IIfcLightSourceSpot : IIfcLightSourcePositional { pub fn orientation (& self) -> & EntityRef < IfcDirection > ; pub fn concentration_exponent (& self) -> & Option < IfcReal > ; pub fn spread_angle (& self) -> & IfcPositivePlaneAngleMeasure ; pub fn beam_width_angle (& self) -> & IfcPositivePlaneAngleMeasure ; } # [derive (Default , Debug)] pub struct IfcLightSourceSpot { name : Option < IfcLabel > , light_colour : EntityRef < IfcColourRgb > , ambient_intensity : Option < IfcNormalisedRatioMeasure > , intensity : Option < IfcNormalisedRatioMeasure > , position : EntityRef < IfcCartesianPoint > , radius : IfcPositiveLengthMeasure , constant_attenuation : IfcReal , distance_attenuation : IfcReal , quadric_attenuation : IfcReal , orientation : EntityRef < IfcDirection > , concentration_exponent : Option < IfcReal > , spread_angle : IfcPositivePlaneAngleMeasure , beam_width_angle : IfcPositivePlaneAngleMeasure , } impl IIfcRepresentationItem for IfcLightSourceSpot { } impl IIfcGeometricRepresentationItem for IfcLightSourceSpot { } impl IIfcLightSource for IfcLightSourceSpot { fn name (& self) -> & Option < IfcLabel > { & self . name } fn light_colour (& self) -> & EntityRef < IfcColourRgb > { & self . light_colour } fn ambient_intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . ambient_intensity } fn intensity (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . intensity } } impl IIfcLightSourcePositional for IfcLightSourceSpot { fn position (& self) -> & EntityRef < IfcCartesianPoint > { & self . position } fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } fn constant_attenuation (& self) -> & IfcReal { & self . constant_attenuation } fn distance_attenuation (& self) -> & IfcReal { & self . distance_attenuation } fn quadric_attenuation (& self) -> & IfcReal { & self . quadric_attenuation } } impl IIfcLightSourceSpot for IfcLightSourceSpot { fn orientation (& self) -> & EntityRef < IfcDirection > { & self . orientation } fn concentration_exponent (& self) -> & Option < IfcReal > { & self . concentration_exponent } fn spread_angle (& self) -> & IfcPositivePlaneAngleMeasure { & self . spread_angle } fn beam_width_angle (& self) -> & IfcPositivePlaneAngleMeasure { & self . beam_width_angle } } impl IfcLightSourceSpot { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLightSourceSpot :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . light_colour = parameter . into () , 2usize => entity . ambient_intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . intensity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . position = parameter . into () , 5usize => entity . radius = parameter . into () , 6usize => entity . constant_attenuation = parameter . into () , 7usize => entity . distance_attenuation = parameter . into () , 8usize => entity . quadric_attenuation = parameter . into () , 9usize => entity . orientation = parameter . into () , 10usize => entity . concentration_exponent = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . spread_angle = parameter . into () , 12usize => entity . beam_width_angle = parameter . into () , _ => { } } } entity } } pub trait IIfcLine : IIfcCurve { pub fn pnt (& self) -> & EntityRef < IfcCartesianPoint > ; pub fn dir (& self) -> & EntityRef < IfcVector > ; } # [derive (Default , Debug)] pub struct IfcLine { pnt : EntityRef < IfcCartesianPoint > , dir : EntityRef < IfcVector > , } impl IIfcRepresentationItem for IfcLine { } impl IIfcGeometricRepresentationItem for IfcLine { } impl IIfcCurve for IfcLine { } impl IIfcLine for IfcLine { fn pnt (& self) -> & EntityRef < IfcCartesianPoint > { & self . pnt } fn dir (& self) -> & EntityRef < IfcVector > { & self . dir } } impl IfcLine { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLine :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . pnt = parameter . into () , 1usize => entity . dir = parameter . into () , _ => { } } } entity } } pub trait IIfcLocalPlacement : IIfcObjectPlacement { pub fn placement_rel_to (& self) -> & Option < EntityRef < IfcObjectPlacement > > ; pub fn relative_placement (& self) -> & EntityRef < IfcAxis2Placement > ; } # [derive (Default , Debug)] pub struct IfcLocalPlacement { placement_rel_to : Option < EntityRef < IfcObjectPlacement > > , relative_placement : EntityRef < IfcAxis2Placement > , } impl IIfcObjectPlacement for IfcLocalPlacement { } impl IIfcLocalPlacement for IfcLocalPlacement { fn placement_rel_to (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . placement_rel_to } fn relative_placement (& self) -> & EntityRef < IfcAxis2Placement > { & self . relative_placement } } impl IfcLocalPlacement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcLocalPlacement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . placement_rel_to = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . relative_placement = parameter . into () , _ => { } } } entity } } pub trait IIfcLoop : IIfcTopologicalRepresentationItem { } # [derive (Default , Debug)] pub struct IfcLoop { } impl IIfcRepresentationItem for IfcLoop { } impl IIfcTopologicalRepresentationItem for IfcLoop { } impl IIfcLoop for IfcLoop { } impl IfcLoop { pub fn form_parameters (_parameters : Vec < Parameter >) -> Self { IfcLoop :: default () } } pub trait IIfcManifoldSolidBrep : IIfcSolidModel { pub fn outer (& self) -> & EntityRef < IfcClosedShell > ; } pub trait IIfcMapConversion : IIfcCoordinateOperation { pub fn eastings (& self) -> & IfcLengthMeasure ; pub fn northings (& self) -> & IfcLengthMeasure ; pub fn orthogonal_height (& self) -> & IfcLengthMeasure ; pub fn x_axis_abscissa (& self) -> & Option < IfcReal > ; pub fn x_axis_ordinate (& self) -> & Option < IfcReal > ; pub fn scale (& self) -> & Option < IfcReal > ; } # [derive (Default , Debug)] pub struct IfcMapConversion { source_crs : EntityRef < IfcCoordinateReferenceSystemSelect > , target_crs : EntityRef < IfcCoordinateReferenceSystem > , eastings : IfcLengthMeasure , northings : IfcLengthMeasure , orthogonal_height : IfcLengthMeasure , x_axis_abscissa : Option < IfcReal > , x_axis_ordinate : Option < IfcReal > , scale : Option < IfcReal > , } impl IIfcCoordinateOperation for IfcMapConversion { fn source_crs (& self) -> & EntityRef < IfcCoordinateReferenceSystemSelect > { & self . source_crs } fn target_crs (& self) -> & EntityRef < IfcCoordinateReferenceSystem > { & self . target_crs } } impl IIfcMapConversion for IfcMapConversion { fn eastings (& self) -> & IfcLengthMeasure { & self . eastings } fn northings (& self) -> & IfcLengthMeasure { & self . northings } fn orthogonal_height (& self) -> & IfcLengthMeasure { & self . orthogonal_height } fn x_axis_abscissa (& self) -> & Option < IfcReal > { & self . x_axis_abscissa } fn x_axis_ordinate (& self) -> & Option < IfcReal > { & self . x_axis_ordinate } fn scale (& self) -> & Option < IfcReal > { & self . scale } } impl IfcMapConversion { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMapConversion :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . source_crs = parameter . into () , 1usize => entity . target_crs = parameter . into () , 2usize => entity . eastings = parameter . into () , 3usize => entity . northings = parameter . into () , 4usize => entity . orthogonal_height = parameter . into () , 5usize => entity . x_axis_abscissa = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . x_axis_ordinate = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . scale = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMappedItem : IIfcRepresentationItem { pub fn mapping_source (& self) -> & EntityRef < IfcRepresentationMap > ; pub fn mapping_target (& self) -> & EntityRef < IfcCartesianTransformationOperator > ; } # [derive (Default , Debug)] pub struct IfcMappedItem { mapping_source : EntityRef < IfcRepresentationMap > , mapping_target : EntityRef < IfcCartesianTransformationOperator > , } impl IIfcRepresentationItem for IfcMappedItem { } impl IIfcMappedItem for IfcMappedItem { fn mapping_source (& self) -> & EntityRef < IfcRepresentationMap > { & self . mapping_source } fn mapping_target (& self) -> & EntityRef < IfcCartesianTransformationOperator > { & self . mapping_target } } impl IfcMappedItem { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMappedItem :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . mapping_source = parameter . into () , 1usize => entity . mapping_target = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterial : IIfcMaterialDefinition { pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn category (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcMaterial { name : IfcLabel , description : Option < IfcText > , category : Option < IfcLabel > , } impl IIfcMaterialDefinition for IfcMaterial { } impl IIfcMaterial for IfcMaterial { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn category (& self) -> & Option < IfcLabel > { & self . category } } impl IfcMaterial { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterial :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialClassificationRelationship : { pub fn material_classifications (& self) -> & HashSet < EntityRef < IfcClassificationSelect > > ; pub fn classified_material (& self) -> & EntityRef < IfcMaterial > ; } # [derive (Default , Debug)] pub struct IfcMaterialClassificationRelationship { material_classifications : HashSet < EntityRef < IfcClassificationSelect > > , classified_material : EntityRef < IfcMaterial > , } impl IIfcMaterialClassificationRelationship for IfcMaterialClassificationRelationship { fn material_classifications (& self) -> & HashSet < EntityRef < IfcClassificationSelect > > { & self . material_classifications } fn classified_material (& self) -> & EntityRef < IfcMaterial > { & self . classified_material } } impl IfcMaterialClassificationRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialClassificationRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . material_classifications = parameter . into () , 1usize => entity . classified_material = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterialConstituent : IIfcMaterialDefinition { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn material (& self) -> & EntityRef < IfcMaterial > ; pub fn fraction (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn category (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcMaterialConstituent { name : Option < IfcLabel > , description : Option < IfcText > , material : EntityRef < IfcMaterial > , fraction : Option < IfcNormalisedRatioMeasure > , category : Option < IfcLabel > , } impl IIfcMaterialDefinition for IfcMaterialConstituent { } impl IIfcMaterialConstituent for IfcMaterialConstituent { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn material (& self) -> & EntityRef < IfcMaterial > { & self . material } fn fraction (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . fraction } fn category (& self) -> & Option < IfcLabel > { & self . category } } impl IfcMaterialConstituent { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialConstituent :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . material = parameter . into () , 3usize => entity . fraction = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialConstituentSet : IIfcMaterialDefinition { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn material_constituents (& self) -> & Option < HashSet < EntityRef < IfcMaterialConstituent > > > ; } # [derive (Default , Debug)] pub struct IfcMaterialConstituentSet { name : Option < IfcLabel > , description : Option < IfcText > , material_constituents : Option < HashSet < EntityRef < IfcMaterialConstituent > > > , } impl IIfcMaterialDefinition for IfcMaterialConstituentSet { } impl IIfcMaterialConstituentSet for IfcMaterialConstituentSet { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn material_constituents (& self) -> & Option < HashSet < EntityRef < IfcMaterialConstituent > > > { & self . material_constituents } } impl IfcMaterialConstituentSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialConstituentSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . material_constituents = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialDefinition : { } pub trait IIfcMaterialDefinitionRepresentation : IIfcProductRepresentation { pub fn represented_material (& self) -> & EntityRef < IfcMaterial > ; } # [derive (Default , Debug)] pub struct IfcMaterialDefinitionRepresentation { name : Option < IfcLabel > , description : Option < IfcText > , representations : Vec < EntityRef < IfcRepresentation > > , represented_material : EntityRef < IfcMaterial > , } impl IIfcProductRepresentation for IfcMaterialDefinitionRepresentation { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn representations (& self) -> & Vec < EntityRef < IfcRepresentation > > { & self . representations } } impl IIfcMaterialDefinitionRepresentation for IfcMaterialDefinitionRepresentation { fn represented_material (& self) -> & EntityRef < IfcMaterial > { & self . represented_material } } impl IfcMaterialDefinitionRepresentation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialDefinitionRepresentation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . representations = parameter . into () , 3usize => entity . represented_material = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterialLayer : IIfcMaterialDefinition { pub fn material (& self) -> & Option < EntityRef < IfcMaterial > > ; pub fn layer_thickness (& self) -> & IfcNonNegativeLengthMeasure ; pub fn is_ventilated (& self) -> & Option < IfcLogical > ; pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn category (& self) -> & Option < IfcLabel > ; pub fn priority (& self) -> & Option < IfcInteger > ; } # [derive (Default , Debug)] pub struct IfcMaterialLayer { material : Option < EntityRef < IfcMaterial > > , layer_thickness : IfcNonNegativeLengthMeasure , is_ventilated : Option < IfcLogical > , name : Option < IfcLabel > , description : Option < IfcText > , category : Option < IfcLabel > , priority : Option < IfcInteger > , } impl IIfcMaterialDefinition for IfcMaterialLayer { } impl IIfcMaterialLayer for IfcMaterialLayer { fn material (& self) -> & Option < EntityRef < IfcMaterial > > { & self . material } fn layer_thickness (& self) -> & IfcNonNegativeLengthMeasure { & self . layer_thickness } fn is_ventilated (& self) -> & Option < IfcLogical > { & self . is_ventilated } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn category (& self) -> & Option < IfcLabel > { & self . category } fn priority (& self) -> & Option < IfcInteger > { & self . priority } } impl IfcMaterialLayer { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialLayer :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . material = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . layer_thickness = parameter . into () , 2usize => entity . is_ventilated = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . priority = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialLayerSet : IIfcMaterialDefinition { pub fn material_layers (& self) -> & Vec < EntityRef < IfcMaterialLayer > > ; pub fn layer_set_name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcMaterialLayerSet { material_layers : Vec < EntityRef < IfcMaterialLayer > > , layer_set_name : Option < IfcLabel > , description : Option < IfcText > , } impl IIfcMaterialDefinition for IfcMaterialLayerSet { } impl IIfcMaterialLayerSet for IfcMaterialLayerSet { fn material_layers (& self) -> & Vec < EntityRef < IfcMaterialLayer > > { & self . material_layers } fn layer_set_name (& self) -> & Option < IfcLabel > { & self . layer_set_name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IfcMaterialLayerSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialLayerSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . material_layers = parameter . into () , 1usize => entity . layer_set_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialLayerSetUsage : IIfcMaterialUsageDefinition { pub fn for_layer_set (& self) -> & EntityRef < IfcMaterialLayerSet > ; pub fn layer_set_direction (& self) -> & IfcLayerSetDirectionEnum ; pub fn direction_sense (& self) -> & IfcDirectionSenseEnum ; pub fn offset_from_reference_line (& self) -> & IfcLengthMeasure ; pub fn reference_extent (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcMaterialLayerSetUsage { for_layer_set : EntityRef < IfcMaterialLayerSet > , layer_set_direction : IfcLayerSetDirectionEnum , direction_sense : IfcDirectionSenseEnum , offset_from_reference_line : IfcLengthMeasure , reference_extent : Option < IfcPositiveLengthMeasure > , } impl IIfcMaterialUsageDefinition for IfcMaterialLayerSetUsage { } impl IIfcMaterialLayerSetUsage for IfcMaterialLayerSetUsage { fn for_layer_set (& self) -> & EntityRef < IfcMaterialLayerSet > { & self . for_layer_set } fn layer_set_direction (& self) -> & IfcLayerSetDirectionEnum { & self . layer_set_direction } fn direction_sense (& self) -> & IfcDirectionSenseEnum { & self . direction_sense } fn offset_from_reference_line (& self) -> & IfcLengthMeasure { & self . offset_from_reference_line } fn reference_extent (& self) -> & Option < IfcPositiveLengthMeasure > { & self . reference_extent } } impl IfcMaterialLayerSetUsage { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialLayerSetUsage :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . for_layer_set = parameter . into () , 1usize => entity . layer_set_direction = parameter . into () , 2usize => entity . direction_sense = parameter . into () , 3usize => entity . offset_from_reference_line = parameter . into () , 4usize => entity . reference_extent = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialLayerWithOffsets : IIfcMaterialLayer { pub fn offset_direction (& self) -> & IfcLayerSetDirectionEnum ; pub fn offset_values (& self) -> & Vec < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcMaterialLayerWithOffsets { material : Option < EntityRef < IfcMaterial > > , layer_thickness : IfcNonNegativeLengthMeasure , is_ventilated : Option < IfcLogical > , name : Option < IfcLabel > , description : Option < IfcText > , category : Option < IfcLabel > , priority : Option < IfcInteger > , offset_direction : IfcLayerSetDirectionEnum , offset_values : Vec < IfcLengthMeasure > , } impl IIfcMaterialDefinition for IfcMaterialLayerWithOffsets { } impl IIfcMaterialLayer for IfcMaterialLayerWithOffsets { fn material (& self) -> & Option < EntityRef < IfcMaterial > > { & self . material } fn layer_thickness (& self) -> & IfcNonNegativeLengthMeasure { & self . layer_thickness } fn is_ventilated (& self) -> & Option < IfcLogical > { & self . is_ventilated } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn category (& self) -> & Option < IfcLabel > { & self . category } fn priority (& self) -> & Option < IfcInteger > { & self . priority } } impl IIfcMaterialLayerWithOffsets for IfcMaterialLayerWithOffsets { fn offset_direction (& self) -> & IfcLayerSetDirectionEnum { & self . offset_direction } fn offset_values (& self) -> & Vec < IfcLengthMeasure > { & self . offset_values } } impl IfcMaterialLayerWithOffsets { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialLayerWithOffsets :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . material = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . layer_thickness = parameter . into () , 2usize => entity . is_ventilated = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . priority = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . offset_direction = parameter . into () , 8usize => entity . offset_values = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterialList : { pub fn materials (& self) -> & Vec < EntityRef < IfcMaterial > > ; } # [derive (Default , Debug)] pub struct IfcMaterialList { materials : Vec < EntityRef < IfcMaterial > > , } impl IIfcMaterialList for IfcMaterialList { fn materials (& self) -> & Vec < EntityRef < IfcMaterial > > { & self . materials } } impl IfcMaterialList { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialList :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . materials = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterialProfile : IIfcMaterialDefinition { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn material (& self) -> & Option < EntityRef < IfcMaterial > > ; pub fn profile (& self) -> & EntityRef < IfcProfileDef > ; pub fn priority (& self) -> & Option < IfcInteger > ; pub fn category (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcMaterialProfile { name : Option < IfcLabel > , description : Option < IfcText > , material : Option < EntityRef < IfcMaterial > > , profile : EntityRef < IfcProfileDef > , priority : Option < IfcInteger > , category : Option < IfcLabel > , } impl IIfcMaterialDefinition for IfcMaterialProfile { } impl IIfcMaterialProfile for IfcMaterialProfile { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn material (& self) -> & Option < EntityRef < IfcMaterial > > { & self . material } fn profile (& self) -> & EntityRef < IfcProfileDef > { & self . profile } fn priority (& self) -> & Option < IfcInteger > { & self . priority } fn category (& self) -> & Option < IfcLabel > { & self . category } } impl IfcMaterialProfile { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialProfile :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . material = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . profile = parameter . into () , 4usize => entity . priority = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialProfileSet : IIfcMaterialDefinition { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn material_profiles (& self) -> & Vec < EntityRef < IfcMaterialProfile > > ; pub fn composite_profile (& self) -> & Option < EntityRef < IfcCompositeProfileDef > > ; } # [derive (Default , Debug)] pub struct IfcMaterialProfileSet { name : Option < IfcLabel > , description : Option < IfcText > , material_profiles : Vec < EntityRef < IfcMaterialProfile > > , composite_profile : Option < EntityRef < IfcCompositeProfileDef > > , } impl IIfcMaterialDefinition for IfcMaterialProfileSet { } impl IIfcMaterialProfileSet for IfcMaterialProfileSet { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn material_profiles (& self) -> & Vec < EntityRef < IfcMaterialProfile > > { & self . material_profiles } fn composite_profile (& self) -> & Option < EntityRef < IfcCompositeProfileDef > > { & self . composite_profile } } impl IfcMaterialProfileSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialProfileSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . material_profiles = parameter . into () , 3usize => entity . composite_profile = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialProfileSetUsage : IIfcMaterialUsageDefinition { pub fn for_profile_set (& self) -> & EntityRef < IfcMaterialProfileSet > ; pub fn cardinal_point (& self) -> & Option < IfcCardinalPointReference > ; pub fn reference_extent (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcMaterialProfileSetUsage { for_profile_set : EntityRef < IfcMaterialProfileSet > , cardinal_point : Option < IfcCardinalPointReference > , reference_extent : Option < IfcPositiveLengthMeasure > , } impl IIfcMaterialUsageDefinition for IfcMaterialProfileSetUsage { } impl IIfcMaterialProfileSetUsage for IfcMaterialProfileSetUsage { fn for_profile_set (& self) -> & EntityRef < IfcMaterialProfileSet > { & self . for_profile_set } fn cardinal_point (& self) -> & Option < IfcCardinalPointReference > { & self . cardinal_point } fn reference_extent (& self) -> & Option < IfcPositiveLengthMeasure > { & self . reference_extent } } impl IfcMaterialProfileSetUsage { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialProfileSetUsage :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . for_profile_set = parameter . into () , 1usize => entity . cardinal_point = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . reference_extent = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialProfileSetUsageTapering : IIfcMaterialProfileSetUsage { pub fn for_profile_end_set (& self) -> & EntityRef < IfcMaterialProfileSet > ; pub fn cardinal_end_point (& self) -> & Option < IfcCardinalPointReference > ; } # [derive (Default , Debug)] pub struct IfcMaterialProfileSetUsageTapering { for_profile_set : EntityRef < IfcMaterialProfileSet > , cardinal_point : Option < IfcCardinalPointReference > , reference_extent : Option < IfcPositiveLengthMeasure > , for_profile_end_set : EntityRef < IfcMaterialProfileSet > , cardinal_end_point : Option < IfcCardinalPointReference > , } impl IIfcMaterialUsageDefinition for IfcMaterialProfileSetUsageTapering { } impl IIfcMaterialProfileSetUsage for IfcMaterialProfileSetUsageTapering { fn for_profile_set (& self) -> & EntityRef < IfcMaterialProfileSet > { & self . for_profile_set } fn cardinal_point (& self) -> & Option < IfcCardinalPointReference > { & self . cardinal_point } fn reference_extent (& self) -> & Option < IfcPositiveLengthMeasure > { & self . reference_extent } } impl IIfcMaterialProfileSetUsageTapering for IfcMaterialProfileSetUsageTapering { fn for_profile_end_set (& self) -> & EntityRef < IfcMaterialProfileSet > { & self . for_profile_end_set } fn cardinal_end_point (& self) -> & Option < IfcCardinalPointReference > { & self . cardinal_end_point } } impl IfcMaterialProfileSetUsageTapering { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialProfileSetUsageTapering :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . for_profile_set = parameter . into () , 1usize => entity . cardinal_point = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . reference_extent = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . for_profile_end_set = parameter . into () , 4usize => entity . cardinal_end_point = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialProfileWithOffsets : IIfcMaterialProfile { pub fn offset_values (& self) -> & Vec < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcMaterialProfileWithOffsets { name : Option < IfcLabel > , description : Option < IfcText > , material : Option < EntityRef < IfcMaterial > > , profile : EntityRef < IfcProfileDef > , priority : Option < IfcInteger > , category : Option < IfcLabel > , offset_values : Vec < IfcLengthMeasure > , } impl IIfcMaterialDefinition for IfcMaterialProfileWithOffsets { } impl IIfcMaterialProfile for IfcMaterialProfileWithOffsets { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn material (& self) -> & Option < EntityRef < IfcMaterial > > { & self . material } fn profile (& self) -> & EntityRef < IfcProfileDef > { & self . profile } fn priority (& self) -> & Option < IfcInteger > { & self . priority } fn category (& self) -> & Option < IfcLabel > { & self . category } } impl IIfcMaterialProfileWithOffsets for IfcMaterialProfileWithOffsets { fn offset_values (& self) -> & Vec < IfcLengthMeasure > { & self . offset_values } } impl IfcMaterialProfileWithOffsets { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialProfileWithOffsets :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . material = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . profile = parameter . into () , 4usize => entity . priority = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . category = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . offset_values = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterialProperties : IIfcExtendedProperties { pub fn material (& self) -> & EntityRef < IfcMaterialDefinition > ; } # [derive (Default , Debug)] pub struct IfcMaterialProperties { name : Option < IfcIdentifier > , description : Option < IfcText > , properties : HashSet < EntityRef < IfcProperty > > , material : EntityRef < IfcMaterialDefinition > , } impl IIfcPropertyAbstraction for IfcMaterialProperties { } impl IIfcExtendedProperties for IfcMaterialProperties { fn name (& self) -> & Option < IfcIdentifier > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn properties (& self) -> & HashSet < EntityRef < IfcProperty > > { & self . properties } } impl IIfcMaterialProperties for IfcMaterialProperties { fn material (& self) -> & EntityRef < IfcMaterialDefinition > { & self . material } } impl IfcMaterialProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . properties = parameter . into () , 3usize => entity . material = parameter . into () , _ => { } } } entity } } pub trait IIfcMaterialRelationship : IIfcResourceLevelRelationship { pub fn relating_material (& self) -> & EntityRef < IfcMaterial > ; pub fn related_materials (& self) -> & HashSet < EntityRef < IfcMaterial > > ; pub fn expression (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcMaterialRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_material : EntityRef < IfcMaterial > , related_materials : HashSet < EntityRef < IfcMaterial > > , expression : Option < IfcLabel > , } impl IIfcResourceLevelRelationship for IfcMaterialRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcMaterialRelationship for IfcMaterialRelationship { fn relating_material (& self) -> & EntityRef < IfcMaterial > { & self . relating_material } fn related_materials (& self) -> & HashSet < EntityRef < IfcMaterial > > { & self . related_materials } fn expression (& self) -> & Option < IfcLabel > { & self . expression } } impl IfcMaterialRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMaterialRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_material = parameter . into () , 3usize => entity . related_materials = parameter . into () , 4usize => entity . expression = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMaterialUsageDefinition : { } pub trait IIfcMeasureWithUnit : { pub fn value_component (& self) -> & IfcValue ; pub fn unit_component (& self) -> & EntityRef < IfcUnit > ; } # [derive (Default , Debug)] pub struct IfcMeasureWithUnit { value_component : IfcValue , unit_component : EntityRef < IfcUnit > , } impl IIfcMeasureWithUnit for IfcMeasureWithUnit { fn value_component (& self) -> & IfcValue { & self . value_component } fn unit_component (& self) -> & EntityRef < IfcUnit > { & self . unit_component } } impl IfcMeasureWithUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMeasureWithUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . value_component = parameter . into () , 1usize => entity . unit_component = parameter . into () , _ => { } } } entity } } pub trait IIfcMechanicalFastener : IIfcElementComponent { pub fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn nominal_length (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn predefined_type (& self) -> & Option < IfcMechanicalFastenerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcMechanicalFastener { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , nominal_diameter : Option < IfcPositiveLengthMeasure > , nominal_length : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcMechanicalFastenerTypeEnum > , } impl IIfcRoot for IfcMechanicalFastener { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMechanicalFastener { } impl IIfcObject for IfcMechanicalFastener { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcMechanicalFastener { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcMechanicalFastener { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcMechanicalFastener { } impl IIfcMechanicalFastener for IfcMechanicalFastener { fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_diameter } fn nominal_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_length } fn predefined_type (& self) -> & Option < IfcMechanicalFastenerTypeEnum > { & self . predefined_type } } impl IfcMechanicalFastener { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMechanicalFastener :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . nominal_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMechanicalFastenerType : IIfcElementComponentType { pub fn predefined_type (& self) -> & IfcMechanicalFastenerTypeEnum ; pub fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn nominal_length (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcMechanicalFastenerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcMechanicalFastenerTypeEnum , nominal_diameter : Option < IfcPositiveLengthMeasure > , nominal_length : Option < IfcPositiveLengthMeasure > , } impl IIfcRoot for IfcMechanicalFastenerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMechanicalFastenerType { } impl IIfcTypeObject for IfcMechanicalFastenerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcMechanicalFastenerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcMechanicalFastenerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcMechanicalFastenerType { } impl IIfcMechanicalFastenerType for IfcMechanicalFastenerType { fn predefined_type (& self) -> & IfcMechanicalFastenerTypeEnum { & self . predefined_type } fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_diameter } fn nominal_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_length } } impl IfcMechanicalFastenerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMechanicalFastenerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . nominal_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMedicalDevice : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcMedicalDeviceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcMedicalDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcMedicalDeviceTypeEnum > , } impl IIfcRoot for IfcMedicalDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMedicalDevice { } impl IIfcObject for IfcMedicalDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcMedicalDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcMedicalDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcMedicalDevice { } impl IIfcDistributionFlowElement for IfcMedicalDevice { } impl IIfcFlowTerminal for IfcMedicalDevice { } impl IIfcMedicalDevice for IfcMedicalDevice { fn predefined_type (& self) -> & Option < IfcMedicalDeviceTypeEnum > { & self . predefined_type } } impl IfcMedicalDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMedicalDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMedicalDeviceType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcMedicalDeviceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcMedicalDeviceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcMedicalDeviceTypeEnum , } impl IIfcRoot for IfcMedicalDeviceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMedicalDeviceType { } impl IIfcTypeObject for IfcMedicalDeviceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcMedicalDeviceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcMedicalDeviceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcMedicalDeviceType { } impl IIfcDistributionFlowElementType for IfcMedicalDeviceType { } impl IIfcFlowTerminalType for IfcMedicalDeviceType { } impl IIfcMedicalDeviceType for IfcMedicalDeviceType { fn predefined_type (& self) -> & IfcMedicalDeviceTypeEnum { & self . predefined_type } } impl IfcMedicalDeviceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMedicalDeviceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcMember : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcMemberTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcMember { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcMemberTypeEnum > , } impl IIfcRoot for IfcMember { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMember { } impl IIfcObject for IfcMember { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcMember { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcMember { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcMember { } impl IIfcMember for IfcMember { fn predefined_type (& self) -> & Option < IfcMemberTypeEnum > { & self . predefined_type } } impl IfcMember { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMember :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMemberStandardCase : IIfcMember { } # [derive (Default , Debug)] pub struct IfcMemberStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcMemberTypeEnum > , } impl IIfcRoot for IfcMemberStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMemberStandardCase { } impl IIfcObject for IfcMemberStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcMemberStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcMemberStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcMemberStandardCase { } impl IIfcMember for IfcMemberStandardCase { fn predefined_type (& self) -> & Option < IfcMemberTypeEnum > { & self . predefined_type } } impl IIfcMemberStandardCase for IfcMemberStandardCase { } impl IfcMemberStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMemberStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMemberType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcMemberTypeEnum ; } # [derive (Default , Debug)] pub struct IfcMemberType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcMemberTypeEnum , } impl IIfcRoot for IfcMemberType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMemberType { } impl IIfcTypeObject for IfcMemberType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcMemberType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcMemberType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcMemberType { } impl IIfcMemberType for IfcMemberType { fn predefined_type (& self) -> & IfcMemberTypeEnum { & self . predefined_type } } impl IfcMemberType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMemberType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcMetric : IIfcConstraint { pub fn benchmark (& self) -> & IfcBenchmarkEnum ; pub fn value_source (& self) -> & Option < IfcLabel > ; pub fn data_value (& self) -> & Option < IfcMetricValueSelect > ; pub fn reference_path (& self) -> & Option < EntityRef < IfcReference > > ; } # [derive (Default , Debug)] pub struct IfcMetric { name : IfcLabel , description : Option < IfcText > , constraint_grade : IfcConstraintEnum , constraint_source : Option < IfcLabel > , creating_actor : Option < EntityRef < IfcActorSelect > > , creation_time : Option < IfcDateTime > , user_defined_grade : Option < IfcLabel > , benchmark : IfcBenchmarkEnum , value_source : Option < IfcLabel > , data_value : Option < IfcMetricValueSelect > , reference_path : Option < EntityRef < IfcReference > > , } impl IIfcConstraint for IfcMetric { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn constraint_grade (& self) -> & IfcConstraintEnum { & self . constraint_grade } fn constraint_source (& self) -> & Option < IfcLabel > { & self . constraint_source } fn creating_actor (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . creating_actor } fn creation_time (& self) -> & Option < IfcDateTime > { & self . creation_time } fn user_defined_grade (& self) -> & Option < IfcLabel > { & self . user_defined_grade } } impl IIfcMetric for IfcMetric { fn benchmark (& self) -> & IfcBenchmarkEnum { & self . benchmark } fn value_source (& self) -> & Option < IfcLabel > { & self . value_source } fn data_value (& self) -> & Option < IfcMetricValueSelect > { & self . data_value } fn reference_path (& self) -> & Option < EntityRef < IfcReference > > { & self . reference_path } } impl IfcMetric { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMetric :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . constraint_grade = parameter . into () , 3usize => entity . constraint_source = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . creating_actor = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . creation_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . user_defined_grade = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . benchmark = parameter . into () , 8usize => entity . value_source = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . data_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . reference_path = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMirroredProfileDef : IIfcDerivedProfileDef { } # [derive (Default , Debug)] pub struct IfcMirroredProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , parent_profile : EntityRef < IfcProfileDef > , operator : EntityRef < IfcCartesianTransformationOperator2D > , label : Option < IfcLabel > , } impl IIfcProfileDef for IfcMirroredProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcDerivedProfileDef for IfcMirroredProfileDef { fn parent_profile (& self) -> & EntityRef < IfcProfileDef > { & self . parent_profile } fn operator (& self) -> & EntityRef < IfcCartesianTransformationOperator2D > { & self . operator } fn label (& self) -> & Option < IfcLabel > { & self . label } } impl IIfcMirroredProfileDef for IfcMirroredProfileDef { } impl IfcMirroredProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMirroredProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . parent_profile = parameter . into () , 3usize => entity . operator = parameter . into () , 4usize => entity . label = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMonetaryUnit : { pub fn currency (& self) -> & IfcLabel ; } # [derive (Default , Debug)] pub struct IfcMonetaryUnit { currency : IfcLabel , } impl IIfcMonetaryUnit for IfcMonetaryUnit { fn currency (& self) -> & IfcLabel { & self . currency } } impl IfcMonetaryUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMonetaryUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . currency = parameter . into () , _ => { } } } entity } } pub trait IIfcMotorConnection : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcMotorConnectionTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcMotorConnection { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcMotorConnectionTypeEnum > , } impl IIfcRoot for IfcMotorConnection { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMotorConnection { } impl IIfcObject for IfcMotorConnection { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcMotorConnection { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcMotorConnection { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcMotorConnection { } impl IIfcDistributionFlowElement for IfcMotorConnection { } impl IIfcEnergyConversionDevice for IfcMotorConnection { } impl IIfcMotorConnection for IfcMotorConnection { fn predefined_type (& self) -> & Option < IfcMotorConnectionTypeEnum > { & self . predefined_type } } impl IfcMotorConnection { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMotorConnection :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcMotorConnectionType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcMotorConnectionTypeEnum ; } # [derive (Default , Debug)] pub struct IfcMotorConnectionType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcMotorConnectionTypeEnum , } impl IIfcRoot for IfcMotorConnectionType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcMotorConnectionType { } impl IIfcTypeObject for IfcMotorConnectionType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcMotorConnectionType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcMotorConnectionType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcMotorConnectionType { } impl IIfcDistributionFlowElementType for IfcMotorConnectionType { } impl IIfcEnergyConversionDeviceType for IfcMotorConnectionType { } impl IIfcMotorConnectionType for IfcMotorConnectionType { fn predefined_type (& self) -> & IfcMotorConnectionTypeEnum { & self . predefined_type } } impl IfcMotorConnectionType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcMotorConnectionType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcNamedUnit : { pub fn dimensions (& self) -> & EntityRef < IfcDimensionalExponents > ; pub fn unit_type (& self) -> & IfcUnitEnum ; } pub trait IIfcObject : IIfcObjectDefinition { pub fn object_type (& self) -> & Option < IfcLabel > ; } pub trait IIfcObjectDefinition : IIfcRoot { } pub trait IIfcObjectPlacement : { } pub trait IIfcObjective : IIfcConstraint { pub fn benchmark_values (& self) -> & Option < Vec < EntityRef < IfcConstraint > > > ; pub fn logical_aggregator (& self) -> & Option < IfcLogicalOperatorEnum > ; pub fn objective_qualifier (& self) -> & IfcObjectiveEnum ; pub fn user_defined_qualifier (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcObjective { name : IfcLabel , description : Option < IfcText > , constraint_grade : IfcConstraintEnum , constraint_source : Option < IfcLabel > , creating_actor : Option < EntityRef < IfcActorSelect > > , creation_time : Option < IfcDateTime > , user_defined_grade : Option < IfcLabel > , benchmark_values : Option < Vec < EntityRef < IfcConstraint > > > , logical_aggregator : Option < IfcLogicalOperatorEnum > , objective_qualifier : IfcObjectiveEnum , user_defined_qualifier : Option < IfcLabel > , } impl IIfcConstraint for IfcObjective { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn constraint_grade (& self) -> & IfcConstraintEnum { & self . constraint_grade } fn constraint_source (& self) -> & Option < IfcLabel > { & self . constraint_source } fn creating_actor (& self) -> & Option < EntityRef < IfcActorSelect > > { & self . creating_actor } fn creation_time (& self) -> & Option < IfcDateTime > { & self . creation_time } fn user_defined_grade (& self) -> & Option < IfcLabel > { & self . user_defined_grade } } impl IIfcObjective for IfcObjective { fn benchmark_values (& self) -> & Option < Vec < EntityRef < IfcConstraint > > > { & self . benchmark_values } fn logical_aggregator (& self) -> & Option < IfcLogicalOperatorEnum > { & self . logical_aggregator } fn objective_qualifier (& self) -> & IfcObjectiveEnum { & self . objective_qualifier } fn user_defined_qualifier (& self) -> & Option < IfcLabel > { & self . user_defined_qualifier } } impl IfcObjective { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcObjective :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . constraint_grade = parameter . into () , 3usize => entity . constraint_source = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . creating_actor = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . creation_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . user_defined_grade = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . benchmark_values = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . logical_aggregator = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . objective_qualifier = parameter . into () , 10usize => entity . user_defined_qualifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcOccupant : IIfcActor { pub fn predefined_type (& self) -> & Option < IfcOccupantTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcOccupant { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , the_actor : EntityRef < IfcActorSelect > , predefined_type : Option < IfcOccupantTypeEnum > , } impl IIfcRoot for IfcOccupant { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcOccupant { } impl IIfcObject for IfcOccupant { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcActor for IfcOccupant { fn the_actor (& self) -> & EntityRef < IfcActorSelect > { & self . the_actor } } impl IIfcOccupant for IfcOccupant { fn predefined_type (& self) -> & Option < IfcOccupantTypeEnum > { & self . predefined_type } } impl IfcOccupant { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOccupant :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . the_actor = parameter . into () , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcOffsetCurve2D : IIfcCurve { pub fn basis_curve (& self) -> & EntityRef < IfcCurve > ; pub fn distance (& self) -> & IfcLengthMeasure ; pub fn self_intersect (& self) -> & IfcLogical ; } # [derive (Default , Debug)] pub struct IfcOffsetCurve2D { basis_curve : EntityRef < IfcCurve > , distance : IfcLengthMeasure , self_intersect : IfcLogical , } impl IIfcRepresentationItem for IfcOffsetCurve2D { } impl IIfcGeometricRepresentationItem for IfcOffsetCurve2D { } impl IIfcCurve for IfcOffsetCurve2D { } impl IIfcOffsetCurve2D for IfcOffsetCurve2D { fn basis_curve (& self) -> & EntityRef < IfcCurve > { & self . basis_curve } fn distance (& self) -> & IfcLengthMeasure { & self . distance } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IfcOffsetCurve2D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOffsetCurve2D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_curve = parameter . into () , 1usize => entity . distance = parameter . into () , 2usize => entity . self_intersect = parameter . into () , _ => { } } } entity } } pub trait IIfcOffsetCurve3D : IIfcCurve { pub fn basis_curve (& self) -> & EntityRef < IfcCurve > ; pub fn distance (& self) -> & IfcLengthMeasure ; pub fn self_intersect (& self) -> & IfcLogical ; pub fn ref_direction (& self) -> & EntityRef < IfcDirection > ; } # [derive (Default , Debug)] pub struct IfcOffsetCurve3D { basis_curve : EntityRef < IfcCurve > , distance : IfcLengthMeasure , self_intersect : IfcLogical , ref_direction : EntityRef < IfcDirection > , } impl IIfcRepresentationItem for IfcOffsetCurve3D { } impl IIfcGeometricRepresentationItem for IfcOffsetCurve3D { } impl IIfcCurve for IfcOffsetCurve3D { } impl IIfcOffsetCurve3D for IfcOffsetCurve3D { fn basis_curve (& self) -> & EntityRef < IfcCurve > { & self . basis_curve } fn distance (& self) -> & IfcLengthMeasure { & self . distance } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } fn ref_direction (& self) -> & EntityRef < IfcDirection > { & self . ref_direction } } impl IfcOffsetCurve3D { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOffsetCurve3D :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_curve = parameter . into () , 1usize => entity . distance = parameter . into () , 2usize => entity . self_intersect = parameter . into () , 3usize => entity . ref_direction = parameter . into () , _ => { } } } entity } } pub trait IIfcOpenShell : IIfcConnectedFaceSet { } # [derive (Default , Debug)] pub struct IfcOpenShell { cfs_faces : HashSet < EntityRef < IfcFace > > , } impl IIfcRepresentationItem for IfcOpenShell { } impl IIfcTopologicalRepresentationItem for IfcOpenShell { } impl IIfcConnectedFaceSet for IfcOpenShell { fn cfs_faces (& self) -> & HashSet < EntityRef < IfcFace > > { & self . cfs_faces } } impl IIfcOpenShell for IfcOpenShell { } impl IfcOpenShell { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOpenShell :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . cfs_faces = parameter . into () , _ => { } } } entity } } pub trait IIfcOpeningElement : IIfcFeatureElementSubtraction { pub fn predefined_type (& self) -> & Option < IfcOpeningElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcOpeningElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcOpeningElementTypeEnum > , } impl IIfcRoot for IfcOpeningElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcOpeningElement { } impl IIfcObject for IfcOpeningElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcOpeningElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcOpeningElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFeatureElement for IfcOpeningElement { } impl IIfcFeatureElementSubtraction for IfcOpeningElement { } impl IIfcOpeningElement for IfcOpeningElement { fn predefined_type (& self) -> & Option < IfcOpeningElementTypeEnum > { & self . predefined_type } } impl IfcOpeningElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOpeningElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcOpeningStandardCase : IIfcOpeningElement { } # [derive (Default , Debug)] pub struct IfcOpeningStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcOpeningElementTypeEnum > , } impl IIfcRoot for IfcOpeningStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcOpeningStandardCase { } impl IIfcObject for IfcOpeningStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcOpeningStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcOpeningStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFeatureElement for IfcOpeningStandardCase { } impl IIfcFeatureElementSubtraction for IfcOpeningStandardCase { } impl IIfcOpeningElement for IfcOpeningStandardCase { fn predefined_type (& self) -> & Option < IfcOpeningElementTypeEnum > { & self . predefined_type } } impl IIfcOpeningStandardCase for IfcOpeningStandardCase { } impl IfcOpeningStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOpeningStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcOrganization : { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn roles (& self) -> & Option < Vec < EntityRef < IfcActorRole > > > ; pub fn addresses (& self) -> & Option < Vec < EntityRef < IfcAddress > > > ; } # [derive (Default , Debug)] pub struct IfcOrganization { identification : Option < IfcIdentifier > , name : IfcLabel , description : Option < IfcText > , roles : Option < Vec < EntityRef < IfcActorRole > > > , addresses : Option < Vec < EntityRef < IfcAddress > > > , } impl IIfcOrganization for IfcOrganization { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn roles (& self) -> & Option < Vec < EntityRef < IfcActorRole > > > { & self . roles } fn addresses (& self) -> & Option < Vec < EntityRef < IfcAddress > > > { & self . addresses } } impl IfcOrganization { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOrganization :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . name = parameter . into () , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . roles = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . addresses = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcOrganizationRelationship : IIfcResourceLevelRelationship { pub fn relating_organization (& self) -> & EntityRef < IfcOrganization > ; pub fn related_organizations (& self) -> & HashSet < EntityRef < IfcOrganization > > ; } # [derive (Default , Debug)] pub struct IfcOrganizationRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_organization : EntityRef < IfcOrganization > , related_organizations : HashSet < EntityRef < IfcOrganization > > , } impl IIfcResourceLevelRelationship for IfcOrganizationRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcOrganizationRelationship for IfcOrganizationRelationship { fn relating_organization (& self) -> & EntityRef < IfcOrganization > { & self . relating_organization } fn related_organizations (& self) -> & HashSet < EntityRef < IfcOrganization > > { & self . related_organizations } } impl IfcOrganizationRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOrganizationRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_organization = parameter . into () , 3usize => entity . related_organizations = parameter . into () , _ => { } } } entity } } pub trait IIfcOrientedEdge : IIfcEdge { pub fn edge_element (& self) -> & EntityRef < IfcEdge > ; pub fn orientation (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcOrientedEdge { edge_start : EntityRef < IfcVertex > , edge_end : EntityRef < IfcVertex > , edge_element : EntityRef < IfcEdge > , orientation : IfcBoolean , } impl IIfcRepresentationItem for IfcOrientedEdge { } impl IIfcTopologicalRepresentationItem for IfcOrientedEdge { } impl IIfcEdge for IfcOrientedEdge { fn edge_start (& self) -> & EntityRef < IfcVertex > { & self . edge_start } fn edge_end (& self) -> & EntityRef < IfcVertex > { & self . edge_end } } impl IIfcOrientedEdge for IfcOrientedEdge { fn edge_element (& self) -> & EntityRef < IfcEdge > { & self . edge_element } fn orientation (& self) -> & IfcBoolean { & self . orientation } } impl IfcOrientedEdge { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOrientedEdge :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . edge_start = parameter . into () , 1usize => entity . edge_end = parameter . into () , 2usize => entity . edge_element = parameter . into () , 3usize => entity . orientation = parameter . into () , _ => { } } } entity } } pub trait IIfcOuterBoundaryCurve : IIfcBoundaryCurve { } # [derive (Default , Debug)] pub struct IfcOuterBoundaryCurve { segments : Vec < EntityRef < IfcCompositeCurveSegment > > , self_intersect : IfcLogical , } impl IIfcRepresentationItem for IfcOuterBoundaryCurve { } impl IIfcGeometricRepresentationItem for IfcOuterBoundaryCurve { } impl IIfcCurve for IfcOuterBoundaryCurve { } impl IIfcBoundedCurve for IfcOuterBoundaryCurve { } impl IIfcCompositeCurve for IfcOuterBoundaryCurve { fn segments (& self) -> & Vec < EntityRef < IfcCompositeCurveSegment > > { & self . segments } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcCompositeCurveOnSurface for IfcOuterBoundaryCurve { } impl IIfcBoundaryCurve for IfcOuterBoundaryCurve { } impl IIfcOuterBoundaryCurve for IfcOuterBoundaryCurve { } impl IfcOuterBoundaryCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOuterBoundaryCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . segments = parameter . into () , 1usize => entity . self_intersect = parameter . into () , _ => { } } } entity } } pub trait IIfcOutlet : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcOutletTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcOutlet { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcOutletTypeEnum > , } impl IIfcRoot for IfcOutlet { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcOutlet { } impl IIfcObject for IfcOutlet { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcOutlet { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcOutlet { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcOutlet { } impl IIfcDistributionFlowElement for IfcOutlet { } impl IIfcFlowTerminal for IfcOutlet { } impl IIfcOutlet for IfcOutlet { fn predefined_type (& self) -> & Option < IfcOutletTypeEnum > { & self . predefined_type } } impl IfcOutlet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOutlet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcOutletType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcOutletTypeEnum ; } # [derive (Default , Debug)] pub struct IfcOutletType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcOutletTypeEnum , } impl IIfcRoot for IfcOutletType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcOutletType { } impl IIfcTypeObject for IfcOutletType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcOutletType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcOutletType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcOutletType { } impl IIfcDistributionFlowElementType for IfcOutletType { } impl IIfcFlowTerminalType for IfcOutletType { } impl IIfcOutletType for IfcOutletType { fn predefined_type (& self) -> & IfcOutletTypeEnum { & self . predefined_type } } impl IfcOutletType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOutletType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcOwnerHistory : { pub fn owning_user (& self) -> & EntityRef < IfcPersonAndOrganization > ; pub fn owning_application (& self) -> & EntityRef < IfcApplication > ; pub fn state (& self) -> & Option < IfcStateEnum > ; pub fn change_action (& self) -> & Option < IfcChangeActionEnum > ; pub fn last_modified_date (& self) -> & Option < IfcTimeStamp > ; pub fn last_modifying_user (& self) -> & Option < EntityRef < IfcPersonAndOrganization > > ; pub fn last_modifying_application (& self) -> & Option < EntityRef < IfcApplication > > ; pub fn creation_date (& self) -> & IfcTimeStamp ; } # [derive (Default , Debug)] pub struct IfcOwnerHistory { owning_user : EntityRef < IfcPersonAndOrganization > , owning_application : EntityRef < IfcApplication > , state : Option < IfcStateEnum > , change_action : Option < IfcChangeActionEnum > , last_modified_date : Option < IfcTimeStamp > , last_modifying_user : Option < EntityRef < IfcPersonAndOrganization > > , last_modifying_application : Option < EntityRef < IfcApplication > > , creation_date : IfcTimeStamp , } impl IIfcOwnerHistory for IfcOwnerHistory { fn owning_user (& self) -> & EntityRef < IfcPersonAndOrganization > { & self . owning_user } fn owning_application (& self) -> & EntityRef < IfcApplication > { & self . owning_application } fn state (& self) -> & Option < IfcStateEnum > { & self . state } fn change_action (& self) -> & Option < IfcChangeActionEnum > { & self . change_action } fn last_modified_date (& self) -> & Option < IfcTimeStamp > { & self . last_modified_date } fn last_modifying_user (& self) -> & Option < EntityRef < IfcPersonAndOrganization > > { & self . last_modifying_user } fn last_modifying_application (& self) -> & Option < EntityRef < IfcApplication > > { & self . last_modifying_application } fn creation_date (& self) -> & IfcTimeStamp { & self . creation_date } } impl IfcOwnerHistory { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcOwnerHistory :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . owning_user = parameter . into () , 1usize => entity . owning_application = parameter . into () , 2usize => entity . state = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . change_action = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . last_modified_date = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . last_modifying_user = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . last_modifying_application = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . creation_date = parameter . into () , _ => { } } } entity } } pub trait IIfcParameterizedProfileDef : IIfcProfileDef { pub fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > ; } pub trait IIfcPath : IIfcTopologicalRepresentationItem { pub fn edge_list (& self) -> & Vec < EntityRef < IfcOrientedEdge > > ; } # [derive (Default , Debug)] pub struct IfcPath { edge_list : Vec < EntityRef < IfcOrientedEdge > > , } impl IIfcRepresentationItem for IfcPath { } impl IIfcTopologicalRepresentationItem for IfcPath { } impl IIfcPath for IfcPath { fn edge_list (& self) -> & Vec < EntityRef < IfcOrientedEdge > > { & self . edge_list } } impl IfcPath { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPath :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . edge_list = parameter . into () , _ => { } } } entity } } pub trait IIfcPcurve : IIfcCurve { pub fn basis_surface (& self) -> & EntityRef < IfcSurface > ; pub fn reference_curve (& self) -> & EntityRef < IfcCurve > ; } # [derive (Default , Debug)] pub struct IfcPcurve { basis_surface : EntityRef < IfcSurface > , reference_curve : EntityRef < IfcCurve > , } impl IIfcRepresentationItem for IfcPcurve { } impl IIfcGeometricRepresentationItem for IfcPcurve { } impl IIfcCurve for IfcPcurve { } impl IIfcPcurve for IfcPcurve { fn basis_surface (& self) -> & EntityRef < IfcSurface > { & self . basis_surface } fn reference_curve (& self) -> & EntityRef < IfcCurve > { & self . reference_curve } } impl IfcPcurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPcurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_surface = parameter . into () , 1usize => entity . reference_curve = parameter . into () , _ => { } } } entity } } pub trait IIfcPerformanceHistory : IIfcControl { pub fn life_cycle_phase (& self) -> & IfcLabel ; pub fn predefined_type (& self) -> & Option < IfcPerformanceHistoryTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcPerformanceHistory { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , life_cycle_phase : IfcLabel , predefined_type : Option < IfcPerformanceHistoryTypeEnum > , } impl IIfcRoot for IfcPerformanceHistory { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPerformanceHistory { } impl IIfcObject for IfcPerformanceHistory { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcPerformanceHistory { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcPerformanceHistory for IfcPerformanceHistory { fn life_cycle_phase (& self) -> & IfcLabel { & self . life_cycle_phase } fn predefined_type (& self) -> & Option < IfcPerformanceHistoryTypeEnum > { & self . predefined_type } } impl IfcPerformanceHistory { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPerformanceHistory :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . life_cycle_phase = parameter . into () , 7usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPermeableCoveringProperties : IIfcPreDefinedPropertySet { pub fn operation_type (& self) -> & IfcPermeableCoveringOperationEnum ; pub fn panel_position (& self) -> & IfcWindowPanelPositionEnum ; pub fn frame_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn frame_thickness (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > ; } # [derive (Default , Debug)] pub struct IfcPermeableCoveringProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , operation_type : IfcPermeableCoveringOperationEnum , panel_position : IfcWindowPanelPositionEnum , frame_depth : Option < IfcPositiveLengthMeasure > , frame_thickness : Option < IfcPositiveLengthMeasure > , shape_aspect_style : Option < EntityRef < IfcShapeAspect > > , } impl IIfcRoot for IfcPermeableCoveringProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcPermeableCoveringProperties { } impl IIfcPropertySetDefinition for IfcPermeableCoveringProperties { } impl IIfcPreDefinedPropertySet for IfcPermeableCoveringProperties { } impl IIfcPermeableCoveringProperties for IfcPermeableCoveringProperties { fn operation_type (& self) -> & IfcPermeableCoveringOperationEnum { & self . operation_type } fn panel_position (& self) -> & IfcWindowPanelPositionEnum { & self . panel_position } fn frame_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . frame_depth } fn frame_thickness (& self) -> & Option < IfcPositiveLengthMeasure > { & self . frame_thickness } fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > { & self . shape_aspect_style } } impl IfcPermeableCoveringProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPermeableCoveringProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . operation_type = parameter . into () , 5usize => entity . panel_position = parameter . into () , 6usize => entity . frame_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . frame_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . shape_aspect_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPermit : IIfcControl { pub fn predefined_type (& self) -> & Option < IfcPermitTypeEnum > ; pub fn status (& self) -> & Option < IfcLabel > ; pub fn long_description (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcPermit { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , predefined_type : Option < IfcPermitTypeEnum > , status : Option < IfcLabel > , long_description : Option < IfcText > , } impl IIfcRoot for IfcPermit { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPermit { } impl IIfcObject for IfcPermit { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcPermit { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcPermit for IfcPermit { fn predefined_type (& self) -> & Option < IfcPermitTypeEnum > { & self . predefined_type } fn status (& self) -> & Option < IfcLabel > { & self . status } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IfcPermit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPermit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPerson : { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn family_name (& self) -> & Option < IfcLabel > ; pub fn given_name (& self) -> & Option < IfcLabel > ; pub fn middle_names (& self) -> & Option < Vec < IfcLabel > > ; pub fn prefix_titles (& self) -> & Option < Vec < IfcLabel > > ; pub fn suffix_titles (& self) -> & Option < Vec < IfcLabel > > ; pub fn roles (& self) -> & Option < Vec < EntityRef < IfcActorRole > > > ; pub fn addresses (& self) -> & Option < Vec < EntityRef < IfcAddress > > > ; } # [derive (Default , Debug)] pub struct IfcPerson { identification : Option < IfcIdentifier > , family_name : Option < IfcLabel > , given_name : Option < IfcLabel > , middle_names : Option < Vec < IfcLabel > > , prefix_titles : Option < Vec < IfcLabel > > , suffix_titles : Option < Vec < IfcLabel > > , roles : Option < Vec < EntityRef < IfcActorRole > > > , addresses : Option < Vec < EntityRef < IfcAddress > > > , } impl IIfcPerson for IfcPerson { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn family_name (& self) -> & Option < IfcLabel > { & self . family_name } fn given_name (& self) -> & Option < IfcLabel > { & self . given_name } fn middle_names (& self) -> & Option < Vec < IfcLabel > > { & self . middle_names } fn prefix_titles (& self) -> & Option < Vec < IfcLabel > > { & self . prefix_titles } fn suffix_titles (& self) -> & Option < Vec < IfcLabel > > { & self . suffix_titles } fn roles (& self) -> & Option < Vec < EntityRef < IfcActorRole > > > { & self . roles } fn addresses (& self) -> & Option < Vec < EntityRef < IfcAddress > > > { & self . addresses } } impl IfcPerson { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPerson :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . family_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . given_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . middle_names = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . prefix_titles = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . suffix_titles = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . roles = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . addresses = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPersonAndOrganization : { pub fn the_person (& self) -> & EntityRef < IfcPerson > ; pub fn the_organization (& self) -> & EntityRef < IfcOrganization > ; pub fn roles (& self) -> & Option < Vec < EntityRef < IfcActorRole > > > ; } # [derive (Default , Debug)] pub struct IfcPersonAndOrganization { the_person : EntityRef < IfcPerson > , the_organization : EntityRef < IfcOrganization > , roles : Option < Vec < EntityRef < IfcActorRole > > > , } impl IIfcPersonAndOrganization for IfcPersonAndOrganization { fn the_person (& self) -> & EntityRef < IfcPerson > { & self . the_person } fn the_organization (& self) -> & EntityRef < IfcOrganization > { & self . the_organization } fn roles (& self) -> & Option < Vec < EntityRef < IfcActorRole > > > { & self . roles } } impl IfcPersonAndOrganization { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPersonAndOrganization :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . the_person = parameter . into () , 1usize => entity . the_organization = parameter . into () , 2usize => entity . roles = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPhysicalComplexQuantity : IIfcPhysicalQuantity { pub fn has_quantities (& self) -> & HashSet < EntityRef < IfcPhysicalQuantity > > ; pub fn discrimination (& self) -> & IfcLabel ; pub fn quality (& self) -> & Option < IfcLabel > ; pub fn usage (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcPhysicalComplexQuantity { name : IfcLabel , description : Option < IfcText > , has_quantities : HashSet < EntityRef < IfcPhysicalQuantity > > , discrimination : IfcLabel , quality : Option < IfcLabel > , usage : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcPhysicalComplexQuantity { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalComplexQuantity for IfcPhysicalComplexQuantity { fn has_quantities (& self) -> & HashSet < EntityRef < IfcPhysicalQuantity > > { & self . has_quantities } fn discrimination (& self) -> & IfcLabel { & self . discrimination } fn quality (& self) -> & Option < IfcLabel > { & self . quality } fn usage (& self) -> & Option < IfcLabel > { & self . usage } } impl IfcPhysicalComplexQuantity { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPhysicalComplexQuantity :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . has_quantities = parameter . into () , 3usize => entity . discrimination = parameter . into () , 4usize => entity . quality = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPhysicalQuantity : { pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; } pub trait IIfcPhysicalSimpleQuantity : IIfcPhysicalQuantity { pub fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > ; } pub trait IIfcPile : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcPileTypeEnum > ; pub fn construction_type (& self) -> & Option < IfcPileConstructionEnum > ; } # [derive (Default , Debug)] pub struct IfcPile { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcPileTypeEnum > , construction_type : Option < IfcPileConstructionEnum > , } impl IIfcRoot for IfcPile { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPile { } impl IIfcObject for IfcPile { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcPile { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcPile { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcPile { } impl IIfcPile for IfcPile { fn predefined_type (& self) -> & Option < IfcPileTypeEnum > { & self . predefined_type } fn construction_type (& self) -> & Option < IfcPileConstructionEnum > { & self . construction_type } } impl IfcPile { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPile :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . construction_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPileType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcPileTypeEnum ; } # [derive (Default , Debug)] pub struct IfcPileType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcPileTypeEnum , } impl IIfcRoot for IfcPileType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPileType { } impl IIfcTypeObject for IfcPileType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcPileType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcPileType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcPileType { } impl IIfcPileType for IfcPileType { fn predefined_type (& self) -> & IfcPileTypeEnum { & self . predefined_type } } impl IfcPileType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPileType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcPipeFitting : IIfcFlowFitting { pub fn predefined_type (& self) -> & Option < IfcPipeFittingTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcPipeFitting { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcPipeFittingTypeEnum > , } impl IIfcRoot for IfcPipeFitting { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPipeFitting { } impl IIfcObject for IfcPipeFitting { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcPipeFitting { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcPipeFitting { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcPipeFitting { } impl IIfcDistributionFlowElement for IfcPipeFitting { } impl IIfcFlowFitting for IfcPipeFitting { } impl IIfcPipeFitting for IfcPipeFitting { fn predefined_type (& self) -> & Option < IfcPipeFittingTypeEnum > { & self . predefined_type } } impl IfcPipeFitting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPipeFitting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPipeFittingType : IIfcFlowFittingType { pub fn predefined_type (& self) -> & IfcPipeFittingTypeEnum ; } # [derive (Default , Debug)] pub struct IfcPipeFittingType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcPipeFittingTypeEnum , } impl IIfcRoot for IfcPipeFittingType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPipeFittingType { } impl IIfcTypeObject for IfcPipeFittingType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcPipeFittingType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcPipeFittingType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcPipeFittingType { } impl IIfcDistributionFlowElementType for IfcPipeFittingType { } impl IIfcFlowFittingType for IfcPipeFittingType { } impl IIfcPipeFittingType for IfcPipeFittingType { fn predefined_type (& self) -> & IfcPipeFittingTypeEnum { & self . predefined_type } } impl IfcPipeFittingType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPipeFittingType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcPipeSegment : IIfcFlowSegment { pub fn predefined_type (& self) -> & Option < IfcPipeSegmentTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcPipeSegment { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcPipeSegmentTypeEnum > , } impl IIfcRoot for IfcPipeSegment { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPipeSegment { } impl IIfcObject for IfcPipeSegment { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcPipeSegment { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcPipeSegment { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcPipeSegment { } impl IIfcDistributionFlowElement for IfcPipeSegment { } impl IIfcFlowSegment for IfcPipeSegment { } impl IIfcPipeSegment for IfcPipeSegment { fn predefined_type (& self) -> & Option < IfcPipeSegmentTypeEnum > { & self . predefined_type } } impl IfcPipeSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPipeSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPipeSegmentType : IIfcFlowSegmentType { pub fn predefined_type (& self) -> & IfcPipeSegmentTypeEnum ; } # [derive (Default , Debug)] pub struct IfcPipeSegmentType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcPipeSegmentTypeEnum , } impl IIfcRoot for IfcPipeSegmentType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPipeSegmentType { } impl IIfcTypeObject for IfcPipeSegmentType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcPipeSegmentType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcPipeSegmentType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcPipeSegmentType { } impl IIfcDistributionFlowElementType for IfcPipeSegmentType { } impl IIfcFlowSegmentType for IfcPipeSegmentType { } impl IIfcPipeSegmentType for IfcPipeSegmentType { fn predefined_type (& self) -> & IfcPipeSegmentTypeEnum { & self . predefined_type } } impl IfcPipeSegmentType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPipeSegmentType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcPixelTexture : IIfcSurfaceTexture { pub fn width (& self) -> & IfcInteger ; pub fn height (& self) -> & IfcInteger ; pub fn colour_components (& self) -> & IfcInteger ; pub fn pixel (& self) -> & Vec < IfcBinary > ; } # [derive (Default , Debug)] pub struct IfcPixelTexture { repeat_s : IfcBoolean , repeat_t : IfcBoolean , mode : Option < IfcIdentifier > , texture_transform : Option < EntityRef < IfcCartesianTransformationOperator2D > > , parameter : Option < Vec < IfcIdentifier > > , width : IfcInteger , height : IfcInteger , colour_components : IfcInteger , pixel : Vec < IfcBinary > , } impl IIfcPresentationItem for IfcPixelTexture { } impl IIfcSurfaceTexture for IfcPixelTexture { fn repeat_s (& self) -> & IfcBoolean { & self . repeat_s } fn repeat_t (& self) -> & IfcBoolean { & self . repeat_t } fn mode (& self) -> & Option < IfcIdentifier > { & self . mode } fn texture_transform (& self) -> & Option < EntityRef < IfcCartesianTransformationOperator2D > > { & self . texture_transform } fn parameter (& self) -> & Option < Vec < IfcIdentifier > > { & self . parameter } } impl IIfcPixelTexture for IfcPixelTexture { fn width (& self) -> & IfcInteger { & self . width } fn height (& self) -> & IfcInteger { & self . height } fn colour_components (& self) -> & IfcInteger { & self . colour_components } fn pixel (& self) -> & Vec < IfcBinary > { & self . pixel } } impl IfcPixelTexture { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPixelTexture :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . repeat_s = parameter . into () , 1usize => entity . repeat_t = parameter . into () , 2usize => entity . mode = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . texture_transform = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . parameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . width = parameter . into () , 6usize => entity . height = parameter . into () , 7usize => entity . colour_components = parameter . into () , 8usize => entity . pixel = parameter . into () , _ => { } } } entity } } pub trait IIfcPlacement : IIfcGeometricRepresentationItem { pub fn location (& self) -> & EntityRef < IfcCartesianPoint > ; } pub trait IIfcPlanarBox : IIfcPlanarExtent { pub fn placement (& self) -> & EntityRef < IfcAxis2Placement > ; } # [derive (Default , Debug)] pub struct IfcPlanarBox { size_in_x : IfcLengthMeasure , size_in_y : IfcLengthMeasure , placement : EntityRef < IfcAxis2Placement > , } impl IIfcRepresentationItem for IfcPlanarBox { } impl IIfcGeometricRepresentationItem for IfcPlanarBox { } impl IIfcPlanarExtent for IfcPlanarBox { fn size_in_x (& self) -> & IfcLengthMeasure { & self . size_in_x } fn size_in_y (& self) -> & IfcLengthMeasure { & self . size_in_y } } impl IIfcPlanarBox for IfcPlanarBox { fn placement (& self) -> & EntityRef < IfcAxis2Placement > { & self . placement } } impl IfcPlanarBox { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPlanarBox :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . size_in_x = parameter . into () , 1usize => entity . size_in_y = parameter . into () , 2usize => entity . placement = parameter . into () , _ => { } } } entity } } pub trait IIfcPlanarExtent : IIfcGeometricRepresentationItem { pub fn size_in_x (& self) -> & IfcLengthMeasure ; pub fn size_in_y (& self) -> & IfcLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcPlanarExtent { size_in_x : IfcLengthMeasure , size_in_y : IfcLengthMeasure , } impl IIfcRepresentationItem for IfcPlanarExtent { } impl IIfcGeometricRepresentationItem for IfcPlanarExtent { } impl IIfcPlanarExtent for IfcPlanarExtent { fn size_in_x (& self) -> & IfcLengthMeasure { & self . size_in_x } fn size_in_y (& self) -> & IfcLengthMeasure { & self . size_in_y } } impl IfcPlanarExtent { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPlanarExtent :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . size_in_x = parameter . into () , 1usize => entity . size_in_y = parameter . into () , _ => { } } } entity } } pub trait IIfcPlane : IIfcElementarySurface { } # [derive (Default , Debug)] pub struct IfcPlane { position : EntityRef < IfcAxis2Placement3D > , } impl IIfcRepresentationItem for IfcPlane { } impl IIfcGeometricRepresentationItem for IfcPlane { } impl IIfcSurface for IfcPlane { } impl IIfcElementarySurface for IfcPlane { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcPlane for IfcPlane { } impl IfcPlane { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPlane :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , _ => { } } } entity } } pub trait IIfcPlate : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcPlateTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcPlate { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcPlateTypeEnum > , } impl IIfcRoot for IfcPlate { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPlate { } impl IIfcObject for IfcPlate { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcPlate { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcPlate { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcPlate { } impl IIfcPlate for IfcPlate { fn predefined_type (& self) -> & Option < IfcPlateTypeEnum > { & self . predefined_type } } impl IfcPlate { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPlate :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPlateStandardCase : IIfcPlate { } # [derive (Default , Debug)] pub struct IfcPlateStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcPlateTypeEnum > , } impl IIfcRoot for IfcPlateStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPlateStandardCase { } impl IIfcObject for IfcPlateStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcPlateStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcPlateStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcPlateStandardCase { } impl IIfcPlate for IfcPlateStandardCase { fn predefined_type (& self) -> & Option < IfcPlateTypeEnum > { & self . predefined_type } } impl IIfcPlateStandardCase for IfcPlateStandardCase { } impl IfcPlateStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPlateStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPlateType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcPlateTypeEnum ; } # [derive (Default , Debug)] pub struct IfcPlateType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcPlateTypeEnum , } impl IIfcRoot for IfcPlateType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPlateType { } impl IIfcTypeObject for IfcPlateType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcPlateType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcPlateType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcPlateType { } impl IIfcPlateType for IfcPlateType { fn predefined_type (& self) -> & IfcPlateTypeEnum { & self . predefined_type } } impl IfcPlateType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPlateType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcPoint : IIfcGeometricRepresentationItem { } pub trait IIfcPointOnCurve : IIfcPoint { pub fn basis_curve (& self) -> & EntityRef < IfcCurve > ; pub fn point_parameter (& self) -> & IfcParameterValue ; } # [derive (Default , Debug)] pub struct IfcPointOnCurve { basis_curve : EntityRef < IfcCurve > , point_parameter : IfcParameterValue , } impl IIfcRepresentationItem for IfcPointOnCurve { } impl IIfcGeometricRepresentationItem for IfcPointOnCurve { } impl IIfcPoint for IfcPointOnCurve { } impl IIfcPointOnCurve for IfcPointOnCurve { fn basis_curve (& self) -> & EntityRef < IfcCurve > { & self . basis_curve } fn point_parameter (& self) -> & IfcParameterValue { & self . point_parameter } } impl IfcPointOnCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPointOnCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_curve = parameter . into () , 1usize => entity . point_parameter = parameter . into () , _ => { } } } entity } } pub trait IIfcPointOnSurface : IIfcPoint { pub fn basis_surface (& self) -> & EntityRef < IfcSurface > ; pub fn point_parameter_u (& self) -> & IfcParameterValue ; pub fn point_parameter_v (& self) -> & IfcParameterValue ; } # [derive (Default , Debug)] pub struct IfcPointOnSurface { basis_surface : EntityRef < IfcSurface > , point_parameter_u : IfcParameterValue , point_parameter_v : IfcParameterValue , } impl IIfcRepresentationItem for IfcPointOnSurface { } impl IIfcGeometricRepresentationItem for IfcPointOnSurface { } impl IIfcPoint for IfcPointOnSurface { } impl IIfcPointOnSurface for IfcPointOnSurface { fn basis_surface (& self) -> & EntityRef < IfcSurface > { & self . basis_surface } fn point_parameter_u (& self) -> & IfcParameterValue { & self . point_parameter_u } fn point_parameter_v (& self) -> & IfcParameterValue { & self . point_parameter_v } } impl IfcPointOnSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPointOnSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_surface = parameter . into () , 1usize => entity . point_parameter_u = parameter . into () , 2usize => entity . point_parameter_v = parameter . into () , _ => { } } } entity } } pub trait IIfcPolyLoop : IIfcLoop { pub fn polygon (& self) -> & Vec < EntityRef < IfcCartesianPoint > > ; } # [derive (Default , Debug)] pub struct IfcPolyLoop { polygon : Vec < EntityRef < IfcCartesianPoint > > , } impl IIfcRepresentationItem for IfcPolyLoop { } impl IIfcTopologicalRepresentationItem for IfcPolyLoop { } impl IIfcLoop for IfcPolyLoop { } impl IIfcPolyLoop for IfcPolyLoop { fn polygon (& self) -> & Vec < EntityRef < IfcCartesianPoint > > { & self . polygon } } impl IfcPolyLoop { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPolyLoop :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . polygon = parameter . into () , _ => { } } } entity } } pub trait IIfcPolygonalBoundedHalfSpace : IIfcHalfSpaceSolid { pub fn position (& self) -> & EntityRef < IfcAxis2Placement3D > ; pub fn polygonal_boundary (& self) -> & EntityRef < IfcBoundedCurve > ; } # [derive (Default , Debug)] pub struct IfcPolygonalBoundedHalfSpace { base_surface : EntityRef < IfcSurface > , agreement_flag : IfcBoolean , position : EntityRef < IfcAxis2Placement3D > , polygonal_boundary : EntityRef < IfcBoundedCurve > , } impl IIfcRepresentationItem for IfcPolygonalBoundedHalfSpace { } impl IIfcGeometricRepresentationItem for IfcPolygonalBoundedHalfSpace { } impl IIfcHalfSpaceSolid for IfcPolygonalBoundedHalfSpace { fn base_surface (& self) -> & EntityRef < IfcSurface > { & self . base_surface } fn agreement_flag (& self) -> & IfcBoolean { & self . agreement_flag } } impl IIfcPolygonalBoundedHalfSpace for IfcPolygonalBoundedHalfSpace { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } fn polygonal_boundary (& self) -> & EntityRef < IfcBoundedCurve > { & self . polygonal_boundary } } impl IfcPolygonalBoundedHalfSpace { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPolygonalBoundedHalfSpace :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . base_surface = parameter . into () , 1usize => entity . agreement_flag = parameter . into () , 2usize => entity . position = parameter . into () , 3usize => entity . polygonal_boundary = parameter . into () , _ => { } } } entity } } pub trait IIfcPolygonalFaceSet : IIfcTessellatedFaceSet { pub fn closed (& self) -> & Option < IfcBoolean > ; pub fn faces (& self) -> & Vec < EntityRef < IfcIndexedPolygonalFace > > ; pub fn pn_index (& self) -> & Option < Vec < IfcPositiveInteger > > ; } # [derive (Default , Debug)] pub struct IfcPolygonalFaceSet { coordinates : EntityRef < IfcCartesianPointList3D > , closed : Option < IfcBoolean > , faces : Vec < EntityRef < IfcIndexedPolygonalFace > > , pn_index : Option < Vec < IfcPositiveInteger > > , } impl IIfcRepresentationItem for IfcPolygonalFaceSet { } impl IIfcGeometricRepresentationItem for IfcPolygonalFaceSet { } impl IIfcTessellatedItem for IfcPolygonalFaceSet { } impl IIfcTessellatedFaceSet for IfcPolygonalFaceSet { fn coordinates (& self) -> & EntityRef < IfcCartesianPointList3D > { & self . coordinates } } impl IIfcPolygonalFaceSet for IfcPolygonalFaceSet { fn closed (& self) -> & Option < IfcBoolean > { & self . closed } fn faces (& self) -> & Vec < EntityRef < IfcIndexedPolygonalFace > > { & self . faces } fn pn_index (& self) -> & Option < Vec < IfcPositiveInteger > > { & self . pn_index } } impl IfcPolygonalFaceSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPolygonalFaceSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coordinates = parameter . into () , 1usize => entity . closed = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . faces = parameter . into () , 3usize => entity . pn_index = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPolyline : IIfcBoundedCurve { pub fn points (& self) -> & Vec < EntityRef < IfcCartesianPoint > > ; } # [derive (Default , Debug)] pub struct IfcPolyline { points : Vec < EntityRef < IfcCartesianPoint > > , } impl IIfcRepresentationItem for IfcPolyline { } impl IIfcGeometricRepresentationItem for IfcPolyline { } impl IIfcCurve for IfcPolyline { } impl IIfcBoundedCurve for IfcPolyline { } impl IIfcPolyline for IfcPolyline { fn points (& self) -> & Vec < EntityRef < IfcCartesianPoint > > { & self . points } } impl IfcPolyline { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPolyline :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . points = parameter . into () , _ => { } } } entity } } pub trait IIfcPort : IIfcProduct { } pub trait IIfcPostalAddress : IIfcAddress { pub fn internal_location (& self) -> & Option < IfcLabel > ; pub fn address_lines (& self) -> & Option < Vec < IfcLabel > > ; pub fn postal_box (& self) -> & Option < IfcLabel > ; pub fn town (& self) -> & Option < IfcLabel > ; pub fn region (& self) -> & Option < IfcLabel > ; pub fn postal_code (& self) -> & Option < IfcLabel > ; pub fn country (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcPostalAddress { purpose : Option < IfcAddressTypeEnum > , description : Option < IfcText > , user_defined_purpose : Option < IfcLabel > , internal_location : Option < IfcLabel > , address_lines : Option < Vec < IfcLabel > > , postal_box : Option < IfcLabel > , town : Option < IfcLabel > , region : Option < IfcLabel > , postal_code : Option < IfcLabel > , country : Option < IfcLabel > , } impl IIfcAddress for IfcPostalAddress { fn purpose (& self) -> & Option < IfcAddressTypeEnum > { & self . purpose } fn description (& self) -> & Option < IfcText > { & self . description } fn user_defined_purpose (& self) -> & Option < IfcLabel > { & self . user_defined_purpose } } impl IIfcPostalAddress for IfcPostalAddress { fn internal_location (& self) -> & Option < IfcLabel > { & self . internal_location } fn address_lines (& self) -> & Option < Vec < IfcLabel > > { & self . address_lines } fn postal_box (& self) -> & Option < IfcLabel > { & self . postal_box } fn town (& self) -> & Option < IfcLabel > { & self . town } fn region (& self) -> & Option < IfcLabel > { & self . region } fn postal_code (& self) -> & Option < IfcLabel > { & self . postal_code } fn country (& self) -> & Option < IfcLabel > { & self . country } } impl IfcPostalAddress { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPostalAddress :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . internal_location = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . address_lines = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . postal_box = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . town = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . region = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . postal_code = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . country = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPreDefinedColour : IIfcPreDefinedItem { } pub trait IIfcPreDefinedCurveFont : IIfcPreDefinedItem { } pub trait IIfcPreDefinedItem : IIfcPresentationItem { pub fn name (& self) -> & IfcLabel ; } pub trait IIfcPreDefinedProperties : IIfcPropertyAbstraction { } pub trait IIfcPreDefinedPropertySet : IIfcPropertySetDefinition { } pub trait IIfcPreDefinedTextFont : IIfcPreDefinedItem { } pub trait IIfcPresentationItem : { } pub trait IIfcPresentationLayerAssignment : { pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn assigned_items (& self) -> & HashSet < EntityRef < IfcLayeredItem > > ; pub fn identifier (& self) -> & Option < IfcIdentifier > ; } # [derive (Default , Debug)] pub struct IfcPresentationLayerAssignment { name : IfcLabel , description : Option < IfcText > , assigned_items : HashSet < EntityRef < IfcLayeredItem > > , identifier : Option < IfcIdentifier > , } impl IIfcPresentationLayerAssignment for IfcPresentationLayerAssignment { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn assigned_items (& self) -> & HashSet < EntityRef < IfcLayeredItem > > { & self . assigned_items } fn identifier (& self) -> & Option < IfcIdentifier > { & self . identifier } } impl IfcPresentationLayerAssignment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPresentationLayerAssignment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . assigned_items = parameter . into () , 3usize => entity . identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPresentationLayerWithStyle : IIfcPresentationLayerAssignment { pub fn layer_on (& self) -> & IfcLogical ; pub fn layer_frozen (& self) -> & IfcLogical ; pub fn layer_blocked (& self) -> & IfcLogical ; pub fn layer_styles (& self) -> & HashSet < EntityRef < IfcPresentationStyle > > ; } # [derive (Default , Debug)] pub struct IfcPresentationLayerWithStyle { name : IfcLabel , description : Option < IfcText > , assigned_items : HashSet < EntityRef < IfcLayeredItem > > , identifier : Option < IfcIdentifier > , layer_on : IfcLogical , layer_frozen : IfcLogical , layer_blocked : IfcLogical , layer_styles : HashSet < EntityRef < IfcPresentationStyle > > , } impl IIfcPresentationLayerAssignment for IfcPresentationLayerWithStyle { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn assigned_items (& self) -> & HashSet < EntityRef < IfcLayeredItem > > { & self . assigned_items } fn identifier (& self) -> & Option < IfcIdentifier > { & self . identifier } } impl IIfcPresentationLayerWithStyle for IfcPresentationLayerWithStyle { fn layer_on (& self) -> & IfcLogical { & self . layer_on } fn layer_frozen (& self) -> & IfcLogical { & self . layer_frozen } fn layer_blocked (& self) -> & IfcLogical { & self . layer_blocked } fn layer_styles (& self) -> & HashSet < EntityRef < IfcPresentationStyle > > { & self . layer_styles } } impl IfcPresentationLayerWithStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPresentationLayerWithStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . assigned_items = parameter . into () , 3usize => entity . identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . layer_on = parameter . into () , 5usize => entity . layer_frozen = parameter . into () , 6usize => entity . layer_blocked = parameter . into () , 7usize => entity . layer_styles = parameter . into () , _ => { } } } entity } } pub trait IIfcPresentationStyle : { pub fn name (& self) -> & Option < IfcLabel > ; } pub trait IIfcPresentationStyleAssignment : { pub fn styles (& self) -> & HashSet < IfcPresentationStyleSelect > ; } # [derive (Default , Debug)] pub struct IfcPresentationStyleAssignment { styles : HashSet < IfcPresentationStyleSelect > , } impl IIfcPresentationStyleAssignment for IfcPresentationStyleAssignment { fn styles (& self) -> & HashSet < IfcPresentationStyleSelect > { & self . styles } } impl IfcPresentationStyleAssignment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPresentationStyleAssignment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . styles = parameter . into () , _ => { } } } entity } } pub trait IIfcProcedure : IIfcProcess { pub fn predefined_type (& self) -> & Option < IfcProcedureTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcProcedure { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , predefined_type : Option < IfcProcedureTypeEnum > , } impl IIfcRoot for IfcProcedure { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProcedure { } impl IIfcObject for IfcProcedure { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProcess for IfcProcedure { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcProcedure for IfcProcedure { fn predefined_type (& self) -> & Option < IfcProcedureTypeEnum > { & self . predefined_type } } impl IfcProcedure { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProcedure :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProcedureType : IIfcTypeProcess { pub fn predefined_type (& self) -> & IfcProcedureTypeEnum ; } # [derive (Default , Debug)] pub struct IfcProcedureType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , process_type : Option < IfcLabel > , predefined_type : IfcProcedureTypeEnum , } impl IIfcRoot for IfcProcedureType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProcedureType { } impl IIfcTypeObject for IfcProcedureType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProcess for IfcProcedureType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn process_type (& self) -> & Option < IfcLabel > { & self . process_type } } impl IIfcProcedureType for IfcProcedureType { fn predefined_type (& self) -> & IfcProcedureTypeEnum { & self . predefined_type } } impl IfcProcedureType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProcedureType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . process_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcProcess : IIfcObject { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn long_description (& self) -> & Option < IfcText > ; } pub trait IIfcProduct : IIfcObject { pub fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > ; pub fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > ; } pub trait IIfcProductDefinitionShape : IIfcProductRepresentation { } # [derive (Default , Debug)] pub struct IfcProductDefinitionShape { name : Option < IfcLabel > , description : Option < IfcText > , representations : Vec < EntityRef < IfcRepresentation > > , } impl IIfcProductRepresentation for IfcProductDefinitionShape { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn representations (& self) -> & Vec < EntityRef < IfcRepresentation > > { & self . representations } } impl IIfcProductDefinitionShape for IfcProductDefinitionShape { } impl IfcProductDefinitionShape { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProductDefinitionShape :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . representations = parameter . into () , _ => { } } } entity } } pub trait IIfcProductRepresentation : { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn representations (& self) -> & Vec < EntityRef < IfcRepresentation > > ; } pub trait IIfcProfileDef : { pub fn profile_type (& self) -> & IfcProfileTypeEnum ; pub fn profile_name (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , } impl IIfcProfileDef for IfcProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IfcProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProfileProperties : IIfcExtendedProperties { pub fn profile_definition (& self) -> & EntityRef < IfcProfileDef > ; } # [derive (Default , Debug)] pub struct IfcProfileProperties { name : Option < IfcIdentifier > , description : Option < IfcText > , properties : HashSet < EntityRef < IfcProperty > > , profile_definition : EntityRef < IfcProfileDef > , } impl IIfcPropertyAbstraction for IfcProfileProperties { } impl IIfcExtendedProperties for IfcProfileProperties { fn name (& self) -> & Option < IfcIdentifier > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn properties (& self) -> & HashSet < EntityRef < IfcProperty > > { & self . properties } } impl IIfcProfileProperties for IfcProfileProperties { fn profile_definition (& self) -> & EntityRef < IfcProfileDef > { & self . profile_definition } } impl IfcProfileProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProfileProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . properties = parameter . into () , 3usize => entity . profile_definition = parameter . into () , _ => { } } } entity } } pub trait IIfcProject : IIfcContext { } # [derive (Default , Debug)] pub struct IfcProject { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , long_name : Option < IfcLabel > , phase : Option < IfcLabel > , representation_contexts : Option < HashSet < EntityRef < IfcRepresentationContext > > > , units_in_context : Option < EntityRef < IfcUnitAssignment > > , } impl IIfcRoot for IfcProject { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProject { } impl IIfcContext for IfcProject { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } fn phase (& self) -> & Option < IfcLabel > { & self . phase } fn representation_contexts (& self) -> & Option < HashSet < EntityRef < IfcRepresentationContext > > > { & self . representation_contexts } fn units_in_context (& self) -> & Option < EntityRef < IfcUnitAssignment > > { & self . units_in_context } } impl IIfcProject for IfcProject { } impl IfcProject { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProject :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . phase = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . representation_contexts = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . units_in_context = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProjectLibrary : IIfcContext { } # [derive (Default , Debug)] pub struct IfcProjectLibrary { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , long_name : Option < IfcLabel > , phase : Option < IfcLabel > , representation_contexts : Option < HashSet < EntityRef < IfcRepresentationContext > > > , units_in_context : Option < EntityRef < IfcUnitAssignment > > , } impl IIfcRoot for IfcProjectLibrary { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProjectLibrary { } impl IIfcContext for IfcProjectLibrary { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } fn phase (& self) -> & Option < IfcLabel > { & self . phase } fn representation_contexts (& self) -> & Option < HashSet < EntityRef < IfcRepresentationContext > > > { & self . representation_contexts } fn units_in_context (& self) -> & Option < EntityRef < IfcUnitAssignment > > { & self . units_in_context } } impl IIfcProjectLibrary for IfcProjectLibrary { } impl IfcProjectLibrary { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProjectLibrary :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . phase = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . representation_contexts = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . units_in_context = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProjectOrder : IIfcControl { pub fn predefined_type (& self) -> & Option < IfcProjectOrderTypeEnum > ; pub fn status (& self) -> & Option < IfcLabel > ; pub fn long_description (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcProjectOrder { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , predefined_type : Option < IfcProjectOrderTypeEnum > , status : Option < IfcLabel > , long_description : Option < IfcText > , } impl IIfcRoot for IfcProjectOrder { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProjectOrder { } impl IIfcObject for IfcProjectOrder { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcProjectOrder { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcProjectOrder for IfcProjectOrder { fn predefined_type (& self) -> & Option < IfcProjectOrderTypeEnum > { & self . predefined_type } fn status (& self) -> & Option < IfcLabel > { & self . status } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IfcProjectOrder { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProjectOrder :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProjectedCrs : IIfcCoordinateReferenceSystem { pub fn map_projection (& self) -> & Option < IfcIdentifier > ; pub fn map_zone (& self) -> & Option < IfcIdentifier > ; pub fn map_unit (& self) -> & Option < EntityRef < IfcNamedUnit > > ; } # [derive (Default , Debug)] pub struct IfcProjectedCrs { name : IfcLabel , description : Option < IfcText > , geodetic_datum : Option < IfcIdentifier > , vertical_datum : Option < IfcIdentifier > , map_projection : Option < IfcIdentifier > , map_zone : Option < IfcIdentifier > , map_unit : Option < EntityRef < IfcNamedUnit > > , } impl IIfcCoordinateReferenceSystem for IfcProjectedCrs { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn geodetic_datum (& self) -> & Option < IfcIdentifier > { & self . geodetic_datum } fn vertical_datum (& self) -> & Option < IfcIdentifier > { & self . vertical_datum } } impl IIfcProjectedCrs for IfcProjectedCrs { fn map_projection (& self) -> & Option < IfcIdentifier > { & self . map_projection } fn map_zone (& self) -> & Option < IfcIdentifier > { & self . map_zone } fn map_unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . map_unit } } impl IfcProjectedCrs { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProjectedCrs :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . geodetic_datum = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . vertical_datum = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . map_projection = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . map_zone = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . map_unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProjectionElement : IIfcFeatureElementAddition { pub fn predefined_type (& self) -> & Option < IfcProjectionElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcProjectionElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcProjectionElementTypeEnum > , } impl IIfcRoot for IfcProjectionElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProjectionElement { } impl IIfcObject for IfcProjectionElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcProjectionElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcProjectionElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFeatureElement for IfcProjectionElement { } impl IIfcFeatureElementAddition for IfcProjectionElement { } impl IIfcProjectionElement for IfcProjectionElement { fn predefined_type (& self) -> & Option < IfcProjectionElementTypeEnum > { & self . predefined_type } } impl IfcProjectionElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProjectionElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProperty : IIfcPropertyAbstraction { pub fn name (& self) -> & IfcIdentifier ; pub fn description (& self) -> & Option < IfcText > ; } pub trait IIfcPropertyAbstraction : { } pub trait IIfcPropertyBoundedValue : IIfcSimpleProperty { pub fn upper_bound_value (& self) -> & Option < IfcValue > ; pub fn lower_bound_value (& self) -> & Option < IfcValue > ; pub fn unit (& self) -> & Option < EntityRef < IfcUnit > > ; pub fn set_point_value (& self) -> & Option < IfcValue > ; } # [derive (Default , Debug)] pub struct IfcPropertyBoundedValue { name : IfcIdentifier , description : Option < IfcText > , upper_bound_value : Option < IfcValue > , lower_bound_value : Option < IfcValue > , unit : Option < EntityRef < IfcUnit > > , set_point_value : Option < IfcValue > , } impl IIfcPropertyAbstraction for IfcPropertyBoundedValue { } impl IIfcProperty for IfcPropertyBoundedValue { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcSimpleProperty for IfcPropertyBoundedValue { } impl IIfcPropertyBoundedValue for IfcPropertyBoundedValue { fn upper_bound_value (& self) -> & Option < IfcValue > { & self . upper_bound_value } fn lower_bound_value (& self) -> & Option < IfcValue > { & self . lower_bound_value } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } fn set_point_value (& self) -> & Option < IfcValue > { & self . set_point_value } } impl IfcPropertyBoundedValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyBoundedValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . upper_bound_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . lower_bound_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . set_point_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyDefinition : IIfcRoot { } pub trait IIfcPropertyDependencyRelationship : IIfcResourceLevelRelationship { pub fn depending_property (& self) -> & EntityRef < IfcProperty > ; pub fn dependant_property (& self) -> & EntityRef < IfcProperty > ; pub fn expression (& self) -> & Option < IfcText > ; } # [derive (Default , Debug)] pub struct IfcPropertyDependencyRelationship { name : Option < IfcLabel > , description : Option < IfcText > , depending_property : EntityRef < IfcProperty > , dependant_property : EntityRef < IfcProperty > , expression : Option < IfcText > , } impl IIfcResourceLevelRelationship for IfcPropertyDependencyRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDependencyRelationship for IfcPropertyDependencyRelationship { fn depending_property (& self) -> & EntityRef < IfcProperty > { & self . depending_property } fn dependant_property (& self) -> & EntityRef < IfcProperty > { & self . dependant_property } fn expression (& self) -> & Option < IfcText > { & self . expression } } impl IfcPropertyDependencyRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyDependencyRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . depending_property = parameter . into () , 3usize => entity . dependant_property = parameter . into () , 4usize => entity . expression = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyEnumeratedValue : IIfcSimpleProperty { pub fn enumeration_values (& self) -> & Option < Vec < IfcValue > > ; pub fn enumeration_reference (& self) -> & Option < EntityRef < IfcPropertyEnumeration > > ; } # [derive (Default , Debug)] pub struct IfcPropertyEnumeratedValue { name : IfcIdentifier , description : Option < IfcText > , enumeration_values : Option < Vec < IfcValue > > , enumeration_reference : Option < EntityRef < IfcPropertyEnumeration > > , } impl IIfcPropertyAbstraction for IfcPropertyEnumeratedValue { } impl IIfcProperty for IfcPropertyEnumeratedValue { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcSimpleProperty for IfcPropertyEnumeratedValue { } impl IIfcPropertyEnumeratedValue for IfcPropertyEnumeratedValue { fn enumeration_values (& self) -> & Option < Vec < IfcValue > > { & self . enumeration_values } fn enumeration_reference (& self) -> & Option < EntityRef < IfcPropertyEnumeration > > { & self . enumeration_reference } } impl IfcPropertyEnumeratedValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyEnumeratedValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . enumeration_values = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . enumeration_reference = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyEnumeration : IIfcPropertyAbstraction { pub fn name (& self) -> & IfcLabel ; pub fn enumeration_values (& self) -> & Vec < IfcValue > ; pub fn unit (& self) -> & Option < EntityRef < IfcUnit > > ; } # [derive (Default , Debug)] pub struct IfcPropertyEnumeration { name : IfcLabel , enumeration_values : Vec < IfcValue > , unit : Option < EntityRef < IfcUnit > > , } impl IIfcPropertyAbstraction for IfcPropertyEnumeration { } impl IIfcPropertyEnumeration for IfcPropertyEnumeration { fn name (& self) -> & IfcLabel { & self . name } fn enumeration_values (& self) -> & Vec < IfcValue > { & self . enumeration_values } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } } impl IfcPropertyEnumeration { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyEnumeration :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . enumeration_values = parameter . into () , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyListValue : IIfcSimpleProperty { pub fn list_values (& self) -> & Option < Vec < IfcValue > > ; pub fn unit (& self) -> & Option < EntityRef < IfcUnit > > ; } # [derive (Default , Debug)] pub struct IfcPropertyListValue { name : IfcIdentifier , description : Option < IfcText > , list_values : Option < Vec < IfcValue > > , unit : Option < EntityRef < IfcUnit > > , } impl IIfcPropertyAbstraction for IfcPropertyListValue { } impl IIfcProperty for IfcPropertyListValue { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcSimpleProperty for IfcPropertyListValue { } impl IIfcPropertyListValue for IfcPropertyListValue { fn list_values (& self) -> & Option < Vec < IfcValue > > { & self . list_values } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } } impl IfcPropertyListValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyListValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . list_values = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyReferenceValue : IIfcSimpleProperty { pub fn usage_name (& self) -> & Option < IfcText > ; pub fn property_reference (& self) -> & Option < EntityRef < IfcObjectReferenceSelect > > ; } # [derive (Default , Debug)] pub struct IfcPropertyReferenceValue { name : IfcIdentifier , description : Option < IfcText > , usage_name : Option < IfcText > , property_reference : Option < EntityRef < IfcObjectReferenceSelect > > , } impl IIfcPropertyAbstraction for IfcPropertyReferenceValue { } impl IIfcProperty for IfcPropertyReferenceValue { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcSimpleProperty for IfcPropertyReferenceValue { } impl IIfcPropertyReferenceValue for IfcPropertyReferenceValue { fn usage_name (& self) -> & Option < IfcText > { & self . usage_name } fn property_reference (& self) -> & Option < EntityRef < IfcObjectReferenceSelect > > { & self . property_reference } } impl IfcPropertyReferenceValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyReferenceValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . usage_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . property_reference = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertySet : IIfcPropertySetDefinition { pub fn has_properties (& self) -> & HashSet < EntityRef < IfcProperty > > ; } # [derive (Default , Debug)] pub struct IfcPropertySet { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , has_properties : HashSet < EntityRef < IfcProperty > > , } impl IIfcRoot for IfcPropertySet { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcPropertySet { } impl IIfcPropertySetDefinition for IfcPropertySet { } impl IIfcPropertySet for IfcPropertySet { fn has_properties (& self) -> & HashSet < EntityRef < IfcProperty > > { & self . has_properties } } impl IfcPropertySet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertySet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . has_properties = parameter . into () , _ => { } } } entity } } pub trait IIfcPropertySetDefinition : IIfcPropertyDefinition { } pub trait IIfcPropertySetTemplate : IIfcPropertyTemplateDefinition { pub fn template_type (& self) -> & Option < IfcPropertySetTemplateTypeEnum > ; pub fn applicable_entity (& self) -> & Option < IfcIdentifier > ; pub fn has_property_templates (& self) -> & HashSet < EntityRef < IfcPropertyTemplate > > ; } # [derive (Default , Debug)] pub struct IfcPropertySetTemplate { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , template_type : Option < IfcPropertySetTemplateTypeEnum > , applicable_entity : Option < IfcIdentifier > , has_property_templates : HashSet < EntityRef < IfcPropertyTemplate > > , } impl IIfcRoot for IfcPropertySetTemplate { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcPropertySetTemplate { } impl IIfcPropertyTemplateDefinition for IfcPropertySetTemplate { } impl IIfcPropertySetTemplate for IfcPropertySetTemplate { fn template_type (& self) -> & Option < IfcPropertySetTemplateTypeEnum > { & self . template_type } fn applicable_entity (& self) -> & Option < IfcIdentifier > { & self . applicable_entity } fn has_property_templates (& self) -> & HashSet < EntityRef < IfcPropertyTemplate > > { & self . has_property_templates } } impl IfcPropertySetTemplate { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertySetTemplate :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . template_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . applicable_entity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . has_property_templates = parameter . into () , _ => { } } } entity } } pub trait IIfcPropertySingleValue : IIfcSimpleProperty { pub fn nominal_value (& self) -> & Option < IfcValue > ; pub fn unit (& self) -> & Option < EntityRef < IfcUnit > > ; } # [derive (Default , Debug)] pub struct IfcPropertySingleValue { name : IfcIdentifier , description : Option < IfcText > , nominal_value : Option < IfcValue > , unit : Option < EntityRef < IfcUnit > > , } impl IIfcPropertyAbstraction for IfcPropertySingleValue { } impl IIfcProperty for IfcPropertySingleValue { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcSimpleProperty for IfcPropertySingleValue { } impl IIfcPropertySingleValue for IfcPropertySingleValue { fn nominal_value (& self) -> & Option < IfcValue > { & self . nominal_value } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } } impl IfcPropertySingleValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertySingleValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . nominal_value = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyTableValue : IIfcSimpleProperty { pub fn defining_values (& self) -> & Option < Vec < IfcValue > > ; pub fn defined_values (& self) -> & Option < Vec < IfcValue > > ; pub fn expression (& self) -> & Option < IfcText > ; pub fn defining_unit (& self) -> & Option < EntityRef < IfcUnit > > ; pub fn defined_unit (& self) -> & Option < EntityRef < IfcUnit > > ; pub fn curve_interpolation (& self) -> & Option < IfcCurveInterpolationEnum > ; } # [derive (Default , Debug)] pub struct IfcPropertyTableValue { name : IfcIdentifier , description : Option < IfcText > , defining_values : Option < Vec < IfcValue > > , defined_values : Option < Vec < IfcValue > > , expression : Option < IfcText > , defining_unit : Option < EntityRef < IfcUnit > > , defined_unit : Option < EntityRef < IfcUnit > > , curve_interpolation : Option < IfcCurveInterpolationEnum > , } impl IIfcPropertyAbstraction for IfcPropertyTableValue { } impl IIfcProperty for IfcPropertyTableValue { fn name (& self) -> & IfcIdentifier { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcSimpleProperty for IfcPropertyTableValue { } impl IIfcPropertyTableValue for IfcPropertyTableValue { fn defining_values (& self) -> & Option < Vec < IfcValue > > { & self . defining_values } fn defined_values (& self) -> & Option < Vec < IfcValue > > { & self . defined_values } fn expression (& self) -> & Option < IfcText > { & self . expression } fn defining_unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . defining_unit } fn defined_unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . defined_unit } fn curve_interpolation (& self) -> & Option < IfcCurveInterpolationEnum > { & self . curve_interpolation } } impl IfcPropertyTableValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPropertyTableValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . defining_values = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . defined_values = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . expression = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . defining_unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . defined_unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . curve_interpolation = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPropertyTemplate : IIfcPropertyTemplateDefinition { } pub trait IIfcPropertyTemplateDefinition : IIfcPropertyDefinition { } pub trait IIfcProtectiveDevice : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcProtectiveDeviceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcProtectiveDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcProtectiveDeviceTypeEnum > , } impl IIfcRoot for IfcProtectiveDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProtectiveDevice { } impl IIfcObject for IfcProtectiveDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcProtectiveDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcProtectiveDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcProtectiveDevice { } impl IIfcDistributionFlowElement for IfcProtectiveDevice { } impl IIfcFlowController for IfcProtectiveDevice { } impl IIfcProtectiveDevice for IfcProtectiveDevice { fn predefined_type (& self) -> & Option < IfcProtectiveDeviceTypeEnum > { & self . predefined_type } } impl IfcProtectiveDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProtectiveDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProtectiveDeviceTrippingUnit : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcProtectiveDeviceTrippingUnitTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcProtectiveDeviceTrippingUnit { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcProtectiveDeviceTrippingUnitTypeEnum > , } impl IIfcRoot for IfcProtectiveDeviceTrippingUnit { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProtectiveDeviceTrippingUnit { } impl IIfcObject for IfcProtectiveDeviceTrippingUnit { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcProtectiveDeviceTrippingUnit { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcProtectiveDeviceTrippingUnit { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcProtectiveDeviceTrippingUnit { } impl IIfcDistributionControlElement for IfcProtectiveDeviceTrippingUnit { } impl IIfcProtectiveDeviceTrippingUnit for IfcProtectiveDeviceTrippingUnit { fn predefined_type (& self) -> & Option < IfcProtectiveDeviceTrippingUnitTypeEnum > { & self . predefined_type } } impl IfcProtectiveDeviceTrippingUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProtectiveDeviceTrippingUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcProtectiveDeviceTrippingUnitType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcProtectiveDeviceTrippingUnitTypeEnum ; } # [derive (Default , Debug)] pub struct IfcProtectiveDeviceTrippingUnitType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcProtectiveDeviceTrippingUnitTypeEnum , } impl IIfcRoot for IfcProtectiveDeviceTrippingUnitType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProtectiveDeviceTrippingUnitType { } impl IIfcTypeObject for IfcProtectiveDeviceTrippingUnitType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcProtectiveDeviceTrippingUnitType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcProtectiveDeviceTrippingUnitType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcProtectiveDeviceTrippingUnitType { } impl IIfcDistributionControlElementType for IfcProtectiveDeviceTrippingUnitType { } impl IIfcProtectiveDeviceTrippingUnitType for IfcProtectiveDeviceTrippingUnitType { fn predefined_type (& self) -> & IfcProtectiveDeviceTrippingUnitTypeEnum { & self . predefined_type } } impl IfcProtectiveDeviceTrippingUnitType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProtectiveDeviceTrippingUnitType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcProtectiveDeviceType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcProtectiveDeviceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcProtectiveDeviceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcProtectiveDeviceTypeEnum , } impl IIfcRoot for IfcProtectiveDeviceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProtectiveDeviceType { } impl IIfcTypeObject for IfcProtectiveDeviceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcProtectiveDeviceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcProtectiveDeviceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcProtectiveDeviceType { } impl IIfcDistributionFlowElementType for IfcProtectiveDeviceType { } impl IIfcFlowControllerType for IfcProtectiveDeviceType { } impl IIfcProtectiveDeviceType for IfcProtectiveDeviceType { fn predefined_type (& self) -> & IfcProtectiveDeviceTypeEnum { & self . predefined_type } } impl IfcProtectiveDeviceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProtectiveDeviceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcProxy : IIfcProduct { pub fn proxy_type (& self) -> & IfcObjectTypeEnum ; pub fn tag (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcProxy { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , proxy_type : IfcObjectTypeEnum , tag : Option < IfcLabel > , } impl IIfcRoot for IfcProxy { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcProxy { } impl IIfcObject for IfcProxy { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcProxy { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcProxy for IfcProxy { fn proxy_type (& self) -> & IfcObjectTypeEnum { & self . proxy_type } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IfcProxy { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcProxy :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . proxy_type = parameter . into () , 8usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPump : IIfcFlowMovingDevice { pub fn predefined_type (& self) -> & Option < IfcPumpTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcPump { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcPumpTypeEnum > , } impl IIfcRoot for IfcPump { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPump { } impl IIfcObject for IfcPump { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcPump { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcPump { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcPump { } impl IIfcDistributionFlowElement for IfcPump { } impl IIfcFlowMovingDevice for IfcPump { } impl IIfcPump for IfcPump { fn predefined_type (& self) -> & Option < IfcPumpTypeEnum > { & self . predefined_type } } impl IfcPump { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPump :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcPumpType : IIfcFlowMovingDeviceType { pub fn predefined_type (& self) -> & IfcPumpTypeEnum ; } # [derive (Default , Debug)] pub struct IfcPumpType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcPumpTypeEnum , } impl IIfcRoot for IfcPumpType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcPumpType { } impl IIfcTypeObject for IfcPumpType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcPumpType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcPumpType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcPumpType { } impl IIfcDistributionFlowElementType for IfcPumpType { } impl IIfcFlowMovingDeviceType for IfcPumpType { } impl IIfcPumpType for IfcPumpType { fn predefined_type (& self) -> & IfcPumpTypeEnum { & self . predefined_type } } impl IfcPumpType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcPumpType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcQuantityArea : IIfcPhysicalSimpleQuantity { pub fn area_value (& self) -> & IfcAreaMeasure ; pub fn formula (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcQuantityArea { name : IfcLabel , description : Option < IfcText > , unit : Option < EntityRef < IfcNamedUnit > > , area_value : IfcAreaMeasure , formula : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcQuantityArea { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalSimpleQuantity for IfcQuantityArea { fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . unit } } impl IIfcQuantityArea for IfcQuantityArea { fn area_value (& self) -> & IfcAreaMeasure { & self . area_value } fn formula (& self) -> & Option < IfcLabel > { & self . formula } } impl IfcQuantityArea { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcQuantityArea :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . area_value = parameter . into () , 4usize => entity . formula = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcQuantityCount : IIfcPhysicalSimpleQuantity { pub fn count_value (& self) -> & IfcCountMeasure ; pub fn formula (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcQuantityCount { name : IfcLabel , description : Option < IfcText > , unit : Option < EntityRef < IfcNamedUnit > > , count_value : IfcCountMeasure , formula : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcQuantityCount { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalSimpleQuantity for IfcQuantityCount { fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . unit } } impl IIfcQuantityCount for IfcQuantityCount { fn count_value (& self) -> & IfcCountMeasure { & self . count_value } fn formula (& self) -> & Option < IfcLabel > { & self . formula } } impl IfcQuantityCount { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcQuantityCount :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . count_value = parameter . into () , 4usize => entity . formula = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcQuantityLength : IIfcPhysicalSimpleQuantity { pub fn length_value (& self) -> & IfcLengthMeasure ; pub fn formula (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcQuantityLength { name : IfcLabel , description : Option < IfcText > , unit : Option < EntityRef < IfcNamedUnit > > , length_value : IfcLengthMeasure , formula : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcQuantityLength { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalSimpleQuantity for IfcQuantityLength { fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . unit } } impl IIfcQuantityLength for IfcQuantityLength { fn length_value (& self) -> & IfcLengthMeasure { & self . length_value } fn formula (& self) -> & Option < IfcLabel > { & self . formula } } impl IfcQuantityLength { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcQuantityLength :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . length_value = parameter . into () , 4usize => entity . formula = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcQuantitySet : IIfcPropertySetDefinition { } pub trait IIfcQuantityTime : IIfcPhysicalSimpleQuantity { pub fn time_value (& self) -> & IfcTimeMeasure ; pub fn formula (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcQuantityTime { name : IfcLabel , description : Option < IfcText > , unit : Option < EntityRef < IfcNamedUnit > > , time_value : IfcTimeMeasure , formula : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcQuantityTime { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalSimpleQuantity for IfcQuantityTime { fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . unit } } impl IIfcQuantityTime for IfcQuantityTime { fn time_value (& self) -> & IfcTimeMeasure { & self . time_value } fn formula (& self) -> & Option < IfcLabel > { & self . formula } } impl IfcQuantityTime { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcQuantityTime :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . time_value = parameter . into () , 4usize => entity . formula = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcQuantityVolume : IIfcPhysicalSimpleQuantity { pub fn volume_value (& self) -> & IfcVolumeMeasure ; pub fn formula (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcQuantityVolume { name : IfcLabel , description : Option < IfcText > , unit : Option < EntityRef < IfcNamedUnit > > , volume_value : IfcVolumeMeasure , formula : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcQuantityVolume { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalSimpleQuantity for IfcQuantityVolume { fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . unit } } impl IIfcQuantityVolume for IfcQuantityVolume { fn volume_value (& self) -> & IfcVolumeMeasure { & self . volume_value } fn formula (& self) -> & Option < IfcLabel > { & self . formula } } impl IfcQuantityVolume { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcQuantityVolume :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . volume_value = parameter . into () , 4usize => entity . formula = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcQuantityWeight : IIfcPhysicalSimpleQuantity { pub fn weight_value (& self) -> & IfcMassMeasure ; pub fn formula (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcQuantityWeight { name : IfcLabel , description : Option < IfcText > , unit : Option < EntityRef < IfcNamedUnit > > , weight_value : IfcMassMeasure , formula : Option < IfcLabel > , } impl IIfcPhysicalQuantity for IfcQuantityWeight { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPhysicalSimpleQuantity for IfcQuantityWeight { fn unit (& self) -> & Option < EntityRef < IfcNamedUnit > > { & self . unit } } impl IIfcQuantityWeight for IfcQuantityWeight { fn weight_value (& self) -> & IfcMassMeasure { & self . weight_value } fn formula (& self) -> & Option < IfcLabel > { & self . formula } } impl IfcQuantityWeight { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcQuantityWeight :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . weight_value = parameter . into () , 4usize => entity . formula = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRailing : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcRailingTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcRailing { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcRailingTypeEnum > , } impl IIfcRoot for IfcRailing { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRailing { } impl IIfcObject for IfcRailing { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcRailing { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcRailing { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcRailing { } impl IIfcRailing for IfcRailing { fn predefined_type (& self) -> & Option < IfcRailingTypeEnum > { & self . predefined_type } } impl IfcRailing { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRailing :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRailingType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcRailingTypeEnum ; } # [derive (Default , Debug)] pub struct IfcRailingType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcRailingTypeEnum , } impl IIfcRoot for IfcRailingType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRailingType { } impl IIfcTypeObject for IfcRailingType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcRailingType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcRailingType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcRailingType { } impl IIfcRailingType for IfcRailingType { fn predefined_type (& self) -> & IfcRailingTypeEnum { & self . predefined_type } } impl IfcRailingType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRailingType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcRamp : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcRampTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcRamp { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcRampTypeEnum > , } impl IIfcRoot for IfcRamp { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRamp { } impl IIfcObject for IfcRamp { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcRamp { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcRamp { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcRamp { } impl IIfcRamp for IfcRamp { fn predefined_type (& self) -> & Option < IfcRampTypeEnum > { & self . predefined_type } } impl IfcRamp { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRamp :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRampFlight : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcRampFlightTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcRampFlight { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcRampFlightTypeEnum > , } impl IIfcRoot for IfcRampFlight { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRampFlight { } impl IIfcObject for IfcRampFlight { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcRampFlight { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcRampFlight { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcRampFlight { } impl IIfcRampFlight for IfcRampFlight { fn predefined_type (& self) -> & Option < IfcRampFlightTypeEnum > { & self . predefined_type } } impl IfcRampFlight { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRampFlight :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRampFlightType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcRampFlightTypeEnum ; } # [derive (Default , Debug)] pub struct IfcRampFlightType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcRampFlightTypeEnum , } impl IIfcRoot for IfcRampFlightType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRampFlightType { } impl IIfcTypeObject for IfcRampFlightType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcRampFlightType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcRampFlightType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcRampFlightType { } impl IIfcRampFlightType for IfcRampFlightType { fn predefined_type (& self) -> & IfcRampFlightTypeEnum { & self . predefined_type } } impl IfcRampFlightType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRampFlightType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcRampType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcRampTypeEnum ; } # [derive (Default , Debug)] pub struct IfcRampType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcRampTypeEnum , } impl IIfcRoot for IfcRampType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRampType { } impl IIfcTypeObject for IfcRampType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcRampType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcRampType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcRampType { } impl IIfcRampType for IfcRampType { fn predefined_type (& self) -> & IfcRampTypeEnum { & self . predefined_type } } impl IfcRampType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRampType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcRationalBSplineCurveWithKnots : IIfcBSplineCurveWithKnots { pub fn weights_data (& self) -> & Vec < IfcReal > ; } # [derive (Default , Debug)] pub struct IfcRationalBSplineCurveWithKnots { degree : IfcInteger , control_points_list : Vec < EntityRef < IfcCartesianPoint > > , curve_form : IfcBSplineCurveForm , closed_curve : IfcLogical , self_intersect : IfcLogical , knot_multiplicities : Vec < IfcInteger > , knots : Vec < IfcParameterValue > , knot_spec : IfcKnotType , weights_data : Vec < IfcReal > , } impl IIfcRepresentationItem for IfcRationalBSplineCurveWithKnots { } impl IIfcGeometricRepresentationItem for IfcRationalBSplineCurveWithKnots { } impl IIfcCurve for IfcRationalBSplineCurveWithKnots { } impl IIfcBoundedCurve for IfcRationalBSplineCurveWithKnots { } impl IIfcBSplineCurve for IfcRationalBSplineCurveWithKnots { fn degree (& self) -> & IfcInteger { & self . degree } fn control_points_list (& self) -> & Vec < EntityRef < IfcCartesianPoint > > { & self . control_points_list } fn curve_form (& self) -> & IfcBSplineCurveForm { & self . curve_form } fn closed_curve (& self) -> & IfcLogical { & self . closed_curve } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcBSplineCurveWithKnots for IfcRationalBSplineCurveWithKnots { fn knot_multiplicities (& self) -> & Vec < IfcInteger > { & self . knot_multiplicities } fn knots (& self) -> & Vec < IfcParameterValue > { & self . knots } fn knot_spec (& self) -> & IfcKnotType { & self . knot_spec } } impl IIfcRationalBSplineCurveWithKnots for IfcRationalBSplineCurveWithKnots { fn weights_data (& self) -> & Vec < IfcReal > { & self . weights_data } } impl IfcRationalBSplineCurveWithKnots { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRationalBSplineCurveWithKnots :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . degree = parameter . into () , 1usize => entity . control_points_list = parameter . into () , 2usize => entity . curve_form = parameter . into () , 3usize => entity . closed_curve = parameter . into () , 4usize => entity . self_intersect = parameter . into () , 5usize => entity . knot_multiplicities = parameter . into () , 6usize => entity . knots = parameter . into () , 7usize => entity . knot_spec = parameter . into () , 8usize => entity . weights_data = parameter . into () , _ => { } } } entity } } pub trait IIfcRationalBSplineSurfaceWithKnots : IIfcBSplineSurfaceWithKnots { pub fn weights_data (& self) -> & Vec < Vec < IfcReal > > ; } # [derive (Default , Debug)] pub struct IfcRationalBSplineSurfaceWithKnots { u_degree : IfcInteger , v_degree : IfcInteger , control_points_list : Vec < Vec < EntityRef < IfcCartesianPoint > > > , surface_form : IfcBSplineSurfaceForm , u_closed : IfcLogical , v_closed : IfcLogical , self_intersect : IfcLogical , u_multiplicities : Vec < IfcInteger > , v_multiplicities : Vec < IfcInteger > , u_knots : Vec < IfcParameterValue > , v_knots : Vec < IfcParameterValue > , knot_spec : IfcKnotType , weights_data : Vec < Vec < IfcReal > > , } impl IIfcRepresentationItem for IfcRationalBSplineSurfaceWithKnots { } impl IIfcGeometricRepresentationItem for IfcRationalBSplineSurfaceWithKnots { } impl IIfcSurface for IfcRationalBSplineSurfaceWithKnots { } impl IIfcBoundedSurface for IfcRationalBSplineSurfaceWithKnots { } impl IIfcBSplineSurface for IfcRationalBSplineSurfaceWithKnots { fn u_degree (& self) -> & IfcInteger { & self . u_degree } fn v_degree (& self) -> & IfcInteger { & self . v_degree } fn control_points_list (& self) -> & Vec < Vec < EntityRef < IfcCartesianPoint > > > { & self . control_points_list } fn surface_form (& self) -> & IfcBSplineSurfaceForm { & self . surface_form } fn u_closed (& self) -> & IfcLogical { & self . u_closed } fn v_closed (& self) -> & IfcLogical { & self . v_closed } fn self_intersect (& self) -> & IfcLogical { & self . self_intersect } } impl IIfcBSplineSurfaceWithKnots for IfcRationalBSplineSurfaceWithKnots { fn u_multiplicities (& self) -> & Vec < IfcInteger > { & self . u_multiplicities } fn v_multiplicities (& self) -> & Vec < IfcInteger > { & self . v_multiplicities } fn u_knots (& self) -> & Vec < IfcParameterValue > { & self . u_knots } fn v_knots (& self) -> & Vec < IfcParameterValue > { & self . v_knots } fn knot_spec (& self) -> & IfcKnotType { & self . knot_spec } } impl IIfcRationalBSplineSurfaceWithKnots for IfcRationalBSplineSurfaceWithKnots { fn weights_data (& self) -> & Vec < Vec < IfcReal > > { & self . weights_data } } impl IfcRationalBSplineSurfaceWithKnots { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRationalBSplineSurfaceWithKnots :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . u_degree = parameter . into () , 1usize => entity . v_degree = parameter . into () , 2usize => entity . control_points_list = parameter . into () , 3usize => entity . surface_form = parameter . into () , 4usize => entity . u_closed = parameter . into () , 5usize => entity . v_closed = parameter . into () , 6usize => entity . self_intersect = parameter . into () , 7usize => entity . u_multiplicities = parameter . into () , 8usize => entity . v_multiplicities = parameter . into () , 9usize => entity . u_knots = parameter . into () , 10usize => entity . v_knots = parameter . into () , 11usize => entity . knot_spec = parameter . into () , 12usize => entity . weights_data = parameter . into () , _ => { } } } entity } } pub trait IIfcRectangleHollowProfileDef : IIfcRectangleProfileDef { pub fn wall_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn inner_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn outer_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcRectangleHollowProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , x_dim : IfcPositiveLengthMeasure , y_dim : IfcPositiveLengthMeasure , wall_thickness : IfcPositiveLengthMeasure , inner_fillet_radius : Option < IfcNonNegativeLengthMeasure > , outer_fillet_radius : Option < IfcNonNegativeLengthMeasure > , } impl IIfcProfileDef for IfcRectangleHollowProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcRectangleHollowProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcRectangleProfileDef for IfcRectangleHollowProfileDef { fn x_dim (& self) -> & IfcPositiveLengthMeasure { & self . x_dim } fn y_dim (& self) -> & IfcPositiveLengthMeasure { & self . y_dim } } impl IIfcRectangleHollowProfileDef for IfcRectangleHollowProfileDef { fn wall_thickness (& self) -> & IfcPositiveLengthMeasure { & self . wall_thickness } fn inner_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . inner_fillet_radius } fn outer_fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . outer_fillet_radius } } impl IfcRectangleHollowProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRectangleHollowProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . x_dim = parameter . into () , 4usize => entity . y_dim = parameter . into () , 5usize => entity . wall_thickness = parameter . into () , 6usize => entity . inner_fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . outer_fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRectangleProfileDef : IIfcParameterizedProfileDef { pub fn x_dim (& self) -> & IfcPositiveLengthMeasure ; pub fn y_dim (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcRectangleProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , x_dim : IfcPositiveLengthMeasure , y_dim : IfcPositiveLengthMeasure , } impl IIfcProfileDef for IfcRectangleProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcRectangleProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcRectangleProfileDef for IfcRectangleProfileDef { fn x_dim (& self) -> & IfcPositiveLengthMeasure { & self . x_dim } fn y_dim (& self) -> & IfcPositiveLengthMeasure { & self . y_dim } } impl IfcRectangleProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRectangleProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . x_dim = parameter . into () , 4usize => entity . y_dim = parameter . into () , _ => { } } } entity } } pub trait IIfcRectangularPyramid : IIfcCsgPrimitive3D { pub fn x_length (& self) -> & IfcPositiveLengthMeasure ; pub fn y_length (& self) -> & IfcPositiveLengthMeasure ; pub fn height (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcRectangularPyramid { position : EntityRef < IfcAxis2Placement3D > , x_length : IfcPositiveLengthMeasure , y_length : IfcPositiveLengthMeasure , height : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcRectangularPyramid { } impl IIfcGeometricRepresentationItem for IfcRectangularPyramid { } impl IIfcCsgPrimitive3D for IfcRectangularPyramid { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcRectangularPyramid for IfcRectangularPyramid { fn x_length (& self) -> & IfcPositiveLengthMeasure { & self . x_length } fn y_length (& self) -> & IfcPositiveLengthMeasure { & self . y_length } fn height (& self) -> & IfcPositiveLengthMeasure { & self . height } } impl IfcRectangularPyramid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRectangularPyramid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . x_length = parameter . into () , 2usize => entity . y_length = parameter . into () , 3usize => entity . height = parameter . into () , _ => { } } } entity } } pub trait IIfcRectangularTrimmedSurface : IIfcBoundedSurface { pub fn basis_surface (& self) -> & EntityRef < IfcSurface > ; pub fn u1 (& self) -> & IfcParameterValue ; pub fn v1 (& self) -> & IfcParameterValue ; pub fn u2 (& self) -> & IfcParameterValue ; pub fn v2 (& self) -> & IfcParameterValue ; pub fn usense (& self) -> & IfcBoolean ; pub fn vsense (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcRectangularTrimmedSurface { basis_surface : EntityRef < IfcSurface > , u1 : IfcParameterValue , v1 : IfcParameterValue , u2 : IfcParameterValue , v2 : IfcParameterValue , usense : IfcBoolean , vsense : IfcBoolean , } impl IIfcRepresentationItem for IfcRectangularTrimmedSurface { } impl IIfcGeometricRepresentationItem for IfcRectangularTrimmedSurface { } impl IIfcSurface for IfcRectangularTrimmedSurface { } impl IIfcBoundedSurface for IfcRectangularTrimmedSurface { } impl IIfcRectangularTrimmedSurface for IfcRectangularTrimmedSurface { fn basis_surface (& self) -> & EntityRef < IfcSurface > { & self . basis_surface } fn u1 (& self) -> & IfcParameterValue { & self . u1 } fn v1 (& self) -> & IfcParameterValue { & self . v1 } fn u2 (& self) -> & IfcParameterValue { & self . u2 } fn v2 (& self) -> & IfcParameterValue { & self . v2 } fn usense (& self) -> & IfcBoolean { & self . usense } fn vsense (& self) -> & IfcBoolean { & self . vsense } } impl IfcRectangularTrimmedSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRectangularTrimmedSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_surface = parameter . into () , 1usize => entity . u1 = parameter . into () , 2usize => entity . v1 = parameter . into () , 3usize => entity . u2 = parameter . into () , 4usize => entity . v2 = parameter . into () , 5usize => entity . usense = parameter . into () , 6usize => entity . vsense = parameter . into () , _ => { } } } entity } } pub trait IIfcRecurrencePattern : { pub fn recurrence_type (& self) -> & IfcRecurrenceTypeEnum ; pub fn day_component (& self) -> & Option < HashSet < IfcDayInMonthNumber > > ; pub fn weekday_component (& self) -> & Option < HashSet < IfcDayInWeekNumber > > ; pub fn month_component (& self) -> & Option < HashSet < IfcMonthInYearNumber > > ; pub fn position (& self) -> & Option < IfcInteger > ; pub fn interval (& self) -> & Option < IfcInteger > ; pub fn occurrences (& self) -> & Option < IfcInteger > ; pub fn time_periods (& self) -> & Option < Vec < EntityRef < IfcTimePeriod > > > ; } # [derive (Default , Debug)] pub struct IfcRecurrencePattern { recurrence_type : IfcRecurrenceTypeEnum , day_component : Option < HashSet < IfcDayInMonthNumber > > , weekday_component : Option < HashSet < IfcDayInWeekNumber > > , month_component : Option < HashSet < IfcMonthInYearNumber > > , position : Option < IfcInteger > , interval : Option < IfcInteger > , occurrences : Option < IfcInteger > , time_periods : Option < Vec < EntityRef < IfcTimePeriod > > > , } impl IIfcRecurrencePattern for IfcRecurrencePattern { fn recurrence_type (& self) -> & IfcRecurrenceTypeEnum { & self . recurrence_type } fn day_component (& self) -> & Option < HashSet < IfcDayInMonthNumber > > { & self . day_component } fn weekday_component (& self) -> & Option < HashSet < IfcDayInWeekNumber > > { & self . weekday_component } fn month_component (& self) -> & Option < HashSet < IfcMonthInYearNumber > > { & self . month_component } fn position (& self) -> & Option < IfcInteger > { & self . position } fn interval (& self) -> & Option < IfcInteger > { & self . interval } fn occurrences (& self) -> & Option < IfcInteger > { & self . occurrences } fn time_periods (& self) -> & Option < Vec < EntityRef < IfcTimePeriod > > > { & self . time_periods } } impl IfcRecurrencePattern { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRecurrencePattern :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . recurrence_type = parameter . into () , 1usize => entity . day_component = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . weekday_component = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . month_component = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . interval = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . occurrences = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . time_periods = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcReference : { pub fn type_identifier (& self) -> & Option < IfcIdentifier > ; pub fn attribute_identifier (& self) -> & Option < IfcIdentifier > ; pub fn instance_name (& self) -> & Option < IfcLabel > ; pub fn list_positions (& self) -> & Option < Vec < IfcInteger > > ; pub fn inner_reference (& self) -> & Option < EntityRef < IfcReference > > ; } # [derive (Default , Debug)] pub struct IfcReference { type_identifier : Option < IfcIdentifier > , attribute_identifier : Option < IfcIdentifier > , instance_name : Option < IfcLabel > , list_positions : Option < Vec < IfcInteger > > , inner_reference : Option < EntityRef < IfcReference > > , } impl IIfcReference for IfcReference { fn type_identifier (& self) -> & Option < IfcIdentifier > { & self . type_identifier } fn attribute_identifier (& self) -> & Option < IfcIdentifier > { & self . attribute_identifier } fn instance_name (& self) -> & Option < IfcLabel > { & self . instance_name } fn list_positions (& self) -> & Option < Vec < IfcInteger > > { & self . list_positions } fn inner_reference (& self) -> & Option < EntityRef < IfcReference > > { & self . inner_reference } } impl IfcReference { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReference :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . type_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . attribute_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . instance_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . list_positions = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . inner_reference = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRegularTimeSeries : IIfcTimeSeries { pub fn time_step (& self) -> & IfcTimeMeasure ; pub fn values (& self) -> & Vec < EntityRef < IfcTimeSeriesValue > > ; } # [derive (Default , Debug)] pub struct IfcRegularTimeSeries { name : IfcLabel , description : Option < IfcText > , start_time : IfcDateTime , end_time : IfcDateTime , time_series_data_type : IfcTimeSeriesDataTypeEnum , data_origin : IfcDataOriginEnum , user_defined_data_origin : Option < IfcLabel > , unit : Option < EntityRef < IfcUnit > > , time_step : IfcTimeMeasure , values : Vec < EntityRef < IfcTimeSeriesValue > > , } impl IIfcTimeSeries for IfcRegularTimeSeries { fn name (& self) -> & IfcLabel { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn start_time (& self) -> & IfcDateTime { & self . start_time } fn end_time (& self) -> & IfcDateTime { & self . end_time } fn time_series_data_type (& self) -> & IfcTimeSeriesDataTypeEnum { & self . time_series_data_type } fn data_origin (& self) -> & IfcDataOriginEnum { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } } impl IIfcRegularTimeSeries for IfcRegularTimeSeries { fn time_step (& self) -> & IfcTimeMeasure { & self . time_step } fn values (& self) -> & Vec < EntityRef < IfcTimeSeriesValue > > { & self . values } } impl IfcRegularTimeSeries { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRegularTimeSeries :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . start_time = parameter . into () , 3usize => entity . end_time = parameter . into () , 4usize => entity . time_series_data_type = parameter . into () , 5usize => entity . data_origin = parameter . into () , 6usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . time_step = parameter . into () , 9usize => entity . values = parameter . into () , _ => { } } } entity } } pub trait IIfcReinforcementBarProperties : IIfcPreDefinedProperties { pub fn total_cross_section_area (& self) -> & IfcAreaMeasure ; pub fn steel_grade (& self) -> & IfcLabel ; pub fn bar_surface (& self) -> & Option < IfcReinforcingBarSurfaceEnum > ; pub fn effective_depth (& self) -> & Option < IfcLengthMeasure > ; pub fn nominal_bar_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn bar_count (& self) -> & Option < IfcCountMeasure > ; } # [derive (Default , Debug)] pub struct IfcReinforcementBarProperties { total_cross_section_area : IfcAreaMeasure , steel_grade : IfcLabel , bar_surface : Option < IfcReinforcingBarSurfaceEnum > , effective_depth : Option < IfcLengthMeasure > , nominal_bar_diameter : Option < IfcPositiveLengthMeasure > , bar_count : Option < IfcCountMeasure > , } impl IIfcPropertyAbstraction for IfcReinforcementBarProperties { } impl IIfcPreDefinedProperties for IfcReinforcementBarProperties { } impl IIfcReinforcementBarProperties for IfcReinforcementBarProperties { fn total_cross_section_area (& self) -> & IfcAreaMeasure { & self . total_cross_section_area } fn steel_grade (& self) -> & IfcLabel { & self . steel_grade } fn bar_surface (& self) -> & Option < IfcReinforcingBarSurfaceEnum > { & self . bar_surface } fn effective_depth (& self) -> & Option < IfcLengthMeasure > { & self . effective_depth } fn nominal_bar_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_bar_diameter } fn bar_count (& self) -> & Option < IfcCountMeasure > { & self . bar_count } } impl IfcReinforcementBarProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReinforcementBarProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . total_cross_section_area = parameter . into () , 1usize => entity . steel_grade = parameter . into () , 2usize => entity . bar_surface = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . effective_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . nominal_bar_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . bar_count = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcReinforcementDefinitionProperties : IIfcPreDefinedPropertySet { pub fn definition_type (& self) -> & Option < IfcLabel > ; pub fn reinforcement_section_definitions (& self) -> & Vec < EntityRef < IfcSectionReinforcementProperties > > ; } # [derive (Default , Debug)] pub struct IfcReinforcementDefinitionProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , definition_type : Option < IfcLabel > , reinforcement_section_definitions : Vec < EntityRef < IfcSectionReinforcementProperties > > , } impl IIfcRoot for IfcReinforcementDefinitionProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcReinforcementDefinitionProperties { } impl IIfcPropertySetDefinition for IfcReinforcementDefinitionProperties { } impl IIfcPreDefinedPropertySet for IfcReinforcementDefinitionProperties { } impl IIfcReinforcementDefinitionProperties for IfcReinforcementDefinitionProperties { fn definition_type (& self) -> & Option < IfcLabel > { & self . definition_type } fn reinforcement_section_definitions (& self) -> & Vec < EntityRef < IfcSectionReinforcementProperties > > { & self . reinforcement_section_definitions } } impl IfcReinforcementDefinitionProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReinforcementDefinitionProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . definition_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . reinforcement_section_definitions = parameter . into () , _ => { } } } entity } } pub trait IIfcReinforcingBar : IIfcReinforcingElement { pub fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn bar_length (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn predefined_type (& self) -> & Option < IfcReinforcingBarTypeEnum > ; pub fn bar_surface (& self) -> & Option < IfcReinforcingBarSurfaceEnum > ; } # [derive (Default , Debug)] pub struct IfcReinforcingBar { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , steel_grade : Option < IfcLabel > , nominal_diameter : Option < IfcPositiveLengthMeasure > , cross_section_area : Option < IfcAreaMeasure > , bar_length : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcReinforcingBarTypeEnum > , bar_surface : Option < IfcReinforcingBarSurfaceEnum > , } impl IIfcRoot for IfcReinforcingBar { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcReinforcingBar { } impl IIfcObject for IfcReinforcingBar { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcReinforcingBar { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcReinforcingBar { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcReinforcingBar { } impl IIfcReinforcingElement for IfcReinforcingBar { fn steel_grade (& self) -> & Option < IfcLabel > { & self . steel_grade } } impl IIfcReinforcingBar for IfcReinforcingBar { fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_diameter } fn cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . cross_section_area } fn bar_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . bar_length } fn predefined_type (& self) -> & Option < IfcReinforcingBarTypeEnum > { & self . predefined_type } fn bar_surface (& self) -> & Option < IfcReinforcingBarSurfaceEnum > { & self . bar_surface } } impl IfcReinforcingBar { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReinforcingBar :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . steel_grade = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . bar_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . bar_surface = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcReinforcingBarType : IIfcReinforcingElementType { pub fn predefined_type (& self) -> & IfcReinforcingBarTypeEnum ; pub fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn bar_length (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn bar_surface (& self) -> & Option < IfcReinforcingBarSurfaceEnum > ; pub fn bending_shape_code (& self) -> & Option < IfcLabel > ; pub fn bending_parameters (& self) -> & Option < Vec < IfcBendingParameterSelect > > ; } # [derive (Default , Debug)] pub struct IfcReinforcingBarType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcReinforcingBarTypeEnum , nominal_diameter : Option < IfcPositiveLengthMeasure > , cross_section_area : Option < IfcAreaMeasure > , bar_length : Option < IfcPositiveLengthMeasure > , bar_surface : Option < IfcReinforcingBarSurfaceEnum > , bending_shape_code : Option < IfcLabel > , bending_parameters : Option < Vec < IfcBendingParameterSelect > > , } impl IIfcRoot for IfcReinforcingBarType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcReinforcingBarType { } impl IIfcTypeObject for IfcReinforcingBarType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcReinforcingBarType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcReinforcingBarType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcReinforcingBarType { } impl IIfcReinforcingElementType for IfcReinforcingBarType { } impl IIfcReinforcingBarType for IfcReinforcingBarType { fn predefined_type (& self) -> & IfcReinforcingBarTypeEnum { & self . predefined_type } fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_diameter } fn cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . cross_section_area } fn bar_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . bar_length } fn bar_surface (& self) -> & Option < IfcReinforcingBarSurfaceEnum > { & self . bar_surface } fn bending_shape_code (& self) -> & Option < IfcLabel > { & self . bending_shape_code } fn bending_parameters (& self) -> & Option < Vec < IfcBendingParameterSelect > > { & self . bending_parameters } } impl IfcReinforcingBarType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReinforcingBarType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . bar_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . bar_surface = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . bending_shape_code = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . bending_parameters = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcReinforcingElement : IIfcElementComponent { pub fn steel_grade (& self) -> & Option < IfcLabel > ; } pub trait IIfcReinforcingElementType : IIfcElementComponentType { } pub trait IIfcReinforcingMesh : IIfcReinforcingElement { pub fn mesh_length (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn mesh_width (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn longitudinal_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn transverse_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn longitudinal_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn transverse_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn longitudinal_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn transverse_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn predefined_type (& self) -> & Option < IfcReinforcingMeshTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcReinforcingMesh { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , steel_grade : Option < IfcLabel > , mesh_length : Option < IfcPositiveLengthMeasure > , mesh_width : Option < IfcPositiveLengthMeasure > , longitudinal_bar_nominal_diameter : Option < IfcPositiveLengthMeasure > , transverse_bar_nominal_diameter : Option < IfcPositiveLengthMeasure > , longitudinal_bar_cross_section_area : Option < IfcAreaMeasure > , transverse_bar_cross_section_area : Option < IfcAreaMeasure > , longitudinal_bar_spacing : Option < IfcPositiveLengthMeasure > , transverse_bar_spacing : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcReinforcingMeshTypeEnum > , } impl IIfcRoot for IfcReinforcingMesh { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcReinforcingMesh { } impl IIfcObject for IfcReinforcingMesh { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcReinforcingMesh { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcReinforcingMesh { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcReinforcingMesh { } impl IIfcReinforcingElement for IfcReinforcingMesh { fn steel_grade (& self) -> & Option < IfcLabel > { & self . steel_grade } } impl IIfcReinforcingMesh for IfcReinforcingMesh { fn mesh_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . mesh_length } fn mesh_width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . mesh_width } fn longitudinal_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . longitudinal_bar_nominal_diameter } fn transverse_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . transverse_bar_nominal_diameter } fn longitudinal_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . longitudinal_bar_cross_section_area } fn transverse_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . transverse_bar_cross_section_area } fn longitudinal_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > { & self . longitudinal_bar_spacing } fn transverse_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > { & self . transverse_bar_spacing } fn predefined_type (& self) -> & Option < IfcReinforcingMeshTypeEnum > { & self . predefined_type } } impl IfcReinforcingMesh { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReinforcingMesh :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . steel_grade = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . mesh_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . mesh_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . longitudinal_bar_nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . transverse_bar_nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . longitudinal_bar_cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . transverse_bar_cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . longitudinal_bar_spacing = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . transverse_bar_spacing = if parameter . is_null () { None } else { Some (parameter . into ()) } , 17usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcReinforcingMeshType : IIfcReinforcingElementType { pub fn predefined_type (& self) -> & IfcReinforcingMeshTypeEnum ; pub fn mesh_length (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn mesh_width (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn longitudinal_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn transverse_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn longitudinal_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn transverse_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn longitudinal_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn transverse_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn bending_shape_code (& self) -> & Option < IfcLabel > ; pub fn bending_parameters (& self) -> & Option < Vec < IfcBendingParameterSelect > > ; } # [derive (Default , Debug)] pub struct IfcReinforcingMeshType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcReinforcingMeshTypeEnum , mesh_length : Option < IfcPositiveLengthMeasure > , mesh_width : Option < IfcPositiveLengthMeasure > , longitudinal_bar_nominal_diameter : Option < IfcPositiveLengthMeasure > , transverse_bar_nominal_diameter : Option < IfcPositiveLengthMeasure > , longitudinal_bar_cross_section_area : Option < IfcAreaMeasure > , transverse_bar_cross_section_area : Option < IfcAreaMeasure > , longitudinal_bar_spacing : Option < IfcPositiveLengthMeasure > , transverse_bar_spacing : Option < IfcPositiveLengthMeasure > , bending_shape_code : Option < IfcLabel > , bending_parameters : Option < Vec < IfcBendingParameterSelect > > , } impl IIfcRoot for IfcReinforcingMeshType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcReinforcingMeshType { } impl IIfcTypeObject for IfcReinforcingMeshType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcReinforcingMeshType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcReinforcingMeshType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcReinforcingMeshType { } impl IIfcReinforcingElementType for IfcReinforcingMeshType { } impl IIfcReinforcingMeshType for IfcReinforcingMeshType { fn predefined_type (& self) -> & IfcReinforcingMeshTypeEnum { & self . predefined_type } fn mesh_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . mesh_length } fn mesh_width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . mesh_width } fn longitudinal_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . longitudinal_bar_nominal_diameter } fn transverse_bar_nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . transverse_bar_nominal_diameter } fn longitudinal_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . longitudinal_bar_cross_section_area } fn transverse_bar_cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . transverse_bar_cross_section_area } fn longitudinal_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > { & self . longitudinal_bar_spacing } fn transverse_bar_spacing (& self) -> & Option < IfcPositiveLengthMeasure > { & self . transverse_bar_spacing } fn bending_shape_code (& self) -> & Option < IfcLabel > { & self . bending_shape_code } fn bending_parameters (& self) -> & Option < Vec < IfcBendingParameterSelect > > { & self . bending_parameters } } impl IfcReinforcingMeshType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReinforcingMeshType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . mesh_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . mesh_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . longitudinal_bar_nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . transverse_bar_nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . longitudinal_bar_cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . transverse_bar_cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . longitudinal_bar_spacing = if parameter . is_null () { None } else { Some (parameter . into ()) } , 17usize => entity . transverse_bar_spacing = if parameter . is_null () { None } else { Some (parameter . into ()) } , 18usize => entity . bending_shape_code = if parameter . is_null () { None } else { Some (parameter . into ()) } , 19usize => entity . bending_parameters = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelAggregates : IIfcRelDecomposes { pub fn relating_object (& self) -> & EntityRef < IfcObjectDefinition > ; pub fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > ; } # [derive (Default , Debug)] pub struct IfcRelAggregates { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_object : EntityRef < IfcObjectDefinition > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , } impl IIfcRoot for IfcRelAggregates { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAggregates { } impl IIfcRelDecomposes for IfcRelAggregates { } impl IIfcRelAggregates for IfcRelAggregates { fn relating_object (& self) -> & EntityRef < IfcObjectDefinition > { & self . relating_object } fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } } impl IfcRelAggregates { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAggregates :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_object = parameter . into () , 5usize => entity . related_objects = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssigns : IIfcRelationship { pub fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > ; pub fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > ; } pub trait IIfcRelAssignsToActor : IIfcRelAssigns { pub fn relating_actor (& self) -> & EntityRef < IfcActor > ; pub fn acting_role (& self) -> & Option < EntityRef < IfcActorRole > > ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToActor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_actor : EntityRef < IfcActor > , acting_role : Option < EntityRef < IfcActorRole > > , } impl IIfcRoot for IfcRelAssignsToActor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToActor { } impl IIfcRelAssigns for IfcRelAssignsToActor { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToActor for IfcRelAssignsToActor { fn relating_actor (& self) -> & EntityRef < IfcActor > { & self . relating_actor } fn acting_role (& self) -> & Option < EntityRef < IfcActorRole > > { & self . acting_role } } impl IfcRelAssignsToActor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToActor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_actor = parameter . into () , 7usize => entity . acting_role = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelAssignsToControl : IIfcRelAssigns { pub fn relating_control (& self) -> & EntityRef < IfcControl > ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToControl { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_control : EntityRef < IfcControl > , } impl IIfcRoot for IfcRelAssignsToControl { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToControl { } impl IIfcRelAssigns for IfcRelAssignsToControl { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToControl for IfcRelAssignsToControl { fn relating_control (& self) -> & EntityRef < IfcControl > { & self . relating_control } } impl IfcRelAssignsToControl { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToControl :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_control = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssignsToGroup : IIfcRelAssigns { pub fn relating_group (& self) -> & EntityRef < IfcGroup > ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToGroup { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_group : EntityRef < IfcGroup > , } impl IIfcRoot for IfcRelAssignsToGroup { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToGroup { } impl IIfcRelAssigns for IfcRelAssignsToGroup { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToGroup for IfcRelAssignsToGroup { fn relating_group (& self) -> & EntityRef < IfcGroup > { & self . relating_group } } impl IfcRelAssignsToGroup { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToGroup :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_group = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssignsToGroupByFactor : IIfcRelAssignsToGroup { pub fn factor (& self) -> & IfcRatioMeasure ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToGroupByFactor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_group : EntityRef < IfcGroup > , factor : IfcRatioMeasure , } impl IIfcRoot for IfcRelAssignsToGroupByFactor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToGroupByFactor { } impl IIfcRelAssigns for IfcRelAssignsToGroupByFactor { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToGroup for IfcRelAssignsToGroupByFactor { fn relating_group (& self) -> & EntityRef < IfcGroup > { & self . relating_group } } impl IIfcRelAssignsToGroupByFactor for IfcRelAssignsToGroupByFactor { fn factor (& self) -> & IfcRatioMeasure { & self . factor } } impl IfcRelAssignsToGroupByFactor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToGroupByFactor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_group = parameter . into () , 7usize => entity . factor = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssignsToProcess : IIfcRelAssigns { pub fn relating_process (& self) -> & EntityRef < IfcProcessSelect > ; pub fn quantity_in_process (& self) -> & Option < EntityRef < IfcMeasureWithUnit > > ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToProcess { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_process : EntityRef < IfcProcessSelect > , quantity_in_process : Option < EntityRef < IfcMeasureWithUnit > > , } impl IIfcRoot for IfcRelAssignsToProcess { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToProcess { } impl IIfcRelAssigns for IfcRelAssignsToProcess { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToProcess for IfcRelAssignsToProcess { fn relating_process (& self) -> & EntityRef < IfcProcessSelect > { & self . relating_process } fn quantity_in_process (& self) -> & Option < EntityRef < IfcMeasureWithUnit > > { & self . quantity_in_process } } impl IfcRelAssignsToProcess { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToProcess :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_process = parameter . into () , 7usize => entity . quantity_in_process = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelAssignsToProduct : IIfcRelAssigns { pub fn relating_product (& self) -> & EntityRef < IfcProductSelect > ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToProduct { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_product : EntityRef < IfcProductSelect > , } impl IIfcRoot for IfcRelAssignsToProduct { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToProduct { } impl IIfcRelAssigns for IfcRelAssignsToProduct { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToProduct for IfcRelAssignsToProduct { fn relating_product (& self) -> & EntityRef < IfcProductSelect > { & self . relating_product } } impl IfcRelAssignsToProduct { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToProduct :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_product = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssignsToResource : IIfcRelAssigns { pub fn relating_resource (& self) -> & EntityRef < IfcResourceSelect > ; } # [derive (Default , Debug)] pub struct IfcRelAssignsToResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , related_objects_type : Option < IfcObjectTypeEnum > , relating_resource : EntityRef < IfcResourceSelect > , } impl IIfcRoot for IfcRelAssignsToResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssignsToResource { } impl IIfcRelAssigns for IfcRelAssignsToResource { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn related_objects_type (& self) -> & Option < IfcObjectTypeEnum > { & self . related_objects_type } } impl IIfcRelAssignsToResource for IfcRelAssignsToResource { fn relating_resource (& self) -> & EntityRef < IfcResourceSelect > { & self . relating_resource } } impl IfcRelAssignsToResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssignsToResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . related_objects_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_resource = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssociates : IIfcRelationship { pub fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > ; } pub trait IIfcRelAssociatesApproval : IIfcRelAssociates { pub fn relating_approval (& self) -> & EntityRef < IfcApproval > ; } # [derive (Default , Debug)] pub struct IfcRelAssociatesApproval { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcDefinitionSelect > > , relating_approval : EntityRef < IfcApproval > , } impl IIfcRoot for IfcRelAssociatesApproval { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssociatesApproval { } impl IIfcRelAssociates for IfcRelAssociatesApproval { fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_objects } } impl IIfcRelAssociatesApproval for IfcRelAssociatesApproval { fn relating_approval (& self) -> & EntityRef < IfcApproval > { & self . relating_approval } } impl IfcRelAssociatesApproval { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssociatesApproval :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_approval = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssociatesClassification : IIfcRelAssociates { pub fn relating_classification (& self) -> & EntityRef < IfcClassificationSelect > ; } # [derive (Default , Debug)] pub struct IfcRelAssociatesClassification { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcDefinitionSelect > > , relating_classification : EntityRef < IfcClassificationSelect > , } impl IIfcRoot for IfcRelAssociatesClassification { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssociatesClassification { } impl IIfcRelAssociates for IfcRelAssociatesClassification { fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_objects } } impl IIfcRelAssociatesClassification for IfcRelAssociatesClassification { fn relating_classification (& self) -> & EntityRef < IfcClassificationSelect > { & self . relating_classification } } impl IfcRelAssociatesClassification { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssociatesClassification :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_classification = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssociatesConstraint : IIfcRelAssociates { pub fn intent (& self) -> & Option < IfcLabel > ; pub fn relating_constraint (& self) -> & EntityRef < IfcConstraint > ; } # [derive (Default , Debug)] pub struct IfcRelAssociatesConstraint { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcDefinitionSelect > > , intent : Option < IfcLabel > , relating_constraint : EntityRef < IfcConstraint > , } impl IIfcRoot for IfcRelAssociatesConstraint { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssociatesConstraint { } impl IIfcRelAssociates for IfcRelAssociatesConstraint { fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_objects } } impl IIfcRelAssociatesConstraint for IfcRelAssociatesConstraint { fn intent (& self) -> & Option < IfcLabel > { & self . intent } fn relating_constraint (& self) -> & EntityRef < IfcConstraint > { & self . relating_constraint } } impl IfcRelAssociatesConstraint { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssociatesConstraint :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . intent = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . relating_constraint = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssociatesDocument : IIfcRelAssociates { pub fn relating_document (& self) -> & EntityRef < IfcDocumentSelect > ; } # [derive (Default , Debug)] pub struct IfcRelAssociatesDocument { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcDefinitionSelect > > , relating_document : EntityRef < IfcDocumentSelect > , } impl IIfcRoot for IfcRelAssociatesDocument { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssociatesDocument { } impl IIfcRelAssociates for IfcRelAssociatesDocument { fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_objects } } impl IIfcRelAssociatesDocument for IfcRelAssociatesDocument { fn relating_document (& self) -> & EntityRef < IfcDocumentSelect > { & self . relating_document } } impl IfcRelAssociatesDocument { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssociatesDocument :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_document = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssociatesLibrary : IIfcRelAssociates { pub fn relating_library (& self) -> & EntityRef < IfcLibrarySelect > ; } # [derive (Default , Debug)] pub struct IfcRelAssociatesLibrary { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcDefinitionSelect > > , relating_library : EntityRef < IfcLibrarySelect > , } impl IIfcRoot for IfcRelAssociatesLibrary { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssociatesLibrary { } impl IIfcRelAssociates for IfcRelAssociatesLibrary { fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_objects } } impl IIfcRelAssociatesLibrary for IfcRelAssociatesLibrary { fn relating_library (& self) -> & EntityRef < IfcLibrarySelect > { & self . relating_library } } impl IfcRelAssociatesLibrary { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssociatesLibrary :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_library = parameter . into () , _ => { } } } entity } } pub trait IIfcRelAssociatesMaterial : IIfcRelAssociates { pub fn relating_material (& self) -> & EntityRef < IfcMaterialSelect > ; } # [derive (Default , Debug)] pub struct IfcRelAssociatesMaterial { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcDefinitionSelect > > , relating_material : EntityRef < IfcMaterialSelect > , } impl IIfcRoot for IfcRelAssociatesMaterial { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelAssociatesMaterial { } impl IIfcRelAssociates for IfcRelAssociatesMaterial { fn related_objects (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_objects } } impl IIfcRelAssociatesMaterial for IfcRelAssociatesMaterial { fn relating_material (& self) -> & EntityRef < IfcMaterialSelect > { & self . relating_material } } impl IfcRelAssociatesMaterial { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelAssociatesMaterial :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_material = parameter . into () , _ => { } } } entity } } pub trait IIfcRelConnects : IIfcRelationship { } pub trait IIfcRelConnectsElements : IIfcRelConnects { pub fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > ; pub fn relating_element (& self) -> & EntityRef < IfcElement > ; pub fn related_element (& self) -> & EntityRef < IfcElement > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsElements { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , connection_geometry : Option < EntityRef < IfcConnectionGeometry > > , relating_element : EntityRef < IfcElement > , related_element : EntityRef < IfcElement > , } impl IIfcRoot for IfcRelConnectsElements { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsElements { } impl IIfcRelConnects for IfcRelConnectsElements { } impl IIfcRelConnectsElements for IfcRelConnectsElements { fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . connection_geometry } fn relating_element (& self) -> & EntityRef < IfcElement > { & self . relating_element } fn related_element (& self) -> & EntityRef < IfcElement > { & self . related_element } } impl IfcRelConnectsElements { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsElements :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . connection_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . relating_element = parameter . into () , 6usize => entity . related_element = parameter . into () , _ => { } } } entity } } pub trait IIfcRelConnectsPathElements : IIfcRelConnectsElements { pub fn relating_priorities (& self) -> & Vec < IfcInteger > ; pub fn related_priorities (& self) -> & Vec < IfcInteger > ; pub fn related_connection_type (& self) -> & IfcConnectionTypeEnum ; pub fn relating_connection_type (& self) -> & IfcConnectionTypeEnum ; } # [derive (Default , Debug)] pub struct IfcRelConnectsPathElements { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , connection_geometry : Option < EntityRef < IfcConnectionGeometry > > , relating_element : EntityRef < IfcElement > , related_element : EntityRef < IfcElement > , relating_priorities : Vec < IfcInteger > , related_priorities : Vec < IfcInteger > , related_connection_type : IfcConnectionTypeEnum , relating_connection_type : IfcConnectionTypeEnum , } impl IIfcRoot for IfcRelConnectsPathElements { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsPathElements { } impl IIfcRelConnects for IfcRelConnectsPathElements { } impl IIfcRelConnectsElements for IfcRelConnectsPathElements { fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . connection_geometry } fn relating_element (& self) -> & EntityRef < IfcElement > { & self . relating_element } fn related_element (& self) -> & EntityRef < IfcElement > { & self . related_element } } impl IIfcRelConnectsPathElements for IfcRelConnectsPathElements { fn relating_priorities (& self) -> & Vec < IfcInteger > { & self . relating_priorities } fn related_priorities (& self) -> & Vec < IfcInteger > { & self . related_priorities } fn related_connection_type (& self) -> & IfcConnectionTypeEnum { & self . related_connection_type } fn relating_connection_type (& self) -> & IfcConnectionTypeEnum { & self . relating_connection_type } } impl IfcRelConnectsPathElements { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsPathElements :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . connection_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . relating_element = parameter . into () , 6usize => entity . related_element = parameter . into () , 7usize => entity . relating_priorities = parameter . into () , 8usize => entity . related_priorities = parameter . into () , 9usize => entity . related_connection_type = parameter . into () , 10usize => entity . relating_connection_type = parameter . into () , _ => { } } } entity } } pub trait IIfcRelConnectsPortToElement : IIfcRelConnects { pub fn relating_port (& self) -> & EntityRef < IfcPort > ; pub fn related_element (& self) -> & EntityRef < IfcDistributionElement > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsPortToElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_port : EntityRef < IfcPort > , related_element : EntityRef < IfcDistributionElement > , } impl IIfcRoot for IfcRelConnectsPortToElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsPortToElement { } impl IIfcRelConnects for IfcRelConnectsPortToElement { } impl IIfcRelConnectsPortToElement for IfcRelConnectsPortToElement { fn relating_port (& self) -> & EntityRef < IfcPort > { & self . relating_port } fn related_element (& self) -> & EntityRef < IfcDistributionElement > { & self . related_element } } impl IfcRelConnectsPortToElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsPortToElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_port = parameter . into () , 5usize => entity . related_element = parameter . into () , _ => { } } } entity } } pub trait IIfcRelConnectsPorts : IIfcRelConnects { pub fn relating_port (& self) -> & EntityRef < IfcPort > ; pub fn related_port (& self) -> & EntityRef < IfcPort > ; pub fn realizing_element (& self) -> & Option < EntityRef < IfcElement > > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsPorts { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_port : EntityRef < IfcPort > , related_port : EntityRef < IfcPort > , realizing_element : Option < EntityRef < IfcElement > > , } impl IIfcRoot for IfcRelConnectsPorts { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsPorts { } impl IIfcRelConnects for IfcRelConnectsPorts { } impl IIfcRelConnectsPorts for IfcRelConnectsPorts { fn relating_port (& self) -> & EntityRef < IfcPort > { & self . relating_port } fn related_port (& self) -> & EntityRef < IfcPort > { & self . related_port } fn realizing_element (& self) -> & Option < EntityRef < IfcElement > > { & self . realizing_element } } impl IfcRelConnectsPorts { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsPorts :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_port = parameter . into () , 5usize => entity . related_port = parameter . into () , 6usize => entity . realizing_element = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelConnectsStructuralActivity : IIfcRelConnects { pub fn relating_element (& self) -> & EntityRef < IfcStructuralActivityAssignmentSelect > ; pub fn related_structural_activity (& self) -> & EntityRef < IfcStructuralActivity > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsStructuralActivity { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_element : EntityRef < IfcStructuralActivityAssignmentSelect > , related_structural_activity : EntityRef < IfcStructuralActivity > , } impl IIfcRoot for IfcRelConnectsStructuralActivity { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsStructuralActivity { } impl IIfcRelConnects for IfcRelConnectsStructuralActivity { } impl IIfcRelConnectsStructuralActivity for IfcRelConnectsStructuralActivity { fn relating_element (& self) -> & EntityRef < IfcStructuralActivityAssignmentSelect > { & self . relating_element } fn related_structural_activity (& self) -> & EntityRef < IfcStructuralActivity > { & self . related_structural_activity } } impl IfcRelConnectsStructuralActivity { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsStructuralActivity :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_element = parameter . into () , 5usize => entity . related_structural_activity = parameter . into () , _ => { } } } entity } } pub trait IIfcRelConnectsStructuralMember : IIfcRelConnects { pub fn relating_structural_member (& self) -> & EntityRef < IfcStructuralMember > ; pub fn related_structural_connection (& self) -> & EntityRef < IfcStructuralConnection > ; pub fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > ; pub fn additional_conditions (& self) -> & Option < EntityRef < IfcStructuralConnectionCondition > > ; pub fn supported_length (& self) -> & Option < IfcLengthMeasure > ; pub fn condition_coordinate_system (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsStructuralMember { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_structural_member : EntityRef < IfcStructuralMember > , related_structural_connection : EntityRef < IfcStructuralConnection > , applied_condition : Option < EntityRef < IfcBoundaryCondition > > , additional_conditions : Option < EntityRef < IfcStructuralConnectionCondition > > , supported_length : Option < IfcLengthMeasure > , condition_coordinate_system : Option < EntityRef < IfcAxis2Placement3D > > , } impl IIfcRoot for IfcRelConnectsStructuralMember { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsStructuralMember { } impl IIfcRelConnects for IfcRelConnectsStructuralMember { } impl IIfcRelConnectsStructuralMember for IfcRelConnectsStructuralMember { fn relating_structural_member (& self) -> & EntityRef < IfcStructuralMember > { & self . relating_structural_member } fn related_structural_connection (& self) -> & EntityRef < IfcStructuralConnection > { & self . related_structural_connection } fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > { & self . applied_condition } fn additional_conditions (& self) -> & Option < EntityRef < IfcStructuralConnectionCondition > > { & self . additional_conditions } fn supported_length (& self) -> & Option < IfcLengthMeasure > { & self . supported_length } fn condition_coordinate_system (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . condition_coordinate_system } } impl IfcRelConnectsStructuralMember { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsStructuralMember :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_structural_member = parameter . into () , 5usize => entity . related_structural_connection = parameter . into () , 6usize => entity . applied_condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . additional_conditions = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . supported_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . condition_coordinate_system = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelConnectsWithEccentricity : IIfcRelConnectsStructuralMember { pub fn connection_constraint (& self) -> & EntityRef < IfcConnectionGeometry > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsWithEccentricity { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_structural_member : EntityRef < IfcStructuralMember > , related_structural_connection : EntityRef < IfcStructuralConnection > , applied_condition : Option < EntityRef < IfcBoundaryCondition > > , additional_conditions : Option < EntityRef < IfcStructuralConnectionCondition > > , supported_length : Option < IfcLengthMeasure > , condition_coordinate_system : Option < EntityRef < IfcAxis2Placement3D > > , connection_constraint : EntityRef < IfcConnectionGeometry > , } impl IIfcRoot for IfcRelConnectsWithEccentricity { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsWithEccentricity { } impl IIfcRelConnects for IfcRelConnectsWithEccentricity { } impl IIfcRelConnectsStructuralMember for IfcRelConnectsWithEccentricity { fn relating_structural_member (& self) -> & EntityRef < IfcStructuralMember > { & self . relating_structural_member } fn related_structural_connection (& self) -> & EntityRef < IfcStructuralConnection > { & self . related_structural_connection } fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > { & self . applied_condition } fn additional_conditions (& self) -> & Option < EntityRef < IfcStructuralConnectionCondition > > { & self . additional_conditions } fn supported_length (& self) -> & Option < IfcLengthMeasure > { & self . supported_length } fn condition_coordinate_system (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . condition_coordinate_system } } impl IIfcRelConnectsWithEccentricity for IfcRelConnectsWithEccentricity { fn connection_constraint (& self) -> & EntityRef < IfcConnectionGeometry > { & self . connection_constraint } } impl IfcRelConnectsWithEccentricity { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsWithEccentricity :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_structural_member = parameter . into () , 5usize => entity . related_structural_connection = parameter . into () , 6usize => entity . applied_condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . additional_conditions = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . supported_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . condition_coordinate_system = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . connection_constraint = parameter . into () , _ => { } } } entity } } pub trait IIfcRelConnectsWithRealizingElements : IIfcRelConnectsElements { pub fn realizing_elements (& self) -> & HashSet < EntityRef < IfcElement > > ; pub fn connection_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcRelConnectsWithRealizingElements { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , connection_geometry : Option < EntityRef < IfcConnectionGeometry > > , relating_element : EntityRef < IfcElement > , related_element : EntityRef < IfcElement > , realizing_elements : HashSet < EntityRef < IfcElement > > , connection_type : Option < IfcLabel > , } impl IIfcRoot for IfcRelConnectsWithRealizingElements { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelConnectsWithRealizingElements { } impl IIfcRelConnects for IfcRelConnectsWithRealizingElements { } impl IIfcRelConnectsElements for IfcRelConnectsWithRealizingElements { fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . connection_geometry } fn relating_element (& self) -> & EntityRef < IfcElement > { & self . relating_element } fn related_element (& self) -> & EntityRef < IfcElement > { & self . related_element } } impl IIfcRelConnectsWithRealizingElements for IfcRelConnectsWithRealizingElements { fn realizing_elements (& self) -> & HashSet < EntityRef < IfcElement > > { & self . realizing_elements } fn connection_type (& self) -> & Option < IfcLabel > { & self . connection_type } } impl IfcRelConnectsWithRealizingElements { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelConnectsWithRealizingElements :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . connection_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . relating_element = parameter . into () , 6usize => entity . related_element = parameter . into () , 7usize => entity . realizing_elements = parameter . into () , 8usize => entity . connection_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelContainedInSpatialStructure : IIfcRelConnects { pub fn related_elements (& self) -> & HashSet < EntityRef < IfcProduct > > ; pub fn relating_structure (& self) -> & EntityRef < IfcSpatialElement > ; } # [derive (Default , Debug)] pub struct IfcRelContainedInSpatialStructure { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_elements : HashSet < EntityRef < IfcProduct > > , relating_structure : EntityRef < IfcSpatialElement > , } impl IIfcRoot for IfcRelContainedInSpatialStructure { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelContainedInSpatialStructure { } impl IIfcRelConnects for IfcRelContainedInSpatialStructure { } impl IIfcRelContainedInSpatialStructure for IfcRelContainedInSpatialStructure { fn related_elements (& self) -> & HashSet < EntityRef < IfcProduct > > { & self . related_elements } fn relating_structure (& self) -> & EntityRef < IfcSpatialElement > { & self . relating_structure } } impl IfcRelContainedInSpatialStructure { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelContainedInSpatialStructure :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_elements = parameter . into () , 5usize => entity . relating_structure = parameter . into () , _ => { } } } entity } } pub trait IIfcRelCoversBldgElements : IIfcRelConnects { pub fn relating_building_element (& self) -> & EntityRef < IfcElement > ; pub fn related_coverings (& self) -> & HashSet < EntityRef < IfcCovering > > ; } # [derive (Default , Debug)] pub struct IfcRelCoversBldgElements { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_building_element : EntityRef < IfcElement > , related_coverings : HashSet < EntityRef < IfcCovering > > , } impl IIfcRoot for IfcRelCoversBldgElements { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelCoversBldgElements { } impl IIfcRelConnects for IfcRelCoversBldgElements { } impl IIfcRelCoversBldgElements for IfcRelCoversBldgElements { fn relating_building_element (& self) -> & EntityRef < IfcElement > { & self . relating_building_element } fn related_coverings (& self) -> & HashSet < EntityRef < IfcCovering > > { & self . related_coverings } } impl IfcRelCoversBldgElements { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelCoversBldgElements :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_building_element = parameter . into () , 5usize => entity . related_coverings = parameter . into () , _ => { } } } entity } } pub trait IIfcRelCoversSpaces : IIfcRelConnects { pub fn relating_space (& self) -> & EntityRef < IfcSpace > ; pub fn related_coverings (& self) -> & HashSet < EntityRef < IfcCovering > > ; } # [derive (Default , Debug)] pub struct IfcRelCoversSpaces { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_space : EntityRef < IfcSpace > , related_coverings : HashSet < EntityRef < IfcCovering > > , } impl IIfcRoot for IfcRelCoversSpaces { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelCoversSpaces { } impl IIfcRelConnects for IfcRelCoversSpaces { } impl IIfcRelCoversSpaces for IfcRelCoversSpaces { fn relating_space (& self) -> & EntityRef < IfcSpace > { & self . relating_space } fn related_coverings (& self) -> & HashSet < EntityRef < IfcCovering > > { & self . related_coverings } } impl IfcRelCoversSpaces { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelCoversSpaces :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_space = parameter . into () , 5usize => entity . related_coverings = parameter . into () , _ => { } } } entity } } pub trait IIfcRelDeclares : IIfcRelationship { pub fn relating_context (& self) -> & EntityRef < IfcContext > ; pub fn related_definitions (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > ; } # [derive (Default , Debug)] pub struct IfcRelDeclares { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_context : EntityRef < IfcContext > , related_definitions : HashSet < EntityRef < IfcDefinitionSelect > > , } impl IIfcRoot for IfcRelDeclares { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelDeclares { } impl IIfcRelDeclares for IfcRelDeclares { fn relating_context (& self) -> & EntityRef < IfcContext > { & self . relating_context } fn related_definitions (& self) -> & HashSet < EntityRef < IfcDefinitionSelect > > { & self . related_definitions } } impl IfcRelDeclares { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelDeclares :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_context = parameter . into () , 5usize => entity . related_definitions = parameter . into () , _ => { } } } entity } } pub trait IIfcRelDecomposes : IIfcRelationship { } pub trait IIfcRelDefines : IIfcRelationship { } pub trait IIfcRelDefinesByObject : IIfcRelDefines { pub fn related_objects (& self) -> & HashSet < EntityRef < IfcObject > > ; pub fn relating_object (& self) -> & EntityRef < IfcObject > ; } # [derive (Default , Debug)] pub struct IfcRelDefinesByObject { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObject > > , relating_object : EntityRef < IfcObject > , } impl IIfcRoot for IfcRelDefinesByObject { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelDefinesByObject { } impl IIfcRelDefines for IfcRelDefinesByObject { } impl IIfcRelDefinesByObject for IfcRelDefinesByObject { fn related_objects (& self) -> & HashSet < EntityRef < IfcObject > > { & self . related_objects } fn relating_object (& self) -> & EntityRef < IfcObject > { & self . relating_object } } impl IfcRelDefinesByObject { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelDefinesByObject :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_object = parameter . into () , _ => { } } } entity } } pub trait IIfcRelDefinesByProperties : IIfcRelDefines { pub fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > ; pub fn relating_property_definition (& self) -> & IfcPropertySetDefinitionSelect ; } # [derive (Default , Debug)] pub struct IfcRelDefinesByProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObjectDefinition > > , relating_property_definition : IfcPropertySetDefinitionSelect , } impl IIfcRoot for IfcRelDefinesByProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelDefinesByProperties { } impl IIfcRelDefines for IfcRelDefinesByProperties { } impl IIfcRelDefinesByProperties for IfcRelDefinesByProperties { fn related_objects (& self) -> & HashSet < EntityRef < IfcObjectDefinition > > { & self . related_objects } fn relating_property_definition (& self) -> & IfcPropertySetDefinitionSelect { & self . relating_property_definition } } impl IfcRelDefinesByProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelDefinesByProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_property_definition = parameter . into () , _ => { } } } entity } } pub trait IIfcRelDefinesByTemplate : IIfcRelDefines { pub fn related_property_sets (& self) -> & HashSet < EntityRef < IfcPropertySetDefinition > > ; pub fn relating_template (& self) -> & EntityRef < IfcPropertySetTemplate > ; } # [derive (Default , Debug)] pub struct IfcRelDefinesByTemplate { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_property_sets : HashSet < EntityRef < IfcPropertySetDefinition > > , relating_template : EntityRef < IfcPropertySetTemplate > , } impl IIfcRoot for IfcRelDefinesByTemplate { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelDefinesByTemplate { } impl IIfcRelDefines for IfcRelDefinesByTemplate { } impl IIfcRelDefinesByTemplate for IfcRelDefinesByTemplate { fn related_property_sets (& self) -> & HashSet < EntityRef < IfcPropertySetDefinition > > { & self . related_property_sets } fn relating_template (& self) -> & EntityRef < IfcPropertySetTemplate > { & self . relating_template } } impl IfcRelDefinesByTemplate { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelDefinesByTemplate :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_property_sets = parameter . into () , 5usize => entity . relating_template = parameter . into () , _ => { } } } entity } } pub trait IIfcRelDefinesByType : IIfcRelDefines { pub fn related_objects (& self) -> & HashSet < EntityRef < IfcObject > > ; pub fn relating_type (& self) -> & EntityRef < IfcTypeObject > ; } # [derive (Default , Debug)] pub struct IfcRelDefinesByType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_objects : HashSet < EntityRef < IfcObject > > , relating_type : EntityRef < IfcTypeObject > , } impl IIfcRoot for IfcRelDefinesByType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelDefinesByType { } impl IIfcRelDefines for IfcRelDefinesByType { } impl IIfcRelDefinesByType for IfcRelDefinesByType { fn related_objects (& self) -> & HashSet < EntityRef < IfcObject > > { & self . related_objects } fn relating_type (& self) -> & EntityRef < IfcTypeObject > { & self . relating_type } } impl IfcRelDefinesByType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelDefinesByType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_objects = parameter . into () , 5usize => entity . relating_type = parameter . into () , _ => { } } } entity } } pub trait IIfcRelFillsElement : IIfcRelConnects { pub fn relating_opening_element (& self) -> & EntityRef < IfcOpeningElement > ; pub fn related_building_element (& self) -> & EntityRef < IfcElement > ; } # [derive (Default , Debug)] pub struct IfcRelFillsElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_opening_element : EntityRef < IfcOpeningElement > , related_building_element : EntityRef < IfcElement > , } impl IIfcRoot for IfcRelFillsElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelFillsElement { } impl IIfcRelConnects for IfcRelFillsElement { } impl IIfcRelFillsElement for IfcRelFillsElement { fn relating_opening_element (& self) -> & EntityRef < IfcOpeningElement > { & self . relating_opening_element } fn related_building_element (& self) -> & EntityRef < IfcElement > { & self . related_building_element } } impl IfcRelFillsElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelFillsElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_opening_element = parameter . into () , 5usize => entity . related_building_element = parameter . into () , _ => { } } } entity } } pub trait IIfcRelFlowControlElements : IIfcRelConnects { pub fn related_control_elements (& self) -> & HashSet < EntityRef < IfcDistributionControlElement > > ; pub fn relating_flow_element (& self) -> & EntityRef < IfcDistributionFlowElement > ; } # [derive (Default , Debug)] pub struct IfcRelFlowControlElements { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_control_elements : HashSet < EntityRef < IfcDistributionControlElement > > , relating_flow_element : EntityRef < IfcDistributionFlowElement > , } impl IIfcRoot for IfcRelFlowControlElements { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelFlowControlElements { } impl IIfcRelConnects for IfcRelFlowControlElements { } impl IIfcRelFlowControlElements for IfcRelFlowControlElements { fn related_control_elements (& self) -> & HashSet < EntityRef < IfcDistributionControlElement > > { & self . related_control_elements } fn relating_flow_element (& self) -> & EntityRef < IfcDistributionFlowElement > { & self . relating_flow_element } } impl IfcRelFlowControlElements { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelFlowControlElements :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_control_elements = parameter . into () , 5usize => entity . relating_flow_element = parameter . into () , _ => { } } } entity } } pub trait IIfcRelInterferesElements : IIfcRelConnects { pub fn relating_element (& self) -> & EntityRef < IfcElement > ; pub fn related_element (& self) -> & EntityRef < IfcElement > ; pub fn interference_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > ; pub fn interference_type (& self) -> & Option < IfcIdentifier > ; pub fn implied_order (& self) -> Option < bool > ; } # [derive (Default , Debug)] pub struct IfcRelInterferesElements { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_element : EntityRef < IfcElement > , related_element : EntityRef < IfcElement > , interference_geometry : Option < EntityRef < IfcConnectionGeometry > > , interference_type : Option < IfcIdentifier > , implied_order : Option < bool > , } impl IIfcRoot for IfcRelInterferesElements { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelInterferesElements { } impl IIfcRelConnects for IfcRelInterferesElements { } impl IIfcRelInterferesElements for IfcRelInterferesElements { fn relating_element (& self) -> & EntityRef < IfcElement > { & self . relating_element } fn related_element (& self) -> & EntityRef < IfcElement > { & self . related_element } fn interference_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . interference_geometry } fn interference_type (& self) -> & Option < IfcIdentifier > { & self . interference_type } fn implied_order (& self) -> Option < bool > { self . implied_order } } impl IfcRelInterferesElements { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelInterferesElements :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_element = parameter . into () , 5usize => entity . related_element = parameter . into () , 6usize => entity . interference_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . interference_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . implied_order = parameter . into () , _ => { } } } entity } } pub trait IIfcRelNests : IIfcRelDecomposes { pub fn relating_object (& self) -> & EntityRef < IfcObjectDefinition > ; pub fn related_objects (& self) -> & Vec < EntityRef < IfcObjectDefinition > > ; } # [derive (Default , Debug)] pub struct IfcRelNests { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_object : EntityRef < IfcObjectDefinition > , related_objects : Vec < EntityRef < IfcObjectDefinition > > , } impl IIfcRoot for IfcRelNests { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelNests { } impl IIfcRelDecomposes for IfcRelNests { } impl IIfcRelNests for IfcRelNests { fn relating_object (& self) -> & EntityRef < IfcObjectDefinition > { & self . relating_object } fn related_objects (& self) -> & Vec < EntityRef < IfcObjectDefinition > > { & self . related_objects } } impl IfcRelNests { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelNests :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_object = parameter . into () , 5usize => entity . related_objects = parameter . into () , _ => { } } } entity } } pub trait IIfcRelProjectsElement : IIfcRelDecomposes { pub fn relating_element (& self) -> & EntityRef < IfcElement > ; pub fn related_feature_element (& self) -> & EntityRef < IfcFeatureElementAddition > ; } # [derive (Default , Debug)] pub struct IfcRelProjectsElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_element : EntityRef < IfcElement > , related_feature_element : EntityRef < IfcFeatureElementAddition > , } impl IIfcRoot for IfcRelProjectsElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelProjectsElement { } impl IIfcRelDecomposes for IfcRelProjectsElement { } impl IIfcRelProjectsElement for IfcRelProjectsElement { fn relating_element (& self) -> & EntityRef < IfcElement > { & self . relating_element } fn related_feature_element (& self) -> & EntityRef < IfcFeatureElementAddition > { & self . related_feature_element } } impl IfcRelProjectsElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelProjectsElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_element = parameter . into () , 5usize => entity . related_feature_element = parameter . into () , _ => { } } } entity } } pub trait IIfcRelReferencedInSpatialStructure : IIfcRelConnects { pub fn related_elements (& self) -> & HashSet < EntityRef < IfcProduct > > ; pub fn relating_structure (& self) -> & EntityRef < IfcSpatialElement > ; } # [derive (Default , Debug)] pub struct IfcRelReferencedInSpatialStructure { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , related_elements : HashSet < EntityRef < IfcProduct > > , relating_structure : EntityRef < IfcSpatialElement > , } impl IIfcRoot for IfcRelReferencedInSpatialStructure { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelReferencedInSpatialStructure { } impl IIfcRelConnects for IfcRelReferencedInSpatialStructure { } impl IIfcRelReferencedInSpatialStructure for IfcRelReferencedInSpatialStructure { fn related_elements (& self) -> & HashSet < EntityRef < IfcProduct > > { & self . related_elements } fn relating_structure (& self) -> & EntityRef < IfcSpatialElement > { & self . relating_structure } } impl IfcRelReferencedInSpatialStructure { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelReferencedInSpatialStructure :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . related_elements = parameter . into () , 5usize => entity . relating_structure = parameter . into () , _ => { } } } entity } } pub trait IIfcRelSequence : IIfcRelConnects { pub fn relating_process (& self) -> & EntityRef < IfcProcess > ; pub fn related_process (& self) -> & EntityRef < IfcProcess > ; pub fn time_lag (& self) -> & Option < EntityRef < IfcLagTime > > ; pub fn sequence_type (& self) -> & Option < IfcSequenceEnum > ; pub fn user_defined_sequence_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcRelSequence { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_process : EntityRef < IfcProcess > , related_process : EntityRef < IfcProcess > , time_lag : Option < EntityRef < IfcLagTime > > , sequence_type : Option < IfcSequenceEnum > , user_defined_sequence_type : Option < IfcLabel > , } impl IIfcRoot for IfcRelSequence { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelSequence { } impl IIfcRelConnects for IfcRelSequence { } impl IIfcRelSequence for IfcRelSequence { fn relating_process (& self) -> & EntityRef < IfcProcess > { & self . relating_process } fn related_process (& self) -> & EntityRef < IfcProcess > { & self . related_process } fn time_lag (& self) -> & Option < EntityRef < IfcLagTime > > { & self . time_lag } fn sequence_type (& self) -> & Option < IfcSequenceEnum > { & self . sequence_type } fn user_defined_sequence_type (& self) -> & Option < IfcLabel > { & self . user_defined_sequence_type } } impl IfcRelSequence { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelSequence :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_process = parameter . into () , 5usize => entity . related_process = parameter . into () , 6usize => entity . time_lag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . sequence_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . user_defined_sequence_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelServicesBuildings : IIfcRelConnects { pub fn relating_system (& self) -> & EntityRef < IfcSystem > ; pub fn related_buildings (& self) -> & HashSet < EntityRef < IfcSpatialElement > > ; } # [derive (Default , Debug)] pub struct IfcRelServicesBuildings { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_system : EntityRef < IfcSystem > , related_buildings : HashSet < EntityRef < IfcSpatialElement > > , } impl IIfcRoot for IfcRelServicesBuildings { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelServicesBuildings { } impl IIfcRelConnects for IfcRelServicesBuildings { } impl IIfcRelServicesBuildings for IfcRelServicesBuildings { fn relating_system (& self) -> & EntityRef < IfcSystem > { & self . relating_system } fn related_buildings (& self) -> & HashSet < EntityRef < IfcSpatialElement > > { & self . related_buildings } } impl IfcRelServicesBuildings { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelServicesBuildings :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_system = parameter . into () , 5usize => entity . related_buildings = parameter . into () , _ => { } } } entity } } pub trait IIfcRelSpaceBoundary : IIfcRelConnects { pub fn relating_space (& self) -> & EntityRef < IfcSpaceBoundarySelect > ; pub fn related_building_element (& self) -> & EntityRef < IfcElement > ; pub fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > ; pub fn physical_or_virtual_boundary (& self) -> & IfcPhysicalOrVirtualEnum ; pub fn internal_or_external_boundary (& self) -> & IfcInternalOrExternalEnum ; } # [derive (Default , Debug)] pub struct IfcRelSpaceBoundary { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_space : EntityRef < IfcSpaceBoundarySelect > , related_building_element : EntityRef < IfcElement > , connection_geometry : Option < EntityRef < IfcConnectionGeometry > > , physical_or_virtual_boundary : IfcPhysicalOrVirtualEnum , internal_or_external_boundary : IfcInternalOrExternalEnum , } impl IIfcRoot for IfcRelSpaceBoundary { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelSpaceBoundary { } impl IIfcRelConnects for IfcRelSpaceBoundary { } impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary { fn relating_space (& self) -> & EntityRef < IfcSpaceBoundarySelect > { & self . relating_space } fn related_building_element (& self) -> & EntityRef < IfcElement > { & self . related_building_element } fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . connection_geometry } fn physical_or_virtual_boundary (& self) -> & IfcPhysicalOrVirtualEnum { & self . physical_or_virtual_boundary } fn internal_or_external_boundary (& self) -> & IfcInternalOrExternalEnum { & self . internal_or_external_boundary } } impl IfcRelSpaceBoundary { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelSpaceBoundary :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_space = parameter . into () , 5usize => entity . related_building_element = parameter . into () , 6usize => entity . connection_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . physical_or_virtual_boundary = parameter . into () , 8usize => entity . internal_or_external_boundary = parameter . into () , _ => { } } } entity } } pub trait IIfcRelSpaceBoundary1stLevel : IIfcRelSpaceBoundary { pub fn parent_boundary (& self) -> & Option < EntityRef < IfcRelSpaceBoundary1stLevel > > ; } # [derive (Default , Debug)] pub struct IfcRelSpaceBoundary1stLevel { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_space : EntityRef < IfcSpaceBoundarySelect > , related_building_element : EntityRef < IfcElement > , connection_geometry : Option < EntityRef < IfcConnectionGeometry > > , physical_or_virtual_boundary : IfcPhysicalOrVirtualEnum , internal_or_external_boundary : IfcInternalOrExternalEnum , parent_boundary : Option < EntityRef < IfcRelSpaceBoundary1stLevel > > , } impl IIfcRoot for IfcRelSpaceBoundary1stLevel { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelSpaceBoundary1stLevel { } impl IIfcRelConnects for IfcRelSpaceBoundary1stLevel { } impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary1stLevel { fn relating_space (& self) -> & EntityRef < IfcSpaceBoundarySelect > { & self . relating_space } fn related_building_element (& self) -> & EntityRef < IfcElement > { & self . related_building_element } fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . connection_geometry } fn physical_or_virtual_boundary (& self) -> & IfcPhysicalOrVirtualEnum { & self . physical_or_virtual_boundary } fn internal_or_external_boundary (& self) -> & IfcInternalOrExternalEnum { & self . internal_or_external_boundary } } impl IIfcRelSpaceBoundary1stLevel for IfcRelSpaceBoundary1stLevel { fn parent_boundary (& self) -> & Option < EntityRef < IfcRelSpaceBoundary1stLevel > > { & self . parent_boundary } } impl IfcRelSpaceBoundary1stLevel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelSpaceBoundary1stLevel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_space = parameter . into () , 5usize => entity . related_building_element = parameter . into () , 6usize => entity . connection_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . physical_or_virtual_boundary = parameter . into () , 8usize => entity . internal_or_external_boundary = parameter . into () , 9usize => entity . parent_boundary = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelSpaceBoundary2ndLevel : IIfcRelSpaceBoundary1stLevel { pub fn corresponding_boundary (& self) -> & Option < EntityRef < IfcRelSpaceBoundary2ndLevel > > ; } # [derive (Default , Debug)] pub struct IfcRelSpaceBoundary2ndLevel { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_space : EntityRef < IfcSpaceBoundarySelect > , related_building_element : EntityRef < IfcElement > , connection_geometry : Option < EntityRef < IfcConnectionGeometry > > , physical_or_virtual_boundary : IfcPhysicalOrVirtualEnum , internal_or_external_boundary : IfcInternalOrExternalEnum , parent_boundary : Option < EntityRef < IfcRelSpaceBoundary1stLevel > > , corresponding_boundary : Option < EntityRef < IfcRelSpaceBoundary2ndLevel > > , } impl IIfcRoot for IfcRelSpaceBoundary2ndLevel { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelSpaceBoundary2ndLevel { } impl IIfcRelConnects for IfcRelSpaceBoundary2ndLevel { } impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary2ndLevel { fn relating_space (& self) -> & EntityRef < IfcSpaceBoundarySelect > { & self . relating_space } fn related_building_element (& self) -> & EntityRef < IfcElement > { & self . related_building_element } fn connection_geometry (& self) -> & Option < EntityRef < IfcConnectionGeometry > > { & self . connection_geometry } fn physical_or_virtual_boundary (& self) -> & IfcPhysicalOrVirtualEnum { & self . physical_or_virtual_boundary } fn internal_or_external_boundary (& self) -> & IfcInternalOrExternalEnum { & self . internal_or_external_boundary } } impl IIfcRelSpaceBoundary1stLevel for IfcRelSpaceBoundary2ndLevel { fn parent_boundary (& self) -> & Option < EntityRef < IfcRelSpaceBoundary1stLevel > > { & self . parent_boundary } } impl IIfcRelSpaceBoundary2ndLevel for IfcRelSpaceBoundary2ndLevel { fn corresponding_boundary (& self) -> & Option < EntityRef < IfcRelSpaceBoundary2ndLevel > > { & self . corresponding_boundary } } impl IfcRelSpaceBoundary2ndLevel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelSpaceBoundary2ndLevel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_space = parameter . into () , 5usize => entity . related_building_element = parameter . into () , 6usize => entity . connection_geometry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . physical_or_virtual_boundary = parameter . into () , 8usize => entity . internal_or_external_boundary = parameter . into () , 9usize => entity . parent_boundary = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . corresponding_boundary = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRelVoidsElement : IIfcRelDecomposes { pub fn relating_building_element (& self) -> & EntityRef < IfcElement > ; pub fn related_opening_element (& self) -> & EntityRef < IfcFeatureElementSubtraction > ; } # [derive (Default , Debug)] pub struct IfcRelVoidsElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , relating_building_element : EntityRef < IfcElement > , related_opening_element : EntityRef < IfcFeatureElementSubtraction > , } impl IIfcRoot for IfcRelVoidsElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcRelationship for IfcRelVoidsElement { } impl IIfcRelDecomposes for IfcRelVoidsElement { } impl IIfcRelVoidsElement for IfcRelVoidsElement { fn relating_building_element (& self) -> & EntityRef < IfcElement > { & self . relating_building_element } fn related_opening_element (& self) -> & EntityRef < IfcFeatureElementSubtraction > { & self . related_opening_element } } impl IfcRelVoidsElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRelVoidsElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . relating_building_element = parameter . into () , 5usize => entity . related_opening_element = parameter . into () , _ => { } } } entity } } pub trait IIfcRelationship : IIfcRoot { } pub trait IIfcReparametrisedCompositeCurveSegment : IIfcCompositeCurveSegment { pub fn param_length (& self) -> & IfcParameterValue ; } # [derive (Default , Debug)] pub struct IfcReparametrisedCompositeCurveSegment { transition : IfcTransitionCode , same_sense : IfcBoolean , parent_curve : EntityRef < IfcCurve > , param_length : IfcParameterValue , } impl IIfcRepresentationItem for IfcReparametrisedCompositeCurveSegment { } impl IIfcGeometricRepresentationItem for IfcReparametrisedCompositeCurveSegment { } impl IIfcCompositeCurveSegment for IfcReparametrisedCompositeCurveSegment { fn transition (& self) -> & IfcTransitionCode { & self . transition } fn same_sense (& self) -> & IfcBoolean { & self . same_sense } fn parent_curve (& self) -> & EntityRef < IfcCurve > { & self . parent_curve } } impl IIfcReparametrisedCompositeCurveSegment for IfcReparametrisedCompositeCurveSegment { fn param_length (& self) -> & IfcParameterValue { & self . param_length } } impl IfcReparametrisedCompositeCurveSegment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcReparametrisedCompositeCurveSegment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . transition = parameter . into () , 1usize => entity . same_sense = parameter . into () , 2usize => entity . parent_curve = parameter . into () , 3usize => entity . param_length = parameter . into () , _ => { } } } entity } } pub trait IIfcRepresentation : { pub fn context_of_items (& self) -> & EntityRef < IfcRepresentationContext > ; pub fn representation_identifier (& self) -> & Option < IfcLabel > ; pub fn representation_type (& self) -> & Option < IfcLabel > ; pub fn items (& self) -> & HashSet < EntityRef < IfcRepresentationItem > > ; } pub trait IIfcRepresentationContext : { pub fn context_identifier (& self) -> & Option < IfcLabel > ; pub fn context_type (& self) -> & Option < IfcLabel > ; } pub trait IIfcRepresentationItem : { } pub trait IIfcRepresentationMap : { pub fn mapping_origin (& self) -> & EntityRef < IfcAxis2Placement > ; pub fn mapped_representation (& self) -> & EntityRef < IfcRepresentation > ; } # [derive (Default , Debug)] pub struct IfcRepresentationMap { mapping_origin : EntityRef < IfcAxis2Placement > , mapped_representation : EntityRef < IfcRepresentation > , } impl IIfcRepresentationMap for IfcRepresentationMap { fn mapping_origin (& self) -> & EntityRef < IfcAxis2Placement > { & self . mapping_origin } fn mapped_representation (& self) -> & EntityRef < IfcRepresentation > { & self . mapped_representation } } impl IfcRepresentationMap { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRepresentationMap :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . mapping_origin = parameter . into () , 1usize => entity . mapped_representation = parameter . into () , _ => { } } } entity } } pub trait IIfcResource : IIfcObject { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn long_description (& self) -> & Option < IfcText > ; } pub trait IIfcResourceApprovalRelationship : IIfcResourceLevelRelationship { pub fn related_resource_objects (& self) -> & HashSet < EntityRef < IfcResourceObjectSelect > > ; pub fn relating_approval (& self) -> & EntityRef < IfcApproval > ; } # [derive (Default , Debug)] pub struct IfcResourceApprovalRelationship { name : Option < IfcLabel > , description : Option < IfcText > , related_resource_objects : HashSet < EntityRef < IfcResourceObjectSelect > > , relating_approval : EntityRef < IfcApproval > , } impl IIfcResourceLevelRelationship for IfcResourceApprovalRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcResourceApprovalRelationship for IfcResourceApprovalRelationship { fn related_resource_objects (& self) -> & HashSet < EntityRef < IfcResourceObjectSelect > > { & self . related_resource_objects } fn relating_approval (& self) -> & EntityRef < IfcApproval > { & self . relating_approval } } impl IfcResourceApprovalRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcResourceApprovalRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . related_resource_objects = parameter . into () , 3usize => entity . relating_approval = parameter . into () , _ => { } } } entity } } pub trait IIfcResourceConstraintRelationship : IIfcResourceLevelRelationship { pub fn relating_constraint (& self) -> & EntityRef < IfcConstraint > ; pub fn related_resource_objects (& self) -> & HashSet < EntityRef < IfcResourceObjectSelect > > ; } # [derive (Default , Debug)] pub struct IfcResourceConstraintRelationship { name : Option < IfcLabel > , description : Option < IfcText > , relating_constraint : EntityRef < IfcConstraint > , related_resource_objects : HashSet < EntityRef < IfcResourceObjectSelect > > , } impl IIfcResourceLevelRelationship for IfcResourceConstraintRelationship { fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcResourceConstraintRelationship for IfcResourceConstraintRelationship { fn relating_constraint (& self) -> & EntityRef < IfcConstraint > { & self . relating_constraint } fn related_resource_objects (& self) -> & HashSet < EntityRef < IfcResourceObjectSelect > > { & self . related_resource_objects } } impl IfcResourceConstraintRelationship { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcResourceConstraintRelationship :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . relating_constraint = parameter . into () , 3usize => entity . related_resource_objects = parameter . into () , _ => { } } } entity } } pub trait IIfcResourceLevelRelationship : { pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; } pub trait IIfcResourceTime : IIfcSchedulingTime { pub fn schedule_work (& self) -> & Option < IfcDuration > ; pub fn schedule_usage (& self) -> & Option < IfcPositiveRatioMeasure > ; pub fn schedule_start (& self) -> & Option < IfcDateTime > ; pub fn schedule_finish (& self) -> & Option < IfcDateTime > ; pub fn schedule_contour (& self) -> & Option < IfcLabel > ; pub fn leveling_delay (& self) -> & Option < IfcDuration > ; pub fn is_over_allocated (& self) -> & Option < IfcBoolean > ; pub fn status_time (& self) -> & Option < IfcDateTime > ; pub fn actual_work (& self) -> & Option < IfcDuration > ; pub fn actual_usage (& self) -> & Option < IfcPositiveRatioMeasure > ; pub fn actual_start (& self) -> & Option < IfcDateTime > ; pub fn actual_finish (& self) -> & Option < IfcDateTime > ; pub fn remaining_work (& self) -> & Option < IfcDuration > ; pub fn remaining_usage (& self) -> & Option < IfcPositiveRatioMeasure > ; pub fn completion (& self) -> & Option < IfcPositiveRatioMeasure > ; } # [derive (Default , Debug)] pub struct IfcResourceTime { name : Option < IfcLabel > , data_origin : Option < IfcDataOriginEnum > , user_defined_data_origin : Option < IfcLabel > , schedule_work : Option < IfcDuration > , schedule_usage : Option < IfcPositiveRatioMeasure > , schedule_start : Option < IfcDateTime > , schedule_finish : Option < IfcDateTime > , schedule_contour : Option < IfcLabel > , leveling_delay : Option < IfcDuration > , is_over_allocated : Option < IfcBoolean > , status_time : Option < IfcDateTime > , actual_work : Option < IfcDuration > , actual_usage : Option < IfcPositiveRatioMeasure > , actual_start : Option < IfcDateTime > , actual_finish : Option < IfcDateTime > , remaining_work : Option < IfcDuration > , remaining_usage : Option < IfcPositiveRatioMeasure > , completion : Option < IfcPositiveRatioMeasure > , } impl IIfcSchedulingTime for IfcResourceTime { fn name (& self) -> & Option < IfcLabel > { & self . name } fn data_origin (& self) -> & Option < IfcDataOriginEnum > { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } } impl IIfcResourceTime for IfcResourceTime { fn schedule_work (& self) -> & Option < IfcDuration > { & self . schedule_work } fn schedule_usage (& self) -> & Option < IfcPositiveRatioMeasure > { & self . schedule_usage } fn schedule_start (& self) -> & Option < IfcDateTime > { & self . schedule_start } fn schedule_finish (& self) -> & Option < IfcDateTime > { & self . schedule_finish } fn schedule_contour (& self) -> & Option < IfcLabel > { & self . schedule_contour } fn leveling_delay (& self) -> & Option < IfcDuration > { & self . leveling_delay } fn is_over_allocated (& self) -> & Option < IfcBoolean > { & self . is_over_allocated } fn status_time (& self) -> & Option < IfcDateTime > { & self . status_time } fn actual_work (& self) -> & Option < IfcDuration > { & self . actual_work } fn actual_usage (& self) -> & Option < IfcPositiveRatioMeasure > { & self . actual_usage } fn actual_start (& self) -> & Option < IfcDateTime > { & self . actual_start } fn actual_finish (& self) -> & Option < IfcDateTime > { & self . actual_finish } fn remaining_work (& self) -> & Option < IfcDuration > { & self . remaining_work } fn remaining_usage (& self) -> & Option < IfcPositiveRatioMeasure > { & self . remaining_usage } fn completion (& self) -> & Option < IfcPositiveRatioMeasure > { & self . completion } } impl IfcResourceTime { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcResourceTime :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . schedule_work = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . schedule_usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . schedule_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . schedule_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . schedule_contour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . leveling_delay = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . is_over_allocated = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . status_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . actual_work = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . actual_usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . actual_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . actual_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . remaining_work = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . remaining_usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 17usize => entity . completion = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRevolvedAreaSolid : IIfcSweptAreaSolid { pub fn axis (& self) -> & EntityRef < IfcAxis1Placement > ; pub fn angle (& self) -> & IfcPlaneAngleMeasure ; } # [derive (Default , Debug)] pub struct IfcRevolvedAreaSolid { swept_area : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , axis : EntityRef < IfcAxis1Placement > , angle : IfcPlaneAngleMeasure , } impl IIfcRepresentationItem for IfcRevolvedAreaSolid { } impl IIfcGeometricRepresentationItem for IfcRevolvedAreaSolid { } impl IIfcSolidModel for IfcRevolvedAreaSolid { } impl IIfcSweptAreaSolid for IfcRevolvedAreaSolid { fn swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . swept_area } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcRevolvedAreaSolid for IfcRevolvedAreaSolid { fn axis (& self) -> & EntityRef < IfcAxis1Placement > { & self . axis } fn angle (& self) -> & IfcPlaneAngleMeasure { & self . angle } } impl IfcRevolvedAreaSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRevolvedAreaSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_area = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . axis = parameter . into () , 3usize => entity . angle = parameter . into () , _ => { } } } entity } } pub trait IIfcRevolvedAreaSolidTapered : IIfcRevolvedAreaSolid { pub fn end_swept_area (& self) -> & EntityRef < IfcProfileDef > ; } # [derive (Default , Debug)] pub struct IfcRevolvedAreaSolidTapered { swept_area : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , axis : EntityRef < IfcAxis1Placement > , angle : IfcPlaneAngleMeasure , end_swept_area : EntityRef < IfcProfileDef > , } impl IIfcRepresentationItem for IfcRevolvedAreaSolidTapered { } impl IIfcGeometricRepresentationItem for IfcRevolvedAreaSolidTapered { } impl IIfcSolidModel for IfcRevolvedAreaSolidTapered { } impl IIfcSweptAreaSolid for IfcRevolvedAreaSolidTapered { fn swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . swept_area } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcRevolvedAreaSolid for IfcRevolvedAreaSolidTapered { fn axis (& self) -> & EntityRef < IfcAxis1Placement > { & self . axis } fn angle (& self) -> & IfcPlaneAngleMeasure { & self . angle } } impl IIfcRevolvedAreaSolidTapered for IfcRevolvedAreaSolidTapered { fn end_swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . end_swept_area } } impl IfcRevolvedAreaSolidTapered { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRevolvedAreaSolidTapered :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_area = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . axis = parameter . into () , 3usize => entity . angle = parameter . into () , 4usize => entity . end_swept_area = parameter . into () , _ => { } } } entity } } pub trait IIfcRightCircularCone : IIfcCsgPrimitive3D { pub fn height (& self) -> & IfcPositiveLengthMeasure ; pub fn bottom_radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcRightCircularCone { position : EntityRef < IfcAxis2Placement3D > , height : IfcPositiveLengthMeasure , bottom_radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcRightCircularCone { } impl IIfcGeometricRepresentationItem for IfcRightCircularCone { } impl IIfcCsgPrimitive3D for IfcRightCircularCone { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcRightCircularCone for IfcRightCircularCone { fn height (& self) -> & IfcPositiveLengthMeasure { & self . height } fn bottom_radius (& self) -> & IfcPositiveLengthMeasure { & self . bottom_radius } } impl IfcRightCircularCone { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRightCircularCone :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . height = parameter . into () , 2usize => entity . bottom_radius = parameter . into () , _ => { } } } entity } } pub trait IIfcRightCircularCylinder : IIfcCsgPrimitive3D { pub fn height (& self) -> & IfcPositiveLengthMeasure ; pub fn radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcRightCircularCylinder { position : EntityRef < IfcAxis2Placement3D > , height : IfcPositiveLengthMeasure , radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcRightCircularCylinder { } impl IIfcGeometricRepresentationItem for IfcRightCircularCylinder { } impl IIfcCsgPrimitive3D for IfcRightCircularCylinder { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcRightCircularCylinder for IfcRightCircularCylinder { fn height (& self) -> & IfcPositiveLengthMeasure { & self . height } fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IfcRightCircularCylinder { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRightCircularCylinder :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . height = parameter . into () , 2usize => entity . radius = parameter . into () , _ => { } } } entity } } pub trait IIfcRoof : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcRoofTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcRoof { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcRoofTypeEnum > , } impl IIfcRoot for IfcRoof { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRoof { } impl IIfcObject for IfcRoof { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcRoof { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcRoof { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcRoof { } impl IIfcRoof for IfcRoof { fn predefined_type (& self) -> & Option < IfcRoofTypeEnum > { & self . predefined_type } } impl IfcRoof { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRoof :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcRoofType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcRoofTypeEnum ; } # [derive (Default , Debug)] pub struct IfcRoofType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcRoofTypeEnum , } impl IIfcRoot for IfcRoofType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcRoofType { } impl IIfcTypeObject for IfcRoofType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcRoofType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcRoofType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcRoofType { } impl IIfcRoofType for IfcRoofType { fn predefined_type (& self) -> & IfcRoofTypeEnum { & self . predefined_type } } impl IfcRoofType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRoofType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcRoot : { pub fn global_id (& self) -> & IfcGloballyUniqueId ; pub fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > ; pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; } pub trait IIfcRoundedRectangleProfileDef : IIfcRectangleProfileDef { pub fn rounding_radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcRoundedRectangleProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , x_dim : IfcPositiveLengthMeasure , y_dim : IfcPositiveLengthMeasure , rounding_radius : IfcPositiveLengthMeasure , } impl IIfcProfileDef for IfcRoundedRectangleProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcRoundedRectangleProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcRectangleProfileDef for IfcRoundedRectangleProfileDef { fn x_dim (& self) -> & IfcPositiveLengthMeasure { & self . x_dim } fn y_dim (& self) -> & IfcPositiveLengthMeasure { & self . y_dim } } impl IIfcRoundedRectangleProfileDef for IfcRoundedRectangleProfileDef { fn rounding_radius (& self) -> & IfcPositiveLengthMeasure { & self . rounding_radius } } impl IfcRoundedRectangleProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcRoundedRectangleProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . x_dim = parameter . into () , 4usize => entity . y_dim = parameter . into () , 5usize => entity . rounding_radius = parameter . into () , _ => { } } } entity } } pub trait IIfcSiUnit : IIfcNamedUnit { pub fn prefix (& self) -> & Option < IfcSiPrefix > ; pub fn name (& self) -> & IfcSiUnitName ; } # [derive (Default , Debug)] pub struct IfcSiUnit { dimensions : EntityRef < IfcDimensionalExponents > , unit_type : IfcUnitEnum , prefix : Option < IfcSiPrefix > , name : IfcSiUnitName , } impl IIfcNamedUnit for IfcSiUnit { fn dimensions (& self) -> & EntityRef < IfcDimensionalExponents > { & self . dimensions } fn unit_type (& self) -> & IfcUnitEnum { & self . unit_type } } impl IIfcSiUnit for IfcSiUnit { fn prefix (& self) -> & Option < IfcSiPrefix > { & self . prefix } fn name (& self) -> & IfcSiUnitName { & self . name } } impl IfcSiUnit { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSiUnit :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . dimensions = parameter . into () , 1usize => entity . unit_type = parameter . into () , 2usize => entity . prefix = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . name = parameter . into () , _ => { } } } entity } } pub trait IIfcSanitaryTerminal : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcSanitaryTerminalTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSanitaryTerminal { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSanitaryTerminalTypeEnum > , } impl IIfcRoot for IfcSanitaryTerminal { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSanitaryTerminal { } impl IIfcObject for IfcSanitaryTerminal { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSanitaryTerminal { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSanitaryTerminal { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcSanitaryTerminal { } impl IIfcDistributionFlowElement for IfcSanitaryTerminal { } impl IIfcFlowTerminal for IfcSanitaryTerminal { } impl IIfcSanitaryTerminal for IfcSanitaryTerminal { fn predefined_type (& self) -> & Option < IfcSanitaryTerminalTypeEnum > { & self . predefined_type } } impl IfcSanitaryTerminal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSanitaryTerminal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSanitaryTerminalType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcSanitaryTerminalTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSanitaryTerminalType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSanitaryTerminalTypeEnum , } impl IIfcRoot for IfcSanitaryTerminalType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSanitaryTerminalType { } impl IIfcTypeObject for IfcSanitaryTerminalType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSanitaryTerminalType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSanitaryTerminalType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcSanitaryTerminalType { } impl IIfcDistributionFlowElementType for IfcSanitaryTerminalType { } impl IIfcFlowTerminalType for IfcSanitaryTerminalType { } impl IIfcSanitaryTerminalType for IfcSanitaryTerminalType { fn predefined_type (& self) -> & IfcSanitaryTerminalTypeEnum { & self . predefined_type } } impl IfcSanitaryTerminalType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSanitaryTerminalType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcSchedulingTime : { pub fn name (& self) -> & Option < IfcLabel > ; pub fn data_origin (& self) -> & Option < IfcDataOriginEnum > ; pub fn user_defined_data_origin (& self) -> & Option < IfcLabel > ; } pub trait IIfcSeamCurve : IIfcSurfaceCurve { } # [derive (Default , Debug)] pub struct IfcSeamCurve { curve3_d : EntityRef < IfcCurve > , associated_geometry : Vec < EntityRef < IfcPcurve > > , master_representation : IfcPreferredSurfaceCurveRepresentation , } impl IIfcRepresentationItem for IfcSeamCurve { } impl IIfcGeometricRepresentationItem for IfcSeamCurve { } impl IIfcCurve for IfcSeamCurve { } impl IIfcSurfaceCurve for IfcSeamCurve { fn curve3_d (& self) -> & EntityRef < IfcCurve > { & self . curve3_d } fn associated_geometry (& self) -> & Vec < EntityRef < IfcPcurve > > { & self . associated_geometry } fn master_representation (& self) -> & IfcPreferredSurfaceCurveRepresentation { & self . master_representation } } impl IIfcSeamCurve for IfcSeamCurve { } impl IfcSeamCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSeamCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . curve3_d = parameter . into () , 1usize => entity . associated_geometry = parameter . into () , 2usize => entity . master_representation = parameter . into () , _ => { } } } entity } } pub trait IIfcSectionProperties : IIfcPreDefinedProperties { pub fn section_type (& self) -> & IfcSectionTypeEnum ; pub fn start_profile (& self) -> & EntityRef < IfcProfileDef > ; pub fn end_profile (& self) -> & Option < EntityRef < IfcProfileDef > > ; } # [derive (Default , Debug)] pub struct IfcSectionProperties { section_type : IfcSectionTypeEnum , start_profile : EntityRef < IfcProfileDef > , end_profile : Option < EntityRef < IfcProfileDef > > , } impl IIfcPropertyAbstraction for IfcSectionProperties { } impl IIfcPreDefinedProperties for IfcSectionProperties { } impl IIfcSectionProperties for IfcSectionProperties { fn section_type (& self) -> & IfcSectionTypeEnum { & self . section_type } fn start_profile (& self) -> & EntityRef < IfcProfileDef > { & self . start_profile } fn end_profile (& self) -> & Option < EntityRef < IfcProfileDef > > { & self . end_profile } } impl IfcSectionProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSectionProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . section_type = parameter . into () , 1usize => entity . start_profile = parameter . into () , 2usize => entity . end_profile = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSectionReinforcementProperties : IIfcPreDefinedProperties { pub fn longitudinal_start_position (& self) -> & IfcLengthMeasure ; pub fn longitudinal_end_position (& self) -> & IfcLengthMeasure ; pub fn transverse_position (& self) -> & Option < IfcLengthMeasure > ; pub fn reinforcement_role (& self) -> & IfcReinforcingBarRoleEnum ; pub fn section_definition (& self) -> & EntityRef < IfcSectionProperties > ; pub fn cross_section_reinforcement_definitions (& self) -> & HashSet < EntityRef < IfcReinforcementBarProperties > > ; } # [derive (Default , Debug)] pub struct IfcSectionReinforcementProperties { longitudinal_start_position : IfcLengthMeasure , longitudinal_end_position : IfcLengthMeasure , transverse_position : Option < IfcLengthMeasure > , reinforcement_role : IfcReinforcingBarRoleEnum , section_definition : EntityRef < IfcSectionProperties > , cross_section_reinforcement_definitions : HashSet < EntityRef < IfcReinforcementBarProperties > > , } impl IIfcPropertyAbstraction for IfcSectionReinforcementProperties { } impl IIfcPreDefinedProperties for IfcSectionReinforcementProperties { } impl IIfcSectionReinforcementProperties for IfcSectionReinforcementProperties { fn longitudinal_start_position (& self) -> & IfcLengthMeasure { & self . longitudinal_start_position } fn longitudinal_end_position (& self) -> & IfcLengthMeasure { & self . longitudinal_end_position } fn transverse_position (& self) -> & Option < IfcLengthMeasure > { & self . transverse_position } fn reinforcement_role (& self) -> & IfcReinforcingBarRoleEnum { & self . reinforcement_role } fn section_definition (& self) -> & EntityRef < IfcSectionProperties > { & self . section_definition } fn cross_section_reinforcement_definitions (& self) -> & HashSet < EntityRef < IfcReinforcementBarProperties > > { & self . cross_section_reinforcement_definitions } } impl IfcSectionReinforcementProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSectionReinforcementProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . longitudinal_start_position = parameter . into () , 1usize => entity . longitudinal_end_position = parameter . into () , 2usize => entity . transverse_position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . reinforcement_role = parameter . into () , 4usize => entity . section_definition = parameter . into () , 5usize => entity . cross_section_reinforcement_definitions = parameter . into () , _ => { } } } entity } } pub trait IIfcSectionedSpine : IIfcGeometricRepresentationItem { pub fn spine_curve (& self) -> & EntityRef < IfcCompositeCurve > ; pub fn cross_sections (& self) -> & Vec < EntityRef < IfcProfileDef > > ; pub fn cross_section_positions (& self) -> & Vec < EntityRef < IfcAxis2Placement3D > > ; } # [derive (Default , Debug)] pub struct IfcSectionedSpine { spine_curve : EntityRef < IfcCompositeCurve > , cross_sections : Vec < EntityRef < IfcProfileDef > > , cross_section_positions : Vec < EntityRef < IfcAxis2Placement3D > > , } impl IIfcRepresentationItem for IfcSectionedSpine { } impl IIfcGeometricRepresentationItem for IfcSectionedSpine { } impl IIfcSectionedSpine for IfcSectionedSpine { fn spine_curve (& self) -> & EntityRef < IfcCompositeCurve > { & self . spine_curve } fn cross_sections (& self) -> & Vec < EntityRef < IfcProfileDef > > { & self . cross_sections } fn cross_section_positions (& self) -> & Vec < EntityRef < IfcAxis2Placement3D > > { & self . cross_section_positions } } impl IfcSectionedSpine { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSectionedSpine :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . spine_curve = parameter . into () , 1usize => entity . cross_sections = parameter . into () , 2usize => entity . cross_section_positions = parameter . into () , _ => { } } } entity } } pub trait IIfcSensor : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcSensorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSensor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSensorTypeEnum > , } impl IIfcRoot for IfcSensor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSensor { } impl IIfcObject for IfcSensor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSensor { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSensor { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcSensor { } impl IIfcDistributionControlElement for IfcSensor { } impl IIfcSensor for IfcSensor { fn predefined_type (& self) -> & Option < IfcSensorTypeEnum > { & self . predefined_type } } impl IfcSensor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSensor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSensorType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcSensorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSensorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSensorTypeEnum , } impl IIfcRoot for IfcSensorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSensorType { } impl IIfcTypeObject for IfcSensorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSensorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSensorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcSensorType { } impl IIfcDistributionControlElementType for IfcSensorType { } impl IIfcSensorType for IfcSensorType { fn predefined_type (& self) -> & IfcSensorTypeEnum { & self . predefined_type } } impl IfcSensorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSensorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcShadingDevice : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcShadingDeviceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcShadingDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcShadingDeviceTypeEnum > , } impl IIfcRoot for IfcShadingDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcShadingDevice { } impl IIfcObject for IfcShadingDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcShadingDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcShadingDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcShadingDevice { } impl IIfcShadingDevice for IfcShadingDevice { fn predefined_type (& self) -> & Option < IfcShadingDeviceTypeEnum > { & self . predefined_type } } impl IfcShadingDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcShadingDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcShadingDeviceType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcShadingDeviceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcShadingDeviceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcShadingDeviceTypeEnum , } impl IIfcRoot for IfcShadingDeviceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcShadingDeviceType { } impl IIfcTypeObject for IfcShadingDeviceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcShadingDeviceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcShadingDeviceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcShadingDeviceType { } impl IIfcShadingDeviceType for IfcShadingDeviceType { fn predefined_type (& self) -> & IfcShadingDeviceTypeEnum { & self . predefined_type } } impl IfcShadingDeviceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcShadingDeviceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcShapeAspect : { pub fn shape_representations (& self) -> & Vec < EntityRef < IfcShapeModel > > ; pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn product_definitional (& self) -> & IfcLogical ; pub fn part_of_product_definition_shape (& self) -> & Option < EntityRef < IfcProductRepresentationSelect > > ; } # [derive (Default , Debug)] pub struct IfcShapeAspect { shape_representations : Vec < EntityRef < IfcShapeModel > > , name : Option < IfcLabel > , description : Option < IfcText > , product_definitional : IfcLogical , part_of_product_definition_shape : Option < EntityRef < IfcProductRepresentationSelect > > , } impl IIfcShapeAspect for IfcShapeAspect { fn shape_representations (& self) -> & Vec < EntityRef < IfcShapeModel > > { & self . shape_representations } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn product_definitional (& self) -> & IfcLogical { & self . product_definitional } fn part_of_product_definition_shape (& self) -> & Option < EntityRef < IfcProductRepresentationSelect > > { & self . part_of_product_definition_shape } } impl IfcShapeAspect { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcShapeAspect :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . shape_representations = parameter . into () , 1usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . product_definitional = parameter . into () , 4usize => entity . part_of_product_definition_shape = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcShapeModel : IIfcRepresentation { } pub trait IIfcShapeRepresentation : IIfcShapeModel { } # [derive (Default , Debug)] pub struct IfcShapeRepresentation { context_of_items : EntityRef < IfcRepresentationContext > , representation_identifier : Option < IfcLabel > , representation_type : Option < IfcLabel > , items : HashSet < EntityRef < IfcRepresentationItem > > , } impl IIfcRepresentation for IfcShapeRepresentation { fn context_of_items (& self) -> & EntityRef < IfcRepresentationContext > { & self . context_of_items } fn representation_identifier (& self) -> & Option < IfcLabel > { & self . representation_identifier } fn representation_type (& self) -> & Option < IfcLabel > { & self . representation_type } fn items (& self) -> & HashSet < EntityRef < IfcRepresentationItem > > { & self . items } } impl IIfcShapeModel for IfcShapeRepresentation { } impl IIfcShapeRepresentation for IfcShapeRepresentation { } impl IfcShapeRepresentation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcShapeRepresentation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . context_of_items = parameter . into () , 1usize => entity . representation_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . representation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . items = parameter . into () , _ => { } } } entity } } pub trait IIfcShellBasedSurfaceModel : IIfcGeometricRepresentationItem { pub fn sbsm_boundary (& self) -> & HashSet < EntityRef < IfcShell > > ; } # [derive (Default , Debug)] pub struct IfcShellBasedSurfaceModel { sbsm_boundary : HashSet < EntityRef < IfcShell > > , } impl IIfcRepresentationItem for IfcShellBasedSurfaceModel { } impl IIfcGeometricRepresentationItem for IfcShellBasedSurfaceModel { } impl IIfcShellBasedSurfaceModel for IfcShellBasedSurfaceModel { fn sbsm_boundary (& self) -> & HashSet < EntityRef < IfcShell > > { & self . sbsm_boundary } } impl IfcShellBasedSurfaceModel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcShellBasedSurfaceModel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . sbsm_boundary = parameter . into () , _ => { } } } entity } } pub trait IIfcSimpleProperty : IIfcProperty { } pub trait IIfcSimplePropertyTemplate : IIfcPropertyTemplate { pub fn template_type (& self) -> & Option < IfcSimplePropertyTemplateTypeEnum > ; pub fn primary_measure_type (& self) -> & Option < IfcLabel > ; pub fn secondary_measure_type (& self) -> & Option < IfcLabel > ; pub fn enumerators (& self) -> & Option < EntityRef < IfcPropertyEnumeration > > ; pub fn primary_unit (& self) -> & Option < EntityRef < IfcUnit > > ; pub fn secondary_unit (& self) -> & Option < EntityRef < IfcUnit > > ; pub fn expression (& self) -> & Option < IfcLabel > ; pub fn access_state (& self) -> & Option < IfcStateEnum > ; } # [derive (Default , Debug)] pub struct IfcSimplePropertyTemplate { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , template_type : Option < IfcSimplePropertyTemplateTypeEnum > , primary_measure_type : Option < IfcLabel > , secondary_measure_type : Option < IfcLabel > , enumerators : Option < EntityRef < IfcPropertyEnumeration > > , primary_unit : Option < EntityRef < IfcUnit > > , secondary_unit : Option < EntityRef < IfcUnit > > , expression : Option < IfcLabel > , access_state : Option < IfcStateEnum > , } impl IIfcRoot for IfcSimplePropertyTemplate { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcSimplePropertyTemplate { } impl IIfcPropertyTemplateDefinition for IfcSimplePropertyTemplate { } impl IIfcPropertyTemplate for IfcSimplePropertyTemplate { } impl IIfcSimplePropertyTemplate for IfcSimplePropertyTemplate { fn template_type (& self) -> & Option < IfcSimplePropertyTemplateTypeEnum > { & self . template_type } fn primary_measure_type (& self) -> & Option < IfcLabel > { & self . primary_measure_type } fn secondary_measure_type (& self) -> & Option < IfcLabel > { & self . secondary_measure_type } fn enumerators (& self) -> & Option < EntityRef < IfcPropertyEnumeration > > { & self . enumerators } fn primary_unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . primary_unit } fn secondary_unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . secondary_unit } fn expression (& self) -> & Option < IfcLabel > { & self . expression } fn access_state (& self) -> & Option < IfcStateEnum > { & self . access_state } } impl IfcSimplePropertyTemplate { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSimplePropertyTemplate :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . template_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . primary_measure_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . secondary_measure_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . enumerators = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . primary_unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . secondary_unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . expression = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . access_state = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSite : IIfcSpatialStructureElement { pub fn ref_latitude (& self) -> & Option < IfcCompoundPlaneAngleMeasure > ; pub fn ref_longitude (& self) -> & Option < IfcCompoundPlaneAngleMeasure > ; pub fn ref_elevation (& self) -> & Option < IfcLengthMeasure > ; pub fn land_title_number (& self) -> & Option < IfcLabel > ; pub fn site_address (& self) -> & Option < EntityRef < IfcPostalAddress > > ; } # [derive (Default , Debug)] pub struct IfcSite { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , long_name : Option < IfcLabel > , composition_type : Option < IfcElementCompositionEnum > , ref_latitude : Option < IfcCompoundPlaneAngleMeasure > , ref_longitude : Option < IfcCompoundPlaneAngleMeasure > , ref_elevation : Option < IfcLengthMeasure > , land_title_number : Option < IfcLabel > , site_address : Option < EntityRef < IfcPostalAddress > > , } impl IIfcRoot for IfcSite { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSite { } impl IIfcObject for IfcSite { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSite { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcSpatialElement for IfcSite { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IIfcSpatialStructureElement for IfcSite { fn composition_type (& self) -> & Option < IfcElementCompositionEnum > { & self . composition_type } } impl IIfcSite for IfcSite { fn ref_latitude (& self) -> & Option < IfcCompoundPlaneAngleMeasure > { & self . ref_latitude } fn ref_longitude (& self) -> & Option < IfcCompoundPlaneAngleMeasure > { & self . ref_longitude } fn ref_elevation (& self) -> & Option < IfcLengthMeasure > { & self . ref_elevation } fn land_title_number (& self) -> & Option < IfcLabel > { & self . land_title_number } fn site_address (& self) -> & Option < EntityRef < IfcPostalAddress > > { & self . site_address } } impl IfcSite { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSite :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . composition_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . ref_latitude = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . ref_longitude = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . ref_elevation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . land_title_number = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . site_address = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSlab : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcSlabTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSlab { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSlabTypeEnum > , } impl IIfcRoot for IfcSlab { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSlab { } impl IIfcObject for IfcSlab { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSlab { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSlab { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcSlab { } impl IIfcSlab for IfcSlab { fn predefined_type (& self) -> & Option < IfcSlabTypeEnum > { & self . predefined_type } } impl IfcSlab { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSlab :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSlabElementedCase : IIfcSlab { } # [derive (Default , Debug)] pub struct IfcSlabElementedCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSlabTypeEnum > , } impl IIfcRoot for IfcSlabElementedCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSlabElementedCase { } impl IIfcObject for IfcSlabElementedCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSlabElementedCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSlabElementedCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcSlabElementedCase { } impl IIfcSlab for IfcSlabElementedCase { fn predefined_type (& self) -> & Option < IfcSlabTypeEnum > { & self . predefined_type } } impl IIfcSlabElementedCase for IfcSlabElementedCase { } impl IfcSlabElementedCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSlabElementedCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSlabStandardCase : IIfcSlab { } # [derive (Default , Debug)] pub struct IfcSlabStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSlabTypeEnum > , } impl IIfcRoot for IfcSlabStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSlabStandardCase { } impl IIfcObject for IfcSlabStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSlabStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSlabStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcSlabStandardCase { } impl IIfcSlab for IfcSlabStandardCase { fn predefined_type (& self) -> & Option < IfcSlabTypeEnum > { & self . predefined_type } } impl IIfcSlabStandardCase for IfcSlabStandardCase { } impl IfcSlabStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSlabStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSlabType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcSlabTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSlabType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSlabTypeEnum , } impl IIfcRoot for IfcSlabType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSlabType { } impl IIfcTypeObject for IfcSlabType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSlabType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSlabType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcSlabType { } impl IIfcSlabType for IfcSlabType { fn predefined_type (& self) -> & IfcSlabTypeEnum { & self . predefined_type } } impl IfcSlabType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSlabType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcSlippageConnectionCondition : IIfcStructuralConnectionCondition { pub fn slippage_x (& self) -> & Option < IfcLengthMeasure > ; pub fn slippage_y (& self) -> & Option < IfcLengthMeasure > ; pub fn slippage_z (& self) -> & Option < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcSlippageConnectionCondition { name : Option < IfcLabel > , slippage_x : Option < IfcLengthMeasure > , slippage_y : Option < IfcLengthMeasure > , slippage_z : Option < IfcLengthMeasure > , } impl IIfcStructuralConnectionCondition for IfcSlippageConnectionCondition { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcSlippageConnectionCondition for IfcSlippageConnectionCondition { fn slippage_x (& self) -> & Option < IfcLengthMeasure > { & self . slippage_x } fn slippage_y (& self) -> & Option < IfcLengthMeasure > { & self . slippage_y } fn slippage_z (& self) -> & Option < IfcLengthMeasure > { & self . slippage_z } } impl IfcSlippageConnectionCondition { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSlippageConnectionCondition :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . slippage_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . slippage_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . slippage_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSolarDevice : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcSolarDeviceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSolarDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSolarDeviceTypeEnum > , } impl IIfcRoot for IfcSolarDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSolarDevice { } impl IIfcObject for IfcSolarDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSolarDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSolarDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcSolarDevice { } impl IIfcDistributionFlowElement for IfcSolarDevice { } impl IIfcEnergyConversionDevice for IfcSolarDevice { } impl IIfcSolarDevice for IfcSolarDevice { fn predefined_type (& self) -> & Option < IfcSolarDeviceTypeEnum > { & self . predefined_type } } impl IfcSolarDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSolarDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSolarDeviceType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcSolarDeviceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSolarDeviceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSolarDeviceTypeEnum , } impl IIfcRoot for IfcSolarDeviceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSolarDeviceType { } impl IIfcTypeObject for IfcSolarDeviceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSolarDeviceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSolarDeviceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcSolarDeviceType { } impl IIfcDistributionFlowElementType for IfcSolarDeviceType { } impl IIfcEnergyConversionDeviceType for IfcSolarDeviceType { } impl IIfcSolarDeviceType for IfcSolarDeviceType { fn predefined_type (& self) -> & IfcSolarDeviceTypeEnum { & self . predefined_type } } impl IfcSolarDeviceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSolarDeviceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcSolidModel : IIfcGeometricRepresentationItem { } pub trait IIfcSpace : IIfcSpatialStructureElement { pub fn predefined_type (& self) -> & Option < IfcSpaceTypeEnum > ; pub fn elevation_with_flooring (& self) -> & Option < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcSpace { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , long_name : Option < IfcLabel > , composition_type : Option < IfcElementCompositionEnum > , predefined_type : Option < IfcSpaceTypeEnum > , elevation_with_flooring : Option < IfcLengthMeasure > , } impl IIfcRoot for IfcSpace { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSpace { } impl IIfcObject for IfcSpace { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSpace { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcSpatialElement for IfcSpace { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IIfcSpatialStructureElement for IfcSpace { fn composition_type (& self) -> & Option < IfcElementCompositionEnum > { & self . composition_type } } impl IIfcSpace for IfcSpace { fn predefined_type (& self) -> & Option < IfcSpaceTypeEnum > { & self . predefined_type } fn elevation_with_flooring (& self) -> & Option < IfcLengthMeasure > { & self . elevation_with_flooring } } impl IfcSpace { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSpace :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . composition_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . elevation_with_flooring = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSpaceHeater : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcSpaceHeaterTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSpaceHeater { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSpaceHeaterTypeEnum > , } impl IIfcRoot for IfcSpaceHeater { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSpaceHeater { } impl IIfcObject for IfcSpaceHeater { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSpaceHeater { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSpaceHeater { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcSpaceHeater { } impl IIfcDistributionFlowElement for IfcSpaceHeater { } impl IIfcFlowTerminal for IfcSpaceHeater { } impl IIfcSpaceHeater for IfcSpaceHeater { fn predefined_type (& self) -> & Option < IfcSpaceHeaterTypeEnum > { & self . predefined_type } } impl IfcSpaceHeater { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSpaceHeater :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSpaceHeaterType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcSpaceHeaterTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSpaceHeaterType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSpaceHeaterTypeEnum , } impl IIfcRoot for IfcSpaceHeaterType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSpaceHeaterType { } impl IIfcTypeObject for IfcSpaceHeaterType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSpaceHeaterType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSpaceHeaterType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcSpaceHeaterType { } impl IIfcDistributionFlowElementType for IfcSpaceHeaterType { } impl IIfcFlowTerminalType for IfcSpaceHeaterType { } impl IIfcSpaceHeaterType for IfcSpaceHeaterType { fn predefined_type (& self) -> & IfcSpaceHeaterTypeEnum { & self . predefined_type } } impl IfcSpaceHeaterType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSpaceHeaterType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcSpaceType : IIfcSpatialStructureElementType { pub fn predefined_type (& self) -> & IfcSpaceTypeEnum ; pub fn long_name (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcSpaceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSpaceTypeEnum , long_name : Option < IfcLabel > , } impl IIfcRoot for IfcSpaceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSpaceType { } impl IIfcTypeObject for IfcSpaceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSpaceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcSpatialElementType for IfcSpaceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcSpatialStructureElementType for IfcSpaceType { } impl IIfcSpaceType for IfcSpaceType { fn predefined_type (& self) -> & IfcSpaceTypeEnum { & self . predefined_type } fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IfcSpaceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSpaceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSpatialElement : IIfcProduct { pub fn long_name (& self) -> & Option < IfcLabel > ; } pub trait IIfcSpatialElementType : IIfcTypeProduct { pub fn element_type (& self) -> & Option < IfcLabel > ; } pub trait IIfcSpatialStructureElement : IIfcSpatialElement { pub fn composition_type (& self) -> & Option < IfcElementCompositionEnum > ; } pub trait IIfcSpatialStructureElementType : IIfcSpatialElementType { } pub trait IIfcSpatialZone : IIfcSpatialElement { pub fn predefined_type (& self) -> & Option < IfcSpatialZoneTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSpatialZone { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , long_name : Option < IfcLabel > , predefined_type : Option < IfcSpatialZoneTypeEnum > , } impl IIfcRoot for IfcSpatialZone { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSpatialZone { } impl IIfcObject for IfcSpatialZone { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSpatialZone { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcSpatialElement for IfcSpatialZone { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IIfcSpatialZone for IfcSpatialZone { fn predefined_type (& self) -> & Option < IfcSpatialZoneTypeEnum > { & self . predefined_type } } impl IfcSpatialZone { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSpatialZone :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSpatialZoneType : IIfcSpatialElementType { pub fn predefined_type (& self) -> & IfcSpatialZoneTypeEnum ; pub fn long_name (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcSpatialZoneType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSpatialZoneTypeEnum , long_name : Option < IfcLabel > , } impl IIfcRoot for IfcSpatialZoneType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSpatialZoneType { } impl IIfcTypeObject for IfcSpatialZoneType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSpatialZoneType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcSpatialElementType for IfcSpatialZoneType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcSpatialZoneType for IfcSpatialZoneType { fn predefined_type (& self) -> & IfcSpatialZoneTypeEnum { & self . predefined_type } fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IfcSpatialZoneType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSpatialZoneType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSphere : IIfcCsgPrimitive3D { pub fn radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcSphere { position : EntityRef < IfcAxis2Placement3D > , radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcSphere { } impl IIfcGeometricRepresentationItem for IfcSphere { } impl IIfcCsgPrimitive3D for IfcSphere { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcSphere for IfcSphere { fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IfcSphere { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSphere :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . radius = parameter . into () , _ => { } } } entity } } pub trait IIfcSphericalSurface : IIfcElementarySurface { pub fn radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcSphericalSurface { position : EntityRef < IfcAxis2Placement3D > , radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcSphericalSurface { } impl IIfcGeometricRepresentationItem for IfcSphericalSurface { } impl IIfcSurface for IfcSphericalSurface { } impl IIfcElementarySurface for IfcSphericalSurface { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcSphericalSurface for IfcSphericalSurface { fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } } impl IfcSphericalSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSphericalSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . radius = parameter . into () , _ => { } } } entity } } pub trait IIfcStackTerminal : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcStackTerminalTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcStackTerminal { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcStackTerminalTypeEnum > , } impl IIfcRoot for IfcStackTerminal { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStackTerminal { } impl IIfcObject for IfcStackTerminal { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStackTerminal { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcStackTerminal { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcStackTerminal { } impl IIfcDistributionFlowElement for IfcStackTerminal { } impl IIfcFlowTerminal for IfcStackTerminal { } impl IIfcStackTerminal for IfcStackTerminal { fn predefined_type (& self) -> & Option < IfcStackTerminalTypeEnum > { & self . predefined_type } } impl IfcStackTerminal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStackTerminal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStackTerminalType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcStackTerminalTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStackTerminalType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcStackTerminalTypeEnum , } impl IIfcRoot for IfcStackTerminalType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStackTerminalType { } impl IIfcTypeObject for IfcStackTerminalType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcStackTerminalType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcStackTerminalType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcStackTerminalType { } impl IIfcDistributionFlowElementType for IfcStackTerminalType { } impl IIfcFlowTerminalType for IfcStackTerminalType { } impl IIfcStackTerminalType for IfcStackTerminalType { fn predefined_type (& self) -> & IfcStackTerminalTypeEnum { & self . predefined_type } } impl IfcStackTerminalType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStackTerminalType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStair : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcStairTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcStair { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcStairTypeEnum > , } impl IIfcRoot for IfcStair { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStair { } impl IIfcObject for IfcStair { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStair { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcStair { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcStair { } impl IIfcStair for IfcStair { fn predefined_type (& self) -> & Option < IfcStairTypeEnum > { & self . predefined_type } } impl IfcStair { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStair :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStairFlight : IIfcBuildingElement { pub fn number_of_risers (& self) -> & Option < IfcInteger > ; pub fn number_of_treads (& self) -> & Option < IfcInteger > ; pub fn riser_height (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn tread_length (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn predefined_type (& self) -> & Option < IfcStairFlightTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcStairFlight { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , number_of_risers : Option < IfcInteger > , number_of_treads : Option < IfcInteger > , riser_height : Option < IfcPositiveLengthMeasure > , tread_length : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcStairFlightTypeEnum > , } impl IIfcRoot for IfcStairFlight { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStairFlight { } impl IIfcObject for IfcStairFlight { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStairFlight { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcStairFlight { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcStairFlight { } impl IIfcStairFlight for IfcStairFlight { fn number_of_risers (& self) -> & Option < IfcInteger > { & self . number_of_risers } fn number_of_treads (& self) -> & Option < IfcInteger > { & self . number_of_treads } fn riser_height (& self) -> & Option < IfcPositiveLengthMeasure > { & self . riser_height } fn tread_length (& self) -> & Option < IfcPositiveLengthMeasure > { & self . tread_length } fn predefined_type (& self) -> & Option < IfcStairFlightTypeEnum > { & self . predefined_type } } impl IfcStairFlight { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStairFlight :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . number_of_risers = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . number_of_treads = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . riser_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . tread_length = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStairFlightType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcStairFlightTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStairFlightType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcStairFlightTypeEnum , } impl IIfcRoot for IfcStairFlightType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStairFlightType { } impl IIfcTypeObject for IfcStairFlightType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcStairFlightType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcStairFlightType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcStairFlightType { } impl IIfcStairFlightType for IfcStairFlightType { fn predefined_type (& self) -> & IfcStairFlightTypeEnum { & self . predefined_type } } impl IfcStairFlightType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStairFlightType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStairType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcStairTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStairType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcStairTypeEnum , } impl IIfcRoot for IfcStairType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStairType { } impl IIfcTypeObject for IfcStairType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcStairType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcStairType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcStairType { } impl IIfcStairType for IfcStairType { fn predefined_type (& self) -> & IfcStairTypeEnum { & self . predefined_type } } impl IfcStairType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStairType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralAction : IIfcStructuralActivity { pub fn destabilizing_load (& self) -> & Option < IfcBoolean > ; } pub trait IIfcStructuralActivity : IIfcProduct { pub fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > ; pub fn global_or_local (& self) -> & IfcGlobalOrLocalEnum ; } pub trait IIfcStructuralAnalysisModel : IIfcSystem { pub fn predefined_type (& self) -> & IfcAnalysisModelTypeEnum ; pub fn orientation_of2_d_plane (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > ; pub fn loaded_by (& self) -> & Option < HashSet < EntityRef < IfcStructuralLoadGroup > > > ; pub fn has_results (& self) -> & Option < HashSet < EntityRef < IfcStructuralResultGroup > > > ; pub fn shared_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > ; } # [derive (Default , Debug)] pub struct IfcStructuralAnalysisModel { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , predefined_type : IfcAnalysisModelTypeEnum , orientation_of2_d_plane : Option < EntityRef < IfcAxis2Placement3D > > , loaded_by : Option < HashSet < EntityRef < IfcStructuralLoadGroup > > > , has_results : Option < HashSet < EntityRef < IfcStructuralResultGroup > > > , shared_placement : Option < EntityRef < IfcObjectPlacement > > , } impl IIfcRoot for IfcStructuralAnalysisModel { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralAnalysisModel { } impl IIfcObject for IfcStructuralAnalysisModel { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcStructuralAnalysisModel { } impl IIfcSystem for IfcStructuralAnalysisModel { } impl IIfcStructuralAnalysisModel for IfcStructuralAnalysisModel { fn predefined_type (& self) -> & IfcAnalysisModelTypeEnum { & self . predefined_type } fn orientation_of2_d_plane (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . orientation_of2_d_plane } fn loaded_by (& self) -> & Option < HashSet < EntityRef < IfcStructuralLoadGroup > > > { & self . loaded_by } fn has_results (& self) -> & Option < HashSet < EntityRef < IfcStructuralResultGroup > > > { & self . has_results } fn shared_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . shared_placement } } impl IfcStructuralAnalysisModel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralAnalysisModel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . predefined_type = parameter . into () , 6usize => entity . orientation_of2_d_plane = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . loaded_by = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . has_results = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . shared_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralConnection : IIfcStructuralItem { pub fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > ; } pub trait IIfcStructuralConnectionCondition : { pub fn name (& self) -> & Option < IfcLabel > ; } pub trait IIfcStructuralCurveAction : IIfcStructuralAction { pub fn projected_or_true (& self) -> & Option < IfcProjectedOrTrueLengthEnum > ; pub fn predefined_type (& self) -> & IfcStructuralCurveActivityTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStructuralCurveAction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , destabilizing_load : Option < IfcBoolean > , projected_or_true : Option < IfcProjectedOrTrueLengthEnum > , predefined_type : IfcStructuralCurveActivityTypeEnum , } impl IIfcRoot for IfcStructuralCurveAction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralCurveAction { } impl IIfcObject for IfcStructuralCurveAction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralCurveAction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralCurveAction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralAction for IfcStructuralCurveAction { fn destabilizing_load (& self) -> & Option < IfcBoolean > { & self . destabilizing_load } } impl IIfcStructuralCurveAction for IfcStructuralCurveAction { fn projected_or_true (& self) -> & Option < IfcProjectedOrTrueLengthEnum > { & self . projected_or_true } fn predefined_type (& self) -> & IfcStructuralCurveActivityTypeEnum { & self . predefined_type } } impl IfcStructuralCurveAction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralCurveAction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . destabilizing_load = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . projected_or_true = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralCurveConnection : IIfcStructuralConnection { pub fn axis (& self) -> & EntityRef < IfcDirection > ; } # [derive (Default , Debug)] pub struct IfcStructuralCurveConnection { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_condition : Option < EntityRef < IfcBoundaryCondition > > , axis : EntityRef < IfcDirection > , } impl IIfcRoot for IfcStructuralCurveConnection { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralCurveConnection { } impl IIfcObject for IfcStructuralCurveConnection { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralCurveConnection { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralCurveConnection { } impl IIfcStructuralConnection for IfcStructuralCurveConnection { fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > { & self . applied_condition } } impl IIfcStructuralCurveConnection for IfcStructuralCurveConnection { fn axis (& self) -> & EntityRef < IfcDirection > { & self . axis } } impl IfcStructuralCurveConnection { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralCurveConnection :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . axis = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralCurveMember : IIfcStructuralMember { pub fn predefined_type (& self) -> & IfcStructuralCurveMemberTypeEnum ; pub fn axis (& self) -> & EntityRef < IfcDirection > ; } # [derive (Default , Debug)] pub struct IfcStructuralCurveMember { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , predefined_type : IfcStructuralCurveMemberTypeEnum , axis : EntityRef < IfcDirection > , } impl IIfcRoot for IfcStructuralCurveMember { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralCurveMember { } impl IIfcObject for IfcStructuralCurveMember { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralCurveMember { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralCurveMember { } impl IIfcStructuralMember for IfcStructuralCurveMember { } impl IIfcStructuralCurveMember for IfcStructuralCurveMember { fn predefined_type (& self) -> & IfcStructuralCurveMemberTypeEnum { & self . predefined_type } fn axis (& self) -> & EntityRef < IfcDirection > { & self . axis } } impl IfcStructuralCurveMember { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralCurveMember :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . predefined_type = parameter . into () , 8usize => entity . axis = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralCurveMemberVarying : IIfcStructuralCurveMember { } # [derive (Default , Debug)] pub struct IfcStructuralCurveMemberVarying { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , predefined_type : IfcStructuralCurveMemberTypeEnum , axis : EntityRef < IfcDirection > , } impl IIfcRoot for IfcStructuralCurveMemberVarying { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralCurveMemberVarying { } impl IIfcObject for IfcStructuralCurveMemberVarying { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralCurveMemberVarying { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralCurveMemberVarying { } impl IIfcStructuralMember for IfcStructuralCurveMemberVarying { } impl IIfcStructuralCurveMember for IfcStructuralCurveMemberVarying { fn predefined_type (& self) -> & IfcStructuralCurveMemberTypeEnum { & self . predefined_type } fn axis (& self) -> & EntityRef < IfcDirection > { & self . axis } } impl IIfcStructuralCurveMemberVarying for IfcStructuralCurveMemberVarying { } impl IfcStructuralCurveMemberVarying { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralCurveMemberVarying :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . predefined_type = parameter . into () , 8usize => entity . axis = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralCurveReaction : IIfcStructuralReaction { pub fn predefined_type (& self) -> & IfcStructuralCurveActivityTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStructuralCurveReaction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , predefined_type : IfcStructuralCurveActivityTypeEnum , } impl IIfcRoot for IfcStructuralCurveReaction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralCurveReaction { } impl IIfcObject for IfcStructuralCurveReaction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralCurveReaction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralCurveReaction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralReaction for IfcStructuralCurveReaction { } impl IIfcStructuralCurveReaction for IfcStructuralCurveReaction { fn predefined_type (& self) -> & IfcStructuralCurveActivityTypeEnum { & self . predefined_type } } impl IfcStructuralCurveReaction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralCurveReaction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralItem : IIfcProduct { } pub trait IIfcStructuralLinearAction : IIfcStructuralCurveAction { } # [derive (Default , Debug)] pub struct IfcStructuralLinearAction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , destabilizing_load : Option < IfcBoolean > , projected_or_true : Option < IfcProjectedOrTrueLengthEnum > , predefined_type : IfcStructuralCurveActivityTypeEnum , } impl IIfcRoot for IfcStructuralLinearAction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralLinearAction { } impl IIfcObject for IfcStructuralLinearAction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralLinearAction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralLinearAction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralAction for IfcStructuralLinearAction { fn destabilizing_load (& self) -> & Option < IfcBoolean > { & self . destabilizing_load } } impl IIfcStructuralCurveAction for IfcStructuralLinearAction { fn projected_or_true (& self) -> & Option < IfcProjectedOrTrueLengthEnum > { & self . projected_or_true } fn predefined_type (& self) -> & IfcStructuralCurveActivityTypeEnum { & self . predefined_type } } impl IIfcStructuralLinearAction for IfcStructuralLinearAction { } impl IfcStructuralLinearAction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLinearAction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . destabilizing_load = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . projected_or_true = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralLoad : { pub fn name (& self) -> & Option < IfcLabel > ; } pub trait IIfcStructuralLoadCase : IIfcStructuralLoadGroup { pub fn self_weight_coefficients (& self) -> & Option < Vec < IfcRatioMeasure > > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , predefined_type : IfcLoadGroupTypeEnum , action_type : IfcActionTypeEnum , action_source : IfcActionSourceTypeEnum , coefficient : Option < IfcRatioMeasure > , purpose : Option < IfcLabel > , self_weight_coefficients : Option < Vec < IfcRatioMeasure > > , } impl IIfcRoot for IfcStructuralLoadCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralLoadCase { } impl IIfcObject for IfcStructuralLoadCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcStructuralLoadCase { } impl IIfcStructuralLoadGroup for IfcStructuralLoadCase { fn predefined_type (& self) -> & IfcLoadGroupTypeEnum { & self . predefined_type } fn action_type (& self) -> & IfcActionTypeEnum { & self . action_type } fn action_source (& self) -> & IfcActionSourceTypeEnum { & self . action_source } fn coefficient (& self) -> & Option < IfcRatioMeasure > { & self . coefficient } fn purpose (& self) -> & Option < IfcLabel > { & self . purpose } } impl IIfcStructuralLoadCase for IfcStructuralLoadCase { fn self_weight_coefficients (& self) -> & Option < Vec < IfcRatioMeasure > > { & self . self_weight_coefficients } } impl IfcStructuralLoadCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . predefined_type = parameter . into () , 6usize => entity . action_type = parameter . into () , 7usize => entity . action_source = parameter . into () , 8usize => entity . coefficient = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . self_weight_coefficients = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadConfiguration : IIfcStructuralLoad { pub fn values (& self) -> & Vec < EntityRef < IfcStructuralLoadOrResult > > ; pub fn locations (& self) -> & Option < Vec < Vec < IfcLengthMeasure > > > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadConfiguration { name : Option < IfcLabel > , values : Vec < EntityRef < IfcStructuralLoadOrResult > > , locations : Option < Vec < Vec < IfcLengthMeasure > > > , } impl IIfcStructuralLoad for IfcStructuralLoadConfiguration { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadConfiguration for IfcStructuralLoadConfiguration { fn values (& self) -> & Vec < EntityRef < IfcStructuralLoadOrResult > > { & self . values } fn locations (& self) -> & Option < Vec < Vec < IfcLengthMeasure > > > { & self . locations } } impl IfcStructuralLoadConfiguration { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadConfiguration :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . values = parameter . into () , 2usize => entity . locations = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadGroup : IIfcGroup { pub fn predefined_type (& self) -> & IfcLoadGroupTypeEnum ; pub fn action_type (& self) -> & IfcActionTypeEnum ; pub fn action_source (& self) -> & IfcActionSourceTypeEnum ; pub fn coefficient (& self) -> & Option < IfcRatioMeasure > ; pub fn purpose (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadGroup { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , predefined_type : IfcLoadGroupTypeEnum , action_type : IfcActionTypeEnum , action_source : IfcActionSourceTypeEnum , coefficient : Option < IfcRatioMeasure > , purpose : Option < IfcLabel > , } impl IIfcRoot for IfcStructuralLoadGroup { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralLoadGroup { } impl IIfcObject for IfcStructuralLoadGroup { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcStructuralLoadGroup { } impl IIfcStructuralLoadGroup for IfcStructuralLoadGroup { fn predefined_type (& self) -> & IfcLoadGroupTypeEnum { & self . predefined_type } fn action_type (& self) -> & IfcActionTypeEnum { & self . action_type } fn action_source (& self) -> & IfcActionSourceTypeEnum { & self . action_source } fn coefficient (& self) -> & Option < IfcRatioMeasure > { & self . coefficient } fn purpose (& self) -> & Option < IfcLabel > { & self . purpose } } impl IfcStructuralLoadGroup { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadGroup :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . predefined_type = parameter . into () , 6usize => entity . action_type = parameter . into () , 7usize => entity . action_source = parameter . into () , 8usize => entity . coefficient = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadLinearForce : IIfcStructuralLoadStatic { pub fn linear_force_x (& self) -> & Option < IfcLinearForceMeasure > ; pub fn linear_force_y (& self) -> & Option < IfcLinearForceMeasure > ; pub fn linear_force_z (& self) -> & Option < IfcLinearForceMeasure > ; pub fn linear_moment_x (& self) -> & Option < IfcLinearMomentMeasure > ; pub fn linear_moment_y (& self) -> & Option < IfcLinearMomentMeasure > ; pub fn linear_moment_z (& self) -> & Option < IfcLinearMomentMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadLinearForce { name : Option < IfcLabel > , linear_force_x : Option < IfcLinearForceMeasure > , linear_force_y : Option < IfcLinearForceMeasure > , linear_force_z : Option < IfcLinearForceMeasure > , linear_moment_x : Option < IfcLinearMomentMeasure > , linear_moment_y : Option < IfcLinearMomentMeasure > , linear_moment_z : Option < IfcLinearMomentMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadLinearForce { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadLinearForce { } impl IIfcStructuralLoadStatic for IfcStructuralLoadLinearForce { } impl IIfcStructuralLoadLinearForce for IfcStructuralLoadLinearForce { fn linear_force_x (& self) -> & Option < IfcLinearForceMeasure > { & self . linear_force_x } fn linear_force_y (& self) -> & Option < IfcLinearForceMeasure > { & self . linear_force_y } fn linear_force_z (& self) -> & Option < IfcLinearForceMeasure > { & self . linear_force_z } fn linear_moment_x (& self) -> & Option < IfcLinearMomentMeasure > { & self . linear_moment_x } fn linear_moment_y (& self) -> & Option < IfcLinearMomentMeasure > { & self . linear_moment_y } fn linear_moment_z (& self) -> & Option < IfcLinearMomentMeasure > { & self . linear_moment_z } } impl IfcStructuralLoadLinearForce { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadLinearForce :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . linear_force_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . linear_force_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . linear_force_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . linear_moment_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . linear_moment_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . linear_moment_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadOrResult : IIfcStructuralLoad { } pub trait IIfcStructuralLoadPlanarForce : IIfcStructuralLoadStatic { pub fn planar_force_x (& self) -> & Option < IfcPlanarForceMeasure > ; pub fn planar_force_y (& self) -> & Option < IfcPlanarForceMeasure > ; pub fn planar_force_z (& self) -> & Option < IfcPlanarForceMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadPlanarForce { name : Option < IfcLabel > , planar_force_x : Option < IfcPlanarForceMeasure > , planar_force_y : Option < IfcPlanarForceMeasure > , planar_force_z : Option < IfcPlanarForceMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadPlanarForce { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadPlanarForce { } impl IIfcStructuralLoadStatic for IfcStructuralLoadPlanarForce { } impl IIfcStructuralLoadPlanarForce for IfcStructuralLoadPlanarForce { fn planar_force_x (& self) -> & Option < IfcPlanarForceMeasure > { & self . planar_force_x } fn planar_force_y (& self) -> & Option < IfcPlanarForceMeasure > { & self . planar_force_y } fn planar_force_z (& self) -> & Option < IfcPlanarForceMeasure > { & self . planar_force_z } } impl IfcStructuralLoadPlanarForce { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadPlanarForce :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . planar_force_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . planar_force_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . planar_force_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadSingleDisplacement : IIfcStructuralLoadStatic { pub fn displacement_x (& self) -> & Option < IfcLengthMeasure > ; pub fn displacement_y (& self) -> & Option < IfcLengthMeasure > ; pub fn displacement_z (& self) -> & Option < IfcLengthMeasure > ; pub fn rotational_displacement_rx (& self) -> & Option < IfcPlaneAngleMeasure > ; pub fn rotational_displacement_ry (& self) -> & Option < IfcPlaneAngleMeasure > ; pub fn rotational_displacement_rz (& self) -> & Option < IfcPlaneAngleMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadSingleDisplacement { name : Option < IfcLabel > , displacement_x : Option < IfcLengthMeasure > , displacement_y : Option < IfcLengthMeasure > , displacement_z : Option < IfcLengthMeasure > , rotational_displacement_rx : Option < IfcPlaneAngleMeasure > , rotational_displacement_ry : Option < IfcPlaneAngleMeasure > , rotational_displacement_rz : Option < IfcPlaneAngleMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadSingleDisplacement { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleDisplacement { } impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleDisplacement { } impl IIfcStructuralLoadSingleDisplacement for IfcStructuralLoadSingleDisplacement { fn displacement_x (& self) -> & Option < IfcLengthMeasure > { & self . displacement_x } fn displacement_y (& self) -> & Option < IfcLengthMeasure > { & self . displacement_y } fn displacement_z (& self) -> & Option < IfcLengthMeasure > { & self . displacement_z } fn rotational_displacement_rx (& self) -> & Option < IfcPlaneAngleMeasure > { & self . rotational_displacement_rx } fn rotational_displacement_ry (& self) -> & Option < IfcPlaneAngleMeasure > { & self . rotational_displacement_ry } fn rotational_displacement_rz (& self) -> & Option < IfcPlaneAngleMeasure > { & self . rotational_displacement_rz } } impl IfcStructuralLoadSingleDisplacement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadSingleDisplacement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . displacement_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . displacement_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . displacement_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . rotational_displacement_rx = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . rotational_displacement_ry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . rotational_displacement_rz = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadSingleDisplacementDistortion : IIfcStructuralLoadSingleDisplacement { pub fn distortion (& self) -> & Option < IfcCurvatureMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadSingleDisplacementDistortion { name : Option < IfcLabel > , displacement_x : Option < IfcLengthMeasure > , displacement_y : Option < IfcLengthMeasure > , displacement_z : Option < IfcLengthMeasure > , rotational_displacement_rx : Option < IfcPlaneAngleMeasure > , rotational_displacement_ry : Option < IfcPlaneAngleMeasure > , rotational_displacement_rz : Option < IfcPlaneAngleMeasure > , distortion : Option < IfcCurvatureMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadSingleDisplacementDistortion { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleDisplacementDistortion { } impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleDisplacementDistortion { } impl IIfcStructuralLoadSingleDisplacement for IfcStructuralLoadSingleDisplacementDistortion { fn displacement_x (& self) -> & Option < IfcLengthMeasure > { & self . displacement_x } fn displacement_y (& self) -> & Option < IfcLengthMeasure > { & self . displacement_y } fn displacement_z (& self) -> & Option < IfcLengthMeasure > { & self . displacement_z } fn rotational_displacement_rx (& self) -> & Option < IfcPlaneAngleMeasure > { & self . rotational_displacement_rx } fn rotational_displacement_ry (& self) -> & Option < IfcPlaneAngleMeasure > { & self . rotational_displacement_ry } fn rotational_displacement_rz (& self) -> & Option < IfcPlaneAngleMeasure > { & self . rotational_displacement_rz } } impl IIfcStructuralLoadSingleDisplacementDistortion for IfcStructuralLoadSingleDisplacementDistortion { fn distortion (& self) -> & Option < IfcCurvatureMeasure > { & self . distortion } } impl IfcStructuralLoadSingleDisplacementDistortion { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadSingleDisplacementDistortion :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . displacement_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . displacement_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . displacement_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . rotational_displacement_rx = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . rotational_displacement_ry = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . rotational_displacement_rz = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . distortion = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadSingleForce : IIfcStructuralLoadStatic { pub fn force_x (& self) -> & Option < IfcForceMeasure > ; pub fn force_y (& self) -> & Option < IfcForceMeasure > ; pub fn force_z (& self) -> & Option < IfcForceMeasure > ; pub fn moment_x (& self) -> & Option < IfcTorqueMeasure > ; pub fn moment_y (& self) -> & Option < IfcTorqueMeasure > ; pub fn moment_z (& self) -> & Option < IfcTorqueMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadSingleForce { name : Option < IfcLabel > , force_x : Option < IfcForceMeasure > , force_y : Option < IfcForceMeasure > , force_z : Option < IfcForceMeasure > , moment_x : Option < IfcTorqueMeasure > , moment_y : Option < IfcTorqueMeasure > , moment_z : Option < IfcTorqueMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadSingleForce { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleForce { } impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleForce { } impl IIfcStructuralLoadSingleForce for IfcStructuralLoadSingleForce { fn force_x (& self) -> & Option < IfcForceMeasure > { & self . force_x } fn force_y (& self) -> & Option < IfcForceMeasure > { & self . force_y } fn force_z (& self) -> & Option < IfcForceMeasure > { & self . force_z } fn moment_x (& self) -> & Option < IfcTorqueMeasure > { & self . moment_x } fn moment_y (& self) -> & Option < IfcTorqueMeasure > { & self . moment_y } fn moment_z (& self) -> & Option < IfcTorqueMeasure > { & self . moment_z } } impl IfcStructuralLoadSingleForce { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadSingleForce :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . force_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . force_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . force_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . moment_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . moment_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . moment_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadSingleForceWarping : IIfcStructuralLoadSingleForce { pub fn warping_moment (& self) -> & Option < IfcWarpingMomentMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadSingleForceWarping { name : Option < IfcLabel > , force_x : Option < IfcForceMeasure > , force_y : Option < IfcForceMeasure > , force_z : Option < IfcForceMeasure > , moment_x : Option < IfcTorqueMeasure > , moment_y : Option < IfcTorqueMeasure > , moment_z : Option < IfcTorqueMeasure > , warping_moment : Option < IfcWarpingMomentMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadSingleForceWarping { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadSingleForceWarping { } impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleForceWarping { } impl IIfcStructuralLoadSingleForce for IfcStructuralLoadSingleForceWarping { fn force_x (& self) -> & Option < IfcForceMeasure > { & self . force_x } fn force_y (& self) -> & Option < IfcForceMeasure > { & self . force_y } fn force_z (& self) -> & Option < IfcForceMeasure > { & self . force_z } fn moment_x (& self) -> & Option < IfcTorqueMeasure > { & self . moment_x } fn moment_y (& self) -> & Option < IfcTorqueMeasure > { & self . moment_y } fn moment_z (& self) -> & Option < IfcTorqueMeasure > { & self . moment_z } } impl IIfcStructuralLoadSingleForceWarping for IfcStructuralLoadSingleForceWarping { fn warping_moment (& self) -> & Option < IfcWarpingMomentMeasure > { & self . warping_moment } } impl IfcStructuralLoadSingleForceWarping { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadSingleForceWarping :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . force_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . force_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . force_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . moment_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . moment_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . moment_z = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . warping_moment = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralLoadStatic : IIfcStructuralLoadOrResult { } pub trait IIfcStructuralLoadTemperature : IIfcStructuralLoadStatic { pub fn delta_t_constant (& self) -> & Option < IfcThermodynamicTemperatureMeasure > ; pub fn delta_ty (& self) -> & Option < IfcThermodynamicTemperatureMeasure > ; pub fn delta_tz (& self) -> & Option < IfcThermodynamicTemperatureMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralLoadTemperature { name : Option < IfcLabel > , delta_t_constant : Option < IfcThermodynamicTemperatureMeasure > , delta_ty : Option < IfcThermodynamicTemperatureMeasure > , delta_tz : Option < IfcThermodynamicTemperatureMeasure > , } impl IIfcStructuralLoad for IfcStructuralLoadTemperature { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcStructuralLoadTemperature { } impl IIfcStructuralLoadStatic for IfcStructuralLoadTemperature { } impl IIfcStructuralLoadTemperature for IfcStructuralLoadTemperature { fn delta_t_constant (& self) -> & Option < IfcThermodynamicTemperatureMeasure > { & self . delta_t_constant } fn delta_ty (& self) -> & Option < IfcThermodynamicTemperatureMeasure > { & self . delta_ty } fn delta_tz (& self) -> & Option < IfcThermodynamicTemperatureMeasure > { & self . delta_tz } } impl IfcStructuralLoadTemperature { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralLoadTemperature :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . delta_t_constant = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . delta_ty = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . delta_tz = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralMember : IIfcStructuralItem { } pub trait IIfcStructuralPlanarAction : IIfcStructuralSurfaceAction { } # [derive (Default , Debug)] pub struct IfcStructuralPlanarAction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , destabilizing_load : Option < IfcBoolean > , projected_or_true : Option < IfcProjectedOrTrueLengthEnum > , predefined_type : IfcStructuralSurfaceActivityTypeEnum , } impl IIfcRoot for IfcStructuralPlanarAction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralPlanarAction { } impl IIfcObject for IfcStructuralPlanarAction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralPlanarAction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralPlanarAction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralAction for IfcStructuralPlanarAction { fn destabilizing_load (& self) -> & Option < IfcBoolean > { & self . destabilizing_load } } impl IIfcStructuralSurfaceAction for IfcStructuralPlanarAction { fn projected_or_true (& self) -> & Option < IfcProjectedOrTrueLengthEnum > { & self . projected_or_true } fn predefined_type (& self) -> & IfcStructuralSurfaceActivityTypeEnum { & self . predefined_type } } impl IIfcStructuralPlanarAction for IfcStructuralPlanarAction { } impl IfcStructuralPlanarAction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralPlanarAction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . destabilizing_load = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . projected_or_true = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralPointAction : IIfcStructuralAction { } # [derive (Default , Debug)] pub struct IfcStructuralPointAction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , destabilizing_load : Option < IfcBoolean > , } impl IIfcRoot for IfcStructuralPointAction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralPointAction { } impl IIfcObject for IfcStructuralPointAction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralPointAction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralPointAction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralAction for IfcStructuralPointAction { fn destabilizing_load (& self) -> & Option < IfcBoolean > { & self . destabilizing_load } } impl IIfcStructuralPointAction for IfcStructuralPointAction { } impl IfcStructuralPointAction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralPointAction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . destabilizing_load = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralPointConnection : IIfcStructuralConnection { pub fn condition_coordinate_system (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > ; } # [derive (Default , Debug)] pub struct IfcStructuralPointConnection { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_condition : Option < EntityRef < IfcBoundaryCondition > > , condition_coordinate_system : Option < EntityRef < IfcAxis2Placement3D > > , } impl IIfcRoot for IfcStructuralPointConnection { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralPointConnection { } impl IIfcObject for IfcStructuralPointConnection { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralPointConnection { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralPointConnection { } impl IIfcStructuralConnection for IfcStructuralPointConnection { fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > { & self . applied_condition } } impl IIfcStructuralPointConnection for IfcStructuralPointConnection { fn condition_coordinate_system (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . condition_coordinate_system } } impl IfcStructuralPointConnection { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralPointConnection :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . condition_coordinate_system = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralPointReaction : IIfcStructuralReaction { } # [derive (Default , Debug)] pub struct IfcStructuralPointReaction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , } impl IIfcRoot for IfcStructuralPointReaction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralPointReaction { } impl IIfcObject for IfcStructuralPointReaction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralPointReaction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralPointReaction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralReaction for IfcStructuralPointReaction { } impl IIfcStructuralPointReaction for IfcStructuralPointReaction { } impl IfcStructuralPointReaction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralPointReaction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralReaction : IIfcStructuralActivity { } pub trait IIfcStructuralResultGroup : IIfcGroup { pub fn theory_type (& self) -> & IfcAnalysisTheoryTypeEnum ; pub fn result_for_load_group (& self) -> & Option < EntityRef < IfcStructuralLoadGroup > > ; pub fn is_linear (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcStructuralResultGroup { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , theory_type : IfcAnalysisTheoryTypeEnum , result_for_load_group : Option < EntityRef < IfcStructuralLoadGroup > > , is_linear : IfcBoolean , } impl IIfcRoot for IfcStructuralResultGroup { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralResultGroup { } impl IIfcObject for IfcStructuralResultGroup { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcStructuralResultGroup { } impl IIfcStructuralResultGroup for IfcStructuralResultGroup { fn theory_type (& self) -> & IfcAnalysisTheoryTypeEnum { & self . theory_type } fn result_for_load_group (& self) -> & Option < EntityRef < IfcStructuralLoadGroup > > { & self . result_for_load_group } fn is_linear (& self) -> & IfcBoolean { & self . is_linear } } impl IfcStructuralResultGroup { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralResultGroup :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . theory_type = parameter . into () , 6usize => entity . result_for_load_group = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . is_linear = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralSurfaceAction : IIfcStructuralAction { pub fn projected_or_true (& self) -> & Option < IfcProjectedOrTrueLengthEnum > ; pub fn predefined_type (& self) -> & IfcStructuralSurfaceActivityTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStructuralSurfaceAction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , destabilizing_load : Option < IfcBoolean > , projected_or_true : Option < IfcProjectedOrTrueLengthEnum > , predefined_type : IfcStructuralSurfaceActivityTypeEnum , } impl IIfcRoot for IfcStructuralSurfaceAction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralSurfaceAction { } impl IIfcObject for IfcStructuralSurfaceAction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralSurfaceAction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralSurfaceAction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralAction for IfcStructuralSurfaceAction { fn destabilizing_load (& self) -> & Option < IfcBoolean > { & self . destabilizing_load } } impl IIfcStructuralSurfaceAction for IfcStructuralSurfaceAction { fn projected_or_true (& self) -> & Option < IfcProjectedOrTrueLengthEnum > { & self . projected_or_true } fn predefined_type (& self) -> & IfcStructuralSurfaceActivityTypeEnum { & self . predefined_type } } impl IfcStructuralSurfaceAction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralSurfaceAction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . destabilizing_load = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . projected_or_true = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStructuralSurfaceConnection : IIfcStructuralConnection { } # [derive (Default , Debug)] pub struct IfcStructuralSurfaceConnection { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_condition : Option < EntityRef < IfcBoundaryCondition > > , } impl IIfcRoot for IfcStructuralSurfaceConnection { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralSurfaceConnection { } impl IIfcObject for IfcStructuralSurfaceConnection { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralSurfaceConnection { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralSurfaceConnection { } impl IIfcStructuralConnection for IfcStructuralSurfaceConnection { fn applied_condition (& self) -> & Option < EntityRef < IfcBoundaryCondition > > { & self . applied_condition } } impl IIfcStructuralSurfaceConnection for IfcStructuralSurfaceConnection { } impl IfcStructuralSurfaceConnection { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralSurfaceConnection :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_condition = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralSurfaceMember : IIfcStructuralMember { pub fn predefined_type (& self) -> & IfcStructuralSurfaceMemberTypeEnum ; pub fn thickness (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcStructuralSurfaceMember { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , predefined_type : IfcStructuralSurfaceMemberTypeEnum , thickness : Option < IfcPositiveLengthMeasure > , } impl IIfcRoot for IfcStructuralSurfaceMember { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralSurfaceMember { } impl IIfcObject for IfcStructuralSurfaceMember { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralSurfaceMember { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralSurfaceMember { } impl IIfcStructuralMember for IfcStructuralSurfaceMember { } impl IIfcStructuralSurfaceMember for IfcStructuralSurfaceMember { fn predefined_type (& self) -> & IfcStructuralSurfaceMemberTypeEnum { & self . predefined_type } fn thickness (& self) -> & Option < IfcPositiveLengthMeasure > { & self . thickness } } impl IfcStructuralSurfaceMember { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralSurfaceMember :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . predefined_type = parameter . into () , 8usize => entity . thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralSurfaceMemberVarying : IIfcStructuralSurfaceMember { } # [derive (Default , Debug)] pub struct IfcStructuralSurfaceMemberVarying { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , predefined_type : IfcStructuralSurfaceMemberTypeEnum , thickness : Option < IfcPositiveLengthMeasure > , } impl IIfcRoot for IfcStructuralSurfaceMemberVarying { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralSurfaceMemberVarying { } impl IIfcObject for IfcStructuralSurfaceMemberVarying { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralSurfaceMemberVarying { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralItem for IfcStructuralSurfaceMemberVarying { } impl IIfcStructuralMember for IfcStructuralSurfaceMemberVarying { } impl IIfcStructuralSurfaceMember for IfcStructuralSurfaceMemberVarying { fn predefined_type (& self) -> & IfcStructuralSurfaceMemberTypeEnum { & self . predefined_type } fn thickness (& self) -> & Option < IfcPositiveLengthMeasure > { & self . thickness } } impl IIfcStructuralSurfaceMemberVarying for IfcStructuralSurfaceMemberVarying { } impl IfcStructuralSurfaceMemberVarying { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralSurfaceMemberVarying :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . predefined_type = parameter . into () , 8usize => entity . thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStructuralSurfaceReaction : IIfcStructuralReaction { pub fn predefined_type (& self) -> & IfcStructuralSurfaceActivityTypeEnum ; } # [derive (Default , Debug)] pub struct IfcStructuralSurfaceReaction { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , applied_load : EntityRef < IfcStructuralLoad > , global_or_local : IfcGlobalOrLocalEnum , predefined_type : IfcStructuralSurfaceActivityTypeEnum , } impl IIfcRoot for IfcStructuralSurfaceReaction { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcStructuralSurfaceReaction { } impl IIfcObject for IfcStructuralSurfaceReaction { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcStructuralSurfaceReaction { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcStructuralActivity for IfcStructuralSurfaceReaction { fn applied_load (& self) -> & EntityRef < IfcStructuralLoad > { & self . applied_load } fn global_or_local (& self) -> & IfcGlobalOrLocalEnum { & self . global_or_local } } impl IIfcStructuralReaction for IfcStructuralSurfaceReaction { } impl IIfcStructuralSurfaceReaction for IfcStructuralSurfaceReaction { fn predefined_type (& self) -> & IfcStructuralSurfaceActivityTypeEnum { & self . predefined_type } } impl IfcStructuralSurfaceReaction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStructuralSurfaceReaction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . applied_load = parameter . into () , 8usize => entity . global_or_local = parameter . into () , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcStyleModel : IIfcRepresentation { } pub trait IIfcStyledItem : IIfcRepresentationItem { pub fn item (& self) -> & Option < EntityRef < IfcRepresentationItem > > ; pub fn styles (& self) -> & HashSet < EntityRef < IfcStyleAssignmentSelect > > ; pub fn name (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcStyledItem { item : Option < EntityRef < IfcRepresentationItem > > , styles : HashSet < EntityRef < IfcStyleAssignmentSelect > > , name : Option < IfcLabel > , } impl IIfcRepresentationItem for IfcStyledItem { } impl IIfcStyledItem for IfcStyledItem { fn item (& self) -> & Option < EntityRef < IfcRepresentationItem > > { & self . item } fn styles (& self) -> & HashSet < EntityRef < IfcStyleAssignmentSelect > > { & self . styles } fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IfcStyledItem { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStyledItem :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . item = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . styles = parameter . into () , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcStyledRepresentation : IIfcStyleModel { } # [derive (Default , Debug)] pub struct IfcStyledRepresentation { context_of_items : EntityRef < IfcRepresentationContext > , representation_identifier : Option < IfcLabel > , representation_type : Option < IfcLabel > , items : HashSet < EntityRef < IfcRepresentationItem > > , } impl IIfcRepresentation for IfcStyledRepresentation { fn context_of_items (& self) -> & EntityRef < IfcRepresentationContext > { & self . context_of_items } fn representation_identifier (& self) -> & Option < IfcLabel > { & self . representation_identifier } fn representation_type (& self) -> & Option < IfcLabel > { & self . representation_type } fn items (& self) -> & HashSet < EntityRef < IfcRepresentationItem > > { & self . items } } impl IIfcStyleModel for IfcStyledRepresentation { } impl IIfcStyledRepresentation for IfcStyledRepresentation { } impl IfcStyledRepresentation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcStyledRepresentation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . context_of_items = parameter . into () , 1usize => entity . representation_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . representation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . items = parameter . into () , _ => { } } } entity } } pub trait IIfcSubContractResource : IIfcConstructionResource { pub fn predefined_type (& self) -> & Option < IfcSubContractResourceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSubContractResource { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , usage : Option < EntityRef < IfcResourceTime > > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : Option < IfcSubContractResourceTypeEnum > , } impl IIfcRoot for IfcSubContractResource { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSubContractResource { } impl IIfcObject for IfcSubContractResource { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcResource for IfcSubContractResource { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcConstructionResource for IfcSubContractResource { fn usage (& self) -> & Option < EntityRef < IfcResourceTime > > { & self . usage } fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcSubContractResource for IfcSubContractResource { fn predefined_type (& self) -> & Option < IfcSubContractResourceTypeEnum > { & self . predefined_type } } impl IfcSubContractResource { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSubContractResource :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . usage = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSubContractResourceType : IIfcConstructionResourceType { pub fn predefined_type (& self) -> & IfcSubContractResourceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSubContractResourceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , resource_type : Option < IfcLabel > , base_costs : Option < Vec < EntityRef < IfcAppliedValue > > > , base_quantity : Option < EntityRef < IfcPhysicalQuantity > > , predefined_type : IfcSubContractResourceTypeEnum , } impl IIfcRoot for IfcSubContractResourceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSubContractResourceType { } impl IIfcTypeObject for IfcSubContractResourceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeResource for IfcSubContractResourceType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn resource_type (& self) -> & Option < IfcLabel > { & self . resource_type } } impl IIfcConstructionResourceType for IfcSubContractResourceType { fn base_costs (& self) -> & Option < Vec < EntityRef < IfcAppliedValue > > > { & self . base_costs } fn base_quantity (& self) -> & Option < EntityRef < IfcPhysicalQuantity > > { & self . base_quantity } } impl IIfcSubContractResourceType for IfcSubContractResourceType { fn predefined_type (& self) -> & IfcSubContractResourceTypeEnum { & self . predefined_type } } impl IfcSubContractResourceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSubContractResourceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . resource_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . base_costs = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . base_quantity = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcSubedge : IIfcEdge { pub fn parent_edge (& self) -> & EntityRef < IfcEdge > ; } # [derive (Default , Debug)] pub struct IfcSubedge { edge_start : EntityRef < IfcVertex > , edge_end : EntityRef < IfcVertex > , parent_edge : EntityRef < IfcEdge > , } impl IIfcRepresentationItem for IfcSubedge { } impl IIfcTopologicalRepresentationItem for IfcSubedge { } impl IIfcEdge for IfcSubedge { fn edge_start (& self) -> & EntityRef < IfcVertex > { & self . edge_start } fn edge_end (& self) -> & EntityRef < IfcVertex > { & self . edge_end } } impl IIfcSubedge for IfcSubedge { fn parent_edge (& self) -> & EntityRef < IfcEdge > { & self . parent_edge } } impl IfcSubedge { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSubedge :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . edge_start = parameter . into () , 1usize => entity . edge_end = parameter . into () , 2usize => entity . parent_edge = parameter . into () , _ => { } } } entity } } pub trait IIfcSurface : IIfcGeometricRepresentationItem { } pub trait IIfcSurfaceCurve : IIfcCurve { pub fn curve3_d (& self) -> & EntityRef < IfcCurve > ; pub fn associated_geometry (& self) -> & Vec < EntityRef < IfcPcurve > > ; pub fn master_representation (& self) -> & IfcPreferredSurfaceCurveRepresentation ; } # [derive (Default , Debug)] pub struct IfcSurfaceCurve { curve3_d : EntityRef < IfcCurve > , associated_geometry : Vec < EntityRef < IfcPcurve > > , master_representation : IfcPreferredSurfaceCurveRepresentation , } impl IIfcRepresentationItem for IfcSurfaceCurve { } impl IIfcGeometricRepresentationItem for IfcSurfaceCurve { } impl IIfcCurve for IfcSurfaceCurve { } impl IIfcSurfaceCurve for IfcSurfaceCurve { fn curve3_d (& self) -> & EntityRef < IfcCurve > { & self . curve3_d } fn associated_geometry (& self) -> & Vec < EntityRef < IfcPcurve > > { & self . associated_geometry } fn master_representation (& self) -> & IfcPreferredSurfaceCurveRepresentation { & self . master_representation } } impl IfcSurfaceCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . curve3_d = parameter . into () , 1usize => entity . associated_geometry = parameter . into () , 2usize => entity . master_representation = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceCurveSweptAreaSolid : IIfcSweptAreaSolid { pub fn directrix (& self) -> & EntityRef < IfcCurve > ; pub fn start_param (& self) -> & Option < IfcParameterValue > ; pub fn end_param (& self) -> & Option < IfcParameterValue > ; pub fn reference_surface (& self) -> & EntityRef < IfcSurface > ; } # [derive (Default , Debug)] pub struct IfcSurfaceCurveSweptAreaSolid { swept_area : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , directrix : EntityRef < IfcCurve > , start_param : Option < IfcParameterValue > , end_param : Option < IfcParameterValue > , reference_surface : EntityRef < IfcSurface > , } impl IIfcRepresentationItem for IfcSurfaceCurveSweptAreaSolid { } impl IIfcGeometricRepresentationItem for IfcSurfaceCurveSweptAreaSolid { } impl IIfcSolidModel for IfcSurfaceCurveSweptAreaSolid { } impl IIfcSweptAreaSolid for IfcSurfaceCurveSweptAreaSolid { fn swept_area (& self) -> & EntityRef < IfcProfileDef > { & self . swept_area } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcSurfaceCurveSweptAreaSolid for IfcSurfaceCurveSweptAreaSolid { fn directrix (& self) -> & EntityRef < IfcCurve > { & self . directrix } fn start_param (& self) -> & Option < IfcParameterValue > { & self . start_param } fn end_param (& self) -> & Option < IfcParameterValue > { & self . end_param } fn reference_surface (& self) -> & EntityRef < IfcSurface > { & self . reference_surface } } impl IfcSurfaceCurveSweptAreaSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceCurveSweptAreaSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_area = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . directrix = parameter . into () , 3usize => entity . start_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . end_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . reference_surface = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceFeature : IIfcFeatureElement { pub fn predefined_type (& self) -> & Option < IfcSurfaceFeatureTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSurfaceFeature { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSurfaceFeatureTypeEnum > , } impl IIfcRoot for IfcSurfaceFeature { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSurfaceFeature { } impl IIfcObject for IfcSurfaceFeature { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSurfaceFeature { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSurfaceFeature { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFeatureElement for IfcSurfaceFeature { } impl IIfcSurfaceFeature for IfcSurfaceFeature { fn predefined_type (& self) -> & Option < IfcSurfaceFeatureTypeEnum > { & self . predefined_type } } impl IfcSurfaceFeature { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceFeature :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSurfaceOfLinearExtrusion : IIfcSweptSurface { pub fn extruded_direction (& self) -> & EntityRef < IfcDirection > ; pub fn depth (& self) -> & IfcLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcSurfaceOfLinearExtrusion { swept_curve : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , extruded_direction : EntityRef < IfcDirection > , depth : IfcLengthMeasure , } impl IIfcRepresentationItem for IfcSurfaceOfLinearExtrusion { } impl IIfcGeometricRepresentationItem for IfcSurfaceOfLinearExtrusion { } impl IIfcSurface for IfcSurfaceOfLinearExtrusion { } impl IIfcSweptSurface for IfcSurfaceOfLinearExtrusion { fn swept_curve (& self) -> & EntityRef < IfcProfileDef > { & self . swept_curve } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcSurfaceOfLinearExtrusion for IfcSurfaceOfLinearExtrusion { fn extruded_direction (& self) -> & EntityRef < IfcDirection > { & self . extruded_direction } fn depth (& self) -> & IfcLengthMeasure { & self . depth } } impl IfcSurfaceOfLinearExtrusion { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceOfLinearExtrusion :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_curve = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . extruded_direction = parameter . into () , 3usize => entity . depth = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceOfRevolution : IIfcSweptSurface { pub fn axis_position (& self) -> & EntityRef < IfcAxis1Placement > ; } # [derive (Default , Debug)] pub struct IfcSurfaceOfRevolution { swept_curve : EntityRef < IfcProfileDef > , position : Option < EntityRef < IfcAxis2Placement3D > > , axis_position : EntityRef < IfcAxis1Placement > , } impl IIfcRepresentationItem for IfcSurfaceOfRevolution { } impl IIfcGeometricRepresentationItem for IfcSurfaceOfRevolution { } impl IIfcSurface for IfcSurfaceOfRevolution { } impl IIfcSweptSurface for IfcSurfaceOfRevolution { fn swept_curve (& self) -> & EntityRef < IfcProfileDef > { & self . swept_curve } fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > { & self . position } } impl IIfcSurfaceOfRevolution for IfcSurfaceOfRevolution { fn axis_position (& self) -> & EntityRef < IfcAxis1Placement > { & self . axis_position } } impl IfcSurfaceOfRevolution { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceOfRevolution :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . swept_curve = parameter . into () , 1usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . axis_position = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceReinforcementArea : IIfcStructuralLoadOrResult { pub fn surface_reinforcement1 (& self) -> & Option < Vec < IfcLengthMeasure > > ; pub fn surface_reinforcement2 (& self) -> & Option < Vec < IfcLengthMeasure > > ; pub fn shear_reinforcement (& self) -> & Option < IfcRatioMeasure > ; } # [derive (Default , Debug)] pub struct IfcSurfaceReinforcementArea { name : Option < IfcLabel > , surface_reinforcement1 : Option < Vec < IfcLengthMeasure > > , surface_reinforcement2 : Option < Vec < IfcLengthMeasure > > , shear_reinforcement : Option < IfcRatioMeasure > , } impl IIfcStructuralLoad for IfcSurfaceReinforcementArea { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcStructuralLoadOrResult for IfcSurfaceReinforcementArea { } impl IIfcSurfaceReinforcementArea for IfcSurfaceReinforcementArea { fn surface_reinforcement1 (& self) -> & Option < Vec < IfcLengthMeasure > > { & self . surface_reinforcement1 } fn surface_reinforcement2 (& self) -> & Option < Vec < IfcLengthMeasure > > { & self . surface_reinforcement2 } fn shear_reinforcement (& self) -> & Option < IfcRatioMeasure > { & self . shear_reinforcement } } impl IfcSurfaceReinforcementArea { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceReinforcementArea :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . surface_reinforcement1 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . surface_reinforcement2 = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . shear_reinforcement = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSurfaceStyle : IIfcPresentationStyle { pub fn side (& self) -> & IfcSurfaceSide ; pub fn styles (& self) -> & HashSet < EntityRef < IfcSurfaceStyleElementSelect > > ; } # [derive (Default , Debug)] pub struct IfcSurfaceStyle { name : Option < IfcLabel > , side : IfcSurfaceSide , styles : HashSet < EntityRef < IfcSurfaceStyleElementSelect > > , } impl IIfcPresentationStyle for IfcSurfaceStyle { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcSurfaceStyle for IfcSurfaceStyle { fn side (& self) -> & IfcSurfaceSide { & self . side } fn styles (& self) -> & HashSet < EntityRef < IfcSurfaceStyleElementSelect > > { & self . styles } } impl IfcSurfaceStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . side = parameter . into () , 2usize => entity . styles = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceStyleLighting : IIfcPresentationItem { pub fn diffuse_transmission_colour (& self) -> & EntityRef < IfcColourRgb > ; pub fn diffuse_reflection_colour (& self) -> & EntityRef < IfcColourRgb > ; pub fn transmission_colour (& self) -> & EntityRef < IfcColourRgb > ; pub fn reflectance_colour (& self) -> & EntityRef < IfcColourRgb > ; } # [derive (Default , Debug)] pub struct IfcSurfaceStyleLighting { diffuse_transmission_colour : EntityRef < IfcColourRgb > , diffuse_reflection_colour : EntityRef < IfcColourRgb > , transmission_colour : EntityRef < IfcColourRgb > , reflectance_colour : EntityRef < IfcColourRgb > , } impl IIfcPresentationItem for IfcSurfaceStyleLighting { } impl IIfcSurfaceStyleLighting for IfcSurfaceStyleLighting { fn diffuse_transmission_colour (& self) -> & EntityRef < IfcColourRgb > { & self . diffuse_transmission_colour } fn diffuse_reflection_colour (& self) -> & EntityRef < IfcColourRgb > { & self . diffuse_reflection_colour } fn transmission_colour (& self) -> & EntityRef < IfcColourRgb > { & self . transmission_colour } fn reflectance_colour (& self) -> & EntityRef < IfcColourRgb > { & self . reflectance_colour } } impl IfcSurfaceStyleLighting { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceStyleLighting :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . diffuse_transmission_colour = parameter . into () , 1usize => entity . diffuse_reflection_colour = parameter . into () , 2usize => entity . transmission_colour = parameter . into () , 3usize => entity . reflectance_colour = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceStyleRefraction : IIfcPresentationItem { pub fn refraction_index (& self) -> & Option < IfcReal > ; pub fn dispersion_factor (& self) -> & Option < IfcReal > ; } # [derive (Default , Debug)] pub struct IfcSurfaceStyleRefraction { refraction_index : Option < IfcReal > , dispersion_factor : Option < IfcReal > , } impl IIfcPresentationItem for IfcSurfaceStyleRefraction { } impl IIfcSurfaceStyleRefraction for IfcSurfaceStyleRefraction { fn refraction_index (& self) -> & Option < IfcReal > { & self . refraction_index } fn dispersion_factor (& self) -> & Option < IfcReal > { & self . dispersion_factor } } impl IfcSurfaceStyleRefraction { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceStyleRefraction :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . refraction_index = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . dispersion_factor = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSurfaceStyleRendering : IIfcSurfaceStyleShading { pub fn diffuse_colour (& self) -> & Option < IfcColourOrFactor > ; pub fn transmission_colour (& self) -> & Option < IfcColourOrFactor > ; pub fn diffuse_transmission_colour (& self) -> & Option < IfcColourOrFactor > ; pub fn reflection_colour (& self) -> & Option < IfcColourOrFactor > ; pub fn specular_colour (& self) -> & Option < IfcColourOrFactor > ; pub fn specular_highlight (& self) -> & Option < IfcSpecularHighlightSelect > ; pub fn reflectance_method (& self) -> & IfcReflectanceMethodEnum ; } # [derive (Default , Debug)] pub struct IfcSurfaceStyleRendering { surface_colour : EntityRef < IfcColourRgb > , transparency : Option < IfcNormalisedRatioMeasure > , diffuse_colour : Option < IfcColourOrFactor > , transmission_colour : Option < IfcColourOrFactor > , diffuse_transmission_colour : Option < IfcColourOrFactor > , reflection_colour : Option < IfcColourOrFactor > , specular_colour : Option < IfcColourOrFactor > , specular_highlight : Option < IfcSpecularHighlightSelect > , reflectance_method : IfcReflectanceMethodEnum , } impl IIfcPresentationItem for IfcSurfaceStyleRendering { } impl IIfcSurfaceStyleShading for IfcSurfaceStyleRendering { fn surface_colour (& self) -> & EntityRef < IfcColourRgb > { & self . surface_colour } fn transparency (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . transparency } } impl IIfcSurfaceStyleRendering for IfcSurfaceStyleRendering { fn diffuse_colour (& self) -> & Option < IfcColourOrFactor > { & self . diffuse_colour } fn transmission_colour (& self) -> & Option < IfcColourOrFactor > { & self . transmission_colour } fn diffuse_transmission_colour (& self) -> & Option < IfcColourOrFactor > { & self . diffuse_transmission_colour } fn reflection_colour (& self) -> & Option < IfcColourOrFactor > { & self . reflection_colour } fn specular_colour (& self) -> & Option < IfcColourOrFactor > { & self . specular_colour } fn specular_highlight (& self) -> & Option < IfcSpecularHighlightSelect > { & self . specular_highlight } fn reflectance_method (& self) -> & IfcReflectanceMethodEnum { & self . reflectance_method } } impl IfcSurfaceStyleRendering { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceStyleRendering :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . surface_colour = parameter . into () , 1usize => entity . transparency = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . diffuse_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . transmission_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . diffuse_transmission_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . reflection_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . specular_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . specular_highlight = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . reflectance_method = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceStyleShading : IIfcPresentationItem { pub fn surface_colour (& self) -> & EntityRef < IfcColourRgb > ; pub fn transparency (& self) -> & Option < IfcNormalisedRatioMeasure > ; } # [derive (Default , Debug)] pub struct IfcSurfaceStyleShading { surface_colour : EntityRef < IfcColourRgb > , transparency : Option < IfcNormalisedRatioMeasure > , } impl IIfcPresentationItem for IfcSurfaceStyleShading { } impl IIfcSurfaceStyleShading for IfcSurfaceStyleShading { fn surface_colour (& self) -> & EntityRef < IfcColourRgb > { & self . surface_colour } fn transparency (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . transparency } } impl IfcSurfaceStyleShading { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceStyleShading :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . surface_colour = parameter . into () , 1usize => entity . transparency = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSurfaceStyleWithTextures : IIfcPresentationItem { pub fn textures (& self) -> & Vec < EntityRef < IfcSurfaceTexture > > ; } # [derive (Default , Debug)] pub struct IfcSurfaceStyleWithTextures { textures : Vec < EntityRef < IfcSurfaceTexture > > , } impl IIfcPresentationItem for IfcSurfaceStyleWithTextures { } impl IIfcSurfaceStyleWithTextures for IfcSurfaceStyleWithTextures { fn textures (& self) -> & Vec < EntityRef < IfcSurfaceTexture > > { & self . textures } } impl IfcSurfaceStyleWithTextures { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSurfaceStyleWithTextures :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . textures = parameter . into () , _ => { } } } entity } } pub trait IIfcSurfaceTexture : IIfcPresentationItem { pub fn repeat_s (& self) -> & IfcBoolean ; pub fn repeat_t (& self) -> & IfcBoolean ; pub fn mode (& self) -> & Option < IfcIdentifier > ; pub fn texture_transform (& self) -> & Option < EntityRef < IfcCartesianTransformationOperator2D > > ; pub fn parameter (& self) -> & Option < Vec < IfcIdentifier > > ; } pub trait IIfcSweptAreaSolid : IIfcSolidModel { pub fn swept_area (& self) -> & EntityRef < IfcProfileDef > ; pub fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > ; } pub trait IIfcSweptDiskSolid : IIfcSolidModel { pub fn directrix (& self) -> & EntityRef < IfcCurve > ; pub fn radius (& self) -> & IfcPositiveLengthMeasure ; pub fn inner_radius (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn start_param (& self) -> & Option < IfcParameterValue > ; pub fn end_param (& self) -> & Option < IfcParameterValue > ; } # [derive (Default , Debug)] pub struct IfcSweptDiskSolid { directrix : EntityRef < IfcCurve > , radius : IfcPositiveLengthMeasure , inner_radius : Option < IfcPositiveLengthMeasure > , start_param : Option < IfcParameterValue > , end_param : Option < IfcParameterValue > , } impl IIfcRepresentationItem for IfcSweptDiskSolid { } impl IIfcGeometricRepresentationItem for IfcSweptDiskSolid { } impl IIfcSolidModel for IfcSweptDiskSolid { } impl IIfcSweptDiskSolid for IfcSweptDiskSolid { fn directrix (& self) -> & EntityRef < IfcCurve > { & self . directrix } fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } fn inner_radius (& self) -> & Option < IfcPositiveLengthMeasure > { & self . inner_radius } fn start_param (& self) -> & Option < IfcParameterValue > { & self . start_param } fn end_param (& self) -> & Option < IfcParameterValue > { & self . end_param } } impl IfcSweptDiskSolid { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSweptDiskSolid :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . directrix = parameter . into () , 1usize => entity . radius = parameter . into () , 2usize => entity . inner_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . start_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . end_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSweptDiskSolidPolygonal : IIfcSweptDiskSolid { pub fn fillet_radius (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcSweptDiskSolidPolygonal { directrix : EntityRef < IfcCurve > , radius : IfcPositiveLengthMeasure , inner_radius : Option < IfcPositiveLengthMeasure > , start_param : Option < IfcParameterValue > , end_param : Option < IfcParameterValue > , fillet_radius : Option < IfcPositiveLengthMeasure > , } impl IIfcRepresentationItem for IfcSweptDiskSolidPolygonal { } impl IIfcGeometricRepresentationItem for IfcSweptDiskSolidPolygonal { } impl IIfcSolidModel for IfcSweptDiskSolidPolygonal { } impl IIfcSweptDiskSolid for IfcSweptDiskSolidPolygonal { fn directrix (& self) -> & EntityRef < IfcCurve > { & self . directrix } fn radius (& self) -> & IfcPositiveLengthMeasure { & self . radius } fn inner_radius (& self) -> & Option < IfcPositiveLengthMeasure > { & self . inner_radius } fn start_param (& self) -> & Option < IfcParameterValue > { & self . start_param } fn end_param (& self) -> & Option < IfcParameterValue > { & self . end_param } } impl IIfcSweptDiskSolidPolygonal for IfcSweptDiskSolidPolygonal { fn fillet_radius (& self) -> & Option < IfcPositiveLengthMeasure > { & self . fillet_radius } } impl IfcSweptDiskSolidPolygonal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSweptDiskSolidPolygonal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . directrix = parameter . into () , 1usize => entity . radius = parameter . into () , 2usize => entity . inner_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . start_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . end_param = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSweptSurface : IIfcSurface { pub fn swept_curve (& self) -> & EntityRef < IfcProfileDef > ; pub fn position (& self) -> & Option < EntityRef < IfcAxis2Placement3D > > ; } pub trait IIfcSwitchingDevice : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcSwitchingDeviceTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSwitchingDevice { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSwitchingDeviceTypeEnum > , } impl IIfcRoot for IfcSwitchingDevice { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSwitchingDevice { } impl IIfcObject for IfcSwitchingDevice { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSwitchingDevice { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSwitchingDevice { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcSwitchingDevice { } impl IIfcDistributionFlowElement for IfcSwitchingDevice { } impl IIfcFlowController for IfcSwitchingDevice { } impl IIfcSwitchingDevice for IfcSwitchingDevice { fn predefined_type (& self) -> & Option < IfcSwitchingDeviceTypeEnum > { & self . predefined_type } } impl IfcSwitchingDevice { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSwitchingDevice :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSwitchingDeviceType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcSwitchingDeviceTypeEnum ; } # [derive (Default , Debug)] pub struct IfcSwitchingDeviceType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcSwitchingDeviceTypeEnum , } impl IIfcRoot for IfcSwitchingDeviceType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSwitchingDeviceType { } impl IIfcTypeObject for IfcSwitchingDeviceType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSwitchingDeviceType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSwitchingDeviceType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcSwitchingDeviceType { } impl IIfcDistributionFlowElementType for IfcSwitchingDeviceType { } impl IIfcFlowControllerType for IfcSwitchingDeviceType { } impl IIfcSwitchingDeviceType for IfcSwitchingDeviceType { fn predefined_type (& self) -> & IfcSwitchingDeviceTypeEnum { & self . predefined_type } } impl IfcSwitchingDeviceType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSwitchingDeviceType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcSystem : IIfcGroup { } # [derive (Default , Debug)] pub struct IfcSystem { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , } impl IIfcRoot for IfcSystem { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSystem { } impl IIfcObject for IfcSystem { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcSystem { } impl IIfcSystem for IfcSystem { } impl IfcSystem { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSystem :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSystemFurnitureElement : IIfcFurnishingElement { pub fn predefined_type (& self) -> & Option < IfcSystemFurnitureElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSystemFurnitureElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcSystemFurnitureElementTypeEnum > , } impl IIfcRoot for IfcSystemFurnitureElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSystemFurnitureElement { } impl IIfcObject for IfcSystemFurnitureElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcSystemFurnitureElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcSystemFurnitureElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFurnishingElement for IfcSystemFurnitureElement { } impl IIfcSystemFurnitureElement for IfcSystemFurnitureElement { fn predefined_type (& self) -> & Option < IfcSystemFurnitureElementTypeEnum > { & self . predefined_type } } impl IfcSystemFurnitureElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSystemFurnitureElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcSystemFurnitureElementType : IIfcFurnishingElementType { pub fn predefined_type (& self) -> & Option < IfcSystemFurnitureElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcSystemFurnitureElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : Option < IfcSystemFurnitureElementTypeEnum > , } impl IIfcRoot for IfcSystemFurnitureElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcSystemFurnitureElementType { } impl IIfcTypeObject for IfcSystemFurnitureElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcSystemFurnitureElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcSystemFurnitureElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcFurnishingElementType for IfcSystemFurnitureElementType { } impl IIfcSystemFurnitureElementType for IfcSystemFurnitureElementType { fn predefined_type (& self) -> & Option < IfcSystemFurnitureElementTypeEnum > { & self . predefined_type } } impl IfcSystemFurnitureElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcSystemFurnitureElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTShapeProfileDef : IIfcParameterizedProfileDef { pub fn depth (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_width (& self) -> & IfcPositiveLengthMeasure ; pub fn web_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn web_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn web_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; pub fn flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; } # [derive (Default , Debug)] pub struct IfcTShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , depth : IfcPositiveLengthMeasure , flange_width : IfcPositiveLengthMeasure , web_thickness : IfcPositiveLengthMeasure , flange_thickness : IfcPositiveLengthMeasure , fillet_radius : Option < IfcNonNegativeLengthMeasure > , flange_edge_radius : Option < IfcNonNegativeLengthMeasure > , web_edge_radius : Option < IfcNonNegativeLengthMeasure > , web_slope : Option < IfcPlaneAngleMeasure > , flange_slope : Option < IfcPlaneAngleMeasure > , } impl IIfcProfileDef for IfcTShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcTShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcTShapeProfileDef for IfcTShapeProfileDef { fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } fn flange_width (& self) -> & IfcPositiveLengthMeasure { & self . flange_width } fn web_thickness (& self) -> & IfcPositiveLengthMeasure { & self . web_thickness } fn flange_thickness (& self) -> & IfcPositiveLengthMeasure { & self . flange_thickness } fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . fillet_radius } fn flange_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . flange_edge_radius } fn web_edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . web_edge_radius } fn web_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . web_slope } fn flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . flange_slope } } impl IfcTShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . depth = parameter . into () , 4usize => entity . flange_width = parameter . into () , 5usize => entity . web_thickness = parameter . into () , 6usize => entity . flange_thickness = parameter . into () , 7usize => entity . fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . flange_edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . web_edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . web_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . flange_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTable : { pub fn name (& self) -> & Option < IfcLabel > ; pub fn rows (& self) -> & Option < Vec < EntityRef < IfcTableRow > > > ; pub fn columns (& self) -> & Option < Vec < EntityRef < IfcTableColumn > > > ; } # [derive (Default , Debug)] pub struct IfcTable { name : Option < IfcLabel > , rows : Option < Vec < EntityRef < IfcTableRow > > > , columns : Option < Vec < EntityRef < IfcTableColumn > > > , } impl IIfcTable for IfcTable { fn name (& self) -> & Option < IfcLabel > { & self . name } fn rows (& self) -> & Option < Vec < EntityRef < IfcTableRow > > > { & self . rows } fn columns (& self) -> & Option < Vec < EntityRef < IfcTableColumn > > > { & self . columns } } impl IfcTable { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTable :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . rows = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . columns = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTableColumn : { pub fn identifier (& self) -> & Option < IfcIdentifier > ; pub fn name (& self) -> & Option < IfcLabel > ; pub fn description (& self) -> & Option < IfcText > ; pub fn unit (& self) -> & Option < EntityRef < IfcUnit > > ; pub fn reference_path (& self) -> & Option < EntityRef < IfcReference > > ; } # [derive (Default , Debug)] pub struct IfcTableColumn { identifier : Option < IfcIdentifier > , name : Option < IfcLabel > , description : Option < IfcText > , unit : Option < EntityRef < IfcUnit > > , reference_path : Option < EntityRef < IfcReference > > , } impl IIfcTableColumn for IfcTableColumn { fn identifier (& self) -> & Option < IfcIdentifier > { & self . identifier } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } fn unit (& self) -> & Option < EntityRef < IfcUnit > > { & self . unit } fn reference_path (& self) -> & Option < EntityRef < IfcReference > > { & self . reference_path } } impl IfcTableColumn { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTableColumn :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . unit = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . reference_path = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTableRow : { pub fn row_cells (& self) -> & Option < Vec < IfcValue > > ; pub fn is_heading (& self) -> & Option < IfcBoolean > ; } # [derive (Default , Debug)] pub struct IfcTableRow { row_cells : Option < Vec < IfcValue > > , is_heading : Option < IfcBoolean > , } impl IIfcTableRow for IfcTableRow { fn row_cells (& self) -> & Option < Vec < IfcValue > > { & self . row_cells } fn is_heading (& self) -> & Option < IfcBoolean > { & self . is_heading } } impl IfcTableRow { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTableRow :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . row_cells = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . is_heading = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTank : IIfcFlowStorageDevice { pub fn predefined_type (& self) -> & Option < IfcTankTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcTank { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcTankTypeEnum > , } impl IIfcRoot for IfcTank { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTank { } impl IIfcObject for IfcTank { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcTank { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcTank { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcTank { } impl IIfcDistributionFlowElement for IfcTank { } impl IIfcFlowStorageDevice for IfcTank { } impl IIfcTank for IfcTank { fn predefined_type (& self) -> & Option < IfcTankTypeEnum > { & self . predefined_type } } impl IfcTank { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTank :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTankType : IIfcFlowStorageDeviceType { pub fn predefined_type (& self) -> & IfcTankTypeEnum ; } # [derive (Default , Debug)] pub struct IfcTankType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcTankTypeEnum , } impl IIfcRoot for IfcTankType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTankType { } impl IIfcTypeObject for IfcTankType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTankType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcTankType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcTankType { } impl IIfcDistributionFlowElementType for IfcTankType { } impl IIfcFlowStorageDeviceType for IfcTankType { } impl IIfcTankType for IfcTankType { fn predefined_type (& self) -> & IfcTankTypeEnum { & self . predefined_type } } impl IfcTankType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTankType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcTask : IIfcProcess { pub fn status (& self) -> & Option < IfcLabel > ; pub fn work_method (& self) -> & Option < IfcLabel > ; pub fn is_milestone (& self) -> & IfcBoolean ; pub fn priority (& self) -> & Option < IfcInteger > ; pub fn task_time (& self) -> & Option < EntityRef < IfcTaskTime > > ; pub fn predefined_type (& self) -> & Option < IfcTaskTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcTask { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , status : Option < IfcLabel > , work_method : Option < IfcLabel > , is_milestone : IfcBoolean , priority : Option < IfcInteger > , task_time : Option < EntityRef < IfcTaskTime > > , predefined_type : Option < IfcTaskTypeEnum > , } impl IIfcRoot for IfcTask { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTask { } impl IIfcObject for IfcTask { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProcess for IfcTask { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } } impl IIfcTask for IfcTask { fn status (& self) -> & Option < IfcLabel > { & self . status } fn work_method (& self) -> & Option < IfcLabel > { & self . work_method } fn is_milestone (& self) -> & IfcBoolean { & self . is_milestone } fn priority (& self) -> & Option < IfcInteger > { & self . priority } fn task_time (& self) -> & Option < EntityRef < IfcTaskTime > > { & self . task_time } fn predefined_type (& self) -> & Option < IfcTaskTypeEnum > { & self . predefined_type } } impl IfcTask { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTask :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . status = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . work_method = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . is_milestone = parameter . into () , 10usize => entity . priority = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . task_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTaskTime : IIfcSchedulingTime { pub fn duration_type (& self) -> & Option < IfcTaskDurationEnum > ; pub fn schedule_duration (& self) -> & Option < IfcDuration > ; pub fn schedule_start (& self) -> & Option < IfcDateTime > ; pub fn schedule_finish (& self) -> & Option < IfcDateTime > ; pub fn early_start (& self) -> & Option < IfcDateTime > ; pub fn early_finish (& self) -> & Option < IfcDateTime > ; pub fn late_start (& self) -> & Option < IfcDateTime > ; pub fn late_finish (& self) -> & Option < IfcDateTime > ; pub fn free_float (& self) -> & Option < IfcDuration > ; pub fn total_float (& self) -> & Option < IfcDuration > ; pub fn is_critical (& self) -> & Option < IfcBoolean > ; pub fn status_time (& self) -> & Option < IfcDateTime > ; pub fn actual_duration (& self) -> & Option < IfcDuration > ; pub fn actual_start (& self) -> & Option < IfcDateTime > ; pub fn actual_finish (& self) -> & Option < IfcDateTime > ; pub fn remaining_time (& self) -> & Option < IfcDuration > ; pub fn completion (& self) -> & Option < IfcPositiveRatioMeasure > ; } # [derive (Default , Debug)] pub struct IfcTaskTime { name : Option < IfcLabel > , data_origin : Option < IfcDataOriginEnum > , user_defined_data_origin : Option < IfcLabel > , duration_type : Option < IfcTaskDurationEnum > , schedule_duration : Option < IfcDuration > , schedule_start : Option < IfcDateTime > , schedule_finish : Option < IfcDateTime > , early_start : Option < IfcDateTime > , early_finish : Option < IfcDateTime > , late_start : Option < IfcDateTime > , late_finish : Option < IfcDateTime > , free_float : Option < IfcDuration > , total_float : Option < IfcDuration > , is_critical : Option < IfcBoolean > , status_time : Option < IfcDateTime > , actual_duration : Option < IfcDuration > , actual_start : Option < IfcDateTime > , actual_finish : Option < IfcDateTime > , remaining_time : Option < IfcDuration > , completion : Option < IfcPositiveRatioMeasure > , } impl IIfcSchedulingTime for IfcTaskTime { fn name (& self) -> & Option < IfcLabel > { & self . name } fn data_origin (& self) -> & Option < IfcDataOriginEnum > { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } } impl IIfcTaskTime for IfcTaskTime { fn duration_type (& self) -> & Option < IfcTaskDurationEnum > { & self . duration_type } fn schedule_duration (& self) -> & Option < IfcDuration > { & self . schedule_duration } fn schedule_start (& self) -> & Option < IfcDateTime > { & self . schedule_start } fn schedule_finish (& self) -> & Option < IfcDateTime > { & self . schedule_finish } fn early_start (& self) -> & Option < IfcDateTime > { & self . early_start } fn early_finish (& self) -> & Option < IfcDateTime > { & self . early_finish } fn late_start (& self) -> & Option < IfcDateTime > { & self . late_start } fn late_finish (& self) -> & Option < IfcDateTime > { & self . late_finish } fn free_float (& self) -> & Option < IfcDuration > { & self . free_float } fn total_float (& self) -> & Option < IfcDuration > { & self . total_float } fn is_critical (& self) -> & Option < IfcBoolean > { & self . is_critical } fn status_time (& self) -> & Option < IfcDateTime > { & self . status_time } fn actual_duration (& self) -> & Option < IfcDuration > { & self . actual_duration } fn actual_start (& self) -> & Option < IfcDateTime > { & self . actual_start } fn actual_finish (& self) -> & Option < IfcDateTime > { & self . actual_finish } fn remaining_time (& self) -> & Option < IfcDuration > { & self . remaining_time } fn completion (& self) -> & Option < IfcPositiveRatioMeasure > { & self . completion } } impl IfcTaskTime { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTaskTime :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . duration_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . schedule_duration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . schedule_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . schedule_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . early_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . early_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . late_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . late_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . free_float = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . total_float = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . is_critical = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . status_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . actual_duration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . actual_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 17usize => entity . actual_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 18usize => entity . remaining_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 19usize => entity . completion = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTaskTimeRecurring : IIfcTaskTime { pub fn recurrence (& self) -> & EntityRef < IfcRecurrencePattern > ; } # [derive (Default , Debug)] pub struct IfcTaskTimeRecurring { name : Option < IfcLabel > , data_origin : Option < IfcDataOriginEnum > , user_defined_data_origin : Option < IfcLabel > , duration_type : Option < IfcTaskDurationEnum > , schedule_duration : Option < IfcDuration > , schedule_start : Option < IfcDateTime > , schedule_finish : Option < IfcDateTime > , early_start : Option < IfcDateTime > , early_finish : Option < IfcDateTime > , late_start : Option < IfcDateTime > , late_finish : Option < IfcDateTime > , free_float : Option < IfcDuration > , total_float : Option < IfcDuration > , is_critical : Option < IfcBoolean > , status_time : Option < IfcDateTime > , actual_duration : Option < IfcDuration > , actual_start : Option < IfcDateTime > , actual_finish : Option < IfcDateTime > , remaining_time : Option < IfcDuration > , completion : Option < IfcPositiveRatioMeasure > , recurrence : EntityRef < IfcRecurrencePattern > , } impl IIfcSchedulingTime for IfcTaskTimeRecurring { fn name (& self) -> & Option < IfcLabel > { & self . name } fn data_origin (& self) -> & Option < IfcDataOriginEnum > { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } } impl IIfcTaskTime for IfcTaskTimeRecurring { fn duration_type (& self) -> & Option < IfcTaskDurationEnum > { & self . duration_type } fn schedule_duration (& self) -> & Option < IfcDuration > { & self . schedule_duration } fn schedule_start (& self) -> & Option < IfcDateTime > { & self . schedule_start } fn schedule_finish (& self) -> & Option < IfcDateTime > { & self . schedule_finish } fn early_start (& self) -> & Option < IfcDateTime > { & self . early_start } fn early_finish (& self) -> & Option < IfcDateTime > { & self . early_finish } fn late_start (& self) -> & Option < IfcDateTime > { & self . late_start } fn late_finish (& self) -> & Option < IfcDateTime > { & self . late_finish } fn free_float (& self) -> & Option < IfcDuration > { & self . free_float } fn total_float (& self) -> & Option < IfcDuration > { & self . total_float } fn is_critical (& self) -> & Option < IfcBoolean > { & self . is_critical } fn status_time (& self) -> & Option < IfcDateTime > { & self . status_time } fn actual_duration (& self) -> & Option < IfcDuration > { & self . actual_duration } fn actual_start (& self) -> & Option < IfcDateTime > { & self . actual_start } fn actual_finish (& self) -> & Option < IfcDateTime > { & self . actual_finish } fn remaining_time (& self) -> & Option < IfcDuration > { & self . remaining_time } fn completion (& self) -> & Option < IfcPositiveRatioMeasure > { & self . completion } } impl IIfcTaskTimeRecurring for IfcTaskTimeRecurring { fn recurrence (& self) -> & EntityRef < IfcRecurrencePattern > { & self . recurrence } } impl IfcTaskTimeRecurring { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTaskTimeRecurring :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . duration_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . schedule_duration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . schedule_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . schedule_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . early_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . early_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . late_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . late_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . free_float = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . total_float = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . is_critical = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . status_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . actual_duration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . actual_start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 17usize => entity . actual_finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , 18usize => entity . remaining_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 19usize => entity . completion = if parameter . is_null () { None } else { Some (parameter . into ()) } , 20usize => entity . recurrence = parameter . into () , _ => { } } } entity } } pub trait IIfcTaskType : IIfcTypeProcess { pub fn predefined_type (& self) -> & IfcTaskTypeEnum ; pub fn work_method (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcTaskType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , identification : Option < IfcIdentifier > , long_description : Option < IfcText > , process_type : Option < IfcLabel > , predefined_type : IfcTaskTypeEnum , work_method : Option < IfcLabel > , } impl IIfcRoot for IfcTaskType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTaskType { } impl IIfcTypeObject for IfcTaskType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProcess for IfcTaskType { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } fn long_description (& self) -> & Option < IfcText > { & self . long_description } fn process_type (& self) -> & Option < IfcLabel > { & self . process_type } } impl IIfcTaskType for IfcTaskType { fn predefined_type (& self) -> & IfcTaskTypeEnum { & self . predefined_type } fn work_method (& self) -> & Option < IfcLabel > { & self . work_method } } impl IfcTaskType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTaskType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . long_description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . process_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . work_method = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTelecomAddress : IIfcAddress { pub fn telephone_numbers (& self) -> & Option < Vec < IfcLabel > > ; pub fn facsimile_numbers (& self) -> & Option < Vec < IfcLabel > > ; pub fn pager_number (& self) -> & Option < IfcLabel > ; pub fn electronic_mail_addresses (& self) -> & Option < Vec < IfcLabel > > ; pub fn www_home_page_url (& self) -> & Option < IfcUriReference > ; pub fn messaging_i_ds (& self) -> & Option < Vec < IfcUriReference > > ; } # [derive (Default , Debug)] pub struct IfcTelecomAddress { purpose : Option < IfcAddressTypeEnum > , description : Option < IfcText > , user_defined_purpose : Option < IfcLabel > , telephone_numbers : Option < Vec < IfcLabel > > , facsimile_numbers : Option < Vec < IfcLabel > > , pager_number : Option < IfcLabel > , electronic_mail_addresses : Option < Vec < IfcLabel > > , www_home_page_url : Option < IfcUriReference > , messaging_i_ds : Option < Vec < IfcUriReference > > , } impl IIfcAddress for IfcTelecomAddress { fn purpose (& self) -> & Option < IfcAddressTypeEnum > { & self . purpose } fn description (& self) -> & Option < IfcText > { & self . description } fn user_defined_purpose (& self) -> & Option < IfcLabel > { & self . user_defined_purpose } } impl IIfcTelecomAddress for IfcTelecomAddress { fn telephone_numbers (& self) -> & Option < Vec < IfcLabel > > { & self . telephone_numbers } fn facsimile_numbers (& self) -> & Option < Vec < IfcLabel > > { & self . facsimile_numbers } fn pager_number (& self) -> & Option < IfcLabel > { & self . pager_number } fn electronic_mail_addresses (& self) -> & Option < Vec < IfcLabel > > { & self . electronic_mail_addresses } fn www_home_page_url (& self) -> & Option < IfcUriReference > { & self . www_home_page_url } fn messaging_i_ds (& self) -> & Option < Vec < IfcUriReference > > { & self . messaging_i_ds } } impl IfcTelecomAddress { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTelecomAddress :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . telephone_numbers = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . facsimile_numbers = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . pager_number = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . electronic_mail_addresses = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . www_home_page_url = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . messaging_i_ds = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTendon : IIfcReinforcingElement { pub fn predefined_type (& self) -> & Option < IfcTendonTypeEnum > ; pub fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn tension_force (& self) -> & Option < IfcForceMeasure > ; pub fn pre_stress (& self) -> & Option < IfcPressureMeasure > ; pub fn friction_coefficient (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn anchorage_slip (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn min_curvature_radius (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcTendon { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , steel_grade : Option < IfcLabel > , predefined_type : Option < IfcTendonTypeEnum > , nominal_diameter : Option < IfcPositiveLengthMeasure > , cross_section_area : Option < IfcAreaMeasure > , tension_force : Option < IfcForceMeasure > , pre_stress : Option < IfcPressureMeasure > , friction_coefficient : Option < IfcNormalisedRatioMeasure > , anchorage_slip : Option < IfcPositiveLengthMeasure > , min_curvature_radius : Option < IfcPositiveLengthMeasure > , } impl IIfcRoot for IfcTendon { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTendon { } impl IIfcObject for IfcTendon { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcTendon { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcTendon { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcTendon { } impl IIfcReinforcingElement for IfcTendon { fn steel_grade (& self) -> & Option < IfcLabel > { & self . steel_grade } } impl IIfcTendon for IfcTendon { fn predefined_type (& self) -> & Option < IfcTendonTypeEnum > { & self . predefined_type } fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_diameter } fn cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . cross_section_area } fn tension_force (& self) -> & Option < IfcForceMeasure > { & self . tension_force } fn pre_stress (& self) -> & Option < IfcPressureMeasure > { & self . pre_stress } fn friction_coefficient (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . friction_coefficient } fn anchorage_slip (& self) -> & Option < IfcPositiveLengthMeasure > { & self . anchorage_slip } fn min_curvature_radius (& self) -> & Option < IfcPositiveLengthMeasure > { & self . min_curvature_radius } } impl IfcTendon { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTendon :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . steel_grade = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . tension_force = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . pre_stress = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . friction_coefficient = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . anchorage_slip = if parameter . is_null () { None } else { Some (parameter . into ()) } , 16usize => entity . min_curvature_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTendonAnchor : IIfcReinforcingElement { pub fn predefined_type (& self) -> & Option < IfcTendonAnchorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcTendonAnchor { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , steel_grade : Option < IfcLabel > , predefined_type : Option < IfcTendonAnchorTypeEnum > , } impl IIfcRoot for IfcTendonAnchor { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTendonAnchor { } impl IIfcObject for IfcTendonAnchor { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcTendonAnchor { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcTendonAnchor { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcTendonAnchor { } impl IIfcReinforcingElement for IfcTendonAnchor { fn steel_grade (& self) -> & Option < IfcLabel > { & self . steel_grade } } impl IIfcTendonAnchor for IfcTendonAnchor { fn predefined_type (& self) -> & Option < IfcTendonAnchorTypeEnum > { & self . predefined_type } } impl IfcTendonAnchor { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTendonAnchor :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . steel_grade = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTendonAnchorType : IIfcReinforcingElementType { pub fn predefined_type (& self) -> & IfcTendonAnchorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcTendonAnchorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcTendonAnchorTypeEnum , } impl IIfcRoot for IfcTendonAnchorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTendonAnchorType { } impl IIfcTypeObject for IfcTendonAnchorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTendonAnchorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcTendonAnchorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcTendonAnchorType { } impl IIfcReinforcingElementType for IfcTendonAnchorType { } impl IIfcTendonAnchorType for IfcTendonAnchorType { fn predefined_type (& self) -> & IfcTendonAnchorTypeEnum { & self . predefined_type } } impl IfcTendonAnchorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTendonAnchorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcTendonType : IIfcReinforcingElementType { pub fn predefined_type (& self) -> & IfcTendonTypeEnum ; pub fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn cross_section_area (& self) -> & Option < IfcAreaMeasure > ; pub fn sheath_diameter (& self) -> & Option < IfcPositiveLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcTendonType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcTendonTypeEnum , nominal_diameter : Option < IfcPositiveLengthMeasure > , cross_section_area : Option < IfcAreaMeasure > , sheath_diameter : Option < IfcPositiveLengthMeasure > , } impl IIfcRoot for IfcTendonType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTendonType { } impl IIfcTypeObject for IfcTendonType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTendonType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcTendonType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcTendonType { } impl IIfcReinforcingElementType for IfcTendonType { } impl IIfcTendonType for IfcTendonType { fn predefined_type (& self) -> & IfcTendonTypeEnum { & self . predefined_type } fn nominal_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . nominal_diameter } fn cross_section_area (& self) -> & Option < IfcAreaMeasure > { & self . cross_section_area } fn sheath_diameter (& self) -> & Option < IfcPositiveLengthMeasure > { & self . sheath_diameter } } impl IfcTendonType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTendonType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . nominal_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . cross_section_area = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . sheath_diameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTessellatedFaceSet : IIfcTessellatedItem { pub fn coordinates (& self) -> & EntityRef < IfcCartesianPointList3D > ; } pub trait IIfcTessellatedItem : IIfcGeometricRepresentationItem { } pub trait IIfcTextLiteral : IIfcGeometricRepresentationItem { pub fn literal (& self) -> & IfcPresentableText ; pub fn placement (& self) -> & EntityRef < IfcAxis2Placement > ; pub fn path (& self) -> & IfcTextPath ; } # [derive (Default , Debug)] pub struct IfcTextLiteral { literal : IfcPresentableText , placement : EntityRef < IfcAxis2Placement > , path : IfcTextPath , } impl IIfcRepresentationItem for IfcTextLiteral { } impl IIfcGeometricRepresentationItem for IfcTextLiteral { } impl IIfcTextLiteral for IfcTextLiteral { fn literal (& self) -> & IfcPresentableText { & self . literal } fn placement (& self) -> & EntityRef < IfcAxis2Placement > { & self . placement } fn path (& self) -> & IfcTextPath { & self . path } } impl IfcTextLiteral { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextLiteral :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . literal = parameter . into () , 1usize => entity . placement = parameter . into () , 2usize => entity . path = parameter . into () , _ => { } } } entity } } pub trait IIfcTextLiteralWithExtent : IIfcTextLiteral { pub fn extent (& self) -> & EntityRef < IfcPlanarExtent > ; pub fn box_alignment (& self) -> & IfcBoxAlignment ; } # [derive (Default , Debug)] pub struct IfcTextLiteralWithExtent { literal : IfcPresentableText , placement : EntityRef < IfcAxis2Placement > , path : IfcTextPath , extent : EntityRef < IfcPlanarExtent > , box_alignment : IfcBoxAlignment , } impl IIfcRepresentationItem for IfcTextLiteralWithExtent { } impl IIfcGeometricRepresentationItem for IfcTextLiteralWithExtent { } impl IIfcTextLiteral for IfcTextLiteralWithExtent { fn literal (& self) -> & IfcPresentableText { & self . literal } fn placement (& self) -> & EntityRef < IfcAxis2Placement > { & self . placement } fn path (& self) -> & IfcTextPath { & self . path } } impl IIfcTextLiteralWithExtent for IfcTextLiteralWithExtent { fn extent (& self) -> & EntityRef < IfcPlanarExtent > { & self . extent } fn box_alignment (& self) -> & IfcBoxAlignment { & self . box_alignment } } impl IfcTextLiteralWithExtent { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextLiteralWithExtent :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . literal = parameter . into () , 1usize => entity . placement = parameter . into () , 2usize => entity . path = parameter . into () , 3usize => entity . extent = parameter . into () , 4usize => entity . box_alignment = parameter . into () , _ => { } } } entity } } pub trait IIfcTextStyle : IIfcPresentationStyle { pub fn text_character_appearance (& self) -> & Option < EntityRef < IfcTextStyleForDefinedFont > > ; pub fn text_style (& self) -> & Option < EntityRef < IfcTextStyleTextModel > > ; pub fn text_font_style (& self) -> & EntityRef < IfcTextFontSelect > ; pub fn model_or_draughting (& self) -> & Option < IfcBoolean > ; } # [derive (Default , Debug)] pub struct IfcTextStyle { name : Option < IfcLabel > , text_character_appearance : Option < EntityRef < IfcTextStyleForDefinedFont > > , text_style : Option < EntityRef < IfcTextStyleTextModel > > , text_font_style : EntityRef < IfcTextFontSelect > , model_or_draughting : Option < IfcBoolean > , } impl IIfcPresentationStyle for IfcTextStyle { fn name (& self) -> & Option < IfcLabel > { & self . name } } impl IIfcTextStyle for IfcTextStyle { fn text_character_appearance (& self) -> & Option < EntityRef < IfcTextStyleForDefinedFont > > { & self . text_character_appearance } fn text_style (& self) -> & Option < EntityRef < IfcTextStyleTextModel > > { & self . text_style } fn text_font_style (& self) -> & EntityRef < IfcTextFontSelect > { & self . text_font_style } fn model_or_draughting (& self) -> & Option < IfcBoolean > { & self . model_or_draughting } } impl IfcTextStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . text_character_appearance = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . text_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . text_font_style = parameter . into () , 4usize => entity . model_or_draughting = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTextStyleFontModel : IIfcPreDefinedTextFont { pub fn font_family (& self) -> & Vec < IfcTextFontName > ; pub fn font_style (& self) -> & Option < IfcFontStyle > ; pub fn font_variant (& self) -> & Option < IfcFontVariant > ; pub fn font_weight (& self) -> & Option < IfcFontWeight > ; pub fn font_size (& self) -> & IfcSizeSelect ; } # [derive (Default , Debug)] pub struct IfcTextStyleFontModel { name : IfcLabel , font_family : Vec < IfcTextFontName > , font_style : Option < IfcFontStyle > , font_variant : Option < IfcFontVariant > , font_weight : Option < IfcFontWeight > , font_size : IfcSizeSelect , } impl IIfcPresentationItem for IfcTextStyleFontModel { } impl IIfcPreDefinedItem for IfcTextStyleFontModel { fn name (& self) -> & IfcLabel { & self . name } } impl IIfcPreDefinedTextFont for IfcTextStyleFontModel { } impl IIfcTextStyleFontModel for IfcTextStyleFontModel { fn font_family (& self) -> & Vec < IfcTextFontName > { & self . font_family } fn font_style (& self) -> & Option < IfcFontStyle > { & self . font_style } fn font_variant (& self) -> & Option < IfcFontVariant > { & self . font_variant } fn font_weight (& self) -> & Option < IfcFontWeight > { & self . font_weight } fn font_size (& self) -> & IfcSizeSelect { & self . font_size } } impl IfcTextStyleFontModel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextStyleFontModel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = parameter . into () , 1usize => entity . font_family = parameter . into () , 2usize => entity . font_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . font_variant = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . font_weight = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . font_size = parameter . into () , _ => { } } } entity } } pub trait IIfcTextStyleForDefinedFont : IIfcPresentationItem { pub fn colour (& self) -> & EntityRef < IfcColour > ; pub fn background_colour (& self) -> & Option < EntityRef < IfcColour > > ; } # [derive (Default , Debug)] pub struct IfcTextStyleForDefinedFont { colour : EntityRef < IfcColour > , background_colour : Option < EntityRef < IfcColour > > , } impl IIfcPresentationItem for IfcTextStyleForDefinedFont { } impl IIfcTextStyleForDefinedFont for IfcTextStyleForDefinedFont { fn colour (& self) -> & EntityRef < IfcColour > { & self . colour } fn background_colour (& self) -> & Option < EntityRef < IfcColour > > { & self . background_colour } } impl IfcTextStyleForDefinedFont { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextStyleForDefinedFont :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . colour = parameter . into () , 1usize => entity . background_colour = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTextStyleTextModel : IIfcPresentationItem { pub fn text_indent (& self) -> & Option < IfcSizeSelect > ; pub fn text_align (& self) -> & Option < IfcTextAlignment > ; pub fn text_decoration (& self) -> & Option < IfcTextDecoration > ; pub fn letter_spacing (& self) -> & Option < IfcSizeSelect > ; pub fn word_spacing (& self) -> & Option < IfcSizeSelect > ; pub fn text_transform (& self) -> & Option < IfcTextTransformation > ; pub fn line_height (& self) -> & Option < IfcSizeSelect > ; } # [derive (Default , Debug)] pub struct IfcTextStyleTextModel { text_indent : Option < IfcSizeSelect > , text_align : Option < IfcTextAlignment > , text_decoration : Option < IfcTextDecoration > , letter_spacing : Option < IfcSizeSelect > , word_spacing : Option < IfcSizeSelect > , text_transform : Option < IfcTextTransformation > , line_height : Option < IfcSizeSelect > , } impl IIfcPresentationItem for IfcTextStyleTextModel { } impl IIfcTextStyleTextModel for IfcTextStyleTextModel { fn text_indent (& self) -> & Option < IfcSizeSelect > { & self . text_indent } fn text_align (& self) -> & Option < IfcTextAlignment > { & self . text_align } fn text_decoration (& self) -> & Option < IfcTextDecoration > { & self . text_decoration } fn letter_spacing (& self) -> & Option < IfcSizeSelect > { & self . letter_spacing } fn word_spacing (& self) -> & Option < IfcSizeSelect > { & self . word_spacing } fn text_transform (& self) -> & Option < IfcTextTransformation > { & self . text_transform } fn line_height (& self) -> & Option < IfcSizeSelect > { & self . line_height } } impl IfcTextStyleTextModel { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextStyleTextModel :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . text_indent = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . text_align = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . text_decoration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . letter_spacing = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . word_spacing = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . text_transform = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . line_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTextureCoordinate : IIfcPresentationItem { pub fn maps (& self) -> & Vec < EntityRef < IfcSurfaceTexture > > ; } pub trait IIfcTextureCoordinateGenerator : IIfcTextureCoordinate { pub fn mode (& self) -> & IfcLabel ; pub fn parameter (& self) -> & Option < Vec < IfcReal > > ; } # [derive (Default , Debug)] pub struct IfcTextureCoordinateGenerator { maps : Vec < EntityRef < IfcSurfaceTexture > > , mode : IfcLabel , parameter : Option < Vec < IfcReal > > , } impl IIfcPresentationItem for IfcTextureCoordinateGenerator { } impl IIfcTextureCoordinate for IfcTextureCoordinateGenerator { fn maps (& self) -> & Vec < EntityRef < IfcSurfaceTexture > > { & self . maps } } impl IIfcTextureCoordinateGenerator for IfcTextureCoordinateGenerator { fn mode (& self) -> & IfcLabel { & self . mode } fn parameter (& self) -> & Option < Vec < IfcReal > > { & self . parameter } } impl IfcTextureCoordinateGenerator { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextureCoordinateGenerator :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . maps = parameter . into () , 1usize => entity . mode = parameter . into () , 2usize => entity . parameter = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTextureMap : IIfcTextureCoordinate { pub fn vertices (& self) -> & Vec < EntityRef < IfcTextureVertex > > ; pub fn mapped_to (& self) -> & EntityRef < IfcFace > ; } # [derive (Default , Debug)] pub struct IfcTextureMap { maps : Vec < EntityRef < IfcSurfaceTexture > > , vertices : Vec < EntityRef < IfcTextureVertex > > , mapped_to : EntityRef < IfcFace > , } impl IIfcPresentationItem for IfcTextureMap { } impl IIfcTextureCoordinate for IfcTextureMap { fn maps (& self) -> & Vec < EntityRef < IfcSurfaceTexture > > { & self . maps } } impl IIfcTextureMap for IfcTextureMap { fn vertices (& self) -> & Vec < EntityRef < IfcTextureVertex > > { & self . vertices } fn mapped_to (& self) -> & EntityRef < IfcFace > { & self . mapped_to } } impl IfcTextureMap { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextureMap :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . maps = parameter . into () , 1usize => entity . vertices = parameter . into () , 2usize => entity . mapped_to = parameter . into () , _ => { } } } entity } } pub trait IIfcTextureVertex : IIfcPresentationItem { pub fn coordinates (& self) -> & Vec < IfcParameterValue > ; } # [derive (Default , Debug)] pub struct IfcTextureVertex { coordinates : Vec < IfcParameterValue > , } impl IIfcPresentationItem for IfcTextureVertex { } impl IIfcTextureVertex for IfcTextureVertex { fn coordinates (& self) -> & Vec < IfcParameterValue > { & self . coordinates } } impl IfcTextureVertex { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextureVertex :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coordinates = parameter . into () , _ => { } } } entity } } pub trait IIfcTextureVertexList : IIfcPresentationItem { pub fn tex_coords_list (& self) -> & Vec < Vec < IfcParameterValue > > ; } # [derive (Default , Debug)] pub struct IfcTextureVertexList { tex_coords_list : Vec < Vec < IfcParameterValue > > , } impl IIfcPresentationItem for IfcTextureVertexList { } impl IIfcTextureVertexList for IfcTextureVertexList { fn tex_coords_list (& self) -> & Vec < Vec < IfcParameterValue > > { & self . tex_coords_list } } impl IfcTextureVertexList { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTextureVertexList :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . tex_coords_list = parameter . into () , _ => { } } } entity } } pub trait IIfcTimePeriod : { pub fn start_time (& self) -> & IfcTime ; pub fn end_time (& self) -> & IfcTime ; } # [derive (Default , Debug)] pub struct IfcTimePeriod { start_time : IfcTime , end_time : IfcTime , } impl IIfcTimePeriod for IfcTimePeriod { fn start_time (& self) -> & IfcTime { & self . start_time } fn end_time (& self) -> & IfcTime { & self . end_time } } impl IfcTimePeriod { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTimePeriod :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . start_time = parameter . into () , 1usize => entity . end_time = parameter . into () , _ => { } } } entity } } pub trait IIfcTimeSeries : { pub fn name (& self) -> & IfcLabel ; pub fn description (& self) -> & Option < IfcText > ; pub fn start_time (& self) -> & IfcDateTime ; pub fn end_time (& self) -> & IfcDateTime ; pub fn time_series_data_type (& self) -> & IfcTimeSeriesDataTypeEnum ; pub fn data_origin (& self) -> & IfcDataOriginEnum ; pub fn user_defined_data_origin (& self) -> & Option < IfcLabel > ; pub fn unit (& self) -> & Option < EntityRef < IfcUnit > > ; } pub trait IIfcTimeSeriesValue : { pub fn list_values (& self) -> & Vec < IfcValue > ; } # [derive (Default , Debug)] pub struct IfcTimeSeriesValue { list_values : Vec < IfcValue > , } impl IIfcTimeSeriesValue for IfcTimeSeriesValue { fn list_values (& self) -> & Vec < IfcValue > { & self . list_values } } impl IfcTimeSeriesValue { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTimeSeriesValue :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . list_values = parameter . into () , _ => { } } } entity } } pub trait IIfcTopologicalRepresentationItem : IIfcRepresentationItem { } pub trait IIfcTopologyRepresentation : IIfcShapeModel { } # [derive (Default , Debug)] pub struct IfcTopologyRepresentation { context_of_items : EntityRef < IfcRepresentationContext > , representation_identifier : Option < IfcLabel > , representation_type : Option < IfcLabel > , items : HashSet < EntityRef < IfcRepresentationItem > > , } impl IIfcRepresentation for IfcTopologyRepresentation { fn context_of_items (& self) -> & EntityRef < IfcRepresentationContext > { & self . context_of_items } fn representation_identifier (& self) -> & Option < IfcLabel > { & self . representation_identifier } fn representation_type (& self) -> & Option < IfcLabel > { & self . representation_type } fn items (& self) -> & HashSet < EntityRef < IfcRepresentationItem > > { & self . items } } impl IIfcShapeModel for IfcTopologyRepresentation { } impl IIfcTopologyRepresentation for IfcTopologyRepresentation { } impl IfcTopologyRepresentation { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTopologyRepresentation :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . context_of_items = parameter . into () , 1usize => entity . representation_identifier = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . representation_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . items = parameter . into () , _ => { } } } entity } } pub trait IIfcToroidalSurface : IIfcElementarySurface { pub fn major_radius (& self) -> & IfcPositiveLengthMeasure ; pub fn minor_radius (& self) -> & IfcPositiveLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcToroidalSurface { position : EntityRef < IfcAxis2Placement3D > , major_radius : IfcPositiveLengthMeasure , minor_radius : IfcPositiveLengthMeasure , } impl IIfcRepresentationItem for IfcToroidalSurface { } impl IIfcGeometricRepresentationItem for IfcToroidalSurface { } impl IIfcSurface for IfcToroidalSurface { } impl IIfcElementarySurface for IfcToroidalSurface { fn position (& self) -> & EntityRef < IfcAxis2Placement3D > { & self . position } } impl IIfcToroidalSurface for IfcToroidalSurface { fn major_radius (& self) -> & IfcPositiveLengthMeasure { & self . major_radius } fn minor_radius (& self) -> & IfcPositiveLengthMeasure { & self . minor_radius } } impl IfcToroidalSurface { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcToroidalSurface :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . position = parameter . into () , 1usize => entity . major_radius = parameter . into () , 2usize => entity . minor_radius = parameter . into () , _ => { } } } entity } } pub trait IIfcTransformer : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcTransformerTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcTransformer { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcTransformerTypeEnum > , } impl IIfcRoot for IfcTransformer { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTransformer { } impl IIfcObject for IfcTransformer { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcTransformer { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcTransformer { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcTransformer { } impl IIfcDistributionFlowElement for IfcTransformer { } impl IIfcEnergyConversionDevice for IfcTransformer { } impl IIfcTransformer for IfcTransformer { fn predefined_type (& self) -> & Option < IfcTransformerTypeEnum > { & self . predefined_type } } impl IfcTransformer { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTransformer :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTransformerType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcTransformerTypeEnum ; } # [derive (Default , Debug)] pub struct IfcTransformerType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcTransformerTypeEnum , } impl IIfcRoot for IfcTransformerType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTransformerType { } impl IIfcTypeObject for IfcTransformerType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTransformerType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcTransformerType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcTransformerType { } impl IIfcDistributionFlowElementType for IfcTransformerType { } impl IIfcEnergyConversionDeviceType for IfcTransformerType { } impl IIfcTransformerType for IfcTransformerType { fn predefined_type (& self) -> & IfcTransformerTypeEnum { & self . predefined_type } } impl IfcTransformerType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTransformerType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcTransportElement : IIfcElement { pub fn predefined_type (& self) -> & Option < IfcTransportElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcTransportElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcTransportElementTypeEnum > , } impl IIfcRoot for IfcTransportElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTransportElement { } impl IIfcObject for IfcTransportElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcTransportElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcTransportElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcTransportElement for IfcTransportElement { fn predefined_type (& self) -> & Option < IfcTransportElementTypeEnum > { & self . predefined_type } } impl IfcTransportElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTransportElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTransportElementType : IIfcElementType { pub fn predefined_type (& self) -> & IfcTransportElementTypeEnum ; } # [derive (Default , Debug)] pub struct IfcTransportElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcTransportElementTypeEnum , } impl IIfcRoot for IfcTransportElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTransportElementType { } impl IIfcTypeObject for IfcTransportElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTransportElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcTransportElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcTransportElementType for IfcTransportElementType { fn predefined_type (& self) -> & IfcTransportElementTypeEnum { & self . predefined_type } } impl IfcTransportElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTransportElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcTrapeziumProfileDef : IIfcParameterizedProfileDef { pub fn bottom_x_dim (& self) -> & IfcPositiveLengthMeasure ; pub fn top_x_dim (& self) -> & IfcPositiveLengthMeasure ; pub fn y_dim (& self) -> & IfcPositiveLengthMeasure ; pub fn top_x_offset (& self) -> & IfcLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcTrapeziumProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , bottom_x_dim : IfcPositiveLengthMeasure , top_x_dim : IfcPositiveLengthMeasure , y_dim : IfcPositiveLengthMeasure , top_x_offset : IfcLengthMeasure , } impl IIfcProfileDef for IfcTrapeziumProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcTrapeziumProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcTrapeziumProfileDef for IfcTrapeziumProfileDef { fn bottom_x_dim (& self) -> & IfcPositiveLengthMeasure { & self . bottom_x_dim } fn top_x_dim (& self) -> & IfcPositiveLengthMeasure { & self . top_x_dim } fn y_dim (& self) -> & IfcPositiveLengthMeasure { & self . y_dim } fn top_x_offset (& self) -> & IfcLengthMeasure { & self . top_x_offset } } impl IfcTrapeziumProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTrapeziumProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . bottom_x_dim = parameter . into () , 4usize => entity . top_x_dim = parameter . into () , 5usize => entity . y_dim = parameter . into () , 6usize => entity . top_x_offset = parameter . into () , _ => { } } } entity } } pub trait IIfcTriangulatedFaceSet : IIfcTessellatedFaceSet { pub fn normals (& self) -> & Option < Vec < Vec < IfcParameterValue > > > ; pub fn closed (& self) -> & Option < IfcBoolean > ; pub fn coord_index (& self) -> & Vec < Vec < IfcPositiveInteger > > ; pub fn pn_index (& self) -> & Option < Vec < IfcPositiveInteger > > ; } # [derive (Default , Debug)] pub struct IfcTriangulatedFaceSet { coordinates : EntityRef < IfcCartesianPointList3D > , normals : Option < Vec < Vec < IfcParameterValue > > > , closed : Option < IfcBoolean > , coord_index : Vec < Vec < IfcPositiveInteger > > , pn_index : Option < Vec < IfcPositiveInteger > > , } impl IIfcRepresentationItem for IfcTriangulatedFaceSet { } impl IIfcGeometricRepresentationItem for IfcTriangulatedFaceSet { } impl IIfcTessellatedItem for IfcTriangulatedFaceSet { } impl IIfcTessellatedFaceSet for IfcTriangulatedFaceSet { fn coordinates (& self) -> & EntityRef < IfcCartesianPointList3D > { & self . coordinates } } impl IIfcTriangulatedFaceSet for IfcTriangulatedFaceSet { fn normals (& self) -> & Option < Vec < Vec < IfcParameterValue > > > { & self . normals } fn closed (& self) -> & Option < IfcBoolean > { & self . closed } fn coord_index (& self) -> & Vec < Vec < IfcPositiveInteger > > { & self . coord_index } fn pn_index (& self) -> & Option < Vec < IfcPositiveInteger > > { & self . pn_index } } impl IfcTriangulatedFaceSet { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTriangulatedFaceSet :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . coordinates = parameter . into () , 1usize => entity . normals = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . closed = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . coord_index = parameter . into () , 4usize => entity . pn_index = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTrimmedCurve : IIfcBoundedCurve { pub fn basis_curve (& self) -> & EntityRef < IfcCurve > ; pub fn trim1 (& self) -> & HashSet < IfcTrimmingSelect > ; pub fn trim2 (& self) -> & HashSet < IfcTrimmingSelect > ; pub fn sense_agreement (& self) -> & IfcBoolean ; pub fn master_representation (& self) -> & IfcTrimmingPreference ; } # [derive (Default , Debug)] pub struct IfcTrimmedCurve { basis_curve : EntityRef < IfcCurve > , trim1 : HashSet < IfcTrimmingSelect > , trim2 : HashSet < IfcTrimmingSelect > , sense_agreement : IfcBoolean , master_representation : IfcTrimmingPreference , } impl IIfcRepresentationItem for IfcTrimmedCurve { } impl IIfcGeometricRepresentationItem for IfcTrimmedCurve { } impl IIfcCurve for IfcTrimmedCurve { } impl IIfcBoundedCurve for IfcTrimmedCurve { } impl IIfcTrimmedCurve for IfcTrimmedCurve { fn basis_curve (& self) -> & EntityRef < IfcCurve > { & self . basis_curve } fn trim1 (& self) -> & HashSet < IfcTrimmingSelect > { & self . trim1 } fn trim2 (& self) -> & HashSet < IfcTrimmingSelect > { & self . trim2 } fn sense_agreement (& self) -> & IfcBoolean { & self . sense_agreement } fn master_representation (& self) -> & IfcTrimmingPreference { & self . master_representation } } impl IfcTrimmedCurve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTrimmedCurve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . basis_curve = parameter . into () , 1usize => entity . trim1 = parameter . into () , 2usize => entity . trim2 = parameter . into () , 3usize => entity . sense_agreement = parameter . into () , 4usize => entity . master_representation = parameter . into () , _ => { } } } entity } } pub trait IIfcTubeBundle : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcTubeBundleTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcTubeBundle { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcTubeBundleTypeEnum > , } impl IIfcRoot for IfcTubeBundle { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTubeBundle { } impl IIfcObject for IfcTubeBundle { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcTubeBundle { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcTubeBundle { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcTubeBundle { } impl IIfcDistributionFlowElement for IfcTubeBundle { } impl IIfcEnergyConversionDevice for IfcTubeBundle { } impl IIfcTubeBundle for IfcTubeBundle { fn predefined_type (& self) -> & Option < IfcTubeBundleTypeEnum > { & self . predefined_type } } impl IfcTubeBundle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTubeBundle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTubeBundleType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcTubeBundleTypeEnum ; } # [derive (Default , Debug)] pub struct IfcTubeBundleType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcTubeBundleTypeEnum , } impl IIfcRoot for IfcTubeBundleType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTubeBundleType { } impl IIfcTypeObject for IfcTubeBundleType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTubeBundleType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcTubeBundleType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcTubeBundleType { } impl IIfcDistributionFlowElementType for IfcTubeBundleType { } impl IIfcEnergyConversionDeviceType for IfcTubeBundleType { } impl IIfcTubeBundleType for IfcTubeBundleType { fn predefined_type (& self) -> & IfcTubeBundleTypeEnum { & self . predefined_type } } impl IfcTubeBundleType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTubeBundleType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcTypeObject : IIfcObjectDefinition { pub fn applicable_occurrence (& self) -> & Option < IfcIdentifier > ; pub fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > ; } # [derive (Default , Debug)] pub struct IfcTypeObject { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , } impl IIfcRoot for IfcTypeObject { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTypeObject { } impl IIfcTypeObject for IfcTypeObject { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IfcTypeObject { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTypeObject :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTypeProcess : IIfcTypeObject { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn long_description (& self) -> & Option < IfcText > ; pub fn process_type (& self) -> & Option < IfcLabel > ; } pub trait IIfcTypeProduct : IIfcTypeObject { pub fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > ; pub fn tag (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcTypeProduct { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , } impl IIfcRoot for IfcTypeProduct { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcTypeProduct { } impl IIfcTypeObject for IfcTypeProduct { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcTypeProduct { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IfcTypeProduct { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcTypeProduct :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcTypeResource : IIfcTypeObject { pub fn identification (& self) -> & Option < IfcIdentifier > ; pub fn long_description (& self) -> & Option < IfcText > ; pub fn resource_type (& self) -> & Option < IfcLabel > ; } pub trait IIfcUShapeProfileDef : IIfcParameterizedProfileDef { pub fn depth (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_width (& self) -> & IfcPositiveLengthMeasure ; pub fn web_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > ; } # [derive (Default , Debug)] pub struct IfcUShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , depth : IfcPositiveLengthMeasure , flange_width : IfcPositiveLengthMeasure , web_thickness : IfcPositiveLengthMeasure , flange_thickness : IfcPositiveLengthMeasure , fillet_radius : Option < IfcNonNegativeLengthMeasure > , edge_radius : Option < IfcNonNegativeLengthMeasure > , flange_slope : Option < IfcPlaneAngleMeasure > , } impl IIfcProfileDef for IfcUShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcUShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcUShapeProfileDef for IfcUShapeProfileDef { fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } fn flange_width (& self) -> & IfcPositiveLengthMeasure { & self . flange_width } fn web_thickness (& self) -> & IfcPositiveLengthMeasure { & self . web_thickness } fn flange_thickness (& self) -> & IfcPositiveLengthMeasure { & self . flange_thickness } fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . fillet_radius } fn edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . edge_radius } fn flange_slope (& self) -> & Option < IfcPlaneAngleMeasure > { & self . flange_slope } } impl IfcUShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcUShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . depth = parameter . into () , 4usize => entity . flange_width = parameter . into () , 5usize => entity . web_thickness = parameter . into () , 6usize => entity . flange_thickness = parameter . into () , 7usize => entity . fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . flange_slope = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcUnitAssignment : { pub fn units (& self) -> & HashSet < EntityRef < IfcUnit > > ; } # [derive (Default , Debug)] pub struct IfcUnitAssignment { units : HashSet < EntityRef < IfcUnit > > , } impl IIfcUnitAssignment for IfcUnitAssignment { fn units (& self) -> & HashSet < EntityRef < IfcUnit > > { & self . units } } impl IfcUnitAssignment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcUnitAssignment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . units = parameter . into () , _ => { } } } entity } } pub trait IIfcUnitaryControlElement : IIfcDistributionControlElement { pub fn predefined_type (& self) -> & Option < IfcUnitaryControlElementTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcUnitaryControlElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcUnitaryControlElementTypeEnum > , } impl IIfcRoot for IfcUnitaryControlElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcUnitaryControlElement { } impl IIfcObject for IfcUnitaryControlElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcUnitaryControlElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcUnitaryControlElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcUnitaryControlElement { } impl IIfcDistributionControlElement for IfcUnitaryControlElement { } impl IIfcUnitaryControlElement for IfcUnitaryControlElement { fn predefined_type (& self) -> & Option < IfcUnitaryControlElementTypeEnum > { & self . predefined_type } } impl IfcUnitaryControlElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcUnitaryControlElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcUnitaryControlElementType : IIfcDistributionControlElementType { pub fn predefined_type (& self) -> & IfcUnitaryControlElementTypeEnum ; } # [derive (Default , Debug)] pub struct IfcUnitaryControlElementType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcUnitaryControlElementTypeEnum , } impl IIfcRoot for IfcUnitaryControlElementType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcUnitaryControlElementType { } impl IIfcTypeObject for IfcUnitaryControlElementType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcUnitaryControlElementType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcUnitaryControlElementType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcUnitaryControlElementType { } impl IIfcDistributionControlElementType for IfcUnitaryControlElementType { } impl IIfcUnitaryControlElementType for IfcUnitaryControlElementType { fn predefined_type (& self) -> & IfcUnitaryControlElementTypeEnum { & self . predefined_type } } impl IfcUnitaryControlElementType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcUnitaryControlElementType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcUnitaryEquipment : IIfcEnergyConversionDevice { pub fn predefined_type (& self) -> & Option < IfcUnitaryEquipmentTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcUnitaryEquipment { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcUnitaryEquipmentTypeEnum > , } impl IIfcRoot for IfcUnitaryEquipment { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcUnitaryEquipment { } impl IIfcObject for IfcUnitaryEquipment { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcUnitaryEquipment { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcUnitaryEquipment { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcUnitaryEquipment { } impl IIfcDistributionFlowElement for IfcUnitaryEquipment { } impl IIfcEnergyConversionDevice for IfcUnitaryEquipment { } impl IIfcUnitaryEquipment for IfcUnitaryEquipment { fn predefined_type (& self) -> & Option < IfcUnitaryEquipmentTypeEnum > { & self . predefined_type } } impl IfcUnitaryEquipment { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcUnitaryEquipment :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcUnitaryEquipmentType : IIfcEnergyConversionDeviceType { pub fn predefined_type (& self) -> & IfcUnitaryEquipmentTypeEnum ; } # [derive (Default , Debug)] pub struct IfcUnitaryEquipmentType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcUnitaryEquipmentTypeEnum , } impl IIfcRoot for IfcUnitaryEquipmentType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcUnitaryEquipmentType { } impl IIfcTypeObject for IfcUnitaryEquipmentType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcUnitaryEquipmentType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcUnitaryEquipmentType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcUnitaryEquipmentType { } impl IIfcDistributionFlowElementType for IfcUnitaryEquipmentType { } impl IIfcEnergyConversionDeviceType for IfcUnitaryEquipmentType { } impl IIfcUnitaryEquipmentType for IfcUnitaryEquipmentType { fn predefined_type (& self) -> & IfcUnitaryEquipmentTypeEnum { & self . predefined_type } } impl IfcUnitaryEquipmentType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcUnitaryEquipmentType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcValve : IIfcFlowController { pub fn predefined_type (& self) -> & Option < IfcValveTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcValve { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcValveTypeEnum > , } impl IIfcRoot for IfcValve { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcValve { } impl IIfcObject for IfcValve { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcValve { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcValve { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcValve { } impl IIfcDistributionFlowElement for IfcValve { } impl IIfcFlowController for IfcValve { } impl IIfcValve for IfcValve { fn predefined_type (& self) -> & Option < IfcValveTypeEnum > { & self . predefined_type } } impl IfcValve { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcValve :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcValveType : IIfcFlowControllerType { pub fn predefined_type (& self) -> & IfcValveTypeEnum ; } # [derive (Default , Debug)] pub struct IfcValveType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcValveTypeEnum , } impl IIfcRoot for IfcValveType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcValveType { } impl IIfcTypeObject for IfcValveType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcValveType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcValveType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcValveType { } impl IIfcDistributionFlowElementType for IfcValveType { } impl IIfcFlowControllerType for IfcValveType { } impl IIfcValveType for IfcValveType { fn predefined_type (& self) -> & IfcValveTypeEnum { & self . predefined_type } } impl IfcValveType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcValveType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcVector : IIfcGeometricRepresentationItem { pub fn orientation (& self) -> & EntityRef < IfcDirection > ; pub fn magnitude (& self) -> & IfcLengthMeasure ; } # [derive (Default , Debug)] pub struct IfcVector { orientation : EntityRef < IfcDirection > , magnitude : IfcLengthMeasure , } impl IIfcRepresentationItem for IfcVector { } impl IIfcGeometricRepresentationItem for IfcVector { } impl IIfcVector for IfcVector { fn orientation (& self) -> & EntityRef < IfcDirection > { & self . orientation } fn magnitude (& self) -> & IfcLengthMeasure { & self . magnitude } } impl IfcVector { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVector :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . orientation = parameter . into () , 1usize => entity . magnitude = parameter . into () , _ => { } } } entity } } pub trait IIfcVertex : IIfcTopologicalRepresentationItem { } # [derive (Default , Debug)] pub struct IfcVertex { } impl IIfcRepresentationItem for IfcVertex { } impl IIfcTopologicalRepresentationItem for IfcVertex { } impl IIfcVertex for IfcVertex { } impl IfcVertex { pub fn form_parameters (_parameters : Vec < Parameter >) -> Self { IfcVertex :: default () } } pub trait IIfcVertexLoop : IIfcLoop { pub fn loop_vertex (& self) -> & EntityRef < IfcVertex > ; } # [derive (Default , Debug)] pub struct IfcVertexLoop { loop_vertex : EntityRef < IfcVertex > , } impl IIfcRepresentationItem for IfcVertexLoop { } impl IIfcTopologicalRepresentationItem for IfcVertexLoop { } impl IIfcLoop for IfcVertexLoop { } impl IIfcVertexLoop for IfcVertexLoop { fn loop_vertex (& self) -> & EntityRef < IfcVertex > { & self . loop_vertex } } impl IfcVertexLoop { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVertexLoop :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . loop_vertex = parameter . into () , _ => { } } } entity } } pub trait IIfcVertexPoint : IIfcVertex { pub fn vertex_geometry (& self) -> & EntityRef < IfcPoint > ; } # [derive (Default , Debug)] pub struct IfcVertexPoint { vertex_geometry : EntityRef < IfcPoint > , } impl IIfcRepresentationItem for IfcVertexPoint { } impl IIfcTopologicalRepresentationItem for IfcVertexPoint { } impl IIfcVertex for IfcVertexPoint { } impl IIfcVertexPoint for IfcVertexPoint { fn vertex_geometry (& self) -> & EntityRef < IfcPoint > { & self . vertex_geometry } } impl IfcVertexPoint { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVertexPoint :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . vertex_geometry = parameter . into () , _ => { } } } entity } } pub trait IIfcVibrationIsolator : IIfcElementComponent { pub fn predefined_type (& self) -> & Option < IfcVibrationIsolatorTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcVibrationIsolator { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcVibrationIsolatorTypeEnum > , } impl IIfcRoot for IfcVibrationIsolator { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcVibrationIsolator { } impl IIfcObject for IfcVibrationIsolator { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcVibrationIsolator { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcVibrationIsolator { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcElementComponent for IfcVibrationIsolator { } impl IIfcVibrationIsolator for IfcVibrationIsolator { fn predefined_type (& self) -> & Option < IfcVibrationIsolatorTypeEnum > { & self . predefined_type } } impl IfcVibrationIsolator { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVibrationIsolator :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcVibrationIsolatorType : IIfcElementComponentType { pub fn predefined_type (& self) -> & IfcVibrationIsolatorTypeEnum ; } # [derive (Default , Debug)] pub struct IfcVibrationIsolatorType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcVibrationIsolatorTypeEnum , } impl IIfcRoot for IfcVibrationIsolatorType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcVibrationIsolatorType { } impl IIfcTypeObject for IfcVibrationIsolatorType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcVibrationIsolatorType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcVibrationIsolatorType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcElementComponentType for IfcVibrationIsolatorType { } impl IIfcVibrationIsolatorType for IfcVibrationIsolatorType { fn predefined_type (& self) -> & IfcVibrationIsolatorTypeEnum { & self . predefined_type } } impl IfcVibrationIsolatorType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVibrationIsolatorType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcVirtualElement : IIfcElement { } # [derive (Default , Debug)] pub struct IfcVirtualElement { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , } impl IIfcRoot for IfcVirtualElement { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcVirtualElement { } impl IIfcObject for IfcVirtualElement { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcVirtualElement { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcVirtualElement { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcVirtualElement for IfcVirtualElement { } impl IfcVirtualElement { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVirtualElement :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcVirtualGridIntersection : { pub fn intersecting_axes (& self) -> & Vec < EntityRef < IfcGridAxis > > ; pub fn offset_distances (& self) -> & Vec < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcVirtualGridIntersection { intersecting_axes : Vec < EntityRef < IfcGridAxis > > , offset_distances : Vec < IfcLengthMeasure > , } impl IIfcVirtualGridIntersection for IfcVirtualGridIntersection { fn intersecting_axes (& self) -> & Vec < EntityRef < IfcGridAxis > > { & self . intersecting_axes } fn offset_distances (& self) -> & Vec < IfcLengthMeasure > { & self . offset_distances } } impl IfcVirtualGridIntersection { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVirtualGridIntersection :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . intersecting_axes = parameter . into () , 1usize => entity . offset_distances = parameter . into () , _ => { } } } entity } } pub trait IIfcVoidingFeature : IIfcFeatureElementSubtraction { pub fn predefined_type (& self) -> & Option < IfcVoidingFeatureTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcVoidingFeature { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcVoidingFeatureTypeEnum > , } impl IIfcRoot for IfcVoidingFeature { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcVoidingFeature { } impl IIfcObject for IfcVoidingFeature { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcVoidingFeature { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcVoidingFeature { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcFeatureElement for IfcVoidingFeature { } impl IIfcFeatureElementSubtraction for IfcVoidingFeature { } impl IIfcVoidingFeature for IfcVoidingFeature { fn predefined_type (& self) -> & Option < IfcVoidingFeatureTypeEnum > { & self . predefined_type } } impl IfcVoidingFeature { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcVoidingFeature :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWall : IIfcBuildingElement { pub fn predefined_type (& self) -> & Option < IfcWallTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcWall { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcWallTypeEnum > , } impl IIfcRoot for IfcWall { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWall { } impl IIfcObject for IfcWall { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcWall { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcWall { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcWall { } impl IIfcWall for IfcWall { fn predefined_type (& self) -> & Option < IfcWallTypeEnum > { & self . predefined_type } } impl IfcWall { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWall :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWallElementedCase : IIfcWall { } # [derive (Default , Debug)] pub struct IfcWallElementedCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcWallTypeEnum > , } impl IIfcRoot for IfcWallElementedCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWallElementedCase { } impl IIfcObject for IfcWallElementedCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcWallElementedCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcWallElementedCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcWallElementedCase { } impl IIfcWall for IfcWallElementedCase { fn predefined_type (& self) -> & Option < IfcWallTypeEnum > { & self . predefined_type } } impl IIfcWallElementedCase for IfcWallElementedCase { } impl IfcWallElementedCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWallElementedCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWallStandardCase : IIfcWall { } # [derive (Default , Debug)] pub struct IfcWallStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcWallTypeEnum > , } impl IIfcRoot for IfcWallStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWallStandardCase { } impl IIfcObject for IfcWallStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcWallStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcWallStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcWallStandardCase { } impl IIfcWall for IfcWallStandardCase { fn predefined_type (& self) -> & Option < IfcWallTypeEnum > { & self . predefined_type } } impl IIfcWallStandardCase for IfcWallStandardCase { } impl IfcWallStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWallStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWallType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcWallTypeEnum ; } # [derive (Default , Debug)] pub struct IfcWallType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcWallTypeEnum , } impl IIfcRoot for IfcWallType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWallType { } impl IIfcTypeObject for IfcWallType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcWallType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcWallType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcWallType { } impl IIfcWallType for IfcWallType { fn predefined_type (& self) -> & IfcWallTypeEnum { & self . predefined_type } } impl IfcWallType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWallType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcWasteTerminal : IIfcFlowTerminal { pub fn predefined_type (& self) -> & Option < IfcWasteTerminalTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcWasteTerminal { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , predefined_type : Option < IfcWasteTerminalTypeEnum > , } impl IIfcRoot for IfcWasteTerminal { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWasteTerminal { } impl IIfcObject for IfcWasteTerminal { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcWasteTerminal { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcWasteTerminal { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcDistributionElement for IfcWasteTerminal { } impl IIfcDistributionFlowElement for IfcWasteTerminal { } impl IIfcFlowTerminal for IfcWasteTerminal { } impl IIfcWasteTerminal for IfcWasteTerminal { fn predefined_type (& self) -> & Option < IfcWasteTerminalTypeEnum > { & self . predefined_type } } impl IfcWasteTerminal { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWasteTerminal :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWasteTerminalType : IIfcFlowTerminalType { pub fn predefined_type (& self) -> & IfcWasteTerminalTypeEnum ; } # [derive (Default , Debug)] pub struct IfcWasteTerminalType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcWasteTerminalTypeEnum , } impl IIfcRoot for IfcWasteTerminalType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWasteTerminalType { } impl IIfcTypeObject for IfcWasteTerminalType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcWasteTerminalType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcWasteTerminalType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcDistributionElementType for IfcWasteTerminalType { } impl IIfcDistributionFlowElementType for IfcWasteTerminalType { } impl IIfcFlowTerminalType for IfcWasteTerminalType { } impl IIfcWasteTerminalType for IfcWasteTerminalType { fn predefined_type (& self) -> & IfcWasteTerminalTypeEnum { & self . predefined_type } } impl IfcWasteTerminalType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWasteTerminalType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , _ => { } } } entity } } pub trait IIfcWindow : IIfcBuildingElement { pub fn overall_height (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn overall_width (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn predefined_type (& self) -> & Option < IfcWindowTypeEnum > ; pub fn partitioning_type (& self) -> & Option < IfcWindowTypePartitioningEnum > ; pub fn user_defined_partitioning_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcWindow { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , overall_height : Option < IfcPositiveLengthMeasure > , overall_width : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcWindowTypeEnum > , partitioning_type : Option < IfcWindowTypePartitioningEnum > , user_defined_partitioning_type : Option < IfcLabel > , } impl IIfcRoot for IfcWindow { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWindow { } impl IIfcObject for IfcWindow { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcWindow { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcWindow { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcWindow { } impl IIfcWindow for IfcWindow { fn overall_height (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_height } fn overall_width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_width } fn predefined_type (& self) -> & Option < IfcWindowTypeEnum > { & self . predefined_type } fn partitioning_type (& self) -> & Option < IfcWindowTypePartitioningEnum > { & self . partitioning_type } fn user_defined_partitioning_type (& self) -> & Option < IfcLabel > { & self . user_defined_partitioning_type } } impl IfcWindow { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWindow :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . overall_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . overall_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . partitioning_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . user_defined_partitioning_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWindowLiningProperties : IIfcPreDefinedPropertySet { pub fn lining_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn lining_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn transom_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn mullion_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn first_transom_offset (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn second_transom_offset (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn first_mullion_offset (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn second_mullion_offset (& self) -> & Option < IfcNormalisedRatioMeasure > ; pub fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > ; pub fn lining_offset (& self) -> & Option < IfcLengthMeasure > ; pub fn lining_to_panel_offset_x (& self) -> & Option < IfcLengthMeasure > ; pub fn lining_to_panel_offset_y (& self) -> & Option < IfcLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcWindowLiningProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , lining_depth : Option < IfcPositiveLengthMeasure > , lining_thickness : Option < IfcNonNegativeLengthMeasure > , transom_thickness : Option < IfcNonNegativeLengthMeasure > , mullion_thickness : Option < IfcNonNegativeLengthMeasure > , first_transom_offset : Option < IfcNormalisedRatioMeasure > , second_transom_offset : Option < IfcNormalisedRatioMeasure > , first_mullion_offset : Option < IfcNormalisedRatioMeasure > , second_mullion_offset : Option < IfcNormalisedRatioMeasure > , shape_aspect_style : Option < EntityRef < IfcShapeAspect > > , lining_offset : Option < IfcLengthMeasure > , lining_to_panel_offset_x : Option < IfcLengthMeasure > , lining_to_panel_offset_y : Option < IfcLengthMeasure > , } impl IIfcRoot for IfcWindowLiningProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcWindowLiningProperties { } impl IIfcPropertySetDefinition for IfcWindowLiningProperties { } impl IIfcPreDefinedPropertySet for IfcWindowLiningProperties { } impl IIfcWindowLiningProperties for IfcWindowLiningProperties { fn lining_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . lining_depth } fn lining_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . lining_thickness } fn transom_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . transom_thickness } fn mullion_thickness (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . mullion_thickness } fn first_transom_offset (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . first_transom_offset } fn second_transom_offset (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . second_transom_offset } fn first_mullion_offset (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . first_mullion_offset } fn second_mullion_offset (& self) -> & Option < IfcNormalisedRatioMeasure > { & self . second_mullion_offset } fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > { & self . shape_aspect_style } fn lining_offset (& self) -> & Option < IfcLengthMeasure > { & self . lining_offset } fn lining_to_panel_offset_x (& self) -> & Option < IfcLengthMeasure > { & self . lining_to_panel_offset_x } fn lining_to_panel_offset_y (& self) -> & Option < IfcLengthMeasure > { & self . lining_to_panel_offset_y } } impl IfcWindowLiningProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWindowLiningProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . lining_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . lining_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . transom_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . mullion_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . first_transom_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . second_transom_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . first_mullion_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . second_mullion_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . shape_aspect_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . lining_offset = if parameter . is_null () { None } else { Some (parameter . into ()) } , 14usize => entity . lining_to_panel_offset_x = if parameter . is_null () { None } else { Some (parameter . into ()) } , 15usize => entity . lining_to_panel_offset_y = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWindowPanelProperties : IIfcPreDefinedPropertySet { pub fn operation_type (& self) -> & IfcWindowPanelOperationEnum ; pub fn panel_position (& self) -> & IfcWindowPanelPositionEnum ; pub fn frame_depth (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn frame_thickness (& self) -> & Option < IfcPositiveLengthMeasure > ; pub fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > ; } # [derive (Default , Debug)] pub struct IfcWindowPanelProperties { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , operation_type : IfcWindowPanelOperationEnum , panel_position : IfcWindowPanelPositionEnum , frame_depth : Option < IfcPositiveLengthMeasure > , frame_thickness : Option < IfcPositiveLengthMeasure > , shape_aspect_style : Option < EntityRef < IfcShapeAspect > > , } impl IIfcRoot for IfcWindowPanelProperties { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcPropertyDefinition for IfcWindowPanelProperties { } impl IIfcPropertySetDefinition for IfcWindowPanelProperties { } impl IIfcPreDefinedPropertySet for IfcWindowPanelProperties { } impl IIfcWindowPanelProperties for IfcWindowPanelProperties { fn operation_type (& self) -> & IfcWindowPanelOperationEnum { & self . operation_type } fn panel_position (& self) -> & IfcWindowPanelPositionEnum { & self . panel_position } fn frame_depth (& self) -> & Option < IfcPositiveLengthMeasure > { & self . frame_depth } fn frame_thickness (& self) -> & Option < IfcPositiveLengthMeasure > { & self . frame_thickness } fn shape_aspect_style (& self) -> & Option < EntityRef < IfcShapeAspect > > { & self . shape_aspect_style } } impl IfcWindowPanelProperties { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWindowPanelProperties :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . operation_type = parameter . into () , 5usize => entity . panel_position = parameter . into () , 6usize => entity . frame_depth = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . frame_thickness = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . shape_aspect_style = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWindowStandardCase : IIfcWindow { } # [derive (Default , Debug)] pub struct IfcWindowStandardCase { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , object_placement : Option < EntityRef < IfcObjectPlacement > > , representation : Option < EntityRef < IfcProductRepresentation > > , tag : Option < IfcIdentifier > , overall_height : Option < IfcPositiveLengthMeasure > , overall_width : Option < IfcPositiveLengthMeasure > , predefined_type : Option < IfcWindowTypeEnum > , partitioning_type : Option < IfcWindowTypePartitioningEnum > , user_defined_partitioning_type : Option < IfcLabel > , } impl IIfcRoot for IfcWindowStandardCase { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWindowStandardCase { } impl IIfcObject for IfcWindowStandardCase { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcProduct for IfcWindowStandardCase { fn object_placement (& self) -> & Option < EntityRef < IfcObjectPlacement > > { & self . object_placement } fn representation (& self) -> & Option < EntityRef < IfcProductRepresentation > > { & self . representation } } impl IIfcElement for IfcWindowStandardCase { fn tag (& self) -> & Option < IfcIdentifier > { & self . tag } } impl IIfcBuildingElement for IfcWindowStandardCase { } impl IIfcWindow for IfcWindowStandardCase { fn overall_height (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_height } fn overall_width (& self) -> & Option < IfcPositiveLengthMeasure > { & self . overall_width } fn predefined_type (& self) -> & Option < IfcWindowTypeEnum > { & self . predefined_type } fn partitioning_type (& self) -> & Option < IfcWindowTypePartitioningEnum > { & self . partitioning_type } fn user_defined_partitioning_type (& self) -> & Option < IfcLabel > { & self . user_defined_partitioning_type } } impl IIfcWindowStandardCase for IfcWindowStandardCase { } impl IfcWindowStandardCase { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWindowStandardCase :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . object_placement = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . overall_height = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . overall_width = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . partitioning_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . user_defined_partitioning_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWindowStyle : IIfcTypeProduct { pub fn construction_type (& self) -> & IfcWindowStyleConstructionEnum ; pub fn operation_type (& self) -> & IfcWindowStyleOperationEnum ; pub fn parameter_takes_precedence (& self) -> & IfcBoolean ; pub fn sizeable (& self) -> & IfcBoolean ; } # [derive (Default , Debug)] pub struct IfcWindowStyle { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , construction_type : IfcWindowStyleConstructionEnum , operation_type : IfcWindowStyleOperationEnum , parameter_takes_precedence : IfcBoolean , sizeable : IfcBoolean , } impl IIfcRoot for IfcWindowStyle { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWindowStyle { } impl IIfcTypeObject for IfcWindowStyle { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcWindowStyle { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcWindowStyle for IfcWindowStyle { fn construction_type (& self) -> & IfcWindowStyleConstructionEnum { & self . construction_type } fn operation_type (& self) -> & IfcWindowStyleOperationEnum { & self . operation_type } fn parameter_takes_precedence (& self) -> & IfcBoolean { & self . parameter_takes_precedence } fn sizeable (& self) -> & IfcBoolean { & self . sizeable } } impl IfcWindowStyle { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWindowStyle :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . construction_type = parameter . into () , 9usize => entity . operation_type = parameter . into () , 10usize => entity . parameter_takes_precedence = parameter . into () , 11usize => entity . sizeable = parameter . into () , _ => { } } } entity } } pub trait IIfcWindowType : IIfcBuildingElementType { pub fn predefined_type (& self) -> & IfcWindowTypeEnum ; pub fn partitioning_type (& self) -> & IfcWindowTypePartitioningEnum ; pub fn parameter_takes_precedence (& self) -> & Option < IfcBoolean > ; pub fn user_defined_partitioning_type (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcWindowType { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , applicable_occurrence : Option < IfcIdentifier > , has_property_sets : Option < HashSet < EntityRef < IfcPropertySetDefinition > > > , representation_maps : Option < Vec < EntityRef < IfcRepresentationMap > > > , tag : Option < IfcLabel > , element_type : Option < IfcLabel > , predefined_type : IfcWindowTypeEnum , partitioning_type : IfcWindowTypePartitioningEnum , parameter_takes_precedence : Option < IfcBoolean > , user_defined_partitioning_type : Option < IfcLabel > , } impl IIfcRoot for IfcWindowType { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWindowType { } impl IIfcTypeObject for IfcWindowType { fn applicable_occurrence (& self) -> & Option < IfcIdentifier > { & self . applicable_occurrence } fn has_property_sets (& self) -> & Option < HashSet < EntityRef < IfcPropertySetDefinition > > > { & self . has_property_sets } } impl IIfcTypeProduct for IfcWindowType { fn representation_maps (& self) -> & Option < Vec < EntityRef < IfcRepresentationMap > > > { & self . representation_maps } fn tag (& self) -> & Option < IfcLabel > { & self . tag } } impl IIfcElementType for IfcWindowType { fn element_type (& self) -> & Option < IfcLabel > { & self . element_type } } impl IIfcBuildingElementType for IfcWindowType { } impl IIfcWindowType for IfcWindowType { fn predefined_type (& self) -> & IfcWindowTypeEnum { & self . predefined_type } fn partitioning_type (& self) -> & IfcWindowTypePartitioningEnum { & self . partitioning_type } fn parameter_takes_precedence (& self) -> & Option < IfcBoolean > { & self . parameter_takes_precedence } fn user_defined_partitioning_type (& self) -> & Option < IfcLabel > { & self . user_defined_partitioning_type } } impl IfcWindowType { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWindowType :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . applicable_occurrence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . has_property_sets = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . representation_maps = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . tag = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . element_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . predefined_type = parameter . into () , 10usize => entity . partitioning_type = parameter . into () , 11usize => entity . parameter_takes_precedence = if parameter . is_null () { None } else { Some (parameter . into ()) } , 12usize => entity . user_defined_partitioning_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWorkCalendar : IIfcControl { pub fn working_times (& self) -> & Option < HashSet < EntityRef < IfcWorkTime > > > ; pub fn exception_times (& self) -> & Option < HashSet < EntityRef < IfcWorkTime > > > ; pub fn predefined_type (& self) -> & Option < IfcWorkCalendarTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcWorkCalendar { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , working_times : Option < HashSet < EntityRef < IfcWorkTime > > > , exception_times : Option < HashSet < EntityRef < IfcWorkTime > > > , predefined_type : Option < IfcWorkCalendarTypeEnum > , } impl IIfcRoot for IfcWorkCalendar { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWorkCalendar { } impl IIfcObject for IfcWorkCalendar { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcWorkCalendar { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcWorkCalendar for IfcWorkCalendar { fn working_times (& self) -> & Option < HashSet < EntityRef < IfcWorkTime > > > { & self . working_times } fn exception_times (& self) -> & Option < HashSet < EntityRef < IfcWorkTime > > > { & self . exception_times } fn predefined_type (& self) -> & Option < IfcWorkCalendarTypeEnum > { & self . predefined_type } } impl IfcWorkCalendar { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWorkCalendar :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . working_times = if parameter . is_null () { None } else { Some (parameter . into ()) } , 7usize => entity . exception_times = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWorkControl : IIfcControl { pub fn creation_date (& self) -> & IfcDateTime ; pub fn creators (& self) -> & Option < HashSet < EntityRef < IfcPerson > > > ; pub fn purpose (& self) -> & Option < IfcLabel > ; pub fn duration (& self) -> & Option < IfcDuration > ; pub fn total_float (& self) -> & Option < IfcDuration > ; pub fn start_time (& self) -> & IfcDateTime ; pub fn finish_time (& self) -> & Option < IfcDateTime > ; } pub trait IIfcWorkPlan : IIfcWorkControl { pub fn predefined_type (& self) -> & Option < IfcWorkPlanTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcWorkPlan { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , creation_date : IfcDateTime , creators : Option < HashSet < EntityRef < IfcPerson > > > , purpose : Option < IfcLabel > , duration : Option < IfcDuration > , total_float : Option < IfcDuration > , start_time : IfcDateTime , finish_time : Option < IfcDateTime > , predefined_type : Option < IfcWorkPlanTypeEnum > , } impl IIfcRoot for IfcWorkPlan { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWorkPlan { } impl IIfcObject for IfcWorkPlan { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcWorkPlan { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcWorkControl for IfcWorkPlan { fn creation_date (& self) -> & IfcDateTime { & self . creation_date } fn creators (& self) -> & Option < HashSet < EntityRef < IfcPerson > > > { & self . creators } fn purpose (& self) -> & Option < IfcLabel > { & self . purpose } fn duration (& self) -> & Option < IfcDuration > { & self . duration } fn total_float (& self) -> & Option < IfcDuration > { & self . total_float } fn start_time (& self) -> & IfcDateTime { & self . start_time } fn finish_time (& self) -> & Option < IfcDateTime > { & self . finish_time } } impl IIfcWorkPlan for IfcWorkPlan { fn predefined_type (& self) -> & Option < IfcWorkPlanTypeEnum > { & self . predefined_type } } impl IfcWorkPlan { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWorkPlan :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . creation_date = parameter . into () , 7usize => entity . creators = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . duration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . total_float = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . start_time = parameter . into () , 12usize => entity . finish_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWorkSchedule : IIfcWorkControl { pub fn predefined_type (& self) -> & Option < IfcWorkScheduleTypeEnum > ; } # [derive (Default , Debug)] pub struct IfcWorkSchedule { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , identification : Option < IfcIdentifier > , creation_date : IfcDateTime , creators : Option < HashSet < EntityRef < IfcPerson > > > , purpose : Option < IfcLabel > , duration : Option < IfcDuration > , total_float : Option < IfcDuration > , start_time : IfcDateTime , finish_time : Option < IfcDateTime > , predefined_type : Option < IfcWorkScheduleTypeEnum > , } impl IIfcRoot for IfcWorkSchedule { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcWorkSchedule { } impl IIfcObject for IfcWorkSchedule { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcControl for IfcWorkSchedule { fn identification (& self) -> & Option < IfcIdentifier > { & self . identification } } impl IIfcWorkControl for IfcWorkSchedule { fn creation_date (& self) -> & IfcDateTime { & self . creation_date } fn creators (& self) -> & Option < HashSet < EntityRef < IfcPerson > > > { & self . creators } fn purpose (& self) -> & Option < IfcLabel > { & self . purpose } fn duration (& self) -> & Option < IfcDuration > { & self . duration } fn total_float (& self) -> & Option < IfcDuration > { & self . total_float } fn start_time (& self) -> & IfcDateTime { & self . start_time } fn finish_time (& self) -> & Option < IfcDateTime > { & self . finish_time } } impl IIfcWorkSchedule for IfcWorkSchedule { fn predefined_type (& self) -> & Option < IfcWorkScheduleTypeEnum > { & self . predefined_type } } impl IfcWorkSchedule { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWorkSchedule :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . identification = if parameter . is_null () { None } else { Some (parameter . into ()) } , 6usize => entity . creation_date = parameter . into () , 7usize => entity . creators = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . purpose = if parameter . is_null () { None } else { Some (parameter . into ()) } , 9usize => entity . duration = if parameter . is_null () { None } else { Some (parameter . into ()) } , 10usize => entity . total_float = if parameter . is_null () { None } else { Some (parameter . into ()) } , 11usize => entity . start_time = parameter . into () , 12usize => entity . finish_time = if parameter . is_null () { None } else { Some (parameter . into ()) } , 13usize => entity . predefined_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcWorkTime : IIfcSchedulingTime { pub fn recurrence_pattern (& self) -> & Option < EntityRef < IfcRecurrencePattern > > ; pub fn start (& self) -> & Option < IfcDate > ; pub fn finish (& self) -> & Option < IfcDate > ; } # [derive (Default , Debug)] pub struct IfcWorkTime { name : Option < IfcLabel > , data_origin : Option < IfcDataOriginEnum > , user_defined_data_origin : Option < IfcLabel > , recurrence_pattern : Option < EntityRef < IfcRecurrencePattern > > , start : Option < IfcDate > , finish : Option < IfcDate > , } impl IIfcSchedulingTime for IfcWorkTime { fn name (& self) -> & Option < IfcLabel > { & self . name } fn data_origin (& self) -> & Option < IfcDataOriginEnum > { & self . data_origin } fn user_defined_data_origin (& self) -> & Option < IfcLabel > { & self . user_defined_data_origin } } impl IIfcWorkTime for IfcWorkTime { fn recurrence_pattern (& self) -> & Option < EntityRef < IfcRecurrencePattern > > { & self . recurrence_pattern } fn start (& self) -> & Option < IfcDate > { & self . start } fn finish (& self) -> & Option < IfcDate > { & self . finish } } impl IfcWorkTime { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcWorkTime :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 1usize => entity . data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . user_defined_data_origin = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . recurrence_pattern = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . start = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . finish = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcZShapeProfileDef : IIfcParameterizedProfileDef { pub fn depth (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_width (& self) -> & IfcPositiveLengthMeasure ; pub fn web_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn flange_thickness (& self) -> & IfcPositiveLengthMeasure ; pub fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; pub fn edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > ; } # [derive (Default , Debug)] pub struct IfcZShapeProfileDef { profile_type : IfcProfileTypeEnum , profile_name : Option < IfcLabel > , position : Option < EntityRef < IfcAxis2Placement2D > > , depth : IfcPositiveLengthMeasure , flange_width : IfcPositiveLengthMeasure , web_thickness : IfcPositiveLengthMeasure , flange_thickness : IfcPositiveLengthMeasure , fillet_radius : Option < IfcNonNegativeLengthMeasure > , edge_radius : Option < IfcNonNegativeLengthMeasure > , } impl IIfcProfileDef for IfcZShapeProfileDef { fn profile_type (& self) -> & IfcProfileTypeEnum { & self . profile_type } fn profile_name (& self) -> & Option < IfcLabel > { & self . profile_name } } impl IIfcParameterizedProfileDef for IfcZShapeProfileDef { fn position (& self) -> & Option < EntityRef < IfcAxis2Placement2D > > { & self . position } } impl IIfcZShapeProfileDef for IfcZShapeProfileDef { fn depth (& self) -> & IfcPositiveLengthMeasure { & self . depth } fn flange_width (& self) -> & IfcPositiveLengthMeasure { & self . flange_width } fn web_thickness (& self) -> & IfcPositiveLengthMeasure { & self . web_thickness } fn flange_thickness (& self) -> & IfcPositiveLengthMeasure { & self . flange_thickness } fn fillet_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . fillet_radius } fn edge_radius (& self) -> & Option < IfcNonNegativeLengthMeasure > { & self . edge_radius } } impl IfcZShapeProfileDef { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcZShapeProfileDef :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . profile_type = parameter . into () , 1usize => entity . profile_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . position = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . depth = parameter . into () , 4usize => entity . flange_width = parameter . into () , 5usize => entity . web_thickness = parameter . into () , 6usize => entity . flange_thickness = parameter . into () , 7usize => entity . fillet_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , 8usize => entity . edge_radius = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } pub trait IIfcZone : IIfcSystem { pub fn long_name (& self) -> & Option < IfcLabel > ; } # [derive (Default , Debug)] pub struct IfcZone { global_id : IfcGloballyUniqueId , owner_history : Option < EntityRef < IfcOwnerHistory > > , name : Option < IfcLabel > , description : Option < IfcText > , object_type : Option < IfcLabel > , long_name : Option < IfcLabel > , } impl IIfcRoot for IfcZone { fn global_id (& self) -> & IfcGloballyUniqueId { & self . global_id } fn owner_history (& self) -> & Option < EntityRef < IfcOwnerHistory > > { & self . owner_history } fn name (& self) -> & Option < IfcLabel > { & self . name } fn description (& self) -> & Option < IfcText > { & self . description } } impl IIfcObjectDefinition for IfcZone { } impl IIfcObject for IfcZone { fn object_type (& self) -> & Option < IfcLabel > { & self . object_type } } impl IIfcGroup for IfcZone { } impl IIfcSystem for IfcZone { } impl IIfcZone for IfcZone { fn long_name (& self) -> & Option < IfcLabel > { & self . long_name } } impl IfcZone { pub fn form_parameters (parameters : Vec < Parameter >) -> Self { let mut entity = IfcZone :: default () ; for (index , parameter) in parameters . into_iter () . enumerate () { match index { 0usize => entity . global_id = parameter . into () , 1usize => entity . owner_history = if parameter . is_null () { None } else { Some (parameter . into ()) } , 2usize => entity . name = if parameter . is_null () { None } else { Some (parameter . into ()) } , 3usize => entity . description = if parameter . is_null () { None } else { Some (parameter . into ()) } , 4usize => entity . object_type = if parameter . is_null () { None } else { Some (parameter . into ()) } , 5usize => entity . long_name = if parameter . is_null () { None } else { Some (parameter . into ()) } , _ => { } } } entity } } use std :: any :: { Any , TypeId } ; use std :: collections :: { BTreeMap , HashMap } ; pub struct Ifc4Reader { pub entities : BTreeMap < i64 , Box < dyn Any >> , pub type_ids : HashMap < TypeId , Vec < i64 >> , pub type_names : HashMap < TypeId , & 'static str > , empty : Vec < i64 > , } impl Ifc4Reader { pub fn new () -> Self { Ifc4Reader { entities : BTreeMap :: new () , type_ids : HashMap :: new () , type_names : HashMap :: new () , empty : Vec :: new () , } } pub fn add_entity < T : Any > (& mut self , id : i64 , entity : T) { let type_id = entity . type_id () ; self . entities . insert (id , Box :: new (entity)) ; self . type_ids . entry (type_id) . or_insert (vec ! []) . push (id) ; self . type_names . entry (type_id) . or_insert (std :: any :: type_name :: < T > ()) ; } pub fn get_entity < T : Any > (& self , entity_ref : EntityRef < T >) -> Option < & T > { self . entities . get (& entity_ref . 0) . map (| entity | entity . downcast_ref :: < T > ()) . flatten () } pub fn get_entities < T : Any > (& self) -> impl Iterator < Item = & T > { let type_id = TypeId :: of :: < T > () ; self . type_ids . get (& type_id) . unwrap_or (& self . empty) . iter () . map (move | id | self . entities [id] . downcast_ref :: < T > () . unwrap ()) } pub fn get_type_name (& self , id : i64) -> & 'static str { let type_id = (* self . entities [& id]) . type_id () ; self . type_names [& type_id] } } impl StepReader for Ifc4Reader { fn read_simple_entity (& mut self , id : i64 , typed_parameter : TypedParameter) { match typed_parameter . type_name . as_str () { "IFCACTIONREQUEST" => { let entity = IfcActionRequest :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCACTOR" => { let entity = IfcActor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCACTORROLE" => { let entity = IfcActorRole :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCACTUATOR" => { let entity = IfcActuator :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCACTUATORTYPE" => { let entity = IfcActuatorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCADVANCEDBREP" => { let entity = IfcAdvancedBrep :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCADVANCEDBREPWITHVOIDS" => { let entity = IfcAdvancedBrepWithVoids :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCADVANCEDFACE" => { let entity = IfcAdvancedFace :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAIRTERMINAL" => { let entity = IfcAirTerminal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAIRTERMINALBOX" => { let entity = IfcAirTerminalBox :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAIRTERMINALBOXTYPE" => { let entity = IfcAirTerminalBoxType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAIRTERMINALTYPE" => { let entity = IfcAirTerminalType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAIRTOAIRHEATRECOVERY" => { let entity = IfcAirToAirHeatRecovery :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAIRTOAIRHEATRECOVERYTYPE" => { let entity = IfcAirToAirHeatRecoveryType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCALARM" => { let entity = IfcAlarm :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCALARMTYPE" => { let entity = IfcAlarmType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCANNOTATION" => { let entity = IfcAnnotation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCANNOTATIONFILLAREA" => { let entity = IfcAnnotationFillArea :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAPPLICATION" => { let entity = IfcApplication :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAPPLIEDVALUE" => { let entity = IfcAppliedValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAPPROVAL" => { let entity = IfcApproval :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAPPROVALRELATIONSHIP" => { let entity = IfcApprovalRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCARBITRARYCLOSEDPROFILEDEF" => { let entity = IfcArbitraryClosedProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCARBITRARYOPENPROFILEDEF" => { let entity = IfcArbitraryOpenProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCARBITRARYPROFILEDEFWITHVOIDS" => { let entity = IfcArbitraryProfileDefWithVoids :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCASSET" => { let entity = IfcAsset :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCASYMMETRICISHAPEPROFILEDEF" => { let entity = IfcAsymmetricIShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAUDIOVISUALAPPLIANCE" => { let entity = IfcAudioVisualAppliance :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAUDIOVISUALAPPLIANCETYPE" => { let entity = IfcAudioVisualApplianceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAXIS1PLACEMENT" => { let entity = IfcAxis1Placement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAXIS2PLACEMENT2D" => { let entity = IfcAxis2Placement2D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCAXIS2PLACEMENT3D" => { let entity = IfcAxis2Placement3D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBSPLINECURVEWITHKNOTS" => { let entity = IfcBSplineCurveWithKnots :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBSPLINESURFACEWITHKNOTS" => { let entity = IfcBSplineSurfaceWithKnots :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBEAM" => { let entity = IfcBeam :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBEAMSTANDARDCASE" => { let entity = IfcBeamStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBEAMTYPE" => { let entity = IfcBeamType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBLOBTEXTURE" => { let entity = IfcBlobTexture :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBLOCK" => { let entity = IfcBlock :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOILER" => { let entity = IfcBoiler :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOILERTYPE" => { let entity = IfcBoilerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOOLEANCLIPPINGRESULT" => { let entity = IfcBooleanClippingResult :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOOLEANRESULT" => { let entity = IfcBooleanResult :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOUNDARYCURVE" => { let entity = IfcBoundaryCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOUNDARYEDGECONDITION" => { let entity = IfcBoundaryEdgeCondition :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOUNDARYFACECONDITION" => { let entity = IfcBoundaryFaceCondition :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOUNDARYNODECONDITION" => { let entity = IfcBoundaryNodeCondition :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOUNDARYNODECONDITIONWARPING" => { let entity = IfcBoundaryNodeConditionWarping :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOUNDINGBOX" => { let entity = IfcBoundingBox :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBOXEDHALFSPACE" => { let entity = IfcBoxedHalfSpace :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDING" => { let entity = IfcBuilding :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDINGELEMENTPART" => { let entity = IfcBuildingElementPart :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDINGELEMENTPARTTYPE" => { let entity = IfcBuildingElementPartType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDINGELEMENTPROXY" => { let entity = IfcBuildingElementProxy :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDINGELEMENTPROXYTYPE" => { let entity = IfcBuildingElementProxyType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDINGSTOREY" => { let entity = IfcBuildingStorey :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBUILDINGSYSTEM" => { let entity = IfcBuildingSystem :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBURNER" => { let entity = IfcBurner :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCBURNERTYPE" => { let entity = IfcBurnerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCSHAPEPROFILEDEF" => { let entity = IfcCShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLECARRIERFITTING" => { let entity = IfcCableCarrierFitting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLECARRIERFITTINGTYPE" => { let entity = IfcCableCarrierFittingType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLECARRIERSEGMENT" => { let entity = IfcCableCarrierSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLECARRIERSEGMENTTYPE" => { let entity = IfcCableCarrierSegmentType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLEFITTING" => { let entity = IfcCableFitting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLEFITTINGTYPE" => { let entity = IfcCableFittingType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLESEGMENT" => { let entity = IfcCableSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCABLESEGMENTTYPE" => { let entity = IfcCableSegmentType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANPOINT" => { let entity = IfcCartesianPoint :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANPOINTLIST2D" => { let entity = IfcCartesianPointList2D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANPOINTLIST3D" => { let entity = IfcCartesianPointList3D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANTRANSFORMATIONOPERATOR2D" => { let entity = IfcCartesianTransformationOperator2D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM" => { let entity = IfcCartesianTransformationOperator2DnonUniform :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANTRANSFORMATIONOPERATOR3D" => { let entity = IfcCartesianTransformationOperator3D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM" => { let entity = IfcCartesianTransformationOperator3DnonUniform :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCENTERLINEPROFILEDEF" => { let entity = IfcCenterLineProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCHILLER" => { let entity = IfcChiller :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCHILLERTYPE" => { let entity = IfcChillerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCHIMNEY" => { let entity = IfcChimney :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCHIMNEYTYPE" => { let entity = IfcChimneyType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCIRCLE" => { let entity = IfcCircle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCIRCLEHOLLOWPROFILEDEF" => { let entity = IfcCircleHollowProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCIRCLEPROFILEDEF" => { let entity = IfcCircleProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCIVILELEMENT" => { let entity = IfcCivilElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCIVILELEMENTTYPE" => { let entity = IfcCivilElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCLASSIFICATION" => { let entity = IfcClassification :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCLASSIFICATIONREFERENCE" => { let entity = IfcClassificationReference :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCLOSEDSHELL" => { let entity = IfcClosedShell :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOIL" => { let entity = IfcCoil :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOILTYPE" => { let entity = IfcCoilType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOLOURRGB" => { let entity = IfcColourRgb :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOLOURRGBLIST" => { let entity = IfcColourRgbList :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOLUMN" => { let entity = IfcColumn :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOLUMNSTANDARDCASE" => { let entity = IfcColumnStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOLUMNTYPE" => { let entity = IfcColumnType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMMUNICATIONSAPPLIANCE" => { let entity = IfcCommunicationsAppliance :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMMUNICATIONSAPPLIANCETYPE" => { let entity = IfcCommunicationsApplianceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPLEXPROPERTY" => { let entity = IfcComplexProperty :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPLEXPROPERTYTEMPLATE" => { let entity = IfcComplexPropertyTemplate :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPOSITECURVE" => { let entity = IfcCompositeCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPOSITECURVEONSURFACE" => { let entity = IfcCompositeCurveOnSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPOSITECURVESEGMENT" => { let entity = IfcCompositeCurveSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPOSITEPROFILEDEF" => { let entity = IfcCompositeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPRESSOR" => { let entity = IfcCompressor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOMPRESSORTYPE" => { let entity = IfcCompressorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONDENSER" => { let entity = IfcCondenser :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONDENSERTYPE" => { let entity = IfcCondenserType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONNECTEDFACESET" => { let entity = IfcConnectedFaceSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONNECTIONCURVEGEOMETRY" => { let entity = IfcConnectionCurveGeometry :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONNECTIONPOINTECCENTRICITY" => { let entity = IfcConnectionPointEccentricity :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONNECTIONPOINTGEOMETRY" => { let entity = IfcConnectionPointGeometry :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONNECTIONSURFACEGEOMETRY" => { let entity = IfcConnectionSurfaceGeometry :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONNECTIONVOLUMEGEOMETRY" => { let entity = IfcConnectionVolumeGeometry :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONSTRUCTIONEQUIPMENTRESOURCE" => { let entity = IfcConstructionEquipmentResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE" => { let entity = IfcConstructionEquipmentResourceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONSTRUCTIONMATERIALRESOURCE" => { let entity = IfcConstructionMaterialResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONSTRUCTIONMATERIALRESOURCETYPE" => { let entity = IfcConstructionMaterialResourceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONSTRUCTIONPRODUCTRESOURCE" => { let entity = IfcConstructionProductResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONSTRUCTIONPRODUCTRESOURCETYPE" => { let entity = IfcConstructionProductResourceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONTEXTDEPENDENTUNIT" => { let entity = IfcContextDependentUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONTROLLER" => { let entity = IfcController :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONTROLLERTYPE" => { let entity = IfcControllerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONVERSIONBASEDUNIT" => { let entity = IfcConversionBasedUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCONVERSIONBASEDUNITWITHOFFSET" => { let entity = IfcConversionBasedUnitWithOffset :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOOLEDBEAM" => { let entity = IfcCooledBeam :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOOLEDBEAMTYPE" => { let entity = IfcCooledBeamType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOOLINGTOWER" => { let entity = IfcCoolingTower :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOOLINGTOWERTYPE" => { let entity = IfcCoolingTowerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOSTITEM" => { let entity = IfcCostItem :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOSTSCHEDULE" => { let entity = IfcCostSchedule :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOSTVALUE" => { let entity = IfcCostValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOVERING" => { let entity = IfcCovering :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCOVERINGTYPE" => { let entity = IfcCoveringType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCREWRESOURCE" => { let entity = IfcCrewResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCREWRESOURCETYPE" => { let entity = IfcCrewResourceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCSGSOLID" => { let entity = IfcCsgSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURRENCYRELATIONSHIP" => { let entity = IfcCurrencyRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURTAINWALL" => { let entity = IfcCurtainWall :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURTAINWALLTYPE" => { let entity = IfcCurtainWallType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURVEBOUNDEDPLANE" => { let entity = IfcCurveBoundedPlane :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURVEBOUNDEDSURFACE" => { let entity = IfcCurveBoundedSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURVESTYLE" => { let entity = IfcCurveStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURVESTYLEFONT" => { let entity = IfcCurveStyleFont :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURVESTYLEFONTANDSCALING" => { let entity = IfcCurveStyleFontAndScaling :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCURVESTYLEFONTPATTERN" => { let entity = IfcCurveStyleFontPattern :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCCYLINDRICALSURFACE" => { let entity = IfcCylindricalSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDAMPER" => { let entity = IfcDamper :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDAMPERTYPE" => { let entity = IfcDamperType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDERIVEDPROFILEDEF" => { let entity = IfcDerivedProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDERIVEDUNIT" => { let entity = IfcDerivedUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDERIVEDUNITELEMENT" => { let entity = IfcDerivedUnitElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDIMENSIONALEXPONENTS" => { let entity = IfcDimensionalExponents :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDIRECTION" => { let entity = IfcDirection :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISCRETEACCESSORY" => { let entity = IfcDiscreteAccessory :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISCRETEACCESSORYTYPE" => { let entity = IfcDiscreteAccessoryType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONCHAMBERELEMENT" => { let entity = IfcDistributionChamberElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONCHAMBERELEMENTTYPE" => { let entity = IfcDistributionChamberElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONCIRCUIT" => { let entity = IfcDistributionCircuit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONCONTROLELEMENT" => { let entity = IfcDistributionControlElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONELEMENT" => { let entity = IfcDistributionElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONELEMENTTYPE" => { let entity = IfcDistributionElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONFLOWELEMENT" => { let entity = IfcDistributionFlowElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONPORT" => { let entity = IfcDistributionPort :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDISTRIBUTIONSYSTEM" => { let entity = IfcDistributionSystem :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOCUMENTINFORMATION" => { let entity = IfcDocumentInformation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOCUMENTINFORMATIONRELATIONSHIP" => { let entity = IfcDocumentInformationRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOCUMENTREFERENCE" => { let entity = IfcDocumentReference :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOOR" => { let entity = IfcDoor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOORLININGPROPERTIES" => { let entity = IfcDoorLiningProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOORPANELPROPERTIES" => { let entity = IfcDoorPanelProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOORSTANDARDCASE" => { let entity = IfcDoorStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOORSTYLE" => { let entity = IfcDoorStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDOORTYPE" => { let entity = IfcDoorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDRAUGHTINGPREDEFINEDCOLOUR" => { let entity = IfcDraughtingPreDefinedColour :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDRAUGHTINGPREDEFINEDCURVEFONT" => { let entity = IfcDraughtingPreDefinedCurveFont :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDUCTFITTING" => { let entity = IfcDuctFitting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDUCTFITTINGTYPE" => { let entity = IfcDuctFittingType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDUCTSEGMENT" => { let entity = IfcDuctSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDUCTSEGMENTTYPE" => { let entity = IfcDuctSegmentType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDUCTSILENCER" => { let entity = IfcDuctSilencer :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCDUCTSILENCERTYPE" => { let entity = IfcDuctSilencerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEDGE" => { let entity = IfcEdge :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEDGECURVE" => { let entity = IfcEdgeCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEDGELOOP" => { let entity = IfcEdgeLoop :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICAPPLIANCE" => { let entity = IfcElectricAppliance :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICAPPLIANCETYPE" => { let entity = IfcElectricApplianceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICDISTRIBUTIONBOARD" => { let entity = IfcElectricDistributionBoard :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICDISTRIBUTIONBOARDTYPE" => { let entity = IfcElectricDistributionBoardType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICFLOWSTORAGEDEVICE" => { let entity = IfcElectricFlowStorageDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICFLOWSTORAGEDEVICETYPE" => { let entity = IfcElectricFlowStorageDeviceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICGENERATOR" => { let entity = IfcElectricGenerator :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICGENERATORTYPE" => { let entity = IfcElectricGeneratorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICMOTOR" => { let entity = IfcElectricMotor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICMOTORTYPE" => { let entity = IfcElectricMotorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICTIMECONTROL" => { let entity = IfcElectricTimeControl :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELECTRICTIMECONTROLTYPE" => { let entity = IfcElectricTimeControlType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELEMENTASSEMBLY" => { let entity = IfcElementAssembly :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELEMENTASSEMBLYTYPE" => { let entity = IfcElementAssemblyType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELEMENTQUANTITY" => { let entity = IfcElementQuantity :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELLIPSE" => { let entity = IfcEllipse :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCELLIPSEPROFILEDEF" => { let entity = IfcEllipseProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCENERGYCONVERSIONDEVICE" => { let entity = IfcEnergyConversionDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCENGINE" => { let entity = IfcEngine :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCENGINETYPE" => { let entity = IfcEngineType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVAPORATIVECOOLER" => { let entity = IfcEvaporativeCooler :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVAPORATIVECOOLERTYPE" => { let entity = IfcEvaporativeCoolerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVAPORATOR" => { let entity = IfcEvaporator :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVAPORATORTYPE" => { let entity = IfcEvaporatorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVENT" => { let entity = IfcEvent :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVENTTIME" => { let entity = IfcEventTime :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEVENTTYPE" => { let entity = IfcEventType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTERNALREFERENCERELATIONSHIP" => { let entity = IfcExternalReferenceRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTERNALSPATIALELEMENT" => { let entity = IfcExternalSpatialElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTERNALLYDEFINEDHATCHSTYLE" => { let entity = IfcExternallyDefinedHatchStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTERNALLYDEFINEDSURFACESTYLE" => { let entity = IfcExternallyDefinedSurfaceStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTERNALLYDEFINEDTEXTFONT" => { let entity = IfcExternallyDefinedTextFont :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTRUDEDAREASOLID" => { let entity = IfcExtrudedAreaSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCEXTRUDEDAREASOLIDTAPERED" => { let entity = IfcExtrudedAreaSolidTapered :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACE" => { let entity = IfcFace :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACEBASEDSURFACEMODEL" => { let entity = IfcFaceBasedSurfaceModel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACEBOUND" => { let entity = IfcFaceBound :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACEOUTERBOUND" => { let entity = IfcFaceOuterBound :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACESURFACE" => { let entity = IfcFaceSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACETEDBREP" => { let entity = IfcFacetedBrep :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFACETEDBREPWITHVOIDS" => { let entity = IfcFacetedBrepWithVoids :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFAILURECONNECTIONCONDITION" => { let entity = IfcFailureConnectionCondition :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFAN" => { let entity = IfcFan :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFANTYPE" => { let entity = IfcFanType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFASTENER" => { let entity = IfcFastener :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFASTENERTYPE" => { let entity = IfcFastenerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFILLAREASTYLE" => { let entity = IfcFillAreaStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFILLAREASTYLEHATCHING" => { let entity = IfcFillAreaStyleHatching :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFILLAREASTYLETILES" => { let entity = IfcFillAreaStyleTiles :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFILTER" => { let entity = IfcFilter :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFILTERTYPE" => { let entity = IfcFilterType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFIRESUPPRESSIONTERMINAL" => { let entity = IfcFireSuppressionTerminal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFIRESUPPRESSIONTERMINALTYPE" => { let entity = IfcFireSuppressionTerminalType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFIXEDREFERENCESWEPTAREASOLID" => { let entity = IfcFixedReferenceSweptAreaSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWCONTROLLER" => { let entity = IfcFlowController :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWFITTING" => { let entity = IfcFlowFitting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWINSTRUMENT" => { let entity = IfcFlowInstrument :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWINSTRUMENTTYPE" => { let entity = IfcFlowInstrumentType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWMETER" => { let entity = IfcFlowMeter :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWMETERTYPE" => { let entity = IfcFlowMeterType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWMOVINGDEVICE" => { let entity = IfcFlowMovingDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWSEGMENT" => { let entity = IfcFlowSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWSTORAGEDEVICE" => { let entity = IfcFlowStorageDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWTERMINAL" => { let entity = IfcFlowTerminal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFLOWTREATMENTDEVICE" => { let entity = IfcFlowTreatmentDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFOOTING" => { let entity = IfcFooting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFOOTINGTYPE" => { let entity = IfcFootingType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFURNISHINGELEMENT" => { let entity = IfcFurnishingElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFURNISHINGELEMENTTYPE" => { let entity = IfcFurnishingElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFURNITURE" => { let entity = IfcFurniture :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCFURNITURETYPE" => { let entity = IfcFurnitureType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGEOGRAPHICELEMENT" => { let entity = IfcGeographicElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGEOGRAPHICELEMENTTYPE" => { let entity = IfcGeographicElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGEOMETRICCURVESET" => { let entity = IfcGeometricCurveSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGEOMETRICREPRESENTATIONCONTEXT" => { let entity = IfcGeometricRepresentationContext :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGEOMETRICREPRESENTATIONSUBCONTEXT" => { let entity = IfcGeometricRepresentationSubContext :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGEOMETRICSET" => { let entity = IfcGeometricSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGRID" => { let entity = IfcGrid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGRIDAXIS" => { let entity = IfcGridAxis :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGRIDPLACEMENT" => { let entity = IfcGridPlacement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCGROUP" => { let entity = IfcGroup :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCHALFSPACESOLID" => { let entity = IfcHalfSpaceSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCHEATEXCHANGER" => { let entity = IfcHeatExchanger :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCHEATEXCHANGERTYPE" => { let entity = IfcHeatExchangerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCHUMIDIFIER" => { let entity = IfcHumidifier :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCHUMIDIFIERTYPE" => { let entity = IfcHumidifierType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCISHAPEPROFILEDEF" => { let entity = IfcIShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCIMAGETEXTURE" => { let entity = IfcImageTexture :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINDEXEDCOLOURMAP" => { let entity = IfcIndexedColourMap :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINDEXEDPOLYCURVE" => { let entity = IfcIndexedPolyCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINDEXEDPOLYGONALFACE" => { let entity = IfcIndexedPolygonalFace :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINDEXEDPOLYGONALFACEWITHVOIDS" => { let entity = IfcIndexedPolygonalFaceWithVoids :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINDEXEDTRIANGLETEXTUREMAP" => { let entity = IfcIndexedTriangleTextureMap :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINTERCEPTOR" => { let entity = IfcInterceptor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINTERCEPTORTYPE" => { let entity = IfcInterceptorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINTERSECTIONCURVE" => { let entity = IfcIntersectionCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCINVENTORY" => { let entity = IfcInventory :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCIRREGULARTIMESERIES" => { let entity = IfcIrregularTimeSeries :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCIRREGULARTIMESERIESVALUE" => { let entity = IfcIrregularTimeSeriesValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCJUNCTIONBOX" => { let entity = IfcJunctionBox :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCJUNCTIONBOXTYPE" => { let entity = IfcJunctionBoxType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLSHAPEPROFILEDEF" => { let entity = IfcLShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLABORRESOURCE" => { let entity = IfcLaborResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLABORRESOURCETYPE" => { let entity = IfcLaborResourceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLAGTIME" => { let entity = IfcLagTime :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLAMP" => { let entity = IfcLamp :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLAMPTYPE" => { let entity = IfcLampType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIBRARYINFORMATION" => { let entity = IfcLibraryInformation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIBRARYREFERENCE" => { let entity = IfcLibraryReference :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTDISTRIBUTIONDATA" => { let entity = IfcLightDistributionData :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTFIXTURE" => { let entity = IfcLightFixture :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTFIXTURETYPE" => { let entity = IfcLightFixtureType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTINTENSITYDISTRIBUTION" => { let entity = IfcLightIntensityDistribution :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTSOURCEAMBIENT" => { let entity = IfcLightSourceAmbient :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTSOURCEDIRECTIONAL" => { let entity = IfcLightSourceDirectional :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTSOURCEGONIOMETRIC" => { let entity = IfcLightSourceGoniometric :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTSOURCEPOSITIONAL" => { let entity = IfcLightSourcePositional :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLIGHTSOURCESPOT" => { let entity = IfcLightSourceSpot :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLINE" => { let entity = IfcLine :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLOCALPLACEMENT" => { let entity = IfcLocalPlacement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCLOOP" => { let entity = IfcLoop :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMAPCONVERSION" => { let entity = IfcMapConversion :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMAPPEDITEM" => { let entity = IfcMappedItem :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIAL" => { let entity = IfcMaterial :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALCLASSIFICATIONRELATIONSHIP" => { let entity = IfcMaterialClassificationRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALCONSTITUENT" => { let entity = IfcMaterialConstituent :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALCONSTITUENTSET" => { let entity = IfcMaterialConstituentSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALDEFINITIONREPRESENTATION" => { let entity = IfcMaterialDefinitionRepresentation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALLAYER" => { let entity = IfcMaterialLayer :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALLAYERSET" => { let entity = IfcMaterialLayerSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALLAYERSETUSAGE" => { let entity = IfcMaterialLayerSetUsage :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALLAYERWITHOFFSETS" => { let entity = IfcMaterialLayerWithOffsets :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALLIST" => { let entity = IfcMaterialList :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALPROFILE" => { let entity = IfcMaterialProfile :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALPROFILESET" => { let entity = IfcMaterialProfileSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALPROFILESETUSAGE" => { let entity = IfcMaterialProfileSetUsage :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALPROFILESETUSAGETAPERING" => { let entity = IfcMaterialProfileSetUsageTapering :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALPROFILEWITHOFFSETS" => { let entity = IfcMaterialProfileWithOffsets :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALPROPERTIES" => { let entity = IfcMaterialProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMATERIALRELATIONSHIP" => { let entity = IfcMaterialRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMEASUREWITHUNIT" => { let entity = IfcMeasureWithUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMECHANICALFASTENER" => { let entity = IfcMechanicalFastener :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMECHANICALFASTENERTYPE" => { let entity = IfcMechanicalFastenerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMEDICALDEVICE" => { let entity = IfcMedicalDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMEDICALDEVICETYPE" => { let entity = IfcMedicalDeviceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMEMBER" => { let entity = IfcMember :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMEMBERSTANDARDCASE" => { let entity = IfcMemberStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMEMBERTYPE" => { let entity = IfcMemberType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMETRIC" => { let entity = IfcMetric :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMIRROREDPROFILEDEF" => { let entity = IfcMirroredProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMONETARYUNIT" => { let entity = IfcMonetaryUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMOTORCONNECTION" => { let entity = IfcMotorConnection :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCMOTORCONNECTIONTYPE" => { let entity = IfcMotorConnectionType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOBJECTIVE" => { let entity = IfcObjective :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOCCUPANT" => { let entity = IfcOccupant :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOFFSETCURVE2D" => { let entity = IfcOffsetCurve2D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOFFSETCURVE3D" => { let entity = IfcOffsetCurve3D :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOPENSHELL" => { let entity = IfcOpenShell :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOPENINGELEMENT" => { let entity = IfcOpeningElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOPENINGSTANDARDCASE" => { let entity = IfcOpeningStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCORGANIZATION" => { let entity = IfcOrganization :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCORGANIZATIONRELATIONSHIP" => { let entity = IfcOrganizationRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCORIENTEDEDGE" => { let entity = IfcOrientedEdge :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOUTERBOUNDARYCURVE" => { let entity = IfcOuterBoundaryCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOUTLET" => { let entity = IfcOutlet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOUTLETTYPE" => { let entity = IfcOutletType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCOWNERHISTORY" => { let entity = IfcOwnerHistory :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPATH" => { let entity = IfcPath :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPCURVE" => { let entity = IfcPcurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPERFORMANCEHISTORY" => { let entity = IfcPerformanceHistory :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPERMEABLECOVERINGPROPERTIES" => { let entity = IfcPermeableCoveringProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPERMIT" => { let entity = IfcPermit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPERSON" => { let entity = IfcPerson :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPERSONANDORGANIZATION" => { let entity = IfcPersonAndOrganization :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPHYSICALCOMPLEXQUANTITY" => { let entity = IfcPhysicalComplexQuantity :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPILE" => { let entity = IfcPile :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPILETYPE" => { let entity = IfcPileType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPIPEFITTING" => { let entity = IfcPipeFitting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPIPEFITTINGTYPE" => { let entity = IfcPipeFittingType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPIPESEGMENT" => { let entity = IfcPipeSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPIPESEGMENTTYPE" => { let entity = IfcPipeSegmentType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPIXELTEXTURE" => { let entity = IfcPixelTexture :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPLANARBOX" => { let entity = IfcPlanarBox :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPLANAREXTENT" => { let entity = IfcPlanarExtent :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPLANE" => { let entity = IfcPlane :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPLATE" => { let entity = IfcPlate :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPLATESTANDARDCASE" => { let entity = IfcPlateStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPLATETYPE" => { let entity = IfcPlateType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOINTONCURVE" => { let entity = IfcPointOnCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOINTONSURFACE" => { let entity = IfcPointOnSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOLYLOOP" => { let entity = IfcPolyLoop :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOLYGONALBOUNDEDHALFSPACE" => { let entity = IfcPolygonalBoundedHalfSpace :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOLYGONALFACESET" => { let entity = IfcPolygonalFaceSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOLYLINE" => { let entity = IfcPolyline :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPOSTALADDRESS" => { let entity = IfcPostalAddress :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPRESENTATIONLAYERASSIGNMENT" => { let entity = IfcPresentationLayerAssignment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPRESENTATIONLAYERWITHSTYLE" => { let entity = IfcPresentationLayerWithStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPRESENTATIONSTYLEASSIGNMENT" => { let entity = IfcPresentationStyleAssignment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROCEDURE" => { let entity = IfcProcedure :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROCEDURETYPE" => { let entity = IfcProcedureType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPRODUCTDEFINITIONSHAPE" => { let entity = IfcProductDefinitionShape :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROFILEDEF" => { let entity = IfcProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROFILEPROPERTIES" => { let entity = IfcProfileProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROJECT" => { let entity = IfcProject :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROJECTLIBRARY" => { let entity = IfcProjectLibrary :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROJECTORDER" => { let entity = IfcProjectOrder :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROJECTEDCRS" => { let entity = IfcProjectedCrs :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROJECTIONELEMENT" => { let entity = IfcProjectionElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYBOUNDEDVALUE" => { let entity = IfcPropertyBoundedValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYDEPENDENCYRELATIONSHIP" => { let entity = IfcPropertyDependencyRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYENUMERATEDVALUE" => { let entity = IfcPropertyEnumeratedValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYENUMERATION" => { let entity = IfcPropertyEnumeration :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYLISTVALUE" => { let entity = IfcPropertyListValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYREFERENCEVALUE" => { let entity = IfcPropertyReferenceValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYSET" => { let entity = IfcPropertySet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYSETTEMPLATE" => { let entity = IfcPropertySetTemplate :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYSINGLEVALUE" => { let entity = IfcPropertySingleValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROPERTYTABLEVALUE" => { let entity = IfcPropertyTableValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROTECTIVEDEVICE" => { let entity = IfcProtectiveDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROTECTIVEDEVICETRIPPINGUNIT" => { let entity = IfcProtectiveDeviceTrippingUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE" => { let entity = IfcProtectiveDeviceTrippingUnitType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROTECTIVEDEVICETYPE" => { let entity = IfcProtectiveDeviceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPROXY" => { let entity = IfcProxy :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPUMP" => { let entity = IfcPump :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCPUMPTYPE" => { let entity = IfcPumpType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCQUANTITYAREA" => { let entity = IfcQuantityArea :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCQUANTITYCOUNT" => { let entity = IfcQuantityCount :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCQUANTITYLENGTH" => { let entity = IfcQuantityLength :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCQUANTITYTIME" => { let entity = IfcQuantityTime :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCQUANTITYVOLUME" => { let entity = IfcQuantityVolume :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCQUANTITYWEIGHT" => { let entity = IfcQuantityWeight :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRAILING" => { let entity = IfcRailing :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRAILINGTYPE" => { let entity = IfcRailingType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRAMP" => { let entity = IfcRamp :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRAMPFLIGHT" => { let entity = IfcRampFlight :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRAMPFLIGHTTYPE" => { let entity = IfcRampFlightType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRAMPTYPE" => { let entity = IfcRampType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRATIONALBSPLINECURVEWITHKNOTS" => { let entity = IfcRationalBSplineCurveWithKnots :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRATIONALBSPLINESURFACEWITHKNOTS" => { let entity = IfcRationalBSplineSurfaceWithKnots :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRECTANGLEHOLLOWPROFILEDEF" => { let entity = IfcRectangleHollowProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRECTANGLEPROFILEDEF" => { let entity = IfcRectangleProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRECTANGULARPYRAMID" => { let entity = IfcRectangularPyramid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRECTANGULARTRIMMEDSURFACE" => { let entity = IfcRectangularTrimmedSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRECURRENCEPATTERN" => { let entity = IfcRecurrencePattern :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREFERENCE" => { let entity = IfcReference :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREGULARTIMESERIES" => { let entity = IfcRegularTimeSeries :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREINFORCEMENTBARPROPERTIES" => { let entity = IfcReinforcementBarProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREINFORCEMENTDEFINITIONPROPERTIES" => { let entity = IfcReinforcementDefinitionProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREINFORCINGBAR" => { let entity = IfcReinforcingBar :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREINFORCINGBARTYPE" => { let entity = IfcReinforcingBarType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREINFORCINGMESH" => { let entity = IfcReinforcingMesh :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREINFORCINGMESHTYPE" => { let entity = IfcReinforcingMeshType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELAGGREGATES" => { let entity = IfcRelAggregates :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTOACTOR" => { let entity = IfcRelAssignsToActor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTOCONTROL" => { let entity = IfcRelAssignsToControl :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTOGROUP" => { let entity = IfcRelAssignsToGroup :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTOGROUPBYFACTOR" => { let entity = IfcRelAssignsToGroupByFactor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTOPROCESS" => { let entity = IfcRelAssignsToProcess :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTOPRODUCT" => { let entity = IfcRelAssignsToProduct :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSIGNSTORESOURCE" => { let entity = IfcRelAssignsToResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSOCIATESAPPROVAL" => { let entity = IfcRelAssociatesApproval :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSOCIATESCLASSIFICATION" => { let entity = IfcRelAssociatesClassification :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSOCIATESCONSTRAINT" => { let entity = IfcRelAssociatesConstraint :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSOCIATESDOCUMENT" => { let entity = IfcRelAssociatesDocument :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSOCIATESLIBRARY" => { let entity = IfcRelAssociatesLibrary :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELASSOCIATESMATERIAL" => { let entity = IfcRelAssociatesMaterial :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSELEMENTS" => { let entity = IfcRelConnectsElements :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSPATHELEMENTS" => { let entity = IfcRelConnectsPathElements :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSPORTTOELEMENT" => { let entity = IfcRelConnectsPortToElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSPORTS" => { let entity = IfcRelConnectsPorts :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSSTRUCTURALACTIVITY" => { let entity = IfcRelConnectsStructuralActivity :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSSTRUCTURALMEMBER" => { let entity = IfcRelConnectsStructuralMember :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSWITHECCENTRICITY" => { let entity = IfcRelConnectsWithEccentricity :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONNECTSWITHREALIZINGELEMENTS" => { let entity = IfcRelConnectsWithRealizingElements :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCONTAINEDINSPATIALSTRUCTURE" => { let entity = IfcRelContainedInSpatialStructure :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCOVERSBLDGELEMENTS" => { let entity = IfcRelCoversBldgElements :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELCOVERSSPACES" => { let entity = IfcRelCoversSpaces :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELDECLARES" => { let entity = IfcRelDeclares :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELDEFINESBYOBJECT" => { let entity = IfcRelDefinesByObject :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELDEFINESBYPROPERTIES" => { let entity = IfcRelDefinesByProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELDEFINESBYTEMPLATE" => { let entity = IfcRelDefinesByTemplate :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELDEFINESBYTYPE" => { let entity = IfcRelDefinesByType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELFILLSELEMENT" => { let entity = IfcRelFillsElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELFLOWCONTROLELEMENTS" => { let entity = IfcRelFlowControlElements :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELINTERFERESELEMENTS" => { let entity = IfcRelInterferesElements :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELNESTS" => { let entity = IfcRelNests :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELPROJECTSELEMENT" => { let entity = IfcRelProjectsElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELREFERENCEDINSPATIALSTRUCTURE" => { let entity = IfcRelReferencedInSpatialStructure :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELSEQUENCE" => { let entity = IfcRelSequence :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELSERVICESBUILDINGS" => { let entity = IfcRelServicesBuildings :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELSPACEBOUNDARY" => { let entity = IfcRelSpaceBoundary :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELSPACEBOUNDARY1STLEVEL" => { let entity = IfcRelSpaceBoundary1stLevel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELSPACEBOUNDARY2NDLEVEL" => { let entity = IfcRelSpaceBoundary2ndLevel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRELVOIDSELEMENT" => { let entity = IfcRelVoidsElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT" => { let entity = IfcReparametrisedCompositeCurveSegment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREPRESENTATIONMAP" => { let entity = IfcRepresentationMap :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRESOURCEAPPROVALRELATIONSHIP" => { let entity = IfcResourceApprovalRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRESOURCECONSTRAINTRELATIONSHIP" => { let entity = IfcResourceConstraintRelationship :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRESOURCETIME" => { let entity = IfcResourceTime :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREVOLVEDAREASOLID" => { let entity = IfcRevolvedAreaSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCREVOLVEDAREASOLIDTAPERED" => { let entity = IfcRevolvedAreaSolidTapered :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRIGHTCIRCULARCONE" => { let entity = IfcRightCircularCone :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCRIGHTCIRCULARCYLINDER" => { let entity = IfcRightCircularCylinder :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCROOF" => { let entity = IfcRoof :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCROOFTYPE" => { let entity = IfcRoofType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCROUNDEDRECTANGLEPROFILEDEF" => { let entity = IfcRoundedRectangleProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSIUNIT" => { let entity = IfcSiUnit :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSANITARYTERMINAL" => { let entity = IfcSanitaryTerminal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSANITARYTERMINALTYPE" => { let entity = IfcSanitaryTerminalType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSEAMCURVE" => { let entity = IfcSeamCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSECTIONPROPERTIES" => { let entity = IfcSectionProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSECTIONREINFORCEMENTPROPERTIES" => { let entity = IfcSectionReinforcementProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSECTIONEDSPINE" => { let entity = IfcSectionedSpine :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSENSOR" => { let entity = IfcSensor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSENSORTYPE" => { let entity = IfcSensorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSHADINGDEVICE" => { let entity = IfcShadingDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSHADINGDEVICETYPE" => { let entity = IfcShadingDeviceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSHAPEASPECT" => { let entity = IfcShapeAspect :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSHAPEREPRESENTATION" => { let entity = IfcShapeRepresentation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSHELLBASEDSURFACEMODEL" => { let entity = IfcShellBasedSurfaceModel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSIMPLEPROPERTYTEMPLATE" => { let entity = IfcSimplePropertyTemplate :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSITE" => { let entity = IfcSite :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSLAB" => { let entity = IfcSlab :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSLABELEMENTEDCASE" => { let entity = IfcSlabElementedCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSLABSTANDARDCASE" => { let entity = IfcSlabStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSLABTYPE" => { let entity = IfcSlabType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSLIPPAGECONNECTIONCONDITION" => { let entity = IfcSlippageConnectionCondition :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSOLARDEVICE" => { let entity = IfcSolarDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSOLARDEVICETYPE" => { let entity = IfcSolarDeviceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPACE" => { let entity = IfcSpace :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPACEHEATER" => { let entity = IfcSpaceHeater :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPACEHEATERTYPE" => { let entity = IfcSpaceHeaterType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPACETYPE" => { let entity = IfcSpaceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPATIALZONE" => { let entity = IfcSpatialZone :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPATIALZONETYPE" => { let entity = IfcSpatialZoneType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPHERE" => { let entity = IfcSphere :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSPHERICALSURFACE" => { let entity = IfcSphericalSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTACKTERMINAL" => { let entity = IfcStackTerminal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTACKTERMINALTYPE" => { let entity = IfcStackTerminalType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTAIR" => { let entity = IfcStair :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTAIRFLIGHT" => { let entity = IfcStairFlight :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTAIRFLIGHTTYPE" => { let entity = IfcStairFlightType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTAIRTYPE" => { let entity = IfcStairType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALANALYSISMODEL" => { let entity = IfcStructuralAnalysisModel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALCURVEACTION" => { let entity = IfcStructuralCurveAction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALCURVECONNECTION" => { let entity = IfcStructuralCurveConnection :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALCURVEMEMBER" => { let entity = IfcStructuralCurveMember :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALCURVEMEMBERVARYING" => { let entity = IfcStructuralCurveMemberVarying :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALCURVEREACTION" => { let entity = IfcStructuralCurveReaction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLINEARACTION" => { let entity = IfcStructuralLinearAction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADCASE" => { let entity = IfcStructuralLoadCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADCONFIGURATION" => { let entity = IfcStructuralLoadConfiguration :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADGROUP" => { let entity = IfcStructuralLoadGroup :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADLINEARFORCE" => { let entity = IfcStructuralLoadLinearForce :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADPLANARFORCE" => { let entity = IfcStructuralLoadPlanarForce :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADSINGLEDISPLACEMENT" => { let entity = IfcStructuralLoadSingleDisplacement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION" => { let entity = IfcStructuralLoadSingleDisplacementDistortion :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADSINGLEFORCE" => { let entity = IfcStructuralLoadSingleForce :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADSINGLEFORCEWARPING" => { let entity = IfcStructuralLoadSingleForceWarping :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALLOADTEMPERATURE" => { let entity = IfcStructuralLoadTemperature :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALPLANARACTION" => { let entity = IfcStructuralPlanarAction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALPOINTACTION" => { let entity = IfcStructuralPointAction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALPOINTCONNECTION" => { let entity = IfcStructuralPointConnection :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALPOINTREACTION" => { let entity = IfcStructuralPointReaction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALRESULTGROUP" => { let entity = IfcStructuralResultGroup :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALSURFACEACTION" => { let entity = IfcStructuralSurfaceAction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALSURFACECONNECTION" => { let entity = IfcStructuralSurfaceConnection :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALSURFACEMEMBER" => { let entity = IfcStructuralSurfaceMember :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALSURFACEMEMBERVARYING" => { let entity = IfcStructuralSurfaceMemberVarying :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTRUCTURALSURFACEREACTION" => { let entity = IfcStructuralSurfaceReaction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTYLEDITEM" => { let entity = IfcStyledItem :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSTYLEDREPRESENTATION" => { let entity = IfcStyledRepresentation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSUBCONTRACTRESOURCE" => { let entity = IfcSubContractResource :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSUBCONTRACTRESOURCETYPE" => { let entity = IfcSubContractResourceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSUBEDGE" => { let entity = IfcSubedge :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACECURVE" => { let entity = IfcSurfaceCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACECURVESWEPTAREASOLID" => { let entity = IfcSurfaceCurveSweptAreaSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACEFEATURE" => { let entity = IfcSurfaceFeature :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACEOFLINEAREXTRUSION" => { let entity = IfcSurfaceOfLinearExtrusion :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACEOFREVOLUTION" => { let entity = IfcSurfaceOfRevolution :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACEREINFORCEMENTAREA" => { let entity = IfcSurfaceReinforcementArea :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACESTYLE" => { let entity = IfcSurfaceStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACESTYLELIGHTING" => { let entity = IfcSurfaceStyleLighting :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACESTYLEREFRACTION" => { let entity = IfcSurfaceStyleRefraction :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACESTYLERENDERING" => { let entity = IfcSurfaceStyleRendering :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACESTYLESHADING" => { let entity = IfcSurfaceStyleShading :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSURFACESTYLEWITHTEXTURES" => { let entity = IfcSurfaceStyleWithTextures :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSWEPTDISKSOLID" => { let entity = IfcSweptDiskSolid :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSWEPTDISKSOLIDPOLYGONAL" => { let entity = IfcSweptDiskSolidPolygonal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSWITCHINGDEVICE" => { let entity = IfcSwitchingDevice :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSWITCHINGDEVICETYPE" => { let entity = IfcSwitchingDeviceType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSYSTEM" => { let entity = IfcSystem :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSYSTEMFURNITUREELEMENT" => { let entity = IfcSystemFurnitureElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCSYSTEMFURNITUREELEMENTTYPE" => { let entity = IfcSystemFurnitureElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTSHAPEPROFILEDEF" => { let entity = IfcTShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTABLE" => { let entity = IfcTable :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTABLECOLUMN" => { let entity = IfcTableColumn :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTABLEROW" => { let entity = IfcTableRow :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTANK" => { let entity = IfcTank :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTANKTYPE" => { let entity = IfcTankType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTASK" => { let entity = IfcTask :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTASKTIME" => { let entity = IfcTaskTime :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTASKTIMERECURRING" => { let entity = IfcTaskTimeRecurring :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTASKTYPE" => { let entity = IfcTaskType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTELECOMADDRESS" => { let entity = IfcTelecomAddress :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTENDON" => { let entity = IfcTendon :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTENDONANCHOR" => { let entity = IfcTendonAnchor :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTENDONANCHORTYPE" => { let entity = IfcTendonAnchorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTENDONTYPE" => { let entity = IfcTendonType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTLITERAL" => { let entity = IfcTextLiteral :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTLITERALWITHEXTENT" => { let entity = IfcTextLiteralWithExtent :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTSTYLE" => { let entity = IfcTextStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTSTYLEFONTMODEL" => { let entity = IfcTextStyleFontModel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTSTYLEFORDEFINEDFONT" => { let entity = IfcTextStyleForDefinedFont :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTSTYLETEXTMODEL" => { let entity = IfcTextStyleTextModel :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTURECOORDINATEGENERATOR" => { let entity = IfcTextureCoordinateGenerator :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTUREMAP" => { let entity = IfcTextureMap :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTUREVERTEX" => { let entity = IfcTextureVertex :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTEXTUREVERTEXLIST" => { let entity = IfcTextureVertexList :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTIMEPERIOD" => { let entity = IfcTimePeriod :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTIMESERIESVALUE" => { let entity = IfcTimeSeriesValue :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTOPOLOGYREPRESENTATION" => { let entity = IfcTopologyRepresentation :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTOROIDALSURFACE" => { let entity = IfcToroidalSurface :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRANSFORMER" => { let entity = IfcTransformer :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRANSFORMERTYPE" => { let entity = IfcTransformerType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRANSPORTELEMENT" => { let entity = IfcTransportElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRANSPORTELEMENTTYPE" => { let entity = IfcTransportElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRAPEZIUMPROFILEDEF" => { let entity = IfcTrapeziumProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRIANGULATEDFACESET" => { let entity = IfcTriangulatedFaceSet :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTRIMMEDCURVE" => { let entity = IfcTrimmedCurve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTUBEBUNDLE" => { let entity = IfcTubeBundle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTUBEBUNDLETYPE" => { let entity = IfcTubeBundleType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTYPEOBJECT" => { let entity = IfcTypeObject :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCTYPEPRODUCT" => { let entity = IfcTypeProduct :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCUSHAPEPROFILEDEF" => { let entity = IfcUShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCUNITASSIGNMENT" => { let entity = IfcUnitAssignment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCUNITARYCONTROLELEMENT" => { let entity = IfcUnitaryControlElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCUNITARYCONTROLELEMENTTYPE" => { let entity = IfcUnitaryControlElementType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCUNITARYEQUIPMENT" => { let entity = IfcUnitaryEquipment :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCUNITARYEQUIPMENTTYPE" => { let entity = IfcUnitaryEquipmentType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVALVE" => { let entity = IfcValve :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVALVETYPE" => { let entity = IfcValveType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVECTOR" => { let entity = IfcVector :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVERTEX" => { let entity = IfcVertex :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVERTEXLOOP" => { let entity = IfcVertexLoop :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVERTEXPOINT" => { let entity = IfcVertexPoint :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVIBRATIONISOLATOR" => { let entity = IfcVibrationIsolator :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVIBRATIONISOLATORTYPE" => { let entity = IfcVibrationIsolatorType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVIRTUALELEMENT" => { let entity = IfcVirtualElement :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVIRTUALGRIDINTERSECTION" => { let entity = IfcVirtualGridIntersection :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCVOIDINGFEATURE" => { let entity = IfcVoidingFeature :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWALL" => { let entity = IfcWall :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWALLELEMENTEDCASE" => { let entity = IfcWallElementedCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWALLSTANDARDCASE" => { let entity = IfcWallStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWALLTYPE" => { let entity = IfcWallType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWASTETERMINAL" => { let entity = IfcWasteTerminal :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWASTETERMINALTYPE" => { let entity = IfcWasteTerminalType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWINDOW" => { let entity = IfcWindow :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWINDOWLININGPROPERTIES" => { let entity = IfcWindowLiningProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWINDOWPANELPROPERTIES" => { let entity = IfcWindowPanelProperties :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWINDOWSTANDARDCASE" => { let entity = IfcWindowStandardCase :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWINDOWSTYLE" => { let entity = IfcWindowStyle :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWINDOWTYPE" => { let entity = IfcWindowType :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWORKCALENDAR" => { let entity = IfcWorkCalendar :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWORKPLAN" => { let entity = IfcWorkPlan :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWORKSCHEDULE" => { let entity = IfcWorkSchedule :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCWORKTIME" => { let entity = IfcWorkTime :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCZSHAPEPROFILEDEF" => { let entity = IfcZShapeProfileDef :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } "IFCZONE" => { let entity = IfcZone :: form_parameters (typed_parameter . parameters) ; self . add_entity (id , entity) ; } _ => println ! ("{} is not implemented" , typed_parameter . type_name) , } } }