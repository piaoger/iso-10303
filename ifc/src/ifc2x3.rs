#![doc = r" This file is generated. Do not edit."]
#![allow(dead_code)]
use iso_10303::step::*;
use std::collections::HashSet;
#[derive(Default, Debug)]
pub struct Unimplemented {}
impl From<Parameter> for Unimplemented {
    fn from(_parameter: Parameter) -> Self {
        Unimplemented {}
    }
}
type IfcAbsorbedDoseMeasure = Real;
type IfcAccelerationMeasure = Real;
type IfcAmountOfSubstanceMeasure = Real;
type IfcAngularVelocityMeasure = Real;
type IfcAreaMeasure = Real;
type IfcBoolean = bool;
type IfcBoxAlignment = IfcLabel;
type IfcComplexNumber = Vec<Real>;
type IfcCompoundPlaneAngleMeasure = Vec<i64>;
type IfcContextDependentMeasure = Real;
type IfcCountMeasure = Real;
type IfcCurvatureMeasure = Real;
type IfcDayInMonthNumber = i64;
type IfcDaylightSavingHour = i64;
type IfcDescriptiveMeasure = String;
type IfcDimensionCount = i64;
type IfcDoseEquivalentMeasure = Real;
type IfcDynamicViscosityMeasure = Real;
type IfcElectricCapacitanceMeasure = Real;
type IfcElectricChargeMeasure = Real;
type IfcElectricConductanceMeasure = Real;
type IfcElectricCurrentMeasure = Real;
type IfcElectricResistanceMeasure = Real;
type IfcElectricVoltageMeasure = Real;
type IfcEnergyMeasure = Real;
type IfcFontStyle = String;
type IfcFontVariant = String;
type IfcFontWeight = String;
type IfcForceMeasure = Real;
type IfcFrequencyMeasure = Real;
type IfcGloballyUniqueId = String;
type IfcHeatFluxDensityMeasure = Real;
type IfcHeatingValueMeasure = Real;
type IfcHourInDay = i64;
type IfcIdentifier = String;
type IfcIlluminanceMeasure = Real;
type IfcInductanceMeasure = Real;
type IfcInteger = i64;
type IfcIntegerCountRateMeasure = i64;
type IfcIonConcentrationMeasure = Real;
type IfcIsothermalMoistureCapacityMeasure = Real;
type IfcKinematicViscosityMeasure = Real;
type IfcLabel = String;
type IfcLengthMeasure = Real;
type IfcLinearForceMeasure = Real;
type IfcLinearMomentMeasure = Real;
type IfcLinearStiffnessMeasure = Real;
type IfcLinearVelocityMeasure = Real;
type IfcLogical = Option<bool>;
type IfcLuminousFluxMeasure = Real;
type IfcLuminousIntensityDistributionMeasure = Real;
type IfcLuminousIntensityMeasure = Real;
type IfcMagneticFluxDensityMeasure = Real;
type IfcMagneticFluxMeasure = Real;
type IfcMassDensityMeasure = Real;
type IfcMassFlowRateMeasure = Real;
type IfcMassMeasure = Real;
type IfcMassPerLengthMeasure = Real;
type IfcMinuteInHour = i64;
type IfcModulusOfElasticityMeasure = Real;
type IfcModulusOfLinearSubgradeReactionMeasure = Real;
type IfcModulusOfRotationalSubgradeReactionMeasure = Real;
type IfcModulusOfSubgradeReactionMeasure = Real;
type IfcMoistureDiffusivityMeasure = Real;
type IfcMolecularWeightMeasure = Real;
type IfcMomentOfInertiaMeasure = Real;
type IfcMonetaryMeasure = Real;
type IfcMonthInYearNumber = i64;
type IfcNormalisedRatioMeasure = IfcRatioMeasure;
type IfcNumericMeasure = Real;
type IfcPhMeasure = Real;
type IfcParameterValue = Real;
type IfcPlanarForceMeasure = Real;
type IfcPlaneAngleMeasure = Real;
type IfcPositiveLengthMeasure = IfcLengthMeasure;
type IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;
type IfcPositiveRatioMeasure = IfcRatioMeasure;
type IfcPowerMeasure = Real;
type IfcPresentableText = String;
type IfcPressureMeasure = Real;
type IfcRadioActivityMeasure = Real;
type IfcRatioMeasure = Real;
type IfcReal = Real;
type IfcRotationalFrequencyMeasure = Real;
type IfcRotationalMassMeasure = Real;
type IfcRotationalStiffnessMeasure = Real;
type IfcSecondInMinute = Real;
type IfcSectionModulusMeasure = Real;
type IfcSectionalAreaIntegralMeasure = Real;
type IfcShearModulusMeasure = Real;
type IfcSolidAngleMeasure = Real;
type IfcSoundPowerMeasure = Real;
type IfcSoundPressureMeasure = Real;
type IfcSpecificHeatCapacityMeasure = Real;
type IfcSpecularExponent = Real;
type IfcSpecularRoughness = Real;
type IfcTemperatureGradientMeasure = Real;
type IfcText = String;
type IfcTextAlignment = String;
type IfcTextDecoration = String;
type IfcTextFontName = String;
type IfcTextTransformation = String;
type IfcThermalAdmittanceMeasure = Real;
type IfcThermalConductivityMeasure = Real;
type IfcThermalExpansionCoefficientMeasure = Real;
type IfcThermalResistanceMeasure = Real;
type IfcThermalTransmittanceMeasure = Real;
type IfcThermodynamicTemperatureMeasure = Real;
type IfcTimeMeasure = Real;
type IfcTimeStamp = i64;
type IfcTorqueMeasure = Real;
type IfcVaporPermeabilityMeasure = Real;
type IfcVolumeMeasure = Real;
type IfcVolumetricFlowRateMeasure = Real;
type IfcWarpingConstantMeasure = Real;
type IfcWarpingMomentMeasure = Real;
type IfcYearNumber = i64;
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActionSourceTypeEnum {
    DeadLoadG,
    CompletionG1,
    LiveLoadQ,
    SnowS,
    WindW,
    PrestressingP,
    SettlementU,
    TemperatureT,
    EarthquakeE,
    Fire,
    Impulse,
    Impact,
    Transport,
    Erection,
    Propping,
    SystemImperfection,
    Shrinkage,
    Creep,
    LackOfFit,
    Buoyancy,
    Ice,
    Current,
    Wave,
    Rain,
    Brakes,
    Userdefined,
    Notdefined,
}
impl Default for IfcActionSourceTypeEnum {
    fn default() -> Self {
        IfcActionSourceTypeEnum::DeadLoadG
    }
}
impl From<String> for IfcActionSourceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DEAD_LOAD_G" => IfcActionSourceTypeEnum::DeadLoadG,
            "COMPLETION_G1" => IfcActionSourceTypeEnum::CompletionG1,
            "LIVE_LOAD_Q" => IfcActionSourceTypeEnum::LiveLoadQ,
            "SNOW_S" => IfcActionSourceTypeEnum::SnowS,
            "WIND_W" => IfcActionSourceTypeEnum::WindW,
            "PRESTRESSING_P" => IfcActionSourceTypeEnum::PrestressingP,
            "SETTLEMENT_U" => IfcActionSourceTypeEnum::SettlementU,
            "TEMPERATURE_T" => IfcActionSourceTypeEnum::TemperatureT,
            "EARTHQUAKE_E" => IfcActionSourceTypeEnum::EarthquakeE,
            "FIRE" => IfcActionSourceTypeEnum::Fire,
            "IMPULSE" => IfcActionSourceTypeEnum::Impulse,
            "IMPACT" => IfcActionSourceTypeEnum::Impact,
            "TRANSPORT" => IfcActionSourceTypeEnum::Transport,
            "ERECTION" => IfcActionSourceTypeEnum::Erection,
            "PROPPING" => IfcActionSourceTypeEnum::Propping,
            "SYSTEM_IMPERFECTION" => IfcActionSourceTypeEnum::SystemImperfection,
            "SHRINKAGE" => IfcActionSourceTypeEnum::Shrinkage,
            "CREEP" => IfcActionSourceTypeEnum::Creep,
            "LACK_OF_FIT" => IfcActionSourceTypeEnum::LackOfFit,
            "BUOYANCY" => IfcActionSourceTypeEnum::Buoyancy,
            "ICE" => IfcActionSourceTypeEnum::Ice,
            "CURRENT" => IfcActionSourceTypeEnum::Current,
            "WAVE" => IfcActionSourceTypeEnum::Wave,
            "RAIN" => IfcActionSourceTypeEnum::Rain,
            "BRAKES" => IfcActionSourceTypeEnum::Brakes,
            "USERDEFINED" => IfcActionSourceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActionSourceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActionSourceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcActionSourceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActionSourceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActionTypeEnum {
    PermanentG,
    VariableQ,
    ExtraordinaryA,
    Userdefined,
    Notdefined,
}
impl Default for IfcActionTypeEnum {
    fn default() -> Self {
        IfcActionTypeEnum::PermanentG
    }
}
impl From<String> for IfcActionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PERMANENT_G" => IfcActionTypeEnum::PermanentG,
            "VARIABLE_Q" => IfcActionTypeEnum::VariableQ,
            "EXTRAORDINARY_A" => IfcActionTypeEnum::ExtraordinaryA,
            "USERDEFINED" => IfcActionTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActionTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcActionTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActuatorTypeEnum {
    Electricactuator,
    Handoperatedactuator,
    Hydraulicactuator,
    Pneumaticactuator,
    Thermostaticactuator,
    Userdefined,
    Notdefined,
}
impl Default for IfcActuatorTypeEnum {
    fn default() -> Self {
        IfcActuatorTypeEnum::Electricactuator
    }
}
impl From<String> for IfcActuatorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELECTRICACTUATOR" => IfcActuatorTypeEnum::Electricactuator,
            "HANDOPERATEDACTUATOR" => IfcActuatorTypeEnum::Handoperatedactuator,
            "HYDRAULICACTUATOR" => IfcActuatorTypeEnum::Hydraulicactuator,
            "PNEUMATICACTUATOR" => IfcActuatorTypeEnum::Pneumaticactuator,
            "THERMOSTATICACTUATOR" => IfcActuatorTypeEnum::Thermostaticactuator,
            "USERDEFINED" => IfcActuatorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcActuatorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcActuatorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcActuatorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcActuatorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAddressTypeEnum {
    Office,
    Site,
    Home,
    Distributionpoint,
    Userdefined,
}
impl Default for IfcAddressTypeEnum {
    fn default() -> Self {
        IfcAddressTypeEnum::Office
    }
}
impl From<String> for IfcAddressTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "OFFICE" => IfcAddressTypeEnum::Office,
            "SITE" => IfcAddressTypeEnum::Site,
            "HOME" => IfcAddressTypeEnum::Home,
            "DISTRIBUTIONPOINT" => IfcAddressTypeEnum::Distributionpoint,
            "USERDEFINED" => IfcAddressTypeEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAddressTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAddressTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAddressTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAheadOrBehind {
    Ahead,
    Behind,
}
impl Default for IfcAheadOrBehind {
    fn default() -> Self {
        IfcAheadOrBehind::Ahead
    }
}
impl From<String> for IfcAheadOrBehind {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AHEAD" => IfcAheadOrBehind::Ahead,
            "BEHIND" => IfcAheadOrBehind::Behind,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAheadOrBehind {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAheadOrBehind::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAheadOrBehind::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAirTerminalBoxTypeEnum {
    Constantflow,
    Variableflowpressuredependant,
    Variableflowpressureindependant,
    Userdefined,
    Notdefined,
}
impl Default for IfcAirTerminalBoxTypeEnum {
    fn default() -> Self {
        IfcAirTerminalBoxTypeEnum::Constantflow
    }
}
impl From<String> for IfcAirTerminalBoxTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSTANTFLOW" => IfcAirTerminalBoxTypeEnum::Constantflow,
            "VARIABLEFLOWPRESSUREDEPENDANT" => IfcAirTerminalBoxTypeEnum::Variableflowpressuredependant,
            "VARIABLEFLOWPRESSUREINDEPENDANT" => IfcAirTerminalBoxTypeEnum::Variableflowpressureindependant,
            "USERDEFINED" => IfcAirTerminalBoxTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAirTerminalBoxTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAirTerminalBoxTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAirTerminalBoxTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAirTerminalBoxTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAirTerminalTypeEnum {
    Grille,
    Register,
    Diffuser,
    Eyeball,
    Iris,
    Lineargrille,
    Lineardiffuser,
    Userdefined,
    Notdefined,
}
impl Default for IfcAirTerminalTypeEnum {
    fn default() -> Self {
        IfcAirTerminalTypeEnum::Grille
    }
}
impl From<String> for IfcAirTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GRILLE" => IfcAirTerminalTypeEnum::Grille,
            "REGISTER" => IfcAirTerminalTypeEnum::Register,
            "DIFFUSER" => IfcAirTerminalTypeEnum::Diffuser,
            "EYEBALL" => IfcAirTerminalTypeEnum::Eyeball,
            "IRIS" => IfcAirTerminalTypeEnum::Iris,
            "LINEARGRILLE" => IfcAirTerminalTypeEnum::Lineargrille,
            "LINEARDIFFUSER" => IfcAirTerminalTypeEnum::Lineardiffuser,
            "USERDEFINED" => IfcAirTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAirTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAirTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAirTerminalTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAirTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAirToAirHeatRecoveryTypeEnum {
    Fixedplatecounterflowexchanger,
    Fixedplatecrossflowexchanger,
    Fixedplateparallelflowexchanger,
    Rotarywheel,
    Runaroundcoilloop,
    Heatpipe,
    Twintowerenthalpyrecoveryloops,
    Thermosiphonsealedtubeheatexchangers,
    Thermosiphoncoiltypeheatexchangers,
    Userdefined,
    Notdefined,
}
impl Default for IfcAirToAirHeatRecoveryTypeEnum {
    fn default() -> Self {
        IfcAirToAirHeatRecoveryTypeEnum::Fixedplatecounterflowexchanger
    }
}
impl From<String> for IfcAirToAirHeatRecoveryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FIXEDPLATECOUNTERFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum::Fixedplatecounterflowexchanger,
            "FIXEDPLATECROSSFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum::Fixedplatecrossflowexchanger,
            "FIXEDPLATEPARALLELFLOWEXCHANGER" => IfcAirToAirHeatRecoveryTypeEnum::Fixedplateparallelflowexchanger,
            "ROTARYWHEEL" => IfcAirToAirHeatRecoveryTypeEnum::Rotarywheel,
            "RUNAROUNDCOILLOOP" => IfcAirToAirHeatRecoveryTypeEnum::Runaroundcoilloop,
            "HEATPIPE" => IfcAirToAirHeatRecoveryTypeEnum::Heatpipe,
            "TWINTOWERENTHALPYRECOVERYLOOPS" => IfcAirToAirHeatRecoveryTypeEnum::Twintowerenthalpyrecoveryloops,
            "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS" => {
                IfcAirToAirHeatRecoveryTypeEnum::Thermosiphonsealedtubeheatexchangers
            }
            "THERMOSIPHONCOILTYPEHEATEXCHANGERS" => IfcAirToAirHeatRecoveryTypeEnum::Thermosiphoncoiltypeheatexchangers,
            "USERDEFINED" => IfcAirToAirHeatRecoveryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAirToAirHeatRecoveryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAirToAirHeatRecoveryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAirToAirHeatRecoveryTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAirToAirHeatRecoveryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAlarmTypeEnum {
    Bell,
    Breakglassbutton,
    Light,
    Manualpullbox,
    Siren,
    Whistle,
    Userdefined,
    Notdefined,
}
impl Default for IfcAlarmTypeEnum {
    fn default() -> Self {
        IfcAlarmTypeEnum::Bell
    }
}
impl From<String> for IfcAlarmTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BELL" => IfcAlarmTypeEnum::Bell,
            "BREAKGLASSBUTTON" => IfcAlarmTypeEnum::Breakglassbutton,
            "LIGHT" => IfcAlarmTypeEnum::Light,
            "MANUALPULLBOX" => IfcAlarmTypeEnum::Manualpullbox,
            "SIREN" => IfcAlarmTypeEnum::Siren,
            "WHISTLE" => IfcAlarmTypeEnum::Whistle,
            "USERDEFINED" => IfcAlarmTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAlarmTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAlarmTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAlarmTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAlarmTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAnalysisModelTypeEnum {
    InPlaneLoading2d,
    OutPlaneLoading2d,
    Loading3d,
    Userdefined,
    Notdefined,
}
impl Default for IfcAnalysisModelTypeEnum {
    fn default() -> Self {
        IfcAnalysisModelTypeEnum::InPlaneLoading2d
    }
}
impl From<String> for IfcAnalysisModelTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "IN_PLANE_LOADING_2D" => IfcAnalysisModelTypeEnum::InPlaneLoading2d,
            "OUT_PLANE_LOADING_2D" => IfcAnalysisModelTypeEnum::OutPlaneLoading2d,
            "LOADING_3D" => IfcAnalysisModelTypeEnum::Loading3d,
            "USERDEFINED" => IfcAnalysisModelTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAnalysisModelTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAnalysisModelTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAnalysisModelTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAnalysisModelTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAnalysisTheoryTypeEnum {
    FirstOrderTheory,
    SecondOrderTheory,
    ThirdOrderTheory,
    FullNonlinearTheory,
    Userdefined,
    Notdefined,
}
impl Default for IfcAnalysisTheoryTypeEnum {
    fn default() -> Self {
        IfcAnalysisTheoryTypeEnum::FirstOrderTheory
    }
}
impl From<String> for IfcAnalysisTheoryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FIRST_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum::FirstOrderTheory,
            "SECOND_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum::SecondOrderTheory,
            "THIRD_ORDER_THEORY" => IfcAnalysisTheoryTypeEnum::ThirdOrderTheory,
            "FULL_NONLINEAR_THEORY" => IfcAnalysisTheoryTypeEnum::FullNonlinearTheory,
            "USERDEFINED" => IfcAnalysisTheoryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcAnalysisTheoryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAnalysisTheoryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAnalysisTheoryTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAnalysisTheoryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcArithmeticOperatorEnum {
    Add,
    Divide,
    Multiply,
    Subtract,
}
impl Default for IfcArithmeticOperatorEnum {
    fn default() -> Self {
        IfcArithmeticOperatorEnum::Add
    }
}
impl From<String> for IfcArithmeticOperatorEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ADD" => IfcArithmeticOperatorEnum::Add,
            "DIVIDE" => IfcArithmeticOperatorEnum::Divide,
            "MULTIPLY" => IfcArithmeticOperatorEnum::Multiply,
            "SUBTRACT" => IfcArithmeticOperatorEnum::Subtract,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcArithmeticOperatorEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcArithmeticOperatorEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcArithmeticOperatorEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcAssemblyPlaceEnum {
    Site,
    Factory,
    Notdefined,
}
impl Default for IfcAssemblyPlaceEnum {
    fn default() -> Self {
        IfcAssemblyPlaceEnum::Site
    }
}
impl From<String> for IfcAssemblyPlaceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SITE" => IfcAssemblyPlaceEnum::Site,
            "FACTORY" => IfcAssemblyPlaceEnum::Factory,
            "NOTDEFINED" => IfcAssemblyPlaceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcAssemblyPlaceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcAssemblyPlaceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcAssemblyPlaceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBSplineCurveForm {
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
}
impl Default for IfcBSplineCurveForm {
    fn default() -> Self {
        IfcBSplineCurveForm::PolylineForm
    }
}
impl From<String> for IfcBSplineCurveForm {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POLYLINE_FORM" => IfcBSplineCurveForm::PolylineForm,
            "CIRCULAR_ARC" => IfcBSplineCurveForm::CircularArc,
            "ELLIPTIC_ARC" => IfcBSplineCurveForm::EllipticArc,
            "PARABOLIC_ARC" => IfcBSplineCurveForm::ParabolicArc,
            "HYPERBOLIC_ARC" => IfcBSplineCurveForm::HyperbolicArc,
            "UNSPECIFIED" => IfcBSplineCurveForm::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBSplineCurveForm {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcBSplineCurveForm::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBSplineCurveForm::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBeamTypeEnum {
    Beam,
    Joist,
    Lintel,
    TBeam,
    Userdefined,
    Notdefined,
}
impl Default for IfcBeamTypeEnum {
    fn default() -> Self {
        IfcBeamTypeEnum::Beam
    }
}
impl From<String> for IfcBeamTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEAM" => IfcBeamTypeEnum::Beam,
            "JOIST" => IfcBeamTypeEnum::Joist,
            "LINTEL" => IfcBeamTypeEnum::Lintel,
            "T_BEAM" => IfcBeamTypeEnum::TBeam,
            "USERDEFINED" => IfcBeamTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBeamTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBeamTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcBeamTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBeamTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBenchmarkEnum {
    Greaterthan,
    Greaterthanorequalto,
    Lessthan,
    Lessthanorequalto,
    Equalto,
    Notequalto,
}
impl Default for IfcBenchmarkEnum {
    fn default() -> Self {
        IfcBenchmarkEnum::Greaterthan
    }
}
impl From<String> for IfcBenchmarkEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GREATERTHAN" => IfcBenchmarkEnum::Greaterthan,
            "GREATERTHANOREQUALTO" => IfcBenchmarkEnum::Greaterthanorequalto,
            "LESSTHAN" => IfcBenchmarkEnum::Lessthan,
            "LESSTHANOREQUALTO" => IfcBenchmarkEnum::Lessthanorequalto,
            "EQUALTO" => IfcBenchmarkEnum::Equalto,
            "NOTEQUALTO" => IfcBenchmarkEnum::Notequalto,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBenchmarkEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcBenchmarkEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBenchmarkEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBoilerTypeEnum {
    Water,
    Steam,
    Userdefined,
    Notdefined,
}
impl Default for IfcBoilerTypeEnum {
    fn default() -> Self {
        IfcBoilerTypeEnum::Water
    }
}
impl From<String> for IfcBoilerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "WATER" => IfcBoilerTypeEnum::Water,
            "STEAM" => IfcBoilerTypeEnum::Steam,
            "USERDEFINED" => IfcBoilerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBoilerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBoilerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcBoilerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBoilerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBooleanOperator {
    Union,
    Intersection,
    Difference,
}
impl Default for IfcBooleanOperator {
    fn default() -> Self {
        IfcBooleanOperator::Union
    }
}
impl From<String> for IfcBooleanOperator {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNION" => IfcBooleanOperator::Union,
            "INTERSECTION" => IfcBooleanOperator::Intersection,
            "DIFFERENCE" => IfcBooleanOperator::Difference,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBooleanOperator {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcBooleanOperator::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBooleanOperator::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcBuildingElementProxyTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcBuildingElementProxyTypeEnum {
    fn default() -> Self {
        IfcBuildingElementProxyTypeEnum::Userdefined
    }
}
impl From<String> for IfcBuildingElementProxyTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcBuildingElementProxyTypeEnum::Userdefined,
            "NOTDEFINED" => IfcBuildingElementProxyTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcBuildingElementProxyTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcBuildingElementProxyTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcBuildingElementProxyTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableCarrierFittingTypeEnum {
    Bend,
    Cross,
    Reducer,
    Tee,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableCarrierFittingTypeEnum {
    fn default() -> Self {
        IfcCableCarrierFittingTypeEnum::Bend
    }
}
impl From<String> for IfcCableCarrierFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEND" => IfcCableCarrierFittingTypeEnum::Bend,
            "CROSS" => IfcCableCarrierFittingTypeEnum::Cross,
            "REDUCER" => IfcCableCarrierFittingTypeEnum::Reducer,
            "TEE" => IfcCableCarrierFittingTypeEnum::Tee,
            "USERDEFINED" => IfcCableCarrierFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableCarrierFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableCarrierFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCableCarrierFittingTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableCarrierFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableCarrierSegmentTypeEnum {
    Cableladdersegment,
    Cabletraysegment,
    Cabletrunkingsegment,
    Conduitsegment,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableCarrierSegmentTypeEnum {
    fn default() -> Self {
        IfcCableCarrierSegmentTypeEnum::Cableladdersegment
    }
}
impl From<String> for IfcCableCarrierSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CABLELADDERSEGMENT" => IfcCableCarrierSegmentTypeEnum::Cableladdersegment,
            "CABLETRAYSEGMENT" => IfcCableCarrierSegmentTypeEnum::Cabletraysegment,
            "CABLETRUNKINGSEGMENT" => IfcCableCarrierSegmentTypeEnum::Cabletrunkingsegment,
            "CONDUITSEGMENT" => IfcCableCarrierSegmentTypeEnum::Conduitsegment,
            "USERDEFINED" => IfcCableCarrierSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableCarrierSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableCarrierSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCableCarrierSegmentTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableCarrierSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCableSegmentTypeEnum {
    Cablesegment,
    Conductorsegment,
    Userdefined,
    Notdefined,
}
impl Default for IfcCableSegmentTypeEnum {
    fn default() -> Self {
        IfcCableSegmentTypeEnum::Cablesegment
    }
}
impl From<String> for IfcCableSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CABLESEGMENT" => IfcCableSegmentTypeEnum::Cablesegment,
            "CONDUCTORSEGMENT" => IfcCableSegmentTypeEnum::Conductorsegment,
            "USERDEFINED" => IfcCableSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCableSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCableSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCableSegmentTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCableSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcChangeActionEnum {
    Nochange,
    Modified,
    Added,
    Deleted,
    Modifiedadded,
    Modifieddeleted,
}
impl Default for IfcChangeActionEnum {
    fn default() -> Self {
        IfcChangeActionEnum::Nochange
    }
}
impl From<String> for IfcChangeActionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NOCHANGE" => IfcChangeActionEnum::Nochange,
            "MODIFIED" => IfcChangeActionEnum::Modified,
            "ADDED" => IfcChangeActionEnum::Added,
            "DELETED" => IfcChangeActionEnum::Deleted,
            "MODIFIEDADDED" => IfcChangeActionEnum::Modifiedadded,
            "MODIFIEDDELETED" => IfcChangeActionEnum::Modifieddeleted,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcChangeActionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcChangeActionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcChangeActionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcChillerTypeEnum {
    Aircooled,
    Watercooled,
    Heatrecovery,
    Userdefined,
    Notdefined,
}
impl Default for IfcChillerTypeEnum {
    fn default() -> Self {
        IfcChillerTypeEnum::Aircooled
    }
}
impl From<String> for IfcChillerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRCOOLED" => IfcChillerTypeEnum::Aircooled,
            "WATERCOOLED" => IfcChillerTypeEnum::Watercooled,
            "HEATRECOVERY" => IfcChillerTypeEnum::Heatrecovery,
            "USERDEFINED" => IfcChillerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcChillerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcChillerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcChillerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcChillerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCoilTypeEnum {
    Dxcoolingcoil,
    Watercoolingcoil,
    Steamheatingcoil,
    Waterheatingcoil,
    Electricheatingcoil,
    Gasheatingcoil,
    Userdefined,
    Notdefined,
}
impl Default for IfcCoilTypeEnum {
    fn default() -> Self {
        IfcCoilTypeEnum::Dxcoolingcoil
    }
}
impl From<String> for IfcCoilTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DXCOOLINGCOIL" => IfcCoilTypeEnum::Dxcoolingcoil,
            "WATERCOOLINGCOIL" => IfcCoilTypeEnum::Watercoolingcoil,
            "STEAMHEATINGCOIL" => IfcCoilTypeEnum::Steamheatingcoil,
            "WATERHEATINGCOIL" => IfcCoilTypeEnum::Waterheatingcoil,
            "ELECTRICHEATINGCOIL" => IfcCoilTypeEnum::Electricheatingcoil,
            "GASHEATINGCOIL" => IfcCoilTypeEnum::Gasheatingcoil,
            "USERDEFINED" => IfcCoilTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCoilTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCoilTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCoilTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCoilTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcColumnTypeEnum {
    Column,
    Userdefined,
    Notdefined,
}
impl Default for IfcColumnTypeEnum {
    fn default() -> Self {
        IfcColumnTypeEnum::Column
    }
}
impl From<String> for IfcColumnTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COLUMN" => IfcColumnTypeEnum::Column,
            "USERDEFINED" => IfcColumnTypeEnum::Userdefined,
            "NOTDEFINED" => IfcColumnTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcColumnTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcColumnTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcColumnTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCompressorTypeEnum {
    Dynamic,
    Reciprocating,
    Rotary,
    Scroll,
    Trochoidal,
    Singlestage,
    Booster,
    Opentype,
    Hermetic,
    Semihermetic,
    Weldedshellhermetic,
    Rollingpiston,
    Rotaryvane,
    Singlescrew,
    Twinscrew,
    Userdefined,
    Notdefined,
}
impl Default for IfcCompressorTypeEnum {
    fn default() -> Self {
        IfcCompressorTypeEnum::Dynamic
    }
}
impl From<String> for IfcCompressorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DYNAMIC" => IfcCompressorTypeEnum::Dynamic,
            "RECIPROCATING" => IfcCompressorTypeEnum::Reciprocating,
            "ROTARY" => IfcCompressorTypeEnum::Rotary,
            "SCROLL" => IfcCompressorTypeEnum::Scroll,
            "TROCHOIDAL" => IfcCompressorTypeEnum::Trochoidal,
            "SINGLESTAGE" => IfcCompressorTypeEnum::Singlestage,
            "BOOSTER" => IfcCompressorTypeEnum::Booster,
            "OPENTYPE" => IfcCompressorTypeEnum::Opentype,
            "HERMETIC" => IfcCompressorTypeEnum::Hermetic,
            "SEMIHERMETIC" => IfcCompressorTypeEnum::Semihermetic,
            "WELDEDSHELLHERMETIC" => IfcCompressorTypeEnum::Weldedshellhermetic,
            "ROLLINGPISTON" => IfcCompressorTypeEnum::Rollingpiston,
            "ROTARYVANE" => IfcCompressorTypeEnum::Rotaryvane,
            "SINGLESCREW" => IfcCompressorTypeEnum::Singlescrew,
            "TWINSCREW" => IfcCompressorTypeEnum::Twinscrew,
            "USERDEFINED" => IfcCompressorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCompressorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCompressorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCompressorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCompressorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCondenserTypeEnum {
    Watercooledshelltube,
    Watercooledshellcoil,
    Watercooledtubeintube,
    Watercooledbrazedplate,
    Aircooled,
    Evaporativecooled,
    Userdefined,
    Notdefined,
}
impl Default for IfcCondenserTypeEnum {
    fn default() -> Self {
        IfcCondenserTypeEnum::Watercooledshelltube
    }
}
impl From<String> for IfcCondenserTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "WATERCOOLEDSHELLTUBE" => IfcCondenserTypeEnum::Watercooledshelltube,
            "WATERCOOLEDSHELLCOIL" => IfcCondenserTypeEnum::Watercooledshellcoil,
            "WATERCOOLEDTUBEINTUBE" => IfcCondenserTypeEnum::Watercooledtubeintube,
            "WATERCOOLEDBRAZEDPLATE" => IfcCondenserTypeEnum::Watercooledbrazedplate,
            "AIRCOOLED" => IfcCondenserTypeEnum::Aircooled,
            "EVAPORATIVECOOLED" => IfcCondenserTypeEnum::Evaporativecooled,
            "USERDEFINED" => IfcCondenserTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCondenserTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCondenserTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCondenserTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCondenserTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConnectionTypeEnum {
    Atpath,
    Atstart,
    Atend,
    Notdefined,
}
impl Default for IfcConnectionTypeEnum {
    fn default() -> Self {
        IfcConnectionTypeEnum::Atpath
    }
}
impl From<String> for IfcConnectionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ATPATH" => IfcConnectionTypeEnum::Atpath,
            "ATSTART" => IfcConnectionTypeEnum::Atstart,
            "ATEND" => IfcConnectionTypeEnum::Atend,
            "NOTDEFINED" => IfcConnectionTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConnectionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcConnectionTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConnectionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcConstraintEnum {
    Hard,
    Soft,
    Advisory,
    Userdefined,
    Notdefined,
}
impl Default for IfcConstraintEnum {
    fn default() -> Self {
        IfcConstraintEnum::Hard
    }
}
impl From<String> for IfcConstraintEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "HARD" => IfcConstraintEnum::Hard,
            "SOFT" => IfcConstraintEnum::Soft,
            "ADVISORY" => IfcConstraintEnum::Advisory,
            "USERDEFINED" => IfcConstraintEnum::Userdefined,
            "NOTDEFINED" => IfcConstraintEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcConstraintEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcConstraintEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcConstraintEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcControllerTypeEnum {
    Floating,
    Proportional,
    Proportionalintegral,
    Proportionalintegralderivative,
    Timedtwoposition,
    Twoposition,
    Userdefined,
    Notdefined,
}
impl Default for IfcControllerTypeEnum {
    fn default() -> Self {
        IfcControllerTypeEnum::Floating
    }
}
impl From<String> for IfcControllerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLOATING" => IfcControllerTypeEnum::Floating,
            "PROPORTIONAL" => IfcControllerTypeEnum::Proportional,
            "PROPORTIONALINTEGRAL" => IfcControllerTypeEnum::Proportionalintegral,
            "PROPORTIONALINTEGRALDERIVATIVE" => IfcControllerTypeEnum::Proportionalintegralderivative,
            "TIMEDTWOPOSITION" => IfcControllerTypeEnum::Timedtwoposition,
            "TWOPOSITION" => IfcControllerTypeEnum::Twoposition,
            "USERDEFINED" => IfcControllerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcControllerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcControllerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcControllerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcControllerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCooledBeamTypeEnum {
    Active,
    Passive,
    Userdefined,
    Notdefined,
}
impl Default for IfcCooledBeamTypeEnum {
    fn default() -> Self {
        IfcCooledBeamTypeEnum::Active
    }
}
impl From<String> for IfcCooledBeamTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACTIVE" => IfcCooledBeamTypeEnum::Active,
            "PASSIVE" => IfcCooledBeamTypeEnum::Passive,
            "USERDEFINED" => IfcCooledBeamTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCooledBeamTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCooledBeamTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCooledBeamTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCooledBeamTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCoolingTowerTypeEnum {
    Naturaldraft,
    Mechanicalinduceddraft,
    Mechanicalforceddraft,
    Userdefined,
    Notdefined,
}
impl Default for IfcCoolingTowerTypeEnum {
    fn default() -> Self {
        IfcCoolingTowerTypeEnum::Naturaldraft
    }
}
impl From<String> for IfcCoolingTowerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NATURALDRAFT" => IfcCoolingTowerTypeEnum::Naturaldraft,
            "MECHANICALINDUCEDDRAFT" => IfcCoolingTowerTypeEnum::Mechanicalinduceddraft,
            "MECHANICALFORCEDDRAFT" => IfcCoolingTowerTypeEnum::Mechanicalforceddraft,
            "USERDEFINED" => IfcCoolingTowerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCoolingTowerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCoolingTowerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCoolingTowerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCoolingTowerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCostScheduleTypeEnum {
    Budget,
    Costplan,
    Estimate,
    Tender,
    Pricedbillofquantities,
    Unpricedbillofquantities,
    Scheduleofrates,
    Userdefined,
    Notdefined,
}
impl Default for IfcCostScheduleTypeEnum {
    fn default() -> Self {
        IfcCostScheduleTypeEnum::Budget
    }
}
impl From<String> for IfcCostScheduleTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BUDGET" => IfcCostScheduleTypeEnum::Budget,
            "COSTPLAN" => IfcCostScheduleTypeEnum::Costplan,
            "ESTIMATE" => IfcCostScheduleTypeEnum::Estimate,
            "TENDER" => IfcCostScheduleTypeEnum::Tender,
            "PRICEDBILLOFQUANTITIES" => IfcCostScheduleTypeEnum::Pricedbillofquantities,
            "UNPRICEDBILLOFQUANTITIES" => IfcCostScheduleTypeEnum::Unpricedbillofquantities,
            "SCHEDULEOFRATES" => IfcCostScheduleTypeEnum::Scheduleofrates,
            "USERDEFINED" => IfcCostScheduleTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCostScheduleTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCostScheduleTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCostScheduleTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCostScheduleTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCoveringTypeEnum {
    Ceiling,
    Flooring,
    Cladding,
    Roofing,
    Insulation,
    Membrane,
    Sleeving,
    Wrapping,
    Userdefined,
    Notdefined,
}
impl Default for IfcCoveringTypeEnum {
    fn default() -> Self {
        IfcCoveringTypeEnum::Ceiling
    }
}
impl From<String> for IfcCoveringTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CEILING" => IfcCoveringTypeEnum::Ceiling,
            "FLOORING" => IfcCoveringTypeEnum::Flooring,
            "CLADDING" => IfcCoveringTypeEnum::Cladding,
            "ROOFING" => IfcCoveringTypeEnum::Roofing,
            "INSULATION" => IfcCoveringTypeEnum::Insulation,
            "MEMBRANE" => IfcCoveringTypeEnum::Membrane,
            "SLEEVING" => IfcCoveringTypeEnum::Sleeving,
            "WRAPPING" => IfcCoveringTypeEnum::Wrapping,
            "USERDEFINED" => IfcCoveringTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCoveringTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCoveringTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCoveringTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCoveringTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCurrencyEnum {
    Aed,
    Aes,
    Ats,
    Aud,
    Bbd,
    Beg,
    Bgl,
    Bhd,
    Bmd,
    Bnd,
    Brl,
    Bsd,
    Bwp,
    Bzd,
    Cad,
    Cbd,
    Chf,
    Clp,
    Cny,
    Cys,
    Czk,
    Ddp,
    Dem,
    Dkk,
    Egl,
    Est,
    Eur,
    Fak,
    Fim,
    Fjd,
    Fkp,
    Frf,
    Gbp,
    Gip,
    Gmd,
    Grx,
    Hkd,
    Huf,
    Ick,
    Idr,
    Ils,
    Inr,
    Irp,
    Itl,
    Jmd,
    Jod,
    Jpy,
    Kes,
    Krw,
    Kwd,
    Kyd,
    Lkr,
    Luf,
    Mtl,
    Mur,
    Mxn,
    Myr,
    Nlg,
    Nzd,
    Omr,
    Pgk,
    Php,
    Pkr,
    Pln,
    Ptn,
    Qar,
    Rur,
    Sar,
    Scr,
    Sek,
    Sgd,
    Skp,
    Thb,
    Trl,
    Ttd,
    Twd,
    Usd,
    Veb,
    Vnd,
    Xeu,
    Zar,
    Zwd,
    Nok,
}
impl Default for IfcCurrencyEnum {
    fn default() -> Self {
        IfcCurrencyEnum::Aed
    }
}
impl From<String> for IfcCurrencyEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AED" => IfcCurrencyEnum::Aed,
            "AES" => IfcCurrencyEnum::Aes,
            "ATS" => IfcCurrencyEnum::Ats,
            "AUD" => IfcCurrencyEnum::Aud,
            "BBD" => IfcCurrencyEnum::Bbd,
            "BEG" => IfcCurrencyEnum::Beg,
            "BGL" => IfcCurrencyEnum::Bgl,
            "BHD" => IfcCurrencyEnum::Bhd,
            "BMD" => IfcCurrencyEnum::Bmd,
            "BND" => IfcCurrencyEnum::Bnd,
            "BRL" => IfcCurrencyEnum::Brl,
            "BSD" => IfcCurrencyEnum::Bsd,
            "BWP" => IfcCurrencyEnum::Bwp,
            "BZD" => IfcCurrencyEnum::Bzd,
            "CAD" => IfcCurrencyEnum::Cad,
            "CBD" => IfcCurrencyEnum::Cbd,
            "CHF" => IfcCurrencyEnum::Chf,
            "CLP" => IfcCurrencyEnum::Clp,
            "CNY" => IfcCurrencyEnum::Cny,
            "CYS" => IfcCurrencyEnum::Cys,
            "CZK" => IfcCurrencyEnum::Czk,
            "DDP" => IfcCurrencyEnum::Ddp,
            "DEM" => IfcCurrencyEnum::Dem,
            "DKK" => IfcCurrencyEnum::Dkk,
            "EGL" => IfcCurrencyEnum::Egl,
            "EST" => IfcCurrencyEnum::Est,
            "EUR" => IfcCurrencyEnum::Eur,
            "FAK" => IfcCurrencyEnum::Fak,
            "FIM" => IfcCurrencyEnum::Fim,
            "FJD" => IfcCurrencyEnum::Fjd,
            "FKP" => IfcCurrencyEnum::Fkp,
            "FRF" => IfcCurrencyEnum::Frf,
            "GBP" => IfcCurrencyEnum::Gbp,
            "GIP" => IfcCurrencyEnum::Gip,
            "GMD" => IfcCurrencyEnum::Gmd,
            "GRX" => IfcCurrencyEnum::Grx,
            "HKD" => IfcCurrencyEnum::Hkd,
            "HUF" => IfcCurrencyEnum::Huf,
            "ICK" => IfcCurrencyEnum::Ick,
            "IDR" => IfcCurrencyEnum::Idr,
            "ILS" => IfcCurrencyEnum::Ils,
            "INR" => IfcCurrencyEnum::Inr,
            "IRP" => IfcCurrencyEnum::Irp,
            "ITL" => IfcCurrencyEnum::Itl,
            "JMD" => IfcCurrencyEnum::Jmd,
            "JOD" => IfcCurrencyEnum::Jod,
            "JPY" => IfcCurrencyEnum::Jpy,
            "KES" => IfcCurrencyEnum::Kes,
            "KRW" => IfcCurrencyEnum::Krw,
            "KWD" => IfcCurrencyEnum::Kwd,
            "KYD" => IfcCurrencyEnum::Kyd,
            "LKR" => IfcCurrencyEnum::Lkr,
            "LUF" => IfcCurrencyEnum::Luf,
            "MTL" => IfcCurrencyEnum::Mtl,
            "MUR" => IfcCurrencyEnum::Mur,
            "MXN" => IfcCurrencyEnum::Mxn,
            "MYR" => IfcCurrencyEnum::Myr,
            "NLG" => IfcCurrencyEnum::Nlg,
            "NZD" => IfcCurrencyEnum::Nzd,
            "OMR" => IfcCurrencyEnum::Omr,
            "PGK" => IfcCurrencyEnum::Pgk,
            "PHP" => IfcCurrencyEnum::Php,
            "PKR" => IfcCurrencyEnum::Pkr,
            "PLN" => IfcCurrencyEnum::Pln,
            "PTN" => IfcCurrencyEnum::Ptn,
            "QAR" => IfcCurrencyEnum::Qar,
            "RUR" => IfcCurrencyEnum::Rur,
            "SAR" => IfcCurrencyEnum::Sar,
            "SCR" => IfcCurrencyEnum::Scr,
            "SEK" => IfcCurrencyEnum::Sek,
            "SGD" => IfcCurrencyEnum::Sgd,
            "SKP" => IfcCurrencyEnum::Skp,
            "THB" => IfcCurrencyEnum::Thb,
            "TRL" => IfcCurrencyEnum::Trl,
            "TTD" => IfcCurrencyEnum::Ttd,
            "TWD" => IfcCurrencyEnum::Twd,
            "USD" => IfcCurrencyEnum::Usd,
            "VEB" => IfcCurrencyEnum::Veb,
            "VND" => IfcCurrencyEnum::Vnd,
            "XEU" => IfcCurrencyEnum::Xeu,
            "ZAR" => IfcCurrencyEnum::Zar,
            "ZWD" => IfcCurrencyEnum::Zwd,
            "NOK" => IfcCurrencyEnum::Nok,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCurrencyEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCurrencyEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCurrencyEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcCurtainWallTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcCurtainWallTypeEnum {
    fn default() -> Self {
        IfcCurtainWallTypeEnum::Userdefined
    }
}
impl From<String> for IfcCurtainWallTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcCurtainWallTypeEnum::Userdefined,
            "NOTDEFINED" => IfcCurtainWallTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcCurtainWallTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcCurtainWallTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcCurtainWallTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDamperTypeEnum {
    Controldamper,
    Firedamper,
    Smokedamper,
    Firesmokedamper,
    Backdraftdamper,
    Reliefdamper,
    Blastdamper,
    Gravitydamper,
    Gravityreliefdamper,
    Balancingdamper,
    Fumehoodexhaust,
    Userdefined,
    Notdefined,
}
impl Default for IfcDamperTypeEnum {
    fn default() -> Self {
        IfcDamperTypeEnum::Controldamper
    }
}
impl From<String> for IfcDamperTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONTROLDAMPER" => IfcDamperTypeEnum::Controldamper,
            "FIREDAMPER" => IfcDamperTypeEnum::Firedamper,
            "SMOKEDAMPER" => IfcDamperTypeEnum::Smokedamper,
            "FIRESMOKEDAMPER" => IfcDamperTypeEnum::Firesmokedamper,
            "BACKDRAFTDAMPER" => IfcDamperTypeEnum::Backdraftdamper,
            "RELIEFDAMPER" => IfcDamperTypeEnum::Reliefdamper,
            "BLASTDAMPER" => IfcDamperTypeEnum::Blastdamper,
            "GRAVITYDAMPER" => IfcDamperTypeEnum::Gravitydamper,
            "GRAVITYRELIEFDAMPER" => IfcDamperTypeEnum::Gravityreliefdamper,
            "BALANCINGDAMPER" => IfcDamperTypeEnum::Balancingdamper,
            "FUMEHOODEXHAUST" => IfcDamperTypeEnum::Fumehoodexhaust,
            "USERDEFINED" => IfcDamperTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDamperTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDamperTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDamperTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDamperTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDataOriginEnum {
    Measured,
    Predicted,
    Simulated,
    Userdefined,
    Notdefined,
}
impl Default for IfcDataOriginEnum {
    fn default() -> Self {
        IfcDataOriginEnum::Measured
    }
}
impl From<String> for IfcDataOriginEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MEASURED" => IfcDataOriginEnum::Measured,
            "PREDICTED" => IfcDataOriginEnum::Predicted,
            "SIMULATED" => IfcDataOriginEnum::Simulated,
            "USERDEFINED" => IfcDataOriginEnum::Userdefined,
            "NOTDEFINED" => IfcDataOriginEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDataOriginEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDataOriginEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDataOriginEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDerivedUnitEnum {
    Angularvelocityunit,
    Compoundplaneangleunit,
    Dynamicviscosityunit,
    Heatfluxdensityunit,
    Integercountrateunit,
    Isothermalmoisturecapacityunit,
    Kinematicviscosityunit,
    Linearvelocityunit,
    Massdensityunit,
    Massflowrateunit,
    Moisturediffusivityunit,
    Molecularweightunit,
    Specificheatcapacityunit,
    Thermaladmittanceunit,
    Thermalconductanceunit,
    Thermalresistanceunit,
    Thermaltransmittanceunit,
    Vaporpermeabilityunit,
    Volumetricflowrateunit,
    Rotationalfrequencyunit,
    Torqueunit,
    Momentofinertiaunit,
    Linearmomentunit,
    Linearforceunit,
    Planarforceunit,
    Modulusofelasticityunit,
    Shearmodulusunit,
    Linearstiffnessunit,
    Rotationalstiffnessunit,
    Modulusofsubgradereactionunit,
    Accelerationunit,
    Curvatureunit,
    Heatingvalueunit,
    Ionconcentrationunit,
    Luminousintensitydistributionunit,
    Massperlengthunit,
    Modulusoflinearsubgradereactionunit,
    Modulusofrotationalsubgradereactionunit,
    Phunit,
    Rotationalmassunit,
    Sectionareaintegralunit,
    Sectionmodulusunit,
    Soundpowerunit,
    Soundpressureunit,
    Temperaturegradientunit,
    Thermalexpansioncoefficientunit,
    Warpingconstantunit,
    Warpingmomentunit,
    Userdefined,
}
impl Default for IfcDerivedUnitEnum {
    fn default() -> Self {
        IfcDerivedUnitEnum::Angularvelocityunit
    }
}
impl From<String> for IfcDerivedUnitEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANGULARVELOCITYUNIT" => IfcDerivedUnitEnum::Angularvelocityunit,
            "COMPOUNDPLANEANGLEUNIT" => IfcDerivedUnitEnum::Compoundplaneangleunit,
            "DYNAMICVISCOSITYUNIT" => IfcDerivedUnitEnum::Dynamicviscosityunit,
            "HEATFLUXDENSITYUNIT" => IfcDerivedUnitEnum::Heatfluxdensityunit,
            "INTEGERCOUNTRATEUNIT" => IfcDerivedUnitEnum::Integercountrateunit,
            "ISOTHERMALMOISTURECAPACITYUNIT" => IfcDerivedUnitEnum::Isothermalmoisturecapacityunit,
            "KINEMATICVISCOSITYUNIT" => IfcDerivedUnitEnum::Kinematicviscosityunit,
            "LINEARVELOCITYUNIT" => IfcDerivedUnitEnum::Linearvelocityunit,
            "MASSDENSITYUNIT" => IfcDerivedUnitEnum::Massdensityunit,
            "MASSFLOWRATEUNIT" => IfcDerivedUnitEnum::Massflowrateunit,
            "MOISTUREDIFFUSIVITYUNIT" => IfcDerivedUnitEnum::Moisturediffusivityunit,
            "MOLECULARWEIGHTUNIT" => IfcDerivedUnitEnum::Molecularweightunit,
            "SPECIFICHEATCAPACITYUNIT" => IfcDerivedUnitEnum::Specificheatcapacityunit,
            "THERMALADMITTANCEUNIT" => IfcDerivedUnitEnum::Thermaladmittanceunit,
            "THERMALCONDUCTANCEUNIT" => IfcDerivedUnitEnum::Thermalconductanceunit,
            "THERMALRESISTANCEUNIT" => IfcDerivedUnitEnum::Thermalresistanceunit,
            "THERMALTRANSMITTANCEUNIT" => IfcDerivedUnitEnum::Thermaltransmittanceunit,
            "VAPORPERMEABILITYUNIT" => IfcDerivedUnitEnum::Vaporpermeabilityunit,
            "VOLUMETRICFLOWRATEUNIT" => IfcDerivedUnitEnum::Volumetricflowrateunit,
            "ROTATIONALFREQUENCYUNIT" => IfcDerivedUnitEnum::Rotationalfrequencyunit,
            "TORQUEUNIT" => IfcDerivedUnitEnum::Torqueunit,
            "MOMENTOFINERTIAUNIT" => IfcDerivedUnitEnum::Momentofinertiaunit,
            "LINEARMOMENTUNIT" => IfcDerivedUnitEnum::Linearmomentunit,
            "LINEARFORCEUNIT" => IfcDerivedUnitEnum::Linearforceunit,
            "PLANARFORCEUNIT" => IfcDerivedUnitEnum::Planarforceunit,
            "MODULUSOFELASTICITYUNIT" => IfcDerivedUnitEnum::Modulusofelasticityunit,
            "SHEARMODULUSUNIT" => IfcDerivedUnitEnum::Shearmodulusunit,
            "LINEARSTIFFNESSUNIT" => IfcDerivedUnitEnum::Linearstiffnessunit,
            "ROTATIONALSTIFFNESSUNIT" => IfcDerivedUnitEnum::Rotationalstiffnessunit,
            "MODULUSOFSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum::Modulusofsubgradereactionunit,
            "ACCELERATIONUNIT" => IfcDerivedUnitEnum::Accelerationunit,
            "CURVATUREUNIT" => IfcDerivedUnitEnum::Curvatureunit,
            "HEATINGVALUEUNIT" => IfcDerivedUnitEnum::Heatingvalueunit,
            "IONCONCENTRATIONUNIT" => IfcDerivedUnitEnum::Ionconcentrationunit,
            "LUMINOUSINTENSITYDISTRIBUTIONUNIT" => IfcDerivedUnitEnum::Luminousintensitydistributionunit,
            "MASSPERLENGTHUNIT" => IfcDerivedUnitEnum::Massperlengthunit,
            "MODULUSOFLINEARSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum::Modulusoflinearsubgradereactionunit,
            "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT" => IfcDerivedUnitEnum::Modulusofrotationalsubgradereactionunit,
            "PHUNIT" => IfcDerivedUnitEnum::Phunit,
            "ROTATIONALMASSUNIT" => IfcDerivedUnitEnum::Rotationalmassunit,
            "SECTIONAREAINTEGRALUNIT" => IfcDerivedUnitEnum::Sectionareaintegralunit,
            "SECTIONMODULUSUNIT" => IfcDerivedUnitEnum::Sectionmodulusunit,
            "SOUNDPOWERUNIT" => IfcDerivedUnitEnum::Soundpowerunit,
            "SOUNDPRESSUREUNIT" => IfcDerivedUnitEnum::Soundpressureunit,
            "TEMPERATUREGRADIENTUNIT" => IfcDerivedUnitEnum::Temperaturegradientunit,
            "THERMALEXPANSIONCOEFFICIENTUNIT" => IfcDerivedUnitEnum::Thermalexpansioncoefficientunit,
            "WARPINGCONSTANTUNIT" => IfcDerivedUnitEnum::Warpingconstantunit,
            "WARPINGMOMENTUNIT" => IfcDerivedUnitEnum::Warpingmomentunit,
            "USERDEFINED" => IfcDerivedUnitEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDerivedUnitEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDerivedUnitEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDerivedUnitEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDimensionExtentUsage {
    Origin,
    Target,
}
impl Default for IfcDimensionExtentUsage {
    fn default() -> Self {
        IfcDimensionExtentUsage::Origin
    }
}
impl From<String> for IfcDimensionExtentUsage {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ORIGIN" => IfcDimensionExtentUsage::Origin,
            "TARGET" => IfcDimensionExtentUsage::Target,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDimensionExtentUsage {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDimensionExtentUsage::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDimensionExtentUsage::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDirectionSenseEnum {
    Positive,
    Negative,
}
impl Default for IfcDirectionSenseEnum {
    fn default() -> Self {
        IfcDirectionSenseEnum::Positive
    }
}
impl From<String> for IfcDirectionSenseEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POSITIVE" => IfcDirectionSenseEnum::Positive,
            "NEGATIVE" => IfcDirectionSenseEnum::Negative,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDirectionSenseEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDirectionSenseEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDirectionSenseEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDistributionChamberElementTypeEnum {
    Formedduct,
    Inspectionchamber,
    Inspectionpit,
    Manhole,
    Meterchamber,
    Sump,
    Trench,
    Valvechamber,
    Userdefined,
    Notdefined,
}
impl Default for IfcDistributionChamberElementTypeEnum {
    fn default() -> Self {
        IfcDistributionChamberElementTypeEnum::Formedduct
    }
}
impl From<String> for IfcDistributionChamberElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FORMEDDUCT" => IfcDistributionChamberElementTypeEnum::Formedduct,
            "INSPECTIONCHAMBER" => IfcDistributionChamberElementTypeEnum::Inspectionchamber,
            "INSPECTIONPIT" => IfcDistributionChamberElementTypeEnum::Inspectionpit,
            "MANHOLE" => IfcDistributionChamberElementTypeEnum::Manhole,
            "METERCHAMBER" => IfcDistributionChamberElementTypeEnum::Meterchamber,
            "SUMP" => IfcDistributionChamberElementTypeEnum::Sump,
            "TRENCH" => IfcDistributionChamberElementTypeEnum::Trench,
            "VALVECHAMBER" => IfcDistributionChamberElementTypeEnum::Valvechamber,
            "USERDEFINED" => IfcDistributionChamberElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDistributionChamberElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDistributionChamberElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDistributionChamberElementTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDistributionChamberElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDocumentConfidentialityEnum {
    Public,
    Restricted,
    Confidential,
    Personal,
    Userdefined,
    Notdefined,
}
impl Default for IfcDocumentConfidentialityEnum {
    fn default() -> Self {
        IfcDocumentConfidentialityEnum::Public
    }
}
impl From<String> for IfcDocumentConfidentialityEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PUBLIC" => IfcDocumentConfidentialityEnum::Public,
            "RESTRICTED" => IfcDocumentConfidentialityEnum::Restricted,
            "CONFIDENTIAL" => IfcDocumentConfidentialityEnum::Confidential,
            "PERSONAL" => IfcDocumentConfidentialityEnum::Personal,
            "USERDEFINED" => IfcDocumentConfidentialityEnum::Userdefined,
            "NOTDEFINED" => IfcDocumentConfidentialityEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDocumentConfidentialityEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDocumentConfidentialityEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDocumentConfidentialityEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDocumentStatusEnum {
    Draft,
    Finaldraft,
    Final,
    Revision,
    Notdefined,
}
impl Default for IfcDocumentStatusEnum {
    fn default() -> Self {
        IfcDocumentStatusEnum::Draft
    }
}
impl From<String> for IfcDocumentStatusEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DRAFT" => IfcDocumentStatusEnum::Draft,
            "FINALDRAFT" => IfcDocumentStatusEnum::Finaldraft,
            "FINAL" => IfcDocumentStatusEnum::Final,
            "REVISION" => IfcDocumentStatusEnum::Revision,
            "NOTDEFINED" => IfcDocumentStatusEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDocumentStatusEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDocumentStatusEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDocumentStatusEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorPanelOperationEnum {
    Swinging,
    DoubleActing,
    Sliding,
    Folding,
    Revolving,
    Rollingup,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorPanelOperationEnum {
    fn default() -> Self {
        IfcDoorPanelOperationEnum::Swinging
    }
}
impl From<String> for IfcDoorPanelOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SWINGING" => IfcDoorPanelOperationEnum::Swinging,
            "DOUBLE_ACTING" => IfcDoorPanelOperationEnum::DoubleActing,
            "SLIDING" => IfcDoorPanelOperationEnum::Sliding,
            "FOLDING" => IfcDoorPanelOperationEnum::Folding,
            "REVOLVING" => IfcDoorPanelOperationEnum::Revolving,
            "ROLLINGUP" => IfcDoorPanelOperationEnum::Rollingup,
            "USERDEFINED" => IfcDoorPanelOperationEnum::Userdefined,
            "NOTDEFINED" => IfcDoorPanelOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorPanelOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDoorPanelOperationEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorPanelOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorPanelPositionEnum {
    Left,
    Middle,
    Right,
    Notdefined,
}
impl Default for IfcDoorPanelPositionEnum {
    fn default() -> Self {
        IfcDoorPanelPositionEnum::Left
    }
}
impl From<String> for IfcDoorPanelPositionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => IfcDoorPanelPositionEnum::Left,
            "MIDDLE" => IfcDoorPanelPositionEnum::Middle,
            "RIGHT" => IfcDoorPanelPositionEnum::Right,
            "NOTDEFINED" => IfcDoorPanelPositionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorPanelPositionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDoorPanelPositionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorPanelPositionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorStyleConstructionEnum {
    Aluminium,
    HighGradeSteel,
    Steel,
    Wood,
    AluminiumWood,
    AluminiumPlastic,
    Plastic,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorStyleConstructionEnum {
    fn default() -> Self {
        IfcDoorStyleConstructionEnum::Aluminium
    }
}
impl From<String> for IfcDoorStyleConstructionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALUMINIUM" => IfcDoorStyleConstructionEnum::Aluminium,
            "HIGH_GRADE_STEEL" => IfcDoorStyleConstructionEnum::HighGradeSteel,
            "STEEL" => IfcDoorStyleConstructionEnum::Steel,
            "WOOD" => IfcDoorStyleConstructionEnum::Wood,
            "ALUMINIUM_WOOD" => IfcDoorStyleConstructionEnum::AluminiumWood,
            "ALUMINIUM_PLASTIC" => IfcDoorStyleConstructionEnum::AluminiumPlastic,
            "PLASTIC" => IfcDoorStyleConstructionEnum::Plastic,
            "USERDEFINED" => IfcDoorStyleConstructionEnum::Userdefined,
            "NOTDEFINED" => IfcDoorStyleConstructionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorStyleConstructionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDoorStyleConstructionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorStyleConstructionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDoorStyleOperationEnum {
    SingleSwingLeft,
    SingleSwingRight,
    DoubleDoorSingleSwing,
    DoubleDoorSingleSwingOppositeLeft,
    DoubleDoorSingleSwingOppositeRight,
    DoubleSwingLeft,
    DoubleSwingRight,
    DoubleDoorDoubleSwing,
    SlidingToLeft,
    SlidingToRight,
    DoubleDoorSliding,
    FoldingToLeft,
    FoldingToRight,
    DoubleDoorFolding,
    Revolving,
    Rollingup,
    Userdefined,
    Notdefined,
}
impl Default for IfcDoorStyleOperationEnum {
    fn default() -> Self {
        IfcDoorStyleOperationEnum::SingleSwingLeft
    }
}
impl From<String> for IfcDoorStyleOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SINGLE_SWING_LEFT" => IfcDoorStyleOperationEnum::SingleSwingLeft,
            "SINGLE_SWING_RIGHT" => IfcDoorStyleOperationEnum::SingleSwingRight,
            "DOUBLE_DOOR_SINGLE_SWING" => IfcDoorStyleOperationEnum::DoubleDoorSingleSwing,
            "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT" => IfcDoorStyleOperationEnum::DoubleDoorSingleSwingOppositeLeft,
            "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT" => IfcDoorStyleOperationEnum::DoubleDoorSingleSwingOppositeRight,
            "DOUBLE_SWING_LEFT" => IfcDoorStyleOperationEnum::DoubleSwingLeft,
            "DOUBLE_SWING_RIGHT" => IfcDoorStyleOperationEnum::DoubleSwingRight,
            "DOUBLE_DOOR_DOUBLE_SWING" => IfcDoorStyleOperationEnum::DoubleDoorDoubleSwing,
            "SLIDING_TO_LEFT" => IfcDoorStyleOperationEnum::SlidingToLeft,
            "SLIDING_TO_RIGHT" => IfcDoorStyleOperationEnum::SlidingToRight,
            "DOUBLE_DOOR_SLIDING" => IfcDoorStyleOperationEnum::DoubleDoorSliding,
            "FOLDING_TO_LEFT" => IfcDoorStyleOperationEnum::FoldingToLeft,
            "FOLDING_TO_RIGHT" => IfcDoorStyleOperationEnum::FoldingToRight,
            "DOUBLE_DOOR_FOLDING" => IfcDoorStyleOperationEnum::DoubleDoorFolding,
            "REVOLVING" => IfcDoorStyleOperationEnum::Revolving,
            "ROLLINGUP" => IfcDoorStyleOperationEnum::Rollingup,
            "USERDEFINED" => IfcDoorStyleOperationEnum::Userdefined,
            "NOTDEFINED" => IfcDoorStyleOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDoorStyleOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDoorStyleOperationEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDoorStyleOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDuctFittingTypeEnum {
    Bend,
    Connector,
    Entry,
    Exit,
    Junction,
    Obstruction,
    Transition,
    Userdefined,
    Notdefined,
}
impl Default for IfcDuctFittingTypeEnum {
    fn default() -> Self {
        IfcDuctFittingTypeEnum::Bend
    }
}
impl From<String> for IfcDuctFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEND" => IfcDuctFittingTypeEnum::Bend,
            "CONNECTOR" => IfcDuctFittingTypeEnum::Connector,
            "ENTRY" => IfcDuctFittingTypeEnum::Entry,
            "EXIT" => IfcDuctFittingTypeEnum::Exit,
            "JUNCTION" => IfcDuctFittingTypeEnum::Junction,
            "OBSTRUCTION" => IfcDuctFittingTypeEnum::Obstruction,
            "TRANSITION" => IfcDuctFittingTypeEnum::Transition,
            "USERDEFINED" => IfcDuctFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDuctFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDuctFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDuctFittingTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDuctFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDuctSegmentTypeEnum {
    Rigidsegment,
    Flexiblesegment,
    Userdefined,
    Notdefined,
}
impl Default for IfcDuctSegmentTypeEnum {
    fn default() -> Self {
        IfcDuctSegmentTypeEnum::Rigidsegment
    }
}
impl From<String> for IfcDuctSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "RIGIDSEGMENT" => IfcDuctSegmentTypeEnum::Rigidsegment,
            "FLEXIBLESEGMENT" => IfcDuctSegmentTypeEnum::Flexiblesegment,
            "USERDEFINED" => IfcDuctSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDuctSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDuctSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDuctSegmentTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDuctSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDuctSilencerTypeEnum {
    Flatoval,
    Rectangular,
    Round,
    Userdefined,
    Notdefined,
}
impl Default for IfcDuctSilencerTypeEnum {
    fn default() -> Self {
        IfcDuctSilencerTypeEnum::Flatoval
    }
}
impl From<String> for IfcDuctSilencerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLATOVAL" => IfcDuctSilencerTypeEnum::Flatoval,
            "RECTANGULAR" => IfcDuctSilencerTypeEnum::Rectangular,
            "ROUND" => IfcDuctSilencerTypeEnum::Round,
            "USERDEFINED" => IfcDuctSilencerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcDuctSilencerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcDuctSilencerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcDuctSilencerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcDuctSilencerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricApplianceTypeEnum {
    Computer,
    Directwaterheater,
    Dishwasher,
    Electriccooker,
    Electricheater,
    Facsimile,
    Freestandingfan,
    Freezer,
    FridgeFreezer,
    Handdryer,
    Indirectwaterheater,
    Microwave,
    Photocopier,
    Printer,
    Refrigerator,
    Radiantheater,
    Scanner,
    Telephone,
    Tumbledryer,
    Tv,
    Vendingmachine,
    Washingmachine,
    Waterheater,
    Watercooler,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricApplianceTypeEnum {
    fn default() -> Self {
        IfcElectricApplianceTypeEnum::Computer
    }
}
impl From<String> for IfcElectricApplianceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPUTER" => IfcElectricApplianceTypeEnum::Computer,
            "DIRECTWATERHEATER" => IfcElectricApplianceTypeEnum::Directwaterheater,
            "DISHWASHER" => IfcElectricApplianceTypeEnum::Dishwasher,
            "ELECTRICCOOKER" => IfcElectricApplianceTypeEnum::Electriccooker,
            "ELECTRICHEATER" => IfcElectricApplianceTypeEnum::Electricheater,
            "FACSIMILE" => IfcElectricApplianceTypeEnum::Facsimile,
            "FREESTANDINGFAN" => IfcElectricApplianceTypeEnum::Freestandingfan,
            "FREEZER" => IfcElectricApplianceTypeEnum::Freezer,
            "FRIDGE_FREEZER" => IfcElectricApplianceTypeEnum::FridgeFreezer,
            "HANDDRYER" => IfcElectricApplianceTypeEnum::Handdryer,
            "INDIRECTWATERHEATER" => IfcElectricApplianceTypeEnum::Indirectwaterheater,
            "MICROWAVE" => IfcElectricApplianceTypeEnum::Microwave,
            "PHOTOCOPIER" => IfcElectricApplianceTypeEnum::Photocopier,
            "PRINTER" => IfcElectricApplianceTypeEnum::Printer,
            "REFRIGERATOR" => IfcElectricApplianceTypeEnum::Refrigerator,
            "RADIANTHEATER" => IfcElectricApplianceTypeEnum::Radiantheater,
            "SCANNER" => IfcElectricApplianceTypeEnum::Scanner,
            "TELEPHONE" => IfcElectricApplianceTypeEnum::Telephone,
            "TUMBLEDRYER" => IfcElectricApplianceTypeEnum::Tumbledryer,
            "TV" => IfcElectricApplianceTypeEnum::Tv,
            "VENDINGMACHINE" => IfcElectricApplianceTypeEnum::Vendingmachine,
            "WASHINGMACHINE" => IfcElectricApplianceTypeEnum::Washingmachine,
            "WATERHEATER" => IfcElectricApplianceTypeEnum::Waterheater,
            "WATERCOOLER" => IfcElectricApplianceTypeEnum::Watercooler,
            "USERDEFINED" => IfcElectricApplianceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricApplianceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricApplianceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricApplianceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricApplianceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricCurrentEnum {
    Alternating,
    Direct,
    Notdefined,
}
impl Default for IfcElectricCurrentEnum {
    fn default() -> Self {
        IfcElectricCurrentEnum::Alternating
    }
}
impl From<String> for IfcElectricCurrentEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALTERNATING" => IfcElectricCurrentEnum::Alternating,
            "DIRECT" => IfcElectricCurrentEnum::Direct,
            "NOTDEFINED" => IfcElectricCurrentEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricCurrentEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricCurrentEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricCurrentEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricDistributionPointFunctionEnum {
    Alarmpanel,
    Consumerunit,
    Controlpanel,
    Distributionboard,
    Gasdetectorpanel,
    Indicatorpanel,
    Mimicpanel,
    Motorcontrolcentre,
    Switchboard,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricDistributionPointFunctionEnum {
    fn default() -> Self {
        IfcElectricDistributionPointFunctionEnum::Alarmpanel
    }
}
impl From<String> for IfcElectricDistributionPointFunctionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALARMPANEL" => IfcElectricDistributionPointFunctionEnum::Alarmpanel,
            "CONSUMERUNIT" => IfcElectricDistributionPointFunctionEnum::Consumerunit,
            "CONTROLPANEL" => IfcElectricDistributionPointFunctionEnum::Controlpanel,
            "DISTRIBUTIONBOARD" => IfcElectricDistributionPointFunctionEnum::Distributionboard,
            "GASDETECTORPANEL" => IfcElectricDistributionPointFunctionEnum::Gasdetectorpanel,
            "INDICATORPANEL" => IfcElectricDistributionPointFunctionEnum::Indicatorpanel,
            "MIMICPANEL" => IfcElectricDistributionPointFunctionEnum::Mimicpanel,
            "MOTORCONTROLCENTRE" => IfcElectricDistributionPointFunctionEnum::Motorcontrolcentre,
            "SWITCHBOARD" => IfcElectricDistributionPointFunctionEnum::Switchboard,
            "USERDEFINED" => IfcElectricDistributionPointFunctionEnum::Userdefined,
            "NOTDEFINED" => IfcElectricDistributionPointFunctionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricDistributionPointFunctionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricDistributionPointFunctionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricDistributionPointFunctionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricFlowStorageDeviceTypeEnum {
    Battery,
    Capacitorbank,
    Harmonicfilter,
    Inductorbank,
    Ups,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricFlowStorageDeviceTypeEnum {
    fn default() -> Self {
        IfcElectricFlowStorageDeviceTypeEnum::Battery
    }
}
impl From<String> for IfcElectricFlowStorageDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BATTERY" => IfcElectricFlowStorageDeviceTypeEnum::Battery,
            "CAPACITORBANK" => IfcElectricFlowStorageDeviceTypeEnum::Capacitorbank,
            "HARMONICFILTER" => IfcElectricFlowStorageDeviceTypeEnum::Harmonicfilter,
            "INDUCTORBANK" => IfcElectricFlowStorageDeviceTypeEnum::Inductorbank,
            "UPS" => IfcElectricFlowStorageDeviceTypeEnum::Ups,
            "USERDEFINED" => IfcElectricFlowStorageDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricFlowStorageDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricFlowStorageDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricFlowStorageDeviceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricFlowStorageDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricGeneratorTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricGeneratorTypeEnum {
    fn default() -> Self {
        IfcElectricGeneratorTypeEnum::Userdefined
    }
}
impl From<String> for IfcElectricGeneratorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcElectricGeneratorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricGeneratorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricGeneratorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricGeneratorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricGeneratorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricHeaterTypeEnum {
    Electricpointheater,
    Electriccableheater,
    Electricmatheater,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricHeaterTypeEnum {
    fn default() -> Self {
        IfcElectricHeaterTypeEnum::Electricpointheater
    }
}
impl From<String> for IfcElectricHeaterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELECTRICPOINTHEATER" => IfcElectricHeaterTypeEnum::Electricpointheater,
            "ELECTRICCABLEHEATER" => IfcElectricHeaterTypeEnum::Electriccableheater,
            "ELECTRICMATHEATER" => IfcElectricHeaterTypeEnum::Electricmatheater,
            "USERDEFINED" => IfcElectricHeaterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricHeaterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricHeaterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricHeaterTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricHeaterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricMotorTypeEnum {
    Dc,
    Induction,
    Polyphase,
    Reluctancesynchronous,
    Synchronous,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricMotorTypeEnum {
    fn default() -> Self {
        IfcElectricMotorTypeEnum::Dc
    }
}
impl From<String> for IfcElectricMotorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DC" => IfcElectricMotorTypeEnum::Dc,
            "INDUCTION" => IfcElectricMotorTypeEnum::Induction,
            "POLYPHASE" => IfcElectricMotorTypeEnum::Polyphase,
            "RELUCTANCESYNCHRONOUS" => IfcElectricMotorTypeEnum::Reluctancesynchronous,
            "SYNCHRONOUS" => IfcElectricMotorTypeEnum::Synchronous,
            "USERDEFINED" => IfcElectricMotorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricMotorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricMotorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricMotorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricMotorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElectricTimeControlTypeEnum {
    Timeclock,
    Timedelay,
    Relay,
    Userdefined,
    Notdefined,
}
impl Default for IfcElectricTimeControlTypeEnum {
    fn default() -> Self {
        IfcElectricTimeControlTypeEnum::Timeclock
    }
}
impl From<String> for IfcElectricTimeControlTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "TIMECLOCK" => IfcElectricTimeControlTypeEnum::Timeclock,
            "TIMEDELAY" => IfcElectricTimeControlTypeEnum::Timedelay,
            "RELAY" => IfcElectricTimeControlTypeEnum::Relay,
            "USERDEFINED" => IfcElectricTimeControlTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElectricTimeControlTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElectricTimeControlTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElectricTimeControlTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElectricTimeControlTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElementAssemblyTypeEnum {
    AccessoryAssembly,
    Arch,
    BeamGrid,
    BracedFrame,
    Girder,
    ReinforcementUnit,
    RigidFrame,
    SlabField,
    Truss,
    Userdefined,
    Notdefined,
}
impl Default for IfcElementAssemblyTypeEnum {
    fn default() -> Self {
        IfcElementAssemblyTypeEnum::AccessoryAssembly
    }
}
impl From<String> for IfcElementAssemblyTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACCESSORY_ASSEMBLY" => IfcElementAssemblyTypeEnum::AccessoryAssembly,
            "ARCH" => IfcElementAssemblyTypeEnum::Arch,
            "BEAM_GRID" => IfcElementAssemblyTypeEnum::BeamGrid,
            "BRACED_FRAME" => IfcElementAssemblyTypeEnum::BracedFrame,
            "GIRDER" => IfcElementAssemblyTypeEnum::Girder,
            "REINFORCEMENT_UNIT" => IfcElementAssemblyTypeEnum::ReinforcementUnit,
            "RIGID_FRAME" => IfcElementAssemblyTypeEnum::RigidFrame,
            "SLAB_FIELD" => IfcElementAssemblyTypeEnum::SlabField,
            "TRUSS" => IfcElementAssemblyTypeEnum::Truss,
            "USERDEFINED" => IfcElementAssemblyTypeEnum::Userdefined,
            "NOTDEFINED" => IfcElementAssemblyTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElementAssemblyTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElementAssemblyTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElementAssemblyTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcElementCompositionEnum {
    Complex,
    Element,
    Partial,
}
impl Default for IfcElementCompositionEnum {
    fn default() -> Self {
        IfcElementCompositionEnum::Complex
    }
}
impl From<String> for IfcElementCompositionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPLEX" => IfcElementCompositionEnum::Complex,
            "ELEMENT" => IfcElementCompositionEnum::Element,
            "PARTIAL" => IfcElementCompositionEnum::Partial,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcElementCompositionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcElementCompositionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcElementCompositionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEnergySequenceEnum {
    Primary,
    Secondary,
    Tertiary,
    Auxiliary,
    Userdefined,
    Notdefined,
}
impl Default for IfcEnergySequenceEnum {
    fn default() -> Self {
        IfcEnergySequenceEnum::Primary
    }
}
impl From<String> for IfcEnergySequenceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PRIMARY" => IfcEnergySequenceEnum::Primary,
            "SECONDARY" => IfcEnergySequenceEnum::Secondary,
            "TERTIARY" => IfcEnergySequenceEnum::Tertiary,
            "AUXILIARY" => IfcEnergySequenceEnum::Auxiliary,
            "USERDEFINED" => IfcEnergySequenceEnum::Userdefined,
            "NOTDEFINED" => IfcEnergySequenceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEnergySequenceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcEnergySequenceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEnergySequenceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEnvironmentalImpactCategoryEnum {
    Combinedvalue,
    Disposal,
    Extraction,
    Installation,
    Manufacture,
    Transportation,
    Userdefined,
    Notdefined,
}
impl Default for IfcEnvironmentalImpactCategoryEnum {
    fn default() -> Self {
        IfcEnvironmentalImpactCategoryEnum::Combinedvalue
    }
}
impl From<String> for IfcEnvironmentalImpactCategoryEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMBINEDVALUE" => IfcEnvironmentalImpactCategoryEnum::Combinedvalue,
            "DISPOSAL" => IfcEnvironmentalImpactCategoryEnum::Disposal,
            "EXTRACTION" => IfcEnvironmentalImpactCategoryEnum::Extraction,
            "INSTALLATION" => IfcEnvironmentalImpactCategoryEnum::Installation,
            "MANUFACTURE" => IfcEnvironmentalImpactCategoryEnum::Manufacture,
            "TRANSPORTATION" => IfcEnvironmentalImpactCategoryEnum::Transportation,
            "USERDEFINED" => IfcEnvironmentalImpactCategoryEnum::Userdefined,
            "NOTDEFINED" => IfcEnvironmentalImpactCategoryEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEnvironmentalImpactCategoryEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcEnvironmentalImpactCategoryEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEnvironmentalImpactCategoryEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEvaporativeCoolerTypeEnum {
    Directevaporativerandommediaaircooler,
    Directevaporativerigidmediaaircooler,
    Directevaporativeslingerspackagedaircooler,
    Directevaporativepackagedrotaryaircooler,
    Directevaporativeairwasher,
    Indirectevaporativepackageaircooler,
    Indirectevaporativewetcoil,
    Indirectevaporativecoolingtowerorcoilcooler,
    Indirectdirectcombination,
    Userdefined,
    Notdefined,
}
impl Default for IfcEvaporativeCoolerTypeEnum {
    fn default() -> Self {
        IfcEvaporativeCoolerTypeEnum::Directevaporativerandommediaaircooler
    }
}
impl From<String> for IfcEvaporativeCoolerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativerandommediaaircooler
            }
            "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativerigidmediaaircooler
            }
            "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativeslingerspackagedaircooler
            }
            "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Directevaporativepackagedrotaryaircooler
            }
            "DIRECTEVAPORATIVEAIRWASHER" => IfcEvaporativeCoolerTypeEnum::Directevaporativeairwasher,
            "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER" => IfcEvaporativeCoolerTypeEnum::Indirectevaporativepackageaircooler,
            "INDIRECTEVAPORATIVEWETCOIL" => IfcEvaporativeCoolerTypeEnum::Indirectevaporativewetcoil,
            "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER" => {
                IfcEvaporativeCoolerTypeEnum::Indirectevaporativecoolingtowerorcoilcooler
            }
            "INDIRECTDIRECTCOMBINATION" => IfcEvaporativeCoolerTypeEnum::Indirectdirectcombination,
            "USERDEFINED" => IfcEvaporativeCoolerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEvaporativeCoolerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEvaporativeCoolerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcEvaporativeCoolerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEvaporativeCoolerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcEvaporatorTypeEnum {
    Directexpansionshellandtube,
    Directexpansiontubeintube,
    Directexpansionbrazedplate,
    Floodedshellandtube,
    Shellandcoil,
    Userdefined,
    Notdefined,
}
impl Default for IfcEvaporatorTypeEnum {
    fn default() -> Self {
        IfcEvaporatorTypeEnum::Directexpansionshellandtube
    }
}
impl From<String> for IfcEvaporatorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DIRECTEXPANSIONSHELLANDTUBE" => IfcEvaporatorTypeEnum::Directexpansionshellandtube,
            "DIRECTEXPANSIONTUBEINTUBE" => IfcEvaporatorTypeEnum::Directexpansiontubeintube,
            "DIRECTEXPANSIONBRAZEDPLATE" => IfcEvaporatorTypeEnum::Directexpansionbrazedplate,
            "FLOODEDSHELLANDTUBE" => IfcEvaporatorTypeEnum::Floodedshellandtube,
            "SHELLANDCOIL" => IfcEvaporatorTypeEnum::Shellandcoil,
            "USERDEFINED" => IfcEvaporatorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcEvaporatorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcEvaporatorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcEvaporatorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcEvaporatorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFanTypeEnum {
    Centrifugalforwardcurved,
    Centrifugalradial,
    Centrifugalbackwardinclinedcurved,
    Centrifugalairfoil,
    Tubeaxial,
    Vaneaxial,
    Propelloraxial,
    Userdefined,
    Notdefined,
}
impl Default for IfcFanTypeEnum {
    fn default() -> Self {
        IfcFanTypeEnum::Centrifugalforwardcurved
    }
}
impl From<String> for IfcFanTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CENTRIFUGALFORWARDCURVED" => IfcFanTypeEnum::Centrifugalforwardcurved,
            "CENTRIFUGALRADIAL" => IfcFanTypeEnum::Centrifugalradial,
            "CENTRIFUGALBACKWARDINCLINEDCURVED" => IfcFanTypeEnum::Centrifugalbackwardinclinedcurved,
            "CENTRIFUGALAIRFOIL" => IfcFanTypeEnum::Centrifugalairfoil,
            "TUBEAXIAL" => IfcFanTypeEnum::Tubeaxial,
            "VANEAXIAL" => IfcFanTypeEnum::Vaneaxial,
            "PROPELLORAXIAL" => IfcFanTypeEnum::Propelloraxial,
            "USERDEFINED" => IfcFanTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFanTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFanTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFanTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFanTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFilterTypeEnum {
    Airparticlefilter,
    Odorfilter,
    Oilfilter,
    Strainer,
    Waterfilter,
    Userdefined,
    Notdefined,
}
impl Default for IfcFilterTypeEnum {
    fn default() -> Self {
        IfcFilterTypeEnum::Airparticlefilter
    }
}
impl From<String> for IfcFilterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRPARTICLEFILTER" => IfcFilterTypeEnum::Airparticlefilter,
            "ODORFILTER" => IfcFilterTypeEnum::Odorfilter,
            "OILFILTER" => IfcFilterTypeEnum::Oilfilter,
            "STRAINER" => IfcFilterTypeEnum::Strainer,
            "WATERFILTER" => IfcFilterTypeEnum::Waterfilter,
            "USERDEFINED" => IfcFilterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFilterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFilterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFilterTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFilterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFireSuppressionTerminalTypeEnum {
    Breechinginlet,
    Firehydrant,
    Hosereel,
    Sprinkler,
    Sprinklerdeflector,
    Userdefined,
    Notdefined,
}
impl Default for IfcFireSuppressionTerminalTypeEnum {
    fn default() -> Self {
        IfcFireSuppressionTerminalTypeEnum::Breechinginlet
    }
}
impl From<String> for IfcFireSuppressionTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BREECHINGINLET" => IfcFireSuppressionTerminalTypeEnum::Breechinginlet,
            "FIREHYDRANT" => IfcFireSuppressionTerminalTypeEnum::Firehydrant,
            "HOSEREEL" => IfcFireSuppressionTerminalTypeEnum::Hosereel,
            "SPRINKLER" => IfcFireSuppressionTerminalTypeEnum::Sprinkler,
            "SPRINKLERDEFLECTOR" => IfcFireSuppressionTerminalTypeEnum::Sprinklerdeflector,
            "USERDEFINED" => IfcFireSuppressionTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFireSuppressionTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFireSuppressionTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFireSuppressionTerminalTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFireSuppressionTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFlowDirectionEnum {
    Source,
    Sink,
    Sourceandsink,
    Notdefined,
}
impl Default for IfcFlowDirectionEnum {
    fn default() -> Self {
        IfcFlowDirectionEnum::Source
    }
}
impl From<String> for IfcFlowDirectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SOURCE" => IfcFlowDirectionEnum::Source,
            "SINK" => IfcFlowDirectionEnum::Sink,
            "SOURCEANDSINK" => IfcFlowDirectionEnum::Sourceandsink,
            "NOTDEFINED" => IfcFlowDirectionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFlowDirectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFlowDirectionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFlowDirectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFlowInstrumentTypeEnum {
    Pressuregauge,
    Thermometer,
    Ammeter,
    Frequencymeter,
    Powerfactormeter,
    Phaseanglemeter,
    VoltmeterPeak,
    VoltmeterRms,
    Userdefined,
    Notdefined,
}
impl Default for IfcFlowInstrumentTypeEnum {
    fn default() -> Self {
        IfcFlowInstrumentTypeEnum::Pressuregauge
    }
}
impl From<String> for IfcFlowInstrumentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PRESSUREGAUGE" => IfcFlowInstrumentTypeEnum::Pressuregauge,
            "THERMOMETER" => IfcFlowInstrumentTypeEnum::Thermometer,
            "AMMETER" => IfcFlowInstrumentTypeEnum::Ammeter,
            "FREQUENCYMETER" => IfcFlowInstrumentTypeEnum::Frequencymeter,
            "POWERFACTORMETER" => IfcFlowInstrumentTypeEnum::Powerfactormeter,
            "PHASEANGLEMETER" => IfcFlowInstrumentTypeEnum::Phaseanglemeter,
            "VOLTMETER_PEAK" => IfcFlowInstrumentTypeEnum::VoltmeterPeak,
            "VOLTMETER_RMS" => IfcFlowInstrumentTypeEnum::VoltmeterRms,
            "USERDEFINED" => IfcFlowInstrumentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFlowInstrumentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFlowInstrumentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFlowInstrumentTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFlowInstrumentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFlowMeterTypeEnum {
    Electricmeter,
    Energymeter,
    Flowmeter,
    Gasmeter,
    Oilmeter,
    Watermeter,
    Userdefined,
    Notdefined,
}
impl Default for IfcFlowMeterTypeEnum {
    fn default() -> Self {
        IfcFlowMeterTypeEnum::Electricmeter
    }
}
impl From<String> for IfcFlowMeterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELECTRICMETER" => IfcFlowMeterTypeEnum::Electricmeter,
            "ENERGYMETER" => IfcFlowMeterTypeEnum::Energymeter,
            "FLOWMETER" => IfcFlowMeterTypeEnum::Flowmeter,
            "GASMETER" => IfcFlowMeterTypeEnum::Gasmeter,
            "OILMETER" => IfcFlowMeterTypeEnum::Oilmeter,
            "WATERMETER" => IfcFlowMeterTypeEnum::Watermeter,
            "USERDEFINED" => IfcFlowMeterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFlowMeterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFlowMeterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFlowMeterTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFlowMeterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFootingTypeEnum {
    FootingBeam,
    PadFooting,
    PileCap,
    StripFooting,
    Userdefined,
    Notdefined,
}
impl Default for IfcFootingTypeEnum {
    fn default() -> Self {
        IfcFootingTypeEnum::FootingBeam
    }
}
impl From<String> for IfcFootingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FOOTING_BEAM" => IfcFootingTypeEnum::FootingBeam,
            "PAD_FOOTING" => IfcFootingTypeEnum::PadFooting,
            "PILE_CAP" => IfcFootingTypeEnum::PileCap,
            "STRIP_FOOTING" => IfcFootingTypeEnum::StripFooting,
            "USERDEFINED" => IfcFootingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcFootingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcFootingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcFootingTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcFootingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGasTerminalTypeEnum {
    Gasappliance,
    Gasbooster,
    Gasburner,
    Userdefined,
    Notdefined,
}
impl Default for IfcGasTerminalTypeEnum {
    fn default() -> Self {
        IfcGasTerminalTypeEnum::Gasappliance
    }
}
impl From<String> for IfcGasTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GASAPPLIANCE" => IfcGasTerminalTypeEnum::Gasappliance,
            "GASBOOSTER" => IfcGasTerminalTypeEnum::Gasbooster,
            "GASBURNER" => IfcGasTerminalTypeEnum::Gasburner,
            "USERDEFINED" => IfcGasTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcGasTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGasTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcGasTerminalTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGasTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGeometricProjectionEnum {
    GraphView,
    SketchView,
    ModelView,
    PlanView,
    ReflectedPlanView,
    SectionView,
    ElevationView,
    Userdefined,
    Notdefined,
}
impl Default for IfcGeometricProjectionEnum {
    fn default() -> Self {
        IfcGeometricProjectionEnum::GraphView
    }
}
impl From<String> for IfcGeometricProjectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GRAPH_VIEW" => IfcGeometricProjectionEnum::GraphView,
            "SKETCH_VIEW" => IfcGeometricProjectionEnum::SketchView,
            "MODEL_VIEW" => IfcGeometricProjectionEnum::ModelView,
            "PLAN_VIEW" => IfcGeometricProjectionEnum::PlanView,
            "REFLECTED_PLAN_VIEW" => IfcGeometricProjectionEnum::ReflectedPlanView,
            "SECTION_VIEW" => IfcGeometricProjectionEnum::SectionView,
            "ELEVATION_VIEW" => IfcGeometricProjectionEnum::ElevationView,
            "USERDEFINED" => IfcGeometricProjectionEnum::Userdefined,
            "NOTDEFINED" => IfcGeometricProjectionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGeometricProjectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcGeometricProjectionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGeometricProjectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGlobalOrLocalEnum {
    GlobalCoords,
    LocalCoords,
}
impl Default for IfcGlobalOrLocalEnum {
    fn default() -> Self {
        IfcGlobalOrLocalEnum::GlobalCoords
    }
}
impl From<String> for IfcGlobalOrLocalEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GLOBAL_COORDS" => IfcGlobalOrLocalEnum::GlobalCoords,
            "LOCAL_COORDS" => IfcGlobalOrLocalEnum::LocalCoords,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcGlobalOrLocalEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcGlobalOrLocalEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcGlobalOrLocalEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcHeatExchangerTypeEnum {
    Plate,
    Shellandtube,
    Userdefined,
    Notdefined,
}
impl Default for IfcHeatExchangerTypeEnum {
    fn default() -> Self {
        IfcHeatExchangerTypeEnum::Plate
    }
}
impl From<String> for IfcHeatExchangerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLATE" => IfcHeatExchangerTypeEnum::Plate,
            "SHELLANDTUBE" => IfcHeatExchangerTypeEnum::Shellandtube,
            "USERDEFINED" => IfcHeatExchangerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcHeatExchangerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcHeatExchangerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcHeatExchangerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcHeatExchangerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcHumidifierTypeEnum {
    Steaminjection,
    Adiabaticairwasher,
    Adiabaticpan,
    Adiabaticwettedelement,
    Adiabaticatomizing,
    Adiabaticultrasonic,
    Adiabaticrigidmedia,
    Adiabaticcompressedairnozzle,
    Assistedelectric,
    Assistednaturalgas,
    Assistedpropane,
    Assistedbutane,
    Assistedsteam,
    Userdefined,
    Notdefined,
}
impl Default for IfcHumidifierTypeEnum {
    fn default() -> Self {
        IfcHumidifierTypeEnum::Steaminjection
    }
}
impl From<String> for IfcHumidifierTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STEAMINJECTION" => IfcHumidifierTypeEnum::Steaminjection,
            "ADIABATICAIRWASHER" => IfcHumidifierTypeEnum::Adiabaticairwasher,
            "ADIABATICPAN" => IfcHumidifierTypeEnum::Adiabaticpan,
            "ADIABATICWETTEDELEMENT" => IfcHumidifierTypeEnum::Adiabaticwettedelement,
            "ADIABATICATOMIZING" => IfcHumidifierTypeEnum::Adiabaticatomizing,
            "ADIABATICULTRASONIC" => IfcHumidifierTypeEnum::Adiabaticultrasonic,
            "ADIABATICRIGIDMEDIA" => IfcHumidifierTypeEnum::Adiabaticrigidmedia,
            "ADIABATICCOMPRESSEDAIRNOZZLE" => IfcHumidifierTypeEnum::Adiabaticcompressedairnozzle,
            "ASSISTEDELECTRIC" => IfcHumidifierTypeEnum::Assistedelectric,
            "ASSISTEDNATURALGAS" => IfcHumidifierTypeEnum::Assistednaturalgas,
            "ASSISTEDPROPANE" => IfcHumidifierTypeEnum::Assistedpropane,
            "ASSISTEDBUTANE" => IfcHumidifierTypeEnum::Assistedbutane,
            "ASSISTEDSTEAM" => IfcHumidifierTypeEnum::Assistedsteam,
            "USERDEFINED" => IfcHumidifierTypeEnum::Userdefined,
            "NOTDEFINED" => IfcHumidifierTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcHumidifierTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcHumidifierTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcHumidifierTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcInternalOrExternalEnum {
    Internal,
    External,
    Notdefined,
}
impl Default for IfcInternalOrExternalEnum {
    fn default() -> Self {
        IfcInternalOrExternalEnum::Internal
    }
}
impl From<String> for IfcInternalOrExternalEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "INTERNAL" => IfcInternalOrExternalEnum::Internal,
            "EXTERNAL" => IfcInternalOrExternalEnum::External,
            "NOTDEFINED" => IfcInternalOrExternalEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcInternalOrExternalEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcInternalOrExternalEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcInternalOrExternalEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcInventoryTypeEnum {
    Assetinventory,
    Spaceinventory,
    Furnitureinventory,
    Userdefined,
    Notdefined,
}
impl Default for IfcInventoryTypeEnum {
    fn default() -> Self {
        IfcInventoryTypeEnum::Assetinventory
    }
}
impl From<String> for IfcInventoryTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ASSETINVENTORY" => IfcInventoryTypeEnum::Assetinventory,
            "SPACEINVENTORY" => IfcInventoryTypeEnum::Spaceinventory,
            "FURNITUREINVENTORY" => IfcInventoryTypeEnum::Furnitureinventory,
            "USERDEFINED" => IfcInventoryTypeEnum::Userdefined,
            "NOTDEFINED" => IfcInventoryTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcInventoryTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcInventoryTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcInventoryTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcJunctionBoxTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcJunctionBoxTypeEnum {
    fn default() -> Self {
        IfcJunctionBoxTypeEnum::Userdefined
    }
}
impl From<String> for IfcJunctionBoxTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcJunctionBoxTypeEnum::Userdefined,
            "NOTDEFINED" => IfcJunctionBoxTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcJunctionBoxTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcJunctionBoxTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcJunctionBoxTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLampTypeEnum {
    Compactfluorescent,
    Fluorescent,
    Highpressuremercury,
    Highpressuresodium,
    Metalhalide,
    Tungstenfilament,
    Userdefined,
    Notdefined,
}
impl Default for IfcLampTypeEnum {
    fn default() -> Self {
        IfcLampTypeEnum::Compactfluorescent
    }
}
impl From<String> for IfcLampTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPACTFLUORESCENT" => IfcLampTypeEnum::Compactfluorescent,
            "FLUORESCENT" => IfcLampTypeEnum::Fluorescent,
            "HIGHPRESSUREMERCURY" => IfcLampTypeEnum::Highpressuremercury,
            "HIGHPRESSURESODIUM" => IfcLampTypeEnum::Highpressuresodium,
            "METALHALIDE" => IfcLampTypeEnum::Metalhalide,
            "TUNGSTENFILAMENT" => IfcLampTypeEnum::Tungstenfilament,
            "USERDEFINED" => IfcLampTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLampTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLampTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLampTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLampTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLayerSetDirectionEnum {
    Axis1,
    Axis2,
    Axis3,
}
impl Default for IfcLayerSetDirectionEnum {
    fn default() -> Self {
        IfcLayerSetDirectionEnum::Axis1
    }
}
impl From<String> for IfcLayerSetDirectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AXIS1" => IfcLayerSetDirectionEnum::Axis1,
            "AXIS2" => IfcLayerSetDirectionEnum::Axis2,
            "AXIS3" => IfcLayerSetDirectionEnum::Axis3,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLayerSetDirectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLayerSetDirectionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLayerSetDirectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLightDistributionCurveEnum {
    TypeA,
    TypeB,
    TypeC,
    Notdefined,
}
impl Default for IfcLightDistributionCurveEnum {
    fn default() -> Self {
        IfcLightDistributionCurveEnum::TypeA
    }
}
impl From<String> for IfcLightDistributionCurveEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "TYPE_A" => IfcLightDistributionCurveEnum::TypeA,
            "TYPE_B" => IfcLightDistributionCurveEnum::TypeB,
            "TYPE_C" => IfcLightDistributionCurveEnum::TypeC,
            "NOTDEFINED" => IfcLightDistributionCurveEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLightDistributionCurveEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLightDistributionCurveEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLightDistributionCurveEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLightEmissionSourceEnum {
    Compactfluorescent,
    Fluorescent,
    Highpressuremercury,
    Highpressuresodium,
    Lightemittingdiode,
    Lowpressuresodium,
    Lowvoltagehalogen,
    Mainvoltagehalogen,
    Metalhalide,
    Tungstenfilament,
    Notdefined,
}
impl Default for IfcLightEmissionSourceEnum {
    fn default() -> Self {
        IfcLightEmissionSourceEnum::Compactfluorescent
    }
}
impl From<String> for IfcLightEmissionSourceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPACTFLUORESCENT" => IfcLightEmissionSourceEnum::Compactfluorescent,
            "FLUORESCENT" => IfcLightEmissionSourceEnum::Fluorescent,
            "HIGHPRESSUREMERCURY" => IfcLightEmissionSourceEnum::Highpressuremercury,
            "HIGHPRESSURESODIUM" => IfcLightEmissionSourceEnum::Highpressuresodium,
            "LIGHTEMITTINGDIODE" => IfcLightEmissionSourceEnum::Lightemittingdiode,
            "LOWPRESSURESODIUM" => IfcLightEmissionSourceEnum::Lowpressuresodium,
            "LOWVOLTAGEHALOGEN" => IfcLightEmissionSourceEnum::Lowvoltagehalogen,
            "MAINVOLTAGEHALOGEN" => IfcLightEmissionSourceEnum::Mainvoltagehalogen,
            "METALHALIDE" => IfcLightEmissionSourceEnum::Metalhalide,
            "TUNGSTENFILAMENT" => IfcLightEmissionSourceEnum::Tungstenfilament,
            "NOTDEFINED" => IfcLightEmissionSourceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLightEmissionSourceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLightEmissionSourceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLightEmissionSourceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLightFixtureTypeEnum {
    Pointsource,
    Directionsource,
    Userdefined,
    Notdefined,
}
impl Default for IfcLightFixtureTypeEnum {
    fn default() -> Self {
        IfcLightFixtureTypeEnum::Pointsource
    }
}
impl From<String> for IfcLightFixtureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POINTSOURCE" => IfcLightFixtureTypeEnum::Pointsource,
            "DIRECTIONSOURCE" => IfcLightFixtureTypeEnum::Directionsource,
            "USERDEFINED" => IfcLightFixtureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLightFixtureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLightFixtureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLightFixtureTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLightFixtureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLoadGroupTypeEnum {
    LoadGroup,
    LoadCase,
    LoadCombinationGroup,
    LoadCombination,
    Userdefined,
    Notdefined,
}
impl Default for IfcLoadGroupTypeEnum {
    fn default() -> Self {
        IfcLoadGroupTypeEnum::LoadGroup
    }
}
impl From<String> for IfcLoadGroupTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LOAD_GROUP" => IfcLoadGroupTypeEnum::LoadGroup,
            "LOAD_CASE" => IfcLoadGroupTypeEnum::LoadCase,
            "LOAD_COMBINATION_GROUP" => IfcLoadGroupTypeEnum::LoadCombinationGroup,
            "LOAD_COMBINATION" => IfcLoadGroupTypeEnum::LoadCombination,
            "USERDEFINED" => IfcLoadGroupTypeEnum::Userdefined,
            "NOTDEFINED" => IfcLoadGroupTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLoadGroupTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLoadGroupTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLoadGroupTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLogicalOperatorEnum {
    Logicaland,
    Logicalor,
}
impl Default for IfcLogicalOperatorEnum {
    fn default() -> Self {
        IfcLogicalOperatorEnum::Logicaland
    }
}
impl From<String> for IfcLogicalOperatorEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LOGICALAND" => IfcLogicalOperatorEnum::Logicaland,
            "LOGICALOR" => IfcLogicalOperatorEnum::Logicalor,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcLogicalOperatorEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcLogicalOperatorEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcLogicalOperatorEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcMemberTypeEnum {
    Brace,
    Chord,
    Collar,
    Member,
    Mullion,
    Plate,
    Post,
    Purlin,
    Rafter,
    Stringer,
    Strut,
    Stud,
    Userdefined,
    Notdefined,
}
impl Default for IfcMemberTypeEnum {
    fn default() -> Self {
        IfcMemberTypeEnum::Brace
    }
}
impl From<String> for IfcMemberTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BRACE" => IfcMemberTypeEnum::Brace,
            "CHORD" => IfcMemberTypeEnum::Chord,
            "COLLAR" => IfcMemberTypeEnum::Collar,
            "MEMBER" => IfcMemberTypeEnum::Member,
            "MULLION" => IfcMemberTypeEnum::Mullion,
            "PLATE" => IfcMemberTypeEnum::Plate,
            "POST" => IfcMemberTypeEnum::Post,
            "PURLIN" => IfcMemberTypeEnum::Purlin,
            "RAFTER" => IfcMemberTypeEnum::Rafter,
            "STRINGER" => IfcMemberTypeEnum::Stringer,
            "STRUT" => IfcMemberTypeEnum::Strut,
            "STUD" => IfcMemberTypeEnum::Stud,
            "USERDEFINED" => IfcMemberTypeEnum::Userdefined,
            "NOTDEFINED" => IfcMemberTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcMemberTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcMemberTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcMemberTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcMotorConnectionTypeEnum {
    Beltdrive,
    Coupling,
    Directdrive,
    Userdefined,
    Notdefined,
}
impl Default for IfcMotorConnectionTypeEnum {
    fn default() -> Self {
        IfcMotorConnectionTypeEnum::Beltdrive
    }
}
impl From<String> for IfcMotorConnectionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BELTDRIVE" => IfcMotorConnectionTypeEnum::Beltdrive,
            "COUPLING" => IfcMotorConnectionTypeEnum::Coupling,
            "DIRECTDRIVE" => IfcMotorConnectionTypeEnum::Directdrive,
            "USERDEFINED" => IfcMotorConnectionTypeEnum::Userdefined,
            "NOTDEFINED" => IfcMotorConnectionTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcMotorConnectionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcMotorConnectionTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcMotorConnectionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcNullStyle {
    Null,
}
impl Default for IfcNullStyle {
    fn default() -> Self {
        IfcNullStyle::Null
    }
}
impl From<String> for IfcNullStyle {
    fn from(value: String) -> Self {
        match value.as_str() {
            "NULL" => IfcNullStyle::Null,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcNullStyle {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcNullStyle::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcNullStyle::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcObjectTypeEnum {
    Product,
    Process,
    Control,
    Resource,
    Actor,
    Group,
    Project,
    Notdefined,
}
impl Default for IfcObjectTypeEnum {
    fn default() -> Self {
        IfcObjectTypeEnum::Product
    }
}
impl From<String> for IfcObjectTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PRODUCT" => IfcObjectTypeEnum::Product,
            "PROCESS" => IfcObjectTypeEnum::Process,
            "CONTROL" => IfcObjectTypeEnum::Control,
            "RESOURCE" => IfcObjectTypeEnum::Resource,
            "ACTOR" => IfcObjectTypeEnum::Actor,
            "GROUP" => IfcObjectTypeEnum::Group,
            "PROJECT" => IfcObjectTypeEnum::Project,
            "NOTDEFINED" => IfcObjectTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcObjectTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcObjectTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcObjectTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcObjectiveEnum {
    Codecompliance,
    Designintent,
    Healthandsafety,
    Requirement,
    Specification,
    Triggercondition,
    Userdefined,
    Notdefined,
}
impl Default for IfcObjectiveEnum {
    fn default() -> Self {
        IfcObjectiveEnum::Codecompliance
    }
}
impl From<String> for IfcObjectiveEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CODECOMPLIANCE" => IfcObjectiveEnum::Codecompliance,
            "DESIGNINTENT" => IfcObjectiveEnum::Designintent,
            "HEALTHANDSAFETY" => IfcObjectiveEnum::Healthandsafety,
            "REQUIREMENT" => IfcObjectiveEnum::Requirement,
            "SPECIFICATION" => IfcObjectiveEnum::Specification,
            "TRIGGERCONDITION" => IfcObjectiveEnum::Triggercondition,
            "USERDEFINED" => IfcObjectiveEnum::Userdefined,
            "NOTDEFINED" => IfcObjectiveEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcObjectiveEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcObjectiveEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcObjectiveEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcOccupantTypeEnum {
    Assignee,
    Assignor,
    Lessee,
    Lessor,
    Lettingagent,
    Owner,
    Tenant,
    Userdefined,
    Notdefined,
}
impl Default for IfcOccupantTypeEnum {
    fn default() -> Self {
        IfcOccupantTypeEnum::Assignee
    }
}
impl From<String> for IfcOccupantTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ASSIGNEE" => IfcOccupantTypeEnum::Assignee,
            "ASSIGNOR" => IfcOccupantTypeEnum::Assignor,
            "LESSEE" => IfcOccupantTypeEnum::Lessee,
            "LESSOR" => IfcOccupantTypeEnum::Lessor,
            "LETTINGAGENT" => IfcOccupantTypeEnum::Lettingagent,
            "OWNER" => IfcOccupantTypeEnum::Owner,
            "TENANT" => IfcOccupantTypeEnum::Tenant,
            "USERDEFINED" => IfcOccupantTypeEnum::Userdefined,
            "NOTDEFINED" => IfcOccupantTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcOccupantTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcOccupantTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcOccupantTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcOutletTypeEnum {
    Audiovisualoutlet,
    Communicationsoutlet,
    Poweroutlet,
    Userdefined,
    Notdefined,
}
impl Default for IfcOutletTypeEnum {
    fn default() -> Self {
        IfcOutletTypeEnum::Audiovisualoutlet
    }
}
impl From<String> for IfcOutletTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AUDIOVISUALOUTLET" => IfcOutletTypeEnum::Audiovisualoutlet,
            "COMMUNICATIONSOUTLET" => IfcOutletTypeEnum::Communicationsoutlet,
            "POWEROUTLET" => IfcOutletTypeEnum::Poweroutlet,
            "USERDEFINED" => IfcOutletTypeEnum::Userdefined,
            "NOTDEFINED" => IfcOutletTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcOutletTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcOutletTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcOutletTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPermeableCoveringOperationEnum {
    Grill,
    Louver,
    Screen,
    Userdefined,
    Notdefined,
}
impl Default for IfcPermeableCoveringOperationEnum {
    fn default() -> Self {
        IfcPermeableCoveringOperationEnum::Grill
    }
}
impl From<String> for IfcPermeableCoveringOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "GRILL" => IfcPermeableCoveringOperationEnum::Grill,
            "LOUVER" => IfcPermeableCoveringOperationEnum::Louver,
            "SCREEN" => IfcPermeableCoveringOperationEnum::Screen,
            "USERDEFINED" => IfcPermeableCoveringOperationEnum::Userdefined,
            "NOTDEFINED" => IfcPermeableCoveringOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPermeableCoveringOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPermeableCoveringOperationEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPermeableCoveringOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPhysicalOrVirtualEnum {
    Physical,
    Virtual,
    Notdefined,
}
impl Default for IfcPhysicalOrVirtualEnum {
    fn default() -> Self {
        IfcPhysicalOrVirtualEnum::Physical
    }
}
impl From<String> for IfcPhysicalOrVirtualEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PHYSICAL" => IfcPhysicalOrVirtualEnum::Physical,
            "VIRTUAL" => IfcPhysicalOrVirtualEnum::Virtual,
            "NOTDEFINED" => IfcPhysicalOrVirtualEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPhysicalOrVirtualEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPhysicalOrVirtualEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPhysicalOrVirtualEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPileConstructionEnum {
    CastInPlace,
    Composite,
    PrecastConcrete,
    PrefabSteel,
    Userdefined,
    Notdefined,
}
impl Default for IfcPileConstructionEnum {
    fn default() -> Self {
        IfcPileConstructionEnum::CastInPlace
    }
}
impl From<String> for IfcPileConstructionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CAST_IN_PLACE" => IfcPileConstructionEnum::CastInPlace,
            "COMPOSITE" => IfcPileConstructionEnum::Composite,
            "PRECAST_CONCRETE" => IfcPileConstructionEnum::PrecastConcrete,
            "PREFAB_STEEL" => IfcPileConstructionEnum::PrefabSteel,
            "USERDEFINED" => IfcPileConstructionEnum::Userdefined,
            "NOTDEFINED" => IfcPileConstructionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPileConstructionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPileConstructionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPileConstructionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPileTypeEnum {
    Cohesion,
    Friction,
    Support,
    Userdefined,
    Notdefined,
}
impl Default for IfcPileTypeEnum {
    fn default() -> Self {
        IfcPileTypeEnum::Cohesion
    }
}
impl From<String> for IfcPileTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COHESION" => IfcPileTypeEnum::Cohesion,
            "FRICTION" => IfcPileTypeEnum::Friction,
            "SUPPORT" => IfcPileTypeEnum::Support,
            "USERDEFINED" => IfcPileTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPileTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPileTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPileTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPileTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPipeFittingTypeEnum {
    Bend,
    Connector,
    Entry,
    Exit,
    Junction,
    Obstruction,
    Transition,
    Userdefined,
    Notdefined,
}
impl Default for IfcPipeFittingTypeEnum {
    fn default() -> Self {
        IfcPipeFittingTypeEnum::Bend
    }
}
impl From<String> for IfcPipeFittingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BEND" => IfcPipeFittingTypeEnum::Bend,
            "CONNECTOR" => IfcPipeFittingTypeEnum::Connector,
            "ENTRY" => IfcPipeFittingTypeEnum::Entry,
            "EXIT" => IfcPipeFittingTypeEnum::Exit,
            "JUNCTION" => IfcPipeFittingTypeEnum::Junction,
            "OBSTRUCTION" => IfcPipeFittingTypeEnum::Obstruction,
            "TRANSITION" => IfcPipeFittingTypeEnum::Transition,
            "USERDEFINED" => IfcPipeFittingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPipeFittingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPipeFittingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPipeFittingTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPipeFittingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPipeSegmentTypeEnum {
    Flexiblesegment,
    Rigidsegment,
    Gutter,
    Spool,
    Userdefined,
    Notdefined,
}
impl Default for IfcPipeSegmentTypeEnum {
    fn default() -> Self {
        IfcPipeSegmentTypeEnum::Flexiblesegment
    }
}
impl From<String> for IfcPipeSegmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLEXIBLESEGMENT" => IfcPipeSegmentTypeEnum::Flexiblesegment,
            "RIGIDSEGMENT" => IfcPipeSegmentTypeEnum::Rigidsegment,
            "GUTTER" => IfcPipeSegmentTypeEnum::Gutter,
            "SPOOL" => IfcPipeSegmentTypeEnum::Spool,
            "USERDEFINED" => IfcPipeSegmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPipeSegmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPipeSegmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPipeSegmentTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPipeSegmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPlateTypeEnum {
    CurtainPanel,
    Sheet,
    Userdefined,
    Notdefined,
}
impl Default for IfcPlateTypeEnum {
    fn default() -> Self {
        IfcPlateTypeEnum::CurtainPanel
    }
}
impl From<String> for IfcPlateTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURTAIN_PANEL" => IfcPlateTypeEnum::CurtainPanel,
            "SHEET" => IfcPlateTypeEnum::Sheet,
            "USERDEFINED" => IfcPlateTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPlateTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPlateTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPlateTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPlateTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProcedureTypeEnum {
    AdviceCaution,
    AdviceNote,
    AdviceWarning,
    Calibration,
    Diagnostic,
    Shutdown,
    Startup,
    Userdefined,
    Notdefined,
}
impl Default for IfcProcedureTypeEnum {
    fn default() -> Self {
        IfcProcedureTypeEnum::AdviceCaution
    }
}
impl From<String> for IfcProcedureTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ADVICE_CAUTION" => IfcProcedureTypeEnum::AdviceCaution,
            "ADVICE_NOTE" => IfcProcedureTypeEnum::AdviceNote,
            "ADVICE_WARNING" => IfcProcedureTypeEnum::AdviceWarning,
            "CALIBRATION" => IfcProcedureTypeEnum::Calibration,
            "DIAGNOSTIC" => IfcProcedureTypeEnum::Diagnostic,
            "SHUTDOWN" => IfcProcedureTypeEnum::Shutdown,
            "STARTUP" => IfcProcedureTypeEnum::Startup,
            "USERDEFINED" => IfcProcedureTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProcedureTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProcedureTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcProcedureTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProcedureTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProfileTypeEnum {
    Curve,
    Area,
}
impl Default for IfcProfileTypeEnum {
    fn default() -> Self {
        IfcProfileTypeEnum::Curve
    }
}
impl From<String> for IfcProfileTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURVE" => IfcProfileTypeEnum::Curve,
            "AREA" => IfcProfileTypeEnum::Area,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProfileTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcProfileTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProfileTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProjectOrderRecordTypeEnum {
    Change,
    Maintenance,
    Move,
    Purchase,
    Work,
    Userdefined,
    Notdefined,
}
impl Default for IfcProjectOrderRecordTypeEnum {
    fn default() -> Self {
        IfcProjectOrderRecordTypeEnum::Change
    }
}
impl From<String> for IfcProjectOrderRecordTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CHANGE" => IfcProjectOrderRecordTypeEnum::Change,
            "MAINTENANCE" => IfcProjectOrderRecordTypeEnum::Maintenance,
            "MOVE" => IfcProjectOrderRecordTypeEnum::Move,
            "PURCHASE" => IfcProjectOrderRecordTypeEnum::Purchase,
            "WORK" => IfcProjectOrderRecordTypeEnum::Work,
            "USERDEFINED" => IfcProjectOrderRecordTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProjectOrderRecordTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProjectOrderRecordTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcProjectOrderRecordTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProjectOrderRecordTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProjectOrderTypeEnum {
    Changeorder,
    Maintenanceworkorder,
    Moveorder,
    Purchaseorder,
    Workorder,
    Userdefined,
    Notdefined,
}
impl Default for IfcProjectOrderTypeEnum {
    fn default() -> Self {
        IfcProjectOrderTypeEnum::Changeorder
    }
}
impl From<String> for IfcProjectOrderTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CHANGEORDER" => IfcProjectOrderTypeEnum::Changeorder,
            "MAINTENANCEWORKORDER" => IfcProjectOrderTypeEnum::Maintenanceworkorder,
            "MOVEORDER" => IfcProjectOrderTypeEnum::Moveorder,
            "PURCHASEORDER" => IfcProjectOrderTypeEnum::Purchaseorder,
            "WORKORDER" => IfcProjectOrderTypeEnum::Workorder,
            "USERDEFINED" => IfcProjectOrderTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProjectOrderTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProjectOrderTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcProjectOrderTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProjectOrderTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProjectedOrTrueLengthEnum {
    ProjectedLength,
    TrueLength,
}
impl Default for IfcProjectedOrTrueLengthEnum {
    fn default() -> Self {
        IfcProjectedOrTrueLengthEnum::ProjectedLength
    }
}
impl From<String> for IfcProjectedOrTrueLengthEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PROJECTED_LENGTH" => IfcProjectedOrTrueLengthEnum::ProjectedLength,
            "TRUE_LENGTH" => IfcProjectedOrTrueLengthEnum::TrueLength,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProjectedOrTrueLengthEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcProjectedOrTrueLengthEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProjectedOrTrueLengthEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPropertySourceEnum {
    Design,
    Designmaximum,
    Designminimum,
    Simulated,
    Asbuilt,
    Commissioning,
    Measured,
    Userdefined,
    Notknown,
}
impl Default for IfcPropertySourceEnum {
    fn default() -> Self {
        IfcPropertySourceEnum::Design
    }
}
impl From<String> for IfcPropertySourceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DESIGN" => IfcPropertySourceEnum::Design,
            "DESIGNMAXIMUM" => IfcPropertySourceEnum::Designmaximum,
            "DESIGNMINIMUM" => IfcPropertySourceEnum::Designminimum,
            "SIMULATED" => IfcPropertySourceEnum::Simulated,
            "ASBUILT" => IfcPropertySourceEnum::Asbuilt,
            "COMMISSIONING" => IfcPropertySourceEnum::Commissioning,
            "MEASURED" => IfcPropertySourceEnum::Measured,
            "USERDEFINED" => IfcPropertySourceEnum::Userdefined,
            "NOTKNOWN" => IfcPropertySourceEnum::Notknown,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPropertySourceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPropertySourceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPropertySourceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcProtectiveDeviceTypeEnum {
    Fusedisconnector,
    Circuitbreaker,
    Earthfailuredevice,
    Residualcurrentcircuitbreaker,
    Residualcurrentswitch,
    Varistor,
    Userdefined,
    Notdefined,
}
impl Default for IfcProtectiveDeviceTypeEnum {
    fn default() -> Self {
        IfcProtectiveDeviceTypeEnum::Fusedisconnector
    }
}
impl From<String> for IfcProtectiveDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FUSEDISCONNECTOR" => IfcProtectiveDeviceTypeEnum::Fusedisconnector,
            "CIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum::Circuitbreaker,
            "EARTHFAILUREDEVICE" => IfcProtectiveDeviceTypeEnum::Earthfailuredevice,
            "RESIDUALCURRENTCIRCUITBREAKER" => IfcProtectiveDeviceTypeEnum::Residualcurrentcircuitbreaker,
            "RESIDUALCURRENTSWITCH" => IfcProtectiveDeviceTypeEnum::Residualcurrentswitch,
            "VARISTOR" => IfcProtectiveDeviceTypeEnum::Varistor,
            "USERDEFINED" => IfcProtectiveDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcProtectiveDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcProtectiveDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcProtectiveDeviceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcProtectiveDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPumpTypeEnum {
    Circulator,
    Endsuction,
    Splitcase,
    Verticalinline,
    Verticalturbine,
    Userdefined,
    Notdefined,
}
impl Default for IfcPumpTypeEnum {
    fn default() -> Self {
        IfcPumpTypeEnum::Circulator
    }
}
impl From<String> for IfcPumpTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CIRCULATOR" => IfcPumpTypeEnum::Circulator,
            "ENDSUCTION" => IfcPumpTypeEnum::Endsuction,
            "SPLITCASE" => IfcPumpTypeEnum::Splitcase,
            "VERTICALINLINE" => IfcPumpTypeEnum::Verticalinline,
            "VERTICALTURBINE" => IfcPumpTypeEnum::Verticalturbine,
            "USERDEFINED" => IfcPumpTypeEnum::Userdefined,
            "NOTDEFINED" => IfcPumpTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcPumpTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcPumpTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcPumpTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRailingTypeEnum {
    Handrail,
    Guardrail,
    Balustrade,
    Userdefined,
    Notdefined,
}
impl Default for IfcRailingTypeEnum {
    fn default() -> Self {
        IfcRailingTypeEnum::Handrail
    }
}
impl From<String> for IfcRailingTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "HANDRAIL" => IfcRailingTypeEnum::Handrail,
            "GUARDRAIL" => IfcRailingTypeEnum::Guardrail,
            "BALUSTRADE" => IfcRailingTypeEnum::Balustrade,
            "USERDEFINED" => IfcRailingTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRailingTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRailingTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcRailingTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRailingTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRampFlightTypeEnum {
    Straight,
    Spiral,
    Userdefined,
    Notdefined,
}
impl Default for IfcRampFlightTypeEnum {
    fn default() -> Self {
        IfcRampFlightTypeEnum::Straight
    }
}
impl From<String> for IfcRampFlightTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT" => IfcRampFlightTypeEnum::Straight,
            "SPIRAL" => IfcRampFlightTypeEnum::Spiral,
            "USERDEFINED" => IfcRampFlightTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRampFlightTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRampFlightTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcRampFlightTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRampFlightTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRampTypeEnum {
    StraightRunRamp,
    TwoStraightRunRamp,
    QuarterTurnRamp,
    TwoQuarterTurnRamp,
    HalfTurnRamp,
    SpiralRamp,
    Userdefined,
    Notdefined,
}
impl Default for IfcRampTypeEnum {
    fn default() -> Self {
        IfcRampTypeEnum::StraightRunRamp
    }
}
impl From<String> for IfcRampTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT_RUN_RAMP" => IfcRampTypeEnum::StraightRunRamp,
            "TWO_STRAIGHT_RUN_RAMP" => IfcRampTypeEnum::TwoStraightRunRamp,
            "QUARTER_TURN_RAMP" => IfcRampTypeEnum::QuarterTurnRamp,
            "TWO_QUARTER_TURN_RAMP" => IfcRampTypeEnum::TwoQuarterTurnRamp,
            "HALF_TURN_RAMP" => IfcRampTypeEnum::HalfTurnRamp,
            "SPIRAL_RAMP" => IfcRampTypeEnum::SpiralRamp,
            "USERDEFINED" => IfcRampTypeEnum::Userdefined,
            "NOTDEFINED" => IfcRampTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRampTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcRampTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRampTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReflectanceMethodEnum {
    Blinn,
    Flat,
    Glass,
    Matt,
    Metal,
    Mirror,
    Phong,
    Plastic,
    Strauss,
    Notdefined,
}
impl Default for IfcReflectanceMethodEnum {
    fn default() -> Self {
        IfcReflectanceMethodEnum::Blinn
    }
}
impl From<String> for IfcReflectanceMethodEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BLINN" => IfcReflectanceMethodEnum::Blinn,
            "FLAT" => IfcReflectanceMethodEnum::Flat,
            "GLASS" => IfcReflectanceMethodEnum::Glass,
            "MATT" => IfcReflectanceMethodEnum::Matt,
            "METAL" => IfcReflectanceMethodEnum::Metal,
            "MIRROR" => IfcReflectanceMethodEnum::Mirror,
            "PHONG" => IfcReflectanceMethodEnum::Phong,
            "PLASTIC" => IfcReflectanceMethodEnum::Plastic,
            "STRAUSS" => IfcReflectanceMethodEnum::Strauss,
            "NOTDEFINED" => IfcReflectanceMethodEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReflectanceMethodEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcReflectanceMethodEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReflectanceMethodEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReinforcingBarRoleEnum {
    Main,
    Shear,
    Ligature,
    Stud,
    Punching,
    Edge,
    Ring,
    Userdefined,
    Notdefined,
}
impl Default for IfcReinforcingBarRoleEnum {
    fn default() -> Self {
        IfcReinforcingBarRoleEnum::Main
    }
}
impl From<String> for IfcReinforcingBarRoleEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "MAIN" => IfcReinforcingBarRoleEnum::Main,
            "SHEAR" => IfcReinforcingBarRoleEnum::Shear,
            "LIGATURE" => IfcReinforcingBarRoleEnum::Ligature,
            "STUD" => IfcReinforcingBarRoleEnum::Stud,
            "PUNCHING" => IfcReinforcingBarRoleEnum::Punching,
            "EDGE" => IfcReinforcingBarRoleEnum::Edge,
            "RING" => IfcReinforcingBarRoleEnum::Ring,
            "USERDEFINED" => IfcReinforcingBarRoleEnum::Userdefined,
            "NOTDEFINED" => IfcReinforcingBarRoleEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReinforcingBarRoleEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcReinforcingBarRoleEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReinforcingBarRoleEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcReinforcingBarSurfaceEnum {
    Plain,
    Textured,
}
impl Default for IfcReinforcingBarSurfaceEnum {
    fn default() -> Self {
        IfcReinforcingBarSurfaceEnum::Plain
    }
}
impl From<String> for IfcReinforcingBarSurfaceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PLAIN" => IfcReinforcingBarSurfaceEnum::Plain,
            "TEXTURED" => IfcReinforcingBarSurfaceEnum::Textured,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcReinforcingBarSurfaceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcReinforcingBarSurfaceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcReinforcingBarSurfaceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcResourceConsumptionEnum {
    Consumed,
    Partiallyconsumed,
    Notconsumed,
    Occupied,
    Partiallyoccupied,
    Notoccupied,
    Userdefined,
    Notdefined,
}
impl Default for IfcResourceConsumptionEnum {
    fn default() -> Self {
        IfcResourceConsumptionEnum::Consumed
    }
}
impl From<String> for IfcResourceConsumptionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONSUMED" => IfcResourceConsumptionEnum::Consumed,
            "PARTIALLYCONSUMED" => IfcResourceConsumptionEnum::Partiallyconsumed,
            "NOTCONSUMED" => IfcResourceConsumptionEnum::Notconsumed,
            "OCCUPIED" => IfcResourceConsumptionEnum::Occupied,
            "PARTIALLYOCCUPIED" => IfcResourceConsumptionEnum::Partiallyoccupied,
            "NOTOCCUPIED" => IfcResourceConsumptionEnum::Notoccupied,
            "USERDEFINED" => IfcResourceConsumptionEnum::Userdefined,
            "NOTDEFINED" => IfcResourceConsumptionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcResourceConsumptionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcResourceConsumptionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcResourceConsumptionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRibPlateDirectionEnum {
    DirectionX,
    DirectionY,
}
impl Default for IfcRibPlateDirectionEnum {
    fn default() -> Self {
        IfcRibPlateDirectionEnum::DirectionX
    }
}
impl From<String> for IfcRibPlateDirectionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DIRECTION_X" => IfcRibPlateDirectionEnum::DirectionX,
            "DIRECTION_Y" => IfcRibPlateDirectionEnum::DirectionY,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRibPlateDirectionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcRibPlateDirectionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRibPlateDirectionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRoleEnum {
    Supplier,
    Manufacturer,
    Contractor,
    Subcontractor,
    Architect,
    Structuralengineer,
    Costengineer,
    Client,
    Buildingowner,
    Buildingoperator,
    Mechanicalengineer,
    Electricalengineer,
    Projectmanager,
    Facilitiesmanager,
    Civilengineer,
    Comissioningengineer,
    Engineer,
    Owner,
    Consultant,
    Constructionmanager,
    Fieldconstructionmanager,
    Reseller,
    Userdefined,
}
impl Default for IfcRoleEnum {
    fn default() -> Self {
        IfcRoleEnum::Supplier
    }
}
impl From<String> for IfcRoleEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SUPPLIER" => IfcRoleEnum::Supplier,
            "MANUFACTURER" => IfcRoleEnum::Manufacturer,
            "CONTRACTOR" => IfcRoleEnum::Contractor,
            "SUBCONTRACTOR" => IfcRoleEnum::Subcontractor,
            "ARCHITECT" => IfcRoleEnum::Architect,
            "STRUCTURALENGINEER" => IfcRoleEnum::Structuralengineer,
            "COSTENGINEER" => IfcRoleEnum::Costengineer,
            "CLIENT" => IfcRoleEnum::Client,
            "BUILDINGOWNER" => IfcRoleEnum::Buildingowner,
            "BUILDINGOPERATOR" => IfcRoleEnum::Buildingoperator,
            "MECHANICALENGINEER" => IfcRoleEnum::Mechanicalengineer,
            "ELECTRICALENGINEER" => IfcRoleEnum::Electricalengineer,
            "PROJECTMANAGER" => IfcRoleEnum::Projectmanager,
            "FACILITIESMANAGER" => IfcRoleEnum::Facilitiesmanager,
            "CIVILENGINEER" => IfcRoleEnum::Civilengineer,
            "COMISSIONINGENGINEER" => IfcRoleEnum::Comissioningengineer,
            "ENGINEER" => IfcRoleEnum::Engineer,
            "OWNER" => IfcRoleEnum::Owner,
            "CONSULTANT" => IfcRoleEnum::Consultant,
            "CONSTRUCTIONMANAGER" => IfcRoleEnum::Constructionmanager,
            "FIELDCONSTRUCTIONMANAGER" => IfcRoleEnum::Fieldconstructionmanager,
            "RESELLER" => IfcRoleEnum::Reseller,
            "USERDEFINED" => IfcRoleEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRoleEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcRoleEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRoleEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcRoofTypeEnum {
    FlatRoof,
    ShedRoof,
    GableRoof,
    HipRoof,
    HippedGableRoof,
    GambrelRoof,
    MansardRoof,
    BarrelRoof,
    RainbowRoof,
    ButterflyRoof,
    PavilionRoof,
    DomeRoof,
    Freeform,
    Notdefined,
}
impl Default for IfcRoofTypeEnum {
    fn default() -> Self {
        IfcRoofTypeEnum::FlatRoof
    }
}
impl From<String> for IfcRoofTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLAT_ROOF" => IfcRoofTypeEnum::FlatRoof,
            "SHED_ROOF" => IfcRoofTypeEnum::ShedRoof,
            "GABLE_ROOF" => IfcRoofTypeEnum::GableRoof,
            "HIP_ROOF" => IfcRoofTypeEnum::HipRoof,
            "HIPPED_GABLE_ROOF" => IfcRoofTypeEnum::HippedGableRoof,
            "GAMBREL_ROOF" => IfcRoofTypeEnum::GambrelRoof,
            "MANSARD_ROOF" => IfcRoofTypeEnum::MansardRoof,
            "BARREL_ROOF" => IfcRoofTypeEnum::BarrelRoof,
            "RAINBOW_ROOF" => IfcRoofTypeEnum::RainbowRoof,
            "BUTTERFLY_ROOF" => IfcRoofTypeEnum::ButterflyRoof,
            "PAVILION_ROOF" => IfcRoofTypeEnum::PavilionRoof,
            "DOME_ROOF" => IfcRoofTypeEnum::DomeRoof,
            "FREEFORM" => IfcRoofTypeEnum::Freeform,
            "NOTDEFINED" => IfcRoofTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcRoofTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcRoofTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcRoofTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSiPrefix {
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
}
impl Default for IfcSiPrefix {
    fn default() -> Self {
        IfcSiPrefix::Exa
    }
}
impl From<String> for IfcSiPrefix {
    fn from(value: String) -> Self {
        match value.as_str() {
            "EXA" => IfcSiPrefix::Exa,
            "PETA" => IfcSiPrefix::Peta,
            "TERA" => IfcSiPrefix::Tera,
            "GIGA" => IfcSiPrefix::Giga,
            "MEGA" => IfcSiPrefix::Mega,
            "KILO" => IfcSiPrefix::Kilo,
            "HECTO" => IfcSiPrefix::Hecto,
            "DECA" => IfcSiPrefix::Deca,
            "DECI" => IfcSiPrefix::Deci,
            "CENTI" => IfcSiPrefix::Centi,
            "MILLI" => IfcSiPrefix::Milli,
            "MICRO" => IfcSiPrefix::Micro,
            "NANO" => IfcSiPrefix::Nano,
            "PICO" => IfcSiPrefix::Pico,
            "FEMTO" => IfcSiPrefix::Femto,
            "ATTO" => IfcSiPrefix::Atto,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSiPrefix {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSiPrefix::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSiPrefix::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSiUnitName {
    Ampere,
    Becquerel,
    Candela,
    Coulomb,
    CubicMetre,
    DegreeCelsius,
    Farad,
    Gram,
    Gray,
    Henry,
    Hertz,
    Joule,
    Kelvin,
    Lumen,
    Lux,
    Metre,
    Mole,
    Newton,
    Ohm,
    Pascal,
    Radian,
    Second,
    Siemens,
    Sievert,
    SquareMetre,
    Steradian,
    Tesla,
    Volt,
    Watt,
    Weber,
}
impl Default for IfcSiUnitName {
    fn default() -> Self {
        IfcSiUnitName::Ampere
    }
}
impl From<String> for IfcSiUnitName {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AMPERE" => IfcSiUnitName::Ampere,
            "BECQUEREL" => IfcSiUnitName::Becquerel,
            "CANDELA" => IfcSiUnitName::Candela,
            "COULOMB" => IfcSiUnitName::Coulomb,
            "CUBIC_METRE" => IfcSiUnitName::CubicMetre,
            "DEGREE_CELSIUS" => IfcSiUnitName::DegreeCelsius,
            "FARAD" => IfcSiUnitName::Farad,
            "GRAM" => IfcSiUnitName::Gram,
            "GRAY" => IfcSiUnitName::Gray,
            "HENRY" => IfcSiUnitName::Henry,
            "HERTZ" => IfcSiUnitName::Hertz,
            "JOULE" => IfcSiUnitName::Joule,
            "KELVIN" => IfcSiUnitName::Kelvin,
            "LUMEN" => IfcSiUnitName::Lumen,
            "LUX" => IfcSiUnitName::Lux,
            "METRE" => IfcSiUnitName::Metre,
            "MOLE" => IfcSiUnitName::Mole,
            "NEWTON" => IfcSiUnitName::Newton,
            "OHM" => IfcSiUnitName::Ohm,
            "PASCAL" => IfcSiUnitName::Pascal,
            "RADIAN" => IfcSiUnitName::Radian,
            "SECOND" => IfcSiUnitName::Second,
            "SIEMENS" => IfcSiUnitName::Siemens,
            "SIEVERT" => IfcSiUnitName::Sievert,
            "SQUARE_METRE" => IfcSiUnitName::SquareMetre,
            "STERADIAN" => IfcSiUnitName::Steradian,
            "TESLA" => IfcSiUnitName::Tesla,
            "VOLT" => IfcSiUnitName::Volt,
            "WATT" => IfcSiUnitName::Watt,
            "WEBER" => IfcSiUnitName::Weber,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSiUnitName {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSiUnitName::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSiUnitName::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSanitaryTerminalTypeEnum {
    Bath,
    Bidet,
    Cistern,
    Shower,
    Sink,
    Sanitaryfountain,
    Toiletpan,
    Urinal,
    Washhandbasin,
    Wcseat,
    Userdefined,
    Notdefined,
}
impl Default for IfcSanitaryTerminalTypeEnum {
    fn default() -> Self {
        IfcSanitaryTerminalTypeEnum::Bath
    }
}
impl From<String> for IfcSanitaryTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BATH" => IfcSanitaryTerminalTypeEnum::Bath,
            "BIDET" => IfcSanitaryTerminalTypeEnum::Bidet,
            "CISTERN" => IfcSanitaryTerminalTypeEnum::Cistern,
            "SHOWER" => IfcSanitaryTerminalTypeEnum::Shower,
            "SINK" => IfcSanitaryTerminalTypeEnum::Sink,
            "SANITARYFOUNTAIN" => IfcSanitaryTerminalTypeEnum::Sanitaryfountain,
            "TOILETPAN" => IfcSanitaryTerminalTypeEnum::Toiletpan,
            "URINAL" => IfcSanitaryTerminalTypeEnum::Urinal,
            "WASHHANDBASIN" => IfcSanitaryTerminalTypeEnum::Washhandbasin,
            "WCSEAT" => IfcSanitaryTerminalTypeEnum::Wcseat,
            "USERDEFINED" => IfcSanitaryTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSanitaryTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSanitaryTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSanitaryTerminalTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSanitaryTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSectionTypeEnum {
    Uniform,
    Tapered,
}
impl Default for IfcSectionTypeEnum {
    fn default() -> Self {
        IfcSectionTypeEnum::Uniform
    }
}
impl From<String> for IfcSectionTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "UNIFORM" => IfcSectionTypeEnum::Uniform,
            "TAPERED" => IfcSectionTypeEnum::Tapered,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSectionTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSectionTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSectionTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSensorTypeEnum {
    Co2sensor,
    Firesensor,
    Flowsensor,
    Gassensor,
    Heatsensor,
    Humiditysensor,
    Lightsensor,
    Moisturesensor,
    Movementsensor,
    Pressuresensor,
    Smokesensor,
    Soundsensor,
    Temperaturesensor,
    Userdefined,
    Notdefined,
}
impl Default for IfcSensorTypeEnum {
    fn default() -> Self {
        IfcSensorTypeEnum::Co2sensor
    }
}
impl From<String> for IfcSensorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CO2SENSOR" => IfcSensorTypeEnum::Co2sensor,
            "FIRESENSOR" => IfcSensorTypeEnum::Firesensor,
            "FLOWSENSOR" => IfcSensorTypeEnum::Flowsensor,
            "GASSENSOR" => IfcSensorTypeEnum::Gassensor,
            "HEATSENSOR" => IfcSensorTypeEnum::Heatsensor,
            "HUMIDITYSENSOR" => IfcSensorTypeEnum::Humiditysensor,
            "LIGHTSENSOR" => IfcSensorTypeEnum::Lightsensor,
            "MOISTURESENSOR" => IfcSensorTypeEnum::Moisturesensor,
            "MOVEMENTSENSOR" => IfcSensorTypeEnum::Movementsensor,
            "PRESSURESENSOR" => IfcSensorTypeEnum::Pressuresensor,
            "SMOKESENSOR" => IfcSensorTypeEnum::Smokesensor,
            "SOUNDSENSOR" => IfcSensorTypeEnum::Soundsensor,
            "TEMPERATURESENSOR" => IfcSensorTypeEnum::Temperaturesensor,
            "USERDEFINED" => IfcSensorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSensorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSensorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSensorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSensorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSequenceEnum {
    StartStart,
    StartFinish,
    FinishStart,
    FinishFinish,
    Notdefined,
}
impl Default for IfcSequenceEnum {
    fn default() -> Self {
        IfcSequenceEnum::StartStart
    }
}
impl From<String> for IfcSequenceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "START_START" => IfcSequenceEnum::StartStart,
            "START_FINISH" => IfcSequenceEnum::StartFinish,
            "FINISH_START" => IfcSequenceEnum::FinishStart,
            "FINISH_FINISH" => IfcSequenceEnum::FinishFinish,
            "NOTDEFINED" => IfcSequenceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSequenceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSequenceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSequenceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcServiceLifeFactorTypeEnum {
    AQualityofcomponents,
    BDesignlevel,
    CWorkexecutionlevel,
    DIndoorenvironment,
    EOutdoorenvironment,
    FInuseconditions,
    GMaintenancelevel,
    Userdefined,
    Notdefined,
}
impl Default for IfcServiceLifeFactorTypeEnum {
    fn default() -> Self {
        IfcServiceLifeFactorTypeEnum::AQualityofcomponents
    }
}
impl From<String> for IfcServiceLifeFactorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "A_QUALITYOFCOMPONENTS" => IfcServiceLifeFactorTypeEnum::AQualityofcomponents,
            "B_DESIGNLEVEL" => IfcServiceLifeFactorTypeEnum::BDesignlevel,
            "C_WORKEXECUTIONLEVEL" => IfcServiceLifeFactorTypeEnum::CWorkexecutionlevel,
            "D_INDOORENVIRONMENT" => IfcServiceLifeFactorTypeEnum::DIndoorenvironment,
            "E_OUTDOORENVIRONMENT" => IfcServiceLifeFactorTypeEnum::EOutdoorenvironment,
            "F_INUSECONDITIONS" => IfcServiceLifeFactorTypeEnum::FInuseconditions,
            "G_MAINTENANCELEVEL" => IfcServiceLifeFactorTypeEnum::GMaintenancelevel,
            "USERDEFINED" => IfcServiceLifeFactorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcServiceLifeFactorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcServiceLifeFactorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcServiceLifeFactorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcServiceLifeFactorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcServiceLifeTypeEnum {
    Actualservicelife,
    Expectedservicelife,
    Optimisticreferenceservicelife,
    Pessimisticreferenceservicelife,
    Referenceservicelife,
}
impl Default for IfcServiceLifeTypeEnum {
    fn default() -> Self {
        IfcServiceLifeTypeEnum::Actualservicelife
    }
}
impl From<String> for IfcServiceLifeTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACTUALSERVICELIFE" => IfcServiceLifeTypeEnum::Actualservicelife,
            "EXPECTEDSERVICELIFE" => IfcServiceLifeTypeEnum::Expectedservicelife,
            "OPTIMISTICREFERENCESERVICELIFE" => IfcServiceLifeTypeEnum::Optimisticreferenceservicelife,
            "PESSIMISTICREFERENCESERVICELIFE" => IfcServiceLifeTypeEnum::Pessimisticreferenceservicelife,
            "REFERENCESERVICELIFE" => IfcServiceLifeTypeEnum::Referenceservicelife,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcServiceLifeTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcServiceLifeTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcServiceLifeTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSlabTypeEnum {
    Floor,
    Roof,
    Landing,
    Baseslab,
    Userdefined,
    Notdefined,
}
impl Default for IfcSlabTypeEnum {
    fn default() -> Self {
        IfcSlabTypeEnum::Floor
    }
}
impl From<String> for IfcSlabTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLOOR" => IfcSlabTypeEnum::Floor,
            "ROOF" => IfcSlabTypeEnum::Roof,
            "LANDING" => IfcSlabTypeEnum::Landing,
            "BASESLAB" => IfcSlabTypeEnum::Baseslab,
            "USERDEFINED" => IfcSlabTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSlabTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSlabTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSlabTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSlabTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSoundScaleEnum {
    Dba,
    Dbb,
    Dbc,
    Nc,
    Nr,
    Userdefined,
    Notdefined,
}
impl Default for IfcSoundScaleEnum {
    fn default() -> Self {
        IfcSoundScaleEnum::Dba
    }
}
impl From<String> for IfcSoundScaleEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DBA" => IfcSoundScaleEnum::Dba,
            "DBB" => IfcSoundScaleEnum::Dbb,
            "DBC" => IfcSoundScaleEnum::Dbc,
            "NC" => IfcSoundScaleEnum::Nc,
            "NR" => IfcSoundScaleEnum::Nr,
            "USERDEFINED" => IfcSoundScaleEnum::Userdefined,
            "NOTDEFINED" => IfcSoundScaleEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSoundScaleEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSoundScaleEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSoundScaleEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSpaceHeaterTypeEnum {
    Sectionalradiator,
    Panelradiator,
    Tubularradiator,
    Convector,
    Baseboardheater,
    Finnedtubeunit,
    Unitheater,
    Userdefined,
    Notdefined,
}
impl Default for IfcSpaceHeaterTypeEnum {
    fn default() -> Self {
        IfcSpaceHeaterTypeEnum::Sectionalradiator
    }
}
impl From<String> for IfcSpaceHeaterTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SECTIONALRADIATOR" => IfcSpaceHeaterTypeEnum::Sectionalradiator,
            "PANELRADIATOR" => IfcSpaceHeaterTypeEnum::Panelradiator,
            "TUBULARRADIATOR" => IfcSpaceHeaterTypeEnum::Tubularradiator,
            "CONVECTOR" => IfcSpaceHeaterTypeEnum::Convector,
            "BASEBOARDHEATER" => IfcSpaceHeaterTypeEnum::Baseboardheater,
            "FINNEDTUBEUNIT" => IfcSpaceHeaterTypeEnum::Finnedtubeunit,
            "UNITHEATER" => IfcSpaceHeaterTypeEnum::Unitheater,
            "USERDEFINED" => IfcSpaceHeaterTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSpaceHeaterTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSpaceHeaterTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSpaceHeaterTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSpaceHeaterTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSpaceTypeEnum {
    Userdefined,
    Notdefined,
}
impl Default for IfcSpaceTypeEnum {
    fn default() -> Self {
        IfcSpaceTypeEnum::Userdefined
    }
}
impl From<String> for IfcSpaceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "USERDEFINED" => IfcSpaceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSpaceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSpaceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSpaceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSpaceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStackTerminalTypeEnum {
    Birdcage,
    Cowl,
    Rainwaterhopper,
    Userdefined,
    Notdefined,
}
impl Default for IfcStackTerminalTypeEnum {
    fn default() -> Self {
        IfcStackTerminalTypeEnum::Birdcage
    }
}
impl From<String> for IfcStackTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BIRDCAGE" => IfcStackTerminalTypeEnum::Birdcage,
            "COWL" => IfcStackTerminalTypeEnum::Cowl,
            "RAINWATERHOPPER" => IfcStackTerminalTypeEnum::Rainwaterhopper,
            "USERDEFINED" => IfcStackTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStackTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStackTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcStackTerminalTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStackTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStairFlightTypeEnum {
    Straight,
    Winder,
    Spiral,
    Curved,
    Freeform,
    Userdefined,
    Notdefined,
}
impl Default for IfcStairFlightTypeEnum {
    fn default() -> Self {
        IfcStairFlightTypeEnum::Straight
    }
}
impl From<String> for IfcStairFlightTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT" => IfcStairFlightTypeEnum::Straight,
            "WINDER" => IfcStairFlightTypeEnum::Winder,
            "SPIRAL" => IfcStairFlightTypeEnum::Spiral,
            "CURVED" => IfcStairFlightTypeEnum::Curved,
            "FREEFORM" => IfcStairFlightTypeEnum::Freeform,
            "USERDEFINED" => IfcStairFlightTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStairFlightTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStairFlightTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcStairFlightTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStairFlightTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStairTypeEnum {
    StraightRunStair,
    TwoStraightRunStair,
    QuarterWindingStair,
    QuarterTurnStair,
    HalfWindingStair,
    HalfTurnStair,
    TwoQuarterWindingStair,
    TwoQuarterTurnStair,
    ThreeQuarterWindingStair,
    ThreeQuarterTurnStair,
    SpiralStair,
    DoubleReturnStair,
    CurvedRunStair,
    TwoCurvedRunStair,
    Userdefined,
    Notdefined,
}
impl Default for IfcStairTypeEnum {
    fn default() -> Self {
        IfcStairTypeEnum::StraightRunStair
    }
}
impl From<String> for IfcStairTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAIGHT_RUN_STAIR" => IfcStairTypeEnum::StraightRunStair,
            "TWO_STRAIGHT_RUN_STAIR" => IfcStairTypeEnum::TwoStraightRunStair,
            "QUARTER_WINDING_STAIR" => IfcStairTypeEnum::QuarterWindingStair,
            "QUARTER_TURN_STAIR" => IfcStairTypeEnum::QuarterTurnStair,
            "HALF_WINDING_STAIR" => IfcStairTypeEnum::HalfWindingStair,
            "HALF_TURN_STAIR" => IfcStairTypeEnum::HalfTurnStair,
            "TWO_QUARTER_WINDING_STAIR" => IfcStairTypeEnum::TwoQuarterWindingStair,
            "TWO_QUARTER_TURN_STAIR" => IfcStairTypeEnum::TwoQuarterTurnStair,
            "THREE_QUARTER_WINDING_STAIR" => IfcStairTypeEnum::ThreeQuarterWindingStair,
            "THREE_QUARTER_TURN_STAIR" => IfcStairTypeEnum::ThreeQuarterTurnStair,
            "SPIRAL_STAIR" => IfcStairTypeEnum::SpiralStair,
            "DOUBLE_RETURN_STAIR" => IfcStairTypeEnum::DoubleReturnStair,
            "CURVED_RUN_STAIR" => IfcStairTypeEnum::CurvedRunStair,
            "TWO_CURVED_RUN_STAIR" => IfcStairTypeEnum::TwoCurvedRunStair,
            "USERDEFINED" => IfcStairTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStairTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStairTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcStairTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStairTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStateEnum {
    Readwrite,
    Readonly,
    Locked,
    Readwritelocked,
    Readonlylocked,
}
impl Default for IfcStateEnum {
    fn default() -> Self {
        IfcStateEnum::Readwrite
    }
}
impl From<String> for IfcStateEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "READWRITE" => IfcStateEnum::Readwrite,
            "READONLY" => IfcStateEnum::Readonly,
            "LOCKED" => IfcStateEnum::Locked,
            "READWRITELOCKED" => IfcStateEnum::Readwritelocked,
            "READONLYLOCKED" => IfcStateEnum::Readonlylocked,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStateEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcStateEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStateEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStructuralCurveTypeEnum {
    RigidJoinedMember,
    PinJoinedMember,
    Cable,
    TensionMember,
    CompressionMember,
    Userdefined,
    Notdefined,
}
impl Default for IfcStructuralCurveTypeEnum {
    fn default() -> Self {
        IfcStructuralCurveTypeEnum::RigidJoinedMember
    }
}
impl From<String> for IfcStructuralCurveTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "RIGID_JOINED_MEMBER" => IfcStructuralCurveTypeEnum::RigidJoinedMember,
            "PIN_JOINED_MEMBER" => IfcStructuralCurveTypeEnum::PinJoinedMember,
            "CABLE" => IfcStructuralCurveTypeEnum::Cable,
            "TENSION_MEMBER" => IfcStructuralCurveTypeEnum::TensionMember,
            "COMPRESSION_MEMBER" => IfcStructuralCurveTypeEnum::CompressionMember,
            "USERDEFINED" => IfcStructuralCurveTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStructuralCurveTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStructuralCurveTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcStructuralCurveTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStructuralCurveTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcStructuralSurfaceTypeEnum {
    BendingElement,
    MembraneElement,
    Shell,
    Userdefined,
    Notdefined,
}
impl Default for IfcStructuralSurfaceTypeEnum {
    fn default() -> Self {
        IfcStructuralSurfaceTypeEnum::BendingElement
    }
}
impl From<String> for IfcStructuralSurfaceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BENDING_ELEMENT" => IfcStructuralSurfaceTypeEnum::BendingElement,
            "MEMBRANE_ELEMENT" => IfcStructuralSurfaceTypeEnum::MembraneElement,
            "SHELL" => IfcStructuralSurfaceTypeEnum::Shell,
            "USERDEFINED" => IfcStructuralSurfaceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcStructuralSurfaceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcStructuralSurfaceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcStructuralSurfaceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcStructuralSurfaceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSurfaceSide {
    Positive,
    Negative,
    Both,
}
impl Default for IfcSurfaceSide {
    fn default() -> Self {
        IfcSurfaceSide::Positive
    }
}
impl From<String> for IfcSurfaceSide {
    fn from(value: String) -> Self {
        match value.as_str() {
            "POSITIVE" => IfcSurfaceSide::Positive,
            "NEGATIVE" => IfcSurfaceSide::Negative,
            "BOTH" => IfcSurfaceSide::Both,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSurfaceSide {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSurfaceSide::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSurfaceSide::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSurfaceTextureEnum {
    Bump,
    Opacity,
    Reflection,
    Selfillumination,
    Shininess,
    Specular,
    Texture,
    Transparencymap,
    Notdefined,
}
impl Default for IfcSurfaceTextureEnum {
    fn default() -> Self {
        IfcSurfaceTextureEnum::Bump
    }
}
impl From<String> for IfcSurfaceTextureEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "BUMP" => IfcSurfaceTextureEnum::Bump,
            "OPACITY" => IfcSurfaceTextureEnum::Opacity,
            "REFLECTION" => IfcSurfaceTextureEnum::Reflection,
            "SELFILLUMINATION" => IfcSurfaceTextureEnum::Selfillumination,
            "SHININESS" => IfcSurfaceTextureEnum::Shininess,
            "SPECULAR" => IfcSurfaceTextureEnum::Specular,
            "TEXTURE" => IfcSurfaceTextureEnum::Texture,
            "TRANSPARENCYMAP" => IfcSurfaceTextureEnum::Transparencymap,
            "NOTDEFINED" => IfcSurfaceTextureEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSurfaceTextureEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSurfaceTextureEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSurfaceTextureEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSwitchingDeviceTypeEnum {
    Contactor,
    Emergencystop,
    Starter,
    Switchdisconnector,
    Toggleswitch,
    Userdefined,
    Notdefined,
}
impl Default for IfcSwitchingDeviceTypeEnum {
    fn default() -> Self {
        IfcSwitchingDeviceTypeEnum::Contactor
    }
}
impl From<String> for IfcSwitchingDeviceTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONTACTOR" => IfcSwitchingDeviceTypeEnum::Contactor,
            "EMERGENCYSTOP" => IfcSwitchingDeviceTypeEnum::Emergencystop,
            "STARTER" => IfcSwitchingDeviceTypeEnum::Starter,
            "SWITCHDISCONNECTOR" => IfcSwitchingDeviceTypeEnum::Switchdisconnector,
            "TOGGLESWITCH" => IfcSwitchingDeviceTypeEnum::Toggleswitch,
            "USERDEFINED" => IfcSwitchingDeviceTypeEnum::Userdefined,
            "NOTDEFINED" => IfcSwitchingDeviceTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcSwitchingDeviceTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcSwitchingDeviceTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcSwitchingDeviceTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTankTypeEnum {
    Preformed,
    Sectional,
    Expansion,
    Pressurevessel,
    Userdefined,
    Notdefined,
}
impl Default for IfcTankTypeEnum {
    fn default() -> Self {
        IfcTankTypeEnum::Preformed
    }
}
impl From<String> for IfcTankTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PREFORMED" => IfcTankTypeEnum::Preformed,
            "SECTIONAL" => IfcTankTypeEnum::Sectional,
            "EXPANSION" => IfcTankTypeEnum::Expansion,
            "PRESSUREVESSEL" => IfcTankTypeEnum::Pressurevessel,
            "USERDEFINED" => IfcTankTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTankTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTankTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTankTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTankTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTendonTypeEnum {
    Strand,
    Wire,
    Bar,
    Coated,
    Userdefined,
    Notdefined,
}
impl Default for IfcTendonTypeEnum {
    fn default() -> Self {
        IfcTendonTypeEnum::Strand
    }
}
impl From<String> for IfcTendonTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STRAND" => IfcTendonTypeEnum::Strand,
            "WIRE" => IfcTendonTypeEnum::Wire,
            "BAR" => IfcTendonTypeEnum::Bar,
            "COATED" => IfcTendonTypeEnum::Coated,
            "USERDEFINED" => IfcTendonTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTendonTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTendonTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTendonTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTendonTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTextPath {
    Left,
    Right,
    Up,
    Down,
}
impl Default for IfcTextPath {
    fn default() -> Self {
        IfcTextPath::Left
    }
}
impl From<String> for IfcTextPath {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => IfcTextPath::Left,
            "RIGHT" => IfcTextPath::Right,
            "UP" => IfcTextPath::Up,
            "DOWN" => IfcTextPath::Down,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTextPath {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTextPath::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTextPath::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcThermalLoadSourceEnum {
    People,
    Lighting,
    Equipment,
    Ventilationindoorair,
    Ventilationoutsideair,
    Recirculatedair,
    Exhaustair,
    Airexchangerate,
    Drybulbtemperature,
    Relativehumidity,
    Infiltration,
    Userdefined,
    Notdefined,
}
impl Default for IfcThermalLoadSourceEnum {
    fn default() -> Self {
        IfcThermalLoadSourceEnum::People
    }
}
impl From<String> for IfcThermalLoadSourceEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "PEOPLE" => IfcThermalLoadSourceEnum::People,
            "LIGHTING" => IfcThermalLoadSourceEnum::Lighting,
            "EQUIPMENT" => IfcThermalLoadSourceEnum::Equipment,
            "VENTILATIONINDOORAIR" => IfcThermalLoadSourceEnum::Ventilationindoorair,
            "VENTILATIONOUTSIDEAIR" => IfcThermalLoadSourceEnum::Ventilationoutsideair,
            "RECIRCULATEDAIR" => IfcThermalLoadSourceEnum::Recirculatedair,
            "EXHAUSTAIR" => IfcThermalLoadSourceEnum::Exhaustair,
            "AIREXCHANGERATE" => IfcThermalLoadSourceEnum::Airexchangerate,
            "DRYBULBTEMPERATURE" => IfcThermalLoadSourceEnum::Drybulbtemperature,
            "RELATIVEHUMIDITY" => IfcThermalLoadSourceEnum::Relativehumidity,
            "INFILTRATION" => IfcThermalLoadSourceEnum::Infiltration,
            "USERDEFINED" => IfcThermalLoadSourceEnum::Userdefined,
            "NOTDEFINED" => IfcThermalLoadSourceEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcThermalLoadSourceEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcThermalLoadSourceEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcThermalLoadSourceEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcThermalLoadTypeEnum {
    Sensible,
    Latent,
    Radiant,
    Notdefined,
}
impl Default for IfcThermalLoadTypeEnum {
    fn default() -> Self {
        IfcThermalLoadTypeEnum::Sensible
    }
}
impl From<String> for IfcThermalLoadTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SENSIBLE" => IfcThermalLoadTypeEnum::Sensible,
            "LATENT" => IfcThermalLoadTypeEnum::Latent,
            "RADIANT" => IfcThermalLoadTypeEnum::Radiant,
            "NOTDEFINED" => IfcThermalLoadTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcThermalLoadTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcThermalLoadTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcThermalLoadTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTimeSeriesDataTypeEnum {
    Continuous,
    Discrete,
    Discretebinary,
    Piecewisebinary,
    Piecewiseconstant,
    Piecewisecontinuous,
    Notdefined,
}
impl Default for IfcTimeSeriesDataTypeEnum {
    fn default() -> Self {
        IfcTimeSeriesDataTypeEnum::Continuous
    }
}
impl From<String> for IfcTimeSeriesDataTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CONTINUOUS" => IfcTimeSeriesDataTypeEnum::Continuous,
            "DISCRETE" => IfcTimeSeriesDataTypeEnum::Discrete,
            "DISCRETEBINARY" => IfcTimeSeriesDataTypeEnum::Discretebinary,
            "PIECEWISEBINARY" => IfcTimeSeriesDataTypeEnum::Piecewisebinary,
            "PIECEWISECONSTANT" => IfcTimeSeriesDataTypeEnum::Piecewiseconstant,
            "PIECEWISECONTINUOUS" => IfcTimeSeriesDataTypeEnum::Piecewisecontinuous,
            "NOTDEFINED" => IfcTimeSeriesDataTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTimeSeriesDataTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTimeSeriesDataTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTimeSeriesDataTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTimeSeriesScheduleTypeEnum {
    Annual,
    Monthly,
    Weekly,
    Daily,
    Userdefined,
    Notdefined,
}
impl Default for IfcTimeSeriesScheduleTypeEnum {
    fn default() -> Self {
        IfcTimeSeriesScheduleTypeEnum::Annual
    }
}
impl From<String> for IfcTimeSeriesScheduleTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ANNUAL" => IfcTimeSeriesScheduleTypeEnum::Annual,
            "MONTHLY" => IfcTimeSeriesScheduleTypeEnum::Monthly,
            "WEEKLY" => IfcTimeSeriesScheduleTypeEnum::Weekly,
            "DAILY" => IfcTimeSeriesScheduleTypeEnum::Daily,
            "USERDEFINED" => IfcTimeSeriesScheduleTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTimeSeriesScheduleTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTimeSeriesScheduleTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTimeSeriesScheduleTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTimeSeriesScheduleTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTransformerTypeEnum {
    Current,
    Frequency,
    Voltage,
    Userdefined,
    Notdefined,
}
impl Default for IfcTransformerTypeEnum {
    fn default() -> Self {
        IfcTransformerTypeEnum::Current
    }
}
impl From<String> for IfcTransformerTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CURRENT" => IfcTransformerTypeEnum::Current,
            "FREQUENCY" => IfcTransformerTypeEnum::Frequency,
            "VOLTAGE" => IfcTransformerTypeEnum::Voltage,
            "USERDEFINED" => IfcTransformerTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTransformerTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTransformerTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTransformerTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTransformerTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTransitionCode {
    Discontinuous,
    Continuous,
    Contsamegradient,
    Contsamegradientsamecurvature,
}
impl Default for IfcTransitionCode {
    fn default() -> Self {
        IfcTransitionCode::Discontinuous
    }
}
impl From<String> for IfcTransitionCode {
    fn from(value: String) -> Self {
        match value.as_str() {
            "DISCONTINUOUS" => IfcTransitionCode::Discontinuous,
            "CONTINUOUS" => IfcTransitionCode::Continuous,
            "CONTSAMEGRADIENT" => IfcTransitionCode::Contsamegradient,
            "CONTSAMEGRADIENTSAMECURVATURE" => IfcTransitionCode::Contsamegradientsamecurvature,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTransitionCode {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTransitionCode::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTransitionCode::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTransportElementTypeEnum {
    Elevator,
    Escalator,
    Movingwalkway,
    Userdefined,
    Notdefined,
}
impl Default for IfcTransportElementTypeEnum {
    fn default() -> Self {
        IfcTransportElementTypeEnum::Elevator
    }
}
impl From<String> for IfcTransportElementTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ELEVATOR" => IfcTransportElementTypeEnum::Elevator,
            "ESCALATOR" => IfcTransportElementTypeEnum::Escalator,
            "MOVINGWALKWAY" => IfcTransportElementTypeEnum::Movingwalkway,
            "USERDEFINED" => IfcTransportElementTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTransportElementTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTransportElementTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTransportElementTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTransportElementTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTrimmingPreference {
    Cartesian,
    Parameter,
    Unspecified,
}
impl Default for IfcTrimmingPreference {
    fn default() -> Self {
        IfcTrimmingPreference::Cartesian
    }
}
impl From<String> for IfcTrimmingPreference {
    fn from(value: String) -> Self {
        match value.as_str() {
            "CARTESIAN" => IfcTrimmingPreference::Cartesian,
            "PARAMETER" => IfcTrimmingPreference::Parameter,
            "UNSPECIFIED" => IfcTrimmingPreference::Unspecified,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTrimmingPreference {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTrimmingPreference::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTrimmingPreference::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTubeBundleTypeEnum {
    Finned,
    Userdefined,
    Notdefined,
}
impl Default for IfcTubeBundleTypeEnum {
    fn default() -> Self {
        IfcTubeBundleTypeEnum::Finned
    }
}
impl From<String> for IfcTubeBundleTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FINNED" => IfcTubeBundleTypeEnum::Finned,
            "USERDEFINED" => IfcTubeBundleTypeEnum::Userdefined,
            "NOTDEFINED" => IfcTubeBundleTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcTubeBundleTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcTubeBundleTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcTubeBundleTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnitEnum {
    Absorbeddoseunit,
    Amountofsubstanceunit,
    Areaunit,
    Doseequivalentunit,
    Electriccapacitanceunit,
    Electricchargeunit,
    Electricconductanceunit,
    Electriccurrentunit,
    Electricresistanceunit,
    Electricvoltageunit,
    Energyunit,
    Forceunit,
    Frequencyunit,
    Illuminanceunit,
    Inductanceunit,
    Lengthunit,
    Luminousfluxunit,
    Luminousintensityunit,
    Magneticfluxdensityunit,
    Magneticfluxunit,
    Massunit,
    Planeangleunit,
    Powerunit,
    Pressureunit,
    Radioactivityunit,
    Solidangleunit,
    Thermodynamictemperatureunit,
    Timeunit,
    Volumeunit,
    Userdefined,
}
impl Default for IfcUnitEnum {
    fn default() -> Self {
        IfcUnitEnum::Absorbeddoseunit
    }
}
impl From<String> for IfcUnitEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ABSORBEDDOSEUNIT" => IfcUnitEnum::Absorbeddoseunit,
            "AMOUNTOFSUBSTANCEUNIT" => IfcUnitEnum::Amountofsubstanceunit,
            "AREAUNIT" => IfcUnitEnum::Areaunit,
            "DOSEEQUIVALENTUNIT" => IfcUnitEnum::Doseequivalentunit,
            "ELECTRICCAPACITANCEUNIT" => IfcUnitEnum::Electriccapacitanceunit,
            "ELECTRICCHARGEUNIT" => IfcUnitEnum::Electricchargeunit,
            "ELECTRICCONDUCTANCEUNIT" => IfcUnitEnum::Electricconductanceunit,
            "ELECTRICCURRENTUNIT" => IfcUnitEnum::Electriccurrentunit,
            "ELECTRICRESISTANCEUNIT" => IfcUnitEnum::Electricresistanceunit,
            "ELECTRICVOLTAGEUNIT" => IfcUnitEnum::Electricvoltageunit,
            "ENERGYUNIT" => IfcUnitEnum::Energyunit,
            "FORCEUNIT" => IfcUnitEnum::Forceunit,
            "FREQUENCYUNIT" => IfcUnitEnum::Frequencyunit,
            "ILLUMINANCEUNIT" => IfcUnitEnum::Illuminanceunit,
            "INDUCTANCEUNIT" => IfcUnitEnum::Inductanceunit,
            "LENGTHUNIT" => IfcUnitEnum::Lengthunit,
            "LUMINOUSFLUXUNIT" => IfcUnitEnum::Luminousfluxunit,
            "LUMINOUSINTENSITYUNIT" => IfcUnitEnum::Luminousintensityunit,
            "MAGNETICFLUXDENSITYUNIT" => IfcUnitEnum::Magneticfluxdensityunit,
            "MAGNETICFLUXUNIT" => IfcUnitEnum::Magneticfluxunit,
            "MASSUNIT" => IfcUnitEnum::Massunit,
            "PLANEANGLEUNIT" => IfcUnitEnum::Planeangleunit,
            "POWERUNIT" => IfcUnitEnum::Powerunit,
            "PRESSUREUNIT" => IfcUnitEnum::Pressureunit,
            "RADIOACTIVITYUNIT" => IfcUnitEnum::Radioactivityunit,
            "SOLIDANGLEUNIT" => IfcUnitEnum::Solidangleunit,
            "THERMODYNAMICTEMPERATUREUNIT" => IfcUnitEnum::Thermodynamictemperatureunit,
            "TIMEUNIT" => IfcUnitEnum::Timeunit,
            "VOLUMEUNIT" => IfcUnitEnum::Volumeunit,
            "USERDEFINED" => IfcUnitEnum::Userdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcUnitEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcUnitEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcUnitEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnitaryEquipmentTypeEnum {
    Airhandler,
    Airconditioningunit,
    Splitsystem,
    Rooftopunit,
    Userdefined,
    Notdefined,
}
impl Default for IfcUnitaryEquipmentTypeEnum {
    fn default() -> Self {
        IfcUnitaryEquipmentTypeEnum::Airhandler
    }
}
impl From<String> for IfcUnitaryEquipmentTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRHANDLER" => IfcUnitaryEquipmentTypeEnum::Airhandler,
            "AIRCONDITIONINGUNIT" => IfcUnitaryEquipmentTypeEnum::Airconditioningunit,
            "SPLITSYSTEM" => IfcUnitaryEquipmentTypeEnum::Splitsystem,
            "ROOFTOPUNIT" => IfcUnitaryEquipmentTypeEnum::Rooftopunit,
            "USERDEFINED" => IfcUnitaryEquipmentTypeEnum::Userdefined,
            "NOTDEFINED" => IfcUnitaryEquipmentTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcUnitaryEquipmentTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcUnitaryEquipmentTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcUnitaryEquipmentTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcValveTypeEnum {
    Airrelease,
    Antivacuum,
    Changeover,
    Check,
    Commissioning,
    Diverting,
    Drawoffcock,
    Doublecheck,
    Doubleregulating,
    Faucet,
    Flushing,
    Gascock,
    Gastap,
    Isolating,
    Mixing,
    Pressurereducing,
    Pressurerelief,
    Regulating,
    Safetycutoff,
    Steamtrap,
    Stopcock,
    Userdefined,
    Notdefined,
}
impl Default for IfcValveTypeEnum {
    fn default() -> Self {
        IfcValveTypeEnum::Airrelease
    }
}
impl From<String> for IfcValveTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "AIRRELEASE" => IfcValveTypeEnum::Airrelease,
            "ANTIVACUUM" => IfcValveTypeEnum::Antivacuum,
            "CHANGEOVER" => IfcValveTypeEnum::Changeover,
            "CHECK" => IfcValveTypeEnum::Check,
            "COMMISSIONING" => IfcValveTypeEnum::Commissioning,
            "DIVERTING" => IfcValveTypeEnum::Diverting,
            "DRAWOFFCOCK" => IfcValveTypeEnum::Drawoffcock,
            "DOUBLECHECK" => IfcValveTypeEnum::Doublecheck,
            "DOUBLEREGULATING" => IfcValveTypeEnum::Doubleregulating,
            "FAUCET" => IfcValveTypeEnum::Faucet,
            "FLUSHING" => IfcValveTypeEnum::Flushing,
            "GASCOCK" => IfcValveTypeEnum::Gascock,
            "GASTAP" => IfcValveTypeEnum::Gastap,
            "ISOLATING" => IfcValveTypeEnum::Isolating,
            "MIXING" => IfcValveTypeEnum::Mixing,
            "PRESSUREREDUCING" => IfcValveTypeEnum::Pressurereducing,
            "PRESSURERELIEF" => IfcValveTypeEnum::Pressurerelief,
            "REGULATING" => IfcValveTypeEnum::Regulating,
            "SAFETYCUTOFF" => IfcValveTypeEnum::Safetycutoff,
            "STEAMTRAP" => IfcValveTypeEnum::Steamtrap,
            "STOPCOCK" => IfcValveTypeEnum::Stopcock,
            "USERDEFINED" => IfcValveTypeEnum::Userdefined,
            "NOTDEFINED" => IfcValveTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcValveTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcValveTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcValveTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcVibrationIsolatorTypeEnum {
    Compression,
    Spring,
    Userdefined,
    Notdefined,
}
impl Default for IfcVibrationIsolatorTypeEnum {
    fn default() -> Self {
        IfcVibrationIsolatorTypeEnum::Compression
    }
}
impl From<String> for IfcVibrationIsolatorTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "COMPRESSION" => IfcVibrationIsolatorTypeEnum::Compression,
            "SPRING" => IfcVibrationIsolatorTypeEnum::Spring,
            "USERDEFINED" => IfcVibrationIsolatorTypeEnum::Userdefined,
            "NOTDEFINED" => IfcVibrationIsolatorTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcVibrationIsolatorTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcVibrationIsolatorTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcVibrationIsolatorTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWallTypeEnum {
    Standard,
    Polygonal,
    Shear,
    Elementedwall,
    Plumbingwall,
    Userdefined,
    Notdefined,
}
impl Default for IfcWallTypeEnum {
    fn default() -> Self {
        IfcWallTypeEnum::Standard
    }
}
impl From<String> for IfcWallTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "STANDARD" => IfcWallTypeEnum::Standard,
            "POLYGONAL" => IfcWallTypeEnum::Polygonal,
            "SHEAR" => IfcWallTypeEnum::Shear,
            "ELEMENTEDWALL" => IfcWallTypeEnum::Elementedwall,
            "PLUMBINGWALL" => IfcWallTypeEnum::Plumbingwall,
            "USERDEFINED" => IfcWallTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWallTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWallTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWallTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWallTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWasteTerminalTypeEnum {
    Floortrap,
    Floorwaste,
    Gullysump,
    Gullytrap,
    Greaseinterceptor,
    Oilinterceptor,
    Petrolinterceptor,
    Roofdrain,
    Wastedisposalunit,
    Wastetrap,
    Userdefined,
    Notdefined,
}
impl Default for IfcWasteTerminalTypeEnum {
    fn default() -> Self {
        IfcWasteTerminalTypeEnum::Floortrap
    }
}
impl From<String> for IfcWasteTerminalTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "FLOORTRAP" => IfcWasteTerminalTypeEnum::Floortrap,
            "FLOORWASTE" => IfcWasteTerminalTypeEnum::Floorwaste,
            "GULLYSUMP" => IfcWasteTerminalTypeEnum::Gullysump,
            "GULLYTRAP" => IfcWasteTerminalTypeEnum::Gullytrap,
            "GREASEINTERCEPTOR" => IfcWasteTerminalTypeEnum::Greaseinterceptor,
            "OILINTERCEPTOR" => IfcWasteTerminalTypeEnum::Oilinterceptor,
            "PETROLINTERCEPTOR" => IfcWasteTerminalTypeEnum::Petrolinterceptor,
            "ROOFDRAIN" => IfcWasteTerminalTypeEnum::Roofdrain,
            "WASTEDISPOSALUNIT" => IfcWasteTerminalTypeEnum::Wastedisposalunit,
            "WASTETRAP" => IfcWasteTerminalTypeEnum::Wastetrap,
            "USERDEFINED" => IfcWasteTerminalTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWasteTerminalTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWasteTerminalTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWasteTerminalTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWasteTerminalTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowPanelOperationEnum {
    Sidehungrighthand,
    Sidehunglefthand,
    Tiltandturnrighthand,
    Tiltandturnlefthand,
    Tophung,
    Bottomhung,
    Pivothorizontal,
    Pivotvertical,
    Slidinghorizontal,
    Slidingvertical,
    Removablecasement,
    Fixedcasement,
    Otheroperation,
    Notdefined,
}
impl Default for IfcWindowPanelOperationEnum {
    fn default() -> Self {
        IfcWindowPanelOperationEnum::Sidehungrighthand
    }
}
impl From<String> for IfcWindowPanelOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SIDEHUNGRIGHTHAND" => IfcWindowPanelOperationEnum::Sidehungrighthand,
            "SIDEHUNGLEFTHAND" => IfcWindowPanelOperationEnum::Sidehunglefthand,
            "TILTANDTURNRIGHTHAND" => IfcWindowPanelOperationEnum::Tiltandturnrighthand,
            "TILTANDTURNLEFTHAND" => IfcWindowPanelOperationEnum::Tiltandturnlefthand,
            "TOPHUNG" => IfcWindowPanelOperationEnum::Tophung,
            "BOTTOMHUNG" => IfcWindowPanelOperationEnum::Bottomhung,
            "PIVOTHORIZONTAL" => IfcWindowPanelOperationEnum::Pivothorizontal,
            "PIVOTVERTICAL" => IfcWindowPanelOperationEnum::Pivotvertical,
            "SLIDINGHORIZONTAL" => IfcWindowPanelOperationEnum::Slidinghorizontal,
            "SLIDINGVERTICAL" => IfcWindowPanelOperationEnum::Slidingvertical,
            "REMOVABLECASEMENT" => IfcWindowPanelOperationEnum::Removablecasement,
            "FIXEDCASEMENT" => IfcWindowPanelOperationEnum::Fixedcasement,
            "OTHEROPERATION" => IfcWindowPanelOperationEnum::Otheroperation,
            "NOTDEFINED" => IfcWindowPanelOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowPanelOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWindowPanelOperationEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowPanelOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowPanelPositionEnum {
    Left,
    Middle,
    Right,
    Bottom,
    Top,
    Notdefined,
}
impl Default for IfcWindowPanelPositionEnum {
    fn default() -> Self {
        IfcWindowPanelPositionEnum::Left
    }
}
impl From<String> for IfcWindowPanelPositionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "LEFT" => IfcWindowPanelPositionEnum::Left,
            "MIDDLE" => IfcWindowPanelPositionEnum::Middle,
            "RIGHT" => IfcWindowPanelPositionEnum::Right,
            "BOTTOM" => IfcWindowPanelPositionEnum::Bottom,
            "TOP" => IfcWindowPanelPositionEnum::Top,
            "NOTDEFINED" => IfcWindowPanelPositionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowPanelPositionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWindowPanelPositionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowPanelPositionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowStyleConstructionEnum {
    Aluminium,
    HighGradeSteel,
    Steel,
    Wood,
    AluminiumWood,
    Plastic,
    OtherConstruction,
    Notdefined,
}
impl Default for IfcWindowStyleConstructionEnum {
    fn default() -> Self {
        IfcWindowStyleConstructionEnum::Aluminium
    }
}
impl From<String> for IfcWindowStyleConstructionEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ALUMINIUM" => IfcWindowStyleConstructionEnum::Aluminium,
            "HIGH_GRADE_STEEL" => IfcWindowStyleConstructionEnum::HighGradeSteel,
            "STEEL" => IfcWindowStyleConstructionEnum::Steel,
            "WOOD" => IfcWindowStyleConstructionEnum::Wood,
            "ALUMINIUM_WOOD" => IfcWindowStyleConstructionEnum::AluminiumWood,
            "PLASTIC" => IfcWindowStyleConstructionEnum::Plastic,
            "OTHER_CONSTRUCTION" => IfcWindowStyleConstructionEnum::OtherConstruction,
            "NOTDEFINED" => IfcWindowStyleConstructionEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowStyleConstructionEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWindowStyleConstructionEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowStyleConstructionEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWindowStyleOperationEnum {
    SinglePanel,
    DoublePanelVertical,
    DoublePanelHorizontal,
    TriplePanelVertical,
    TriplePanelBottom,
    TriplePanelTop,
    TriplePanelLeft,
    TriplePanelRight,
    TriplePanelHorizontal,
    Userdefined,
    Notdefined,
}
impl Default for IfcWindowStyleOperationEnum {
    fn default() -> Self {
        IfcWindowStyleOperationEnum::SinglePanel
    }
}
impl From<String> for IfcWindowStyleOperationEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "SINGLE_PANEL" => IfcWindowStyleOperationEnum::SinglePanel,
            "DOUBLE_PANEL_VERTICAL" => IfcWindowStyleOperationEnum::DoublePanelVertical,
            "DOUBLE_PANEL_HORIZONTAL" => IfcWindowStyleOperationEnum::DoublePanelHorizontal,
            "TRIPLE_PANEL_VERTICAL" => IfcWindowStyleOperationEnum::TriplePanelVertical,
            "TRIPLE_PANEL_BOTTOM" => IfcWindowStyleOperationEnum::TriplePanelBottom,
            "TRIPLE_PANEL_TOP" => IfcWindowStyleOperationEnum::TriplePanelTop,
            "TRIPLE_PANEL_LEFT" => IfcWindowStyleOperationEnum::TriplePanelLeft,
            "TRIPLE_PANEL_RIGHT" => IfcWindowStyleOperationEnum::TriplePanelRight,
            "TRIPLE_PANEL_HORIZONTAL" => IfcWindowStyleOperationEnum::TriplePanelHorizontal,
            "USERDEFINED" => IfcWindowStyleOperationEnum::Userdefined,
            "NOTDEFINED" => IfcWindowStyleOperationEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWindowStyleOperationEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWindowStyleOperationEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWindowStyleOperationEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcWorkControlTypeEnum {
    Actual,
    Baseline,
    Planned,
    Userdefined,
    Notdefined,
}
impl Default for IfcWorkControlTypeEnum {
    fn default() -> Self {
        IfcWorkControlTypeEnum::Actual
    }
}
impl From<String> for IfcWorkControlTypeEnum {
    fn from(value: String) -> Self {
        match value.as_str() {
            "ACTUAL" => IfcWorkControlTypeEnum::Actual,
            "BASELINE" => IfcWorkControlTypeEnum::Baseline,
            "PLANNED" => IfcWorkControlTypeEnum::Planned,
            "USERDEFINED" => IfcWorkControlTypeEnum::Userdefined,
            "NOTDEFINED" => IfcWorkControlTypeEnum::Notdefined,
            _ => panic!("{} is not a valid value", value),
        }
    }
}
impl From<Parameter> for IfcWorkControlTypeEnum {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EnumValue(value) => value.into(),
                UnTypedParameter::Null => IfcWorkControlTypeEnum::default(),
                _ => panic!("parameter is not an enum value"),
            },
            Parameter::OmittedParameter => IfcWorkControlTypeEnum::default(),
            _ => panic!("parameter is not an enum value"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcActorSelect {
    EntityRef(EntityRef),
    IfcOrganization(EntityRef),
    IfcPerson(EntityRef),
    IfcPersonAndOrganization(EntityRef),
}
impl Default for IfcActorSelect {
    fn default() -> Self {
        IfcActorSelect::IfcOrganization(EntityRef::default())
    }
}
impl From<Parameter> for IfcActorSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcActorSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcAppliedValueSelect {
    IfcRatioMeasure(IfcRatioMeasure),
    IfcMeasureWithUnit(EntityRef),
    IfcMonetaryMeasure(IfcMonetaryMeasure),
}
impl Default for IfcAppliedValueSelect {
    fn default() -> Self {
        IfcAppliedValueSelect::IfcRatioMeasure(IfcRatioMeasure::default())
    }
}
impl From<Parameter> for IfcAppliedValueSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCRATIOMEASURE" => IfcAppliedValueSelect::IfcRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMONETARYMEASURE" => IfcAppliedValueSelect::IfcMonetaryMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcAppliedValueSelect::IfcMeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcAxis2Placement {
    EntityRef(EntityRef),
    IfcAxis2Placement2D(EntityRef),
    IfcAxis2Placement3D(EntityRef),
}
impl Default for IfcAxis2Placement {
    fn default() -> Self {
        IfcAxis2Placement::IfcAxis2Placement2D(EntityRef::default())
    }
}
impl From<Parameter> for IfcAxis2Placement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcAxis2Placement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcBooleanOperand {
    EntityRef(EntityRef),
    IfcSolidModel(EntityRef),
    IfcHalfSpaceSolid(EntityRef),
    IfcBooleanResult(EntityRef),
    IfcCsgPrimitive3D(EntityRef),
}
impl Default for IfcBooleanOperand {
    fn default() -> Self {
        IfcBooleanOperand::IfcSolidModel(EntityRef::default())
    }
}
impl From<Parameter> for IfcBooleanOperand {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcBooleanOperand::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCharacterStyleSelect {
    IfcTextStyleForDefinedFont(EntityRef),
}
impl Default for IfcCharacterStyleSelect {
    fn default() -> Self {
        IfcCharacterStyleSelect::IfcTextStyleForDefinedFont(EntityRef::default())
    }
}
impl From<Parameter> for IfcCharacterStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCharacterStyleSelect::IfcTextStyleForDefinedFont(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcClassificationNotationSelect {
    EntityRef(EntityRef),
    IfcClassificationNotation(EntityRef),
    IfcClassificationReference(EntityRef),
}
impl Default for IfcClassificationNotationSelect {
    fn default() -> Self {
        IfcClassificationNotationSelect::IfcClassificationNotation(EntityRef::default())
    }
}
impl From<Parameter> for IfcClassificationNotationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcClassificationNotationSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcColour {
    EntityRef(EntityRef),
    IfcColourSpecification(EntityRef),
    IfcPreDefinedColour(EntityRef),
}
impl Default for IfcColour {
    fn default() -> Self {
        IfcColour::IfcColourSpecification(EntityRef::default())
    }
}
impl From<Parameter> for IfcColour {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcColour::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcColourOrFactor {
    IfcColourRgb(EntityRef),
    IfcNormalisedRatioMeasure(IfcNormalisedRatioMeasure),
}
impl Default for IfcColourOrFactor {
    fn default() -> Self {
        IfcColourOrFactor::IfcColourRgb(EntityRef::default())
    }
}
impl From<Parameter> for IfcColourOrFactor {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCNORMALISEDRATIOMEASURE" => IfcColourOrFactor::IfcNormalisedRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcColourOrFactor::IfcColourRgb(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcConditionCriterionSelect {
    IfcLabel(IfcLabel),
    IfcMeasureWithUnit(EntityRef),
}
impl Default for IfcConditionCriterionSelect {
    fn default() -> Self {
        IfcConditionCriterionSelect::IfcLabel(IfcLabel::default())
    }
}
impl From<Parameter> for IfcConditionCriterionSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCLABEL" => {
                    IfcConditionCriterionSelect::IfcLabel(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcConditionCriterionSelect::IfcMeasureWithUnit(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCsgSelect {
    EntityRef(EntityRef),
    IfcBooleanResult(EntityRef),
    IfcCsgPrimitive3D(EntityRef),
}
impl Default for IfcCsgSelect {
    fn default() -> Self {
        IfcCsgSelect::IfcBooleanResult(EntityRef::default())
    }
}
impl From<Parameter> for IfcCsgSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCsgSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveFontOrScaledCurveFontSelect {
    IfcCurveStyleFontSelect(IfcCurveStyleFontSelect),
    IfcCurveStyleFontAndScaling(EntityRef),
}
impl Default for IfcCurveFontOrScaledCurveFontSelect {
    fn default() -> Self {
        IfcCurveFontOrScaledCurveFontSelect::IfcCurveStyleFontSelect(IfcCurveStyleFontSelect::default())
    }
}
impl From<Parameter> for IfcCurveFontOrScaledCurveFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCPREDEFINEDCURVEFONT" | "IFCCURVESTYLEFONT" => {
                    IfcCurveFontOrScaledCurveFontSelect::IfcCurveStyleFontSelect(IfcCurveStyleFontSelect::from(
                        Parameter::TypedParameter(TypedParameter {
                            type_name: typed_parameter.type_name,
                            parameters: typed_parameter.parameters,
                        }),
                    ))
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    IfcCurveFontOrScaledCurveFontSelect::IfcCurveStyleFontAndScaling(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveOrEdgeCurve {
    EntityRef(EntityRef),
    IfcBoundedCurve(EntityRef),
    IfcEdgeCurve(EntityRef),
}
impl Default for IfcCurveOrEdgeCurve {
    fn default() -> Self {
        IfcCurveOrEdgeCurve::IfcBoundedCurve(EntityRef::default())
    }
}
impl From<Parameter> for IfcCurveOrEdgeCurve {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCurveOrEdgeCurve::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcCurveStyleFontSelect {
    EntityRef(EntityRef),
    IfcPreDefinedCurveFont(EntityRef),
    IfcCurveStyleFont(EntityRef),
}
impl Default for IfcCurveStyleFontSelect {
    fn default() -> Self {
        IfcCurveStyleFontSelect::IfcPreDefinedCurveFont(EntityRef::default())
    }
}
impl From<Parameter> for IfcCurveStyleFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcCurveStyleFontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcDateTimeSelect {
    EntityRef(EntityRef),
    IfcCalendarDate(EntityRef),
    IfcLocalTime(EntityRef),
    IfcDateAndTime(EntityRef),
}
impl Default for IfcDateTimeSelect {
    fn default() -> Self {
        IfcDateTimeSelect::IfcCalendarDate(EntityRef::default())
    }
}
impl From<Parameter> for IfcDateTimeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcDateTimeSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcDefinedSymbolSelect {
    EntityRef(EntityRef),
    IfcPreDefinedSymbol(EntityRef),
    IfcExternallyDefinedSymbol(EntityRef),
}
impl Default for IfcDefinedSymbolSelect {
    fn default() -> Self {
        IfcDefinedSymbolSelect::IfcPreDefinedSymbol(EntityRef::default())
    }
}
impl From<Parameter> for IfcDefinedSymbolSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcDefinedSymbolSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcDerivedMeasureValue {
    IfcVolumetricFlowRateMeasure(IfcVolumetricFlowRateMeasure),
    IfcTimeStamp(IfcTimeStamp),
    IfcThermalTransmittanceMeasure(IfcThermalTransmittanceMeasure),
    IfcThermalResistanceMeasure(IfcThermalResistanceMeasure),
    IfcThermalAdmittanceMeasure(IfcThermalAdmittanceMeasure),
    IfcPressureMeasure(IfcPressureMeasure),
    IfcPowerMeasure(IfcPowerMeasure),
    IfcMassFlowRateMeasure(IfcMassFlowRateMeasure),
    IfcMassDensityMeasure(IfcMassDensityMeasure),
    IfcLinearVelocityMeasure(IfcLinearVelocityMeasure),
    IfcKinematicViscosityMeasure(IfcKinematicViscosityMeasure),
    IfcIntegerCountRateMeasure(IfcIntegerCountRateMeasure),
    IfcHeatFluxDensityMeasure(IfcHeatFluxDensityMeasure),
    IfcFrequencyMeasure(IfcFrequencyMeasure),
    IfcEnergyMeasure(IfcEnergyMeasure),
    IfcElectricVoltageMeasure(IfcElectricVoltageMeasure),
    IfcDynamicViscosityMeasure(IfcDynamicViscosityMeasure),
    IfcCompoundPlaneAngleMeasure(IfcCompoundPlaneAngleMeasure),
    IfcAngularVelocityMeasure(IfcAngularVelocityMeasure),
    IfcThermalConductivityMeasure(IfcThermalConductivityMeasure),
    IfcMolecularWeightMeasure(IfcMolecularWeightMeasure),
    IfcVaporPermeabilityMeasure(IfcVaporPermeabilityMeasure),
    IfcMoistureDiffusivityMeasure(IfcMoistureDiffusivityMeasure),
    IfcIsothermalMoistureCapacityMeasure(IfcIsothermalMoistureCapacityMeasure),
    IfcSpecificHeatCapacityMeasure(IfcSpecificHeatCapacityMeasure),
    IfcMonetaryMeasure(IfcMonetaryMeasure),
    IfcMagneticFluxDensityMeasure(IfcMagneticFluxDensityMeasure),
    IfcMagneticFluxMeasure(IfcMagneticFluxMeasure),
    IfcLuminousFluxMeasure(IfcLuminousFluxMeasure),
    IfcForceMeasure(IfcForceMeasure),
    IfcInductanceMeasure(IfcInductanceMeasure),
    IfcIlluminanceMeasure(IfcIlluminanceMeasure),
    IfcElectricResistanceMeasure(IfcElectricResistanceMeasure),
    IfcElectricConductanceMeasure(IfcElectricConductanceMeasure),
    IfcElectricChargeMeasure(IfcElectricChargeMeasure),
    IfcDoseEquivalentMeasure(IfcDoseEquivalentMeasure),
    IfcElectricCapacitanceMeasure(IfcElectricCapacitanceMeasure),
    IfcAbsorbedDoseMeasure(IfcAbsorbedDoseMeasure),
    IfcRadioActivityMeasure(IfcRadioActivityMeasure),
    IfcRotationalFrequencyMeasure(IfcRotationalFrequencyMeasure),
    IfcTorqueMeasure(IfcTorqueMeasure),
    IfcAccelerationMeasure(IfcAccelerationMeasure),
    IfcLinearForceMeasure(IfcLinearForceMeasure),
    IfcLinearStiffnessMeasure(IfcLinearStiffnessMeasure),
    IfcModulusOfSubgradeReactionMeasure(IfcModulusOfSubgradeReactionMeasure),
    IfcModulusOfElasticityMeasure(IfcModulusOfElasticityMeasure),
    IfcMomentOfInertiaMeasure(IfcMomentOfInertiaMeasure),
    IfcPlanarForceMeasure(IfcPlanarForceMeasure),
    IfcRotationalStiffnessMeasure(IfcRotationalStiffnessMeasure),
    IfcShearModulusMeasure(IfcShearModulusMeasure),
    IfcLinearMomentMeasure(IfcLinearMomentMeasure),
    IfcLuminousIntensityDistributionMeasure(IfcLuminousIntensityDistributionMeasure),
    IfcCurvatureMeasure(IfcCurvatureMeasure),
    IfcMassPerLengthMeasure(IfcMassPerLengthMeasure),
    IfcModulusOfLinearSubgradeReactionMeasure(IfcModulusOfLinearSubgradeReactionMeasure),
    IfcModulusOfRotationalSubgradeReactionMeasure(IfcModulusOfRotationalSubgradeReactionMeasure),
    IfcRotationalMassMeasure(IfcRotationalMassMeasure),
    IfcSectionalAreaIntegralMeasure(IfcSectionalAreaIntegralMeasure),
    IfcSectionModulusMeasure(IfcSectionModulusMeasure),
    IfcTemperatureGradientMeasure(IfcTemperatureGradientMeasure),
    IfcThermalExpansionCoefficientMeasure(IfcThermalExpansionCoefficientMeasure),
    IfcWarpingConstantMeasure(IfcWarpingConstantMeasure),
    IfcWarpingMomentMeasure(IfcWarpingMomentMeasure),
    IfcSoundPowerMeasure(IfcSoundPowerMeasure),
    IfcSoundPressureMeasure(IfcSoundPressureMeasure),
    IfcHeatingValueMeasure(IfcHeatingValueMeasure),
    IfcPhMeasure(IfcPhMeasure),
    IfcIonConcentrationMeasure(IfcIonConcentrationMeasure),
}
impl Default for IfcDerivedMeasureValue {
    fn default() -> Self {
        IfcDerivedMeasureValue::IfcVolumetricFlowRateMeasure(IfcVolumetricFlowRateMeasure::default())
    }
}
impl From<Parameter> for IfcDerivedMeasureValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCVOLUMETRICFLOWRATEMEASURE" => IfcDerivedMeasureValue::IfcVolumetricFlowRateMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTIMESTAMP" => {
                    IfcDerivedMeasureValue::IfcTimeStamp(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCTHERMALTRANSMITTANCEMEASURE" => IfcDerivedMeasureValue::IfcThermalTransmittanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTHERMALRESISTANCEMEASURE" => IfcDerivedMeasureValue::IfcThermalResistanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTHERMALADMITTANCEMEASURE" => IfcDerivedMeasureValue::IfcThermalAdmittanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCPRESSUREMEASURE" => IfcDerivedMeasureValue::IfcPressureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCPOWERMEASURE" => IfcDerivedMeasureValue::IfcPowerMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMASSFLOWRATEMEASURE" => IfcDerivedMeasureValue::IfcMassFlowRateMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMASSDENSITYMEASURE" => IfcDerivedMeasureValue::IfcMassDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLINEARVELOCITYMEASURE" => IfcDerivedMeasureValue::IfcLinearVelocityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCKINEMATICVISCOSITYMEASURE" => IfcDerivedMeasureValue::IfcKinematicViscosityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCINTEGERCOUNTRATEMEASURE" => IfcDerivedMeasureValue::IfcIntegerCountRateMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCHEATFLUXDENSITYMEASURE" => IfcDerivedMeasureValue::IfcHeatFluxDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCFREQUENCYMEASURE" => IfcDerivedMeasureValue::IfcFrequencyMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCENERGYMEASURE" => IfcDerivedMeasureValue::IfcEnergyMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCELECTRICVOLTAGEMEASURE" => IfcDerivedMeasureValue::IfcElectricVoltageMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCDYNAMICVISCOSITYMEASURE" => IfcDerivedMeasureValue::IfcDynamicViscosityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCCOMPOUNDPLANEANGLEMEASURE" => IfcDerivedMeasureValue::IfcCompoundPlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCANGULARVELOCITYMEASURE" => IfcDerivedMeasureValue::IfcAngularVelocityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTHERMALCONDUCTIVITYMEASURE" => IfcDerivedMeasureValue::IfcThermalConductivityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMOLECULARWEIGHTMEASURE" => IfcDerivedMeasureValue::IfcMolecularWeightMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCVAPORPERMEABILITYMEASURE" => IfcDerivedMeasureValue::IfcVaporPermeabilityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMOISTUREDIFFUSIVITYMEASURE" => IfcDerivedMeasureValue::IfcMoistureDiffusivityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCISOTHERMALMOISTURECAPACITYMEASURE" => IfcDerivedMeasureValue::IfcIsothermalMoistureCapacityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSPECIFICHEATCAPACITYMEASURE" => IfcDerivedMeasureValue::IfcSpecificHeatCapacityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMONETARYMEASURE" => IfcDerivedMeasureValue::IfcMonetaryMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMAGNETICFLUXDENSITYMEASURE" => IfcDerivedMeasureValue::IfcMagneticFluxDensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMAGNETICFLUXMEASURE" => IfcDerivedMeasureValue::IfcMagneticFluxMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLUMINOUSFLUXMEASURE" => IfcDerivedMeasureValue::IfcLuminousFluxMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCFORCEMEASURE" => IfcDerivedMeasureValue::IfcForceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCINDUCTANCEMEASURE" => IfcDerivedMeasureValue::IfcInductanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCILLUMINANCEMEASURE" => IfcDerivedMeasureValue::IfcIlluminanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCELECTRICRESISTANCEMEASURE" => IfcDerivedMeasureValue::IfcElectricResistanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCELECTRICCONDUCTANCEMEASURE" => IfcDerivedMeasureValue::IfcElectricConductanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCELECTRICCHARGEMEASURE" => IfcDerivedMeasureValue::IfcElectricChargeMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCDOSEEQUIVALENTMEASURE" => IfcDerivedMeasureValue::IfcDoseEquivalentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCELECTRICCAPACITANCEMEASURE" => IfcDerivedMeasureValue::IfcElectricCapacitanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCABSORBEDDOSEMEASURE" => IfcDerivedMeasureValue::IfcAbsorbedDoseMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCRADIOACTIVITYMEASURE" => IfcDerivedMeasureValue::IfcRadioActivityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCROTATIONALFREQUENCYMEASURE" => IfcDerivedMeasureValue::IfcRotationalFrequencyMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTORQUEMEASURE" => IfcDerivedMeasureValue::IfcTorqueMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCACCELERATIONMEASURE" => IfcDerivedMeasureValue::IfcAccelerationMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLINEARFORCEMEASURE" => IfcDerivedMeasureValue::IfcLinearForceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLINEARSTIFFNESSMEASURE" => IfcDerivedMeasureValue::IfcLinearStiffnessMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMODULUSOFSUBGRADEREACTIONMEASURE" => IfcDerivedMeasureValue::IfcModulusOfSubgradeReactionMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMODULUSOFELASTICITYMEASURE" => IfcDerivedMeasureValue::IfcModulusOfElasticityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMOMENTOFINERTIAMEASURE" => IfcDerivedMeasureValue::IfcMomentOfInertiaMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCPLANARFORCEMEASURE" => IfcDerivedMeasureValue::IfcPlanarForceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCROTATIONALSTIFFNESSMEASURE" => IfcDerivedMeasureValue::IfcRotationalStiffnessMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSHEARMODULUSMEASURE" => IfcDerivedMeasureValue::IfcShearModulusMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLINEARMOMENTMEASURE" => IfcDerivedMeasureValue::IfcLinearMomentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE" => {
                    IfcDerivedMeasureValue::IfcLuminousIntensityDistributionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFCCURVATUREMEASURE" => IfcDerivedMeasureValue::IfcCurvatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMASSPERLENGTHMEASURE" => IfcDerivedMeasureValue::IfcMassPerLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE" => {
                    IfcDerivedMeasureValue::IfcModulusOfLinearSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE" => {
                    IfcDerivedMeasureValue::IfcModulusOfRotationalSubgradeReactionMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFCROTATIONALMASSMEASURE" => IfcDerivedMeasureValue::IfcRotationalMassMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSECTIONALAREAINTEGRALMEASURE" => IfcDerivedMeasureValue::IfcSectionalAreaIntegralMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSECTIONMODULUSMEASURE" => IfcDerivedMeasureValue::IfcSectionModulusMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTEMPERATUREGRADIENTMEASURE" => IfcDerivedMeasureValue::IfcTemperatureGradientMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE" => {
                    IfcDerivedMeasureValue::IfcThermalExpansionCoefficientMeasure(
                        typed_parameter.parameters.into_iter().next().unwrap().into(),
                    )
                }
                "IFCWARPINGCONSTANTMEASURE" => IfcDerivedMeasureValue::IfcWarpingConstantMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCWARPINGMOMENTMEASURE" => IfcDerivedMeasureValue::IfcWarpingMomentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSOUNDPOWERMEASURE" => IfcDerivedMeasureValue::IfcSoundPowerMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSOUNDPRESSUREMEASURE" => IfcDerivedMeasureValue::IfcSoundPressureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCHEATINGVALUEMEASURE" => IfcDerivedMeasureValue::IfcHeatingValueMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCPHMEASURE" => {
                    IfcDerivedMeasureValue::IfcPhMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCIONCONCENTRATIONMEASURE" => IfcDerivedMeasureValue::IfcIonConcentrationMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDocumentSelect {
    EntityRef(EntityRef),
    IfcDocumentReference(EntityRef),
    IfcDocumentInformation(EntityRef),
}
impl Default for IfcDocumentSelect {
    fn default() -> Self {
        IfcDocumentSelect::IfcDocumentReference(EntityRef::default())
    }
}
impl From<Parameter> for IfcDocumentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcDocumentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcDraughtingCalloutElement {
    EntityRef(EntityRef),
    IfcAnnotationCurveOccurrence(EntityRef),
    IfcAnnotationTextOccurrence(EntityRef),
    IfcAnnotationSymbolOccurrence(EntityRef),
}
impl Default for IfcDraughtingCalloutElement {
    fn default() -> Self {
        IfcDraughtingCalloutElement::IfcAnnotationCurveOccurrence(EntityRef::default())
    }
}
impl From<Parameter> for IfcDraughtingCalloutElement {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcDraughtingCalloutElement::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFillAreaStyleTileShapeSelect {
    IfcFillAreaStyleTileSymbolWithStyle(EntityRef),
}
impl Default for IfcFillAreaStyleTileShapeSelect {
    fn default() -> Self {
        IfcFillAreaStyleTileShapeSelect::IfcFillAreaStyleTileSymbolWithStyle(EntityRef::default())
    }
}
impl From<Parameter> for IfcFillAreaStyleTileShapeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    IfcFillAreaStyleTileShapeSelect::IfcFillAreaStyleTileSymbolWithStyle(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcFillStyleSelect {
    EntityRef(EntityRef),
    IfcFillAreaStyleHatching(EntityRef),
    IfcFillAreaStyleTiles(EntityRef),
    IfcColour(IfcColour),
    IfcExternallyDefinedHatchStyle(EntityRef),
}
impl Default for IfcFillStyleSelect {
    fn default() -> Self {
        IfcFillStyleSelect::IfcFillAreaStyleHatching(EntityRef::default())
    }
}
impl From<Parameter> for IfcFillStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCCOLOURSPECIFICATION" | "IFCPREDEFINEDCOLOUR" => {
                    IfcFillStyleSelect::IfcColour(IfcColour::from(Parameter::TypedParameter(TypedParameter {
                        type_name: typed_parameter.type_name,
                        parameters: typed_parameter.parameters,
                    })))
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcFillStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcGeometricSetSelect {
    EntityRef(EntityRef),
    IfcPoint(EntityRef),
    IfcCurve(EntityRef),
    IfcSurface(EntityRef),
}
impl Default for IfcGeometricSetSelect {
    fn default() -> Self {
        IfcGeometricSetSelect::IfcPoint(EntityRef::default())
    }
}
impl From<Parameter> for IfcGeometricSetSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcGeometricSetSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcHatchLineDistanceSelect {
    IfcOneDirectionRepeatFactor(EntityRef),
    IfcPositiveLengthMeasure(IfcPositiveLengthMeasure),
}
impl Default for IfcHatchLineDistanceSelect {
    fn default() -> Self {
        IfcHatchLineDistanceSelect::IfcOneDirectionRepeatFactor(EntityRef::default())
    }
}
impl From<Parameter> for IfcHatchLineDistanceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCPOSITIVELENGTHMEASURE" => IfcHatchLineDistanceSelect::IfcPositiveLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => {
                    IfcHatchLineDistanceSelect::IfcOneDirectionRepeatFactor(EntityRef(id))
                }
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcLayeredItem {
    EntityRef(EntityRef),
    IfcRepresentationItem(EntityRef),
    IfcRepresentation(EntityRef),
}
impl Default for IfcLayeredItem {
    fn default() -> Self {
        IfcLayeredItem::IfcRepresentationItem(EntityRef::default())
    }
}
impl From<Parameter> for IfcLayeredItem {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcLayeredItem::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcLibrarySelect {
    EntityRef(EntityRef),
    IfcLibraryReference(EntityRef),
    IfcLibraryInformation(EntityRef),
}
impl Default for IfcLibrarySelect {
    fn default() -> Self {
        IfcLibrarySelect::IfcLibraryReference(EntityRef::default())
    }
}
impl From<Parameter> for IfcLibrarySelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcLibrarySelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcLightDistributionDataSourceSelect {
    EntityRef(EntityRef),
    IfcExternalReference(EntityRef),
    IfcLightIntensityDistribution(EntityRef),
}
impl Default for IfcLightDistributionDataSourceSelect {
    fn default() -> Self {
        IfcLightDistributionDataSourceSelect::IfcExternalReference(EntityRef::default())
    }
}
impl From<Parameter> for IfcLightDistributionDataSourceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcLightDistributionDataSourceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcMaterialSelect {
    EntityRef(EntityRef),
    IfcMaterial(EntityRef),
    IfcMaterialList(EntityRef),
    IfcMaterialLayerSetUsage(EntityRef),
    IfcMaterialLayerSet(EntityRef),
    IfcMaterialLayer(EntityRef),
}
impl Default for IfcMaterialSelect {
    fn default() -> Self {
        IfcMaterialSelect::IfcMaterial(EntityRef::default())
    }
}
impl From<Parameter> for IfcMaterialSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcMaterialSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcMeasureValue {
    IfcVolumeMeasure(IfcVolumeMeasure),
    IfcTimeMeasure(IfcTimeMeasure),
    IfcThermodynamicTemperatureMeasure(IfcThermodynamicTemperatureMeasure),
    IfcSolidAngleMeasure(IfcSolidAngleMeasure),
    IfcPositiveRatioMeasure(IfcPositiveRatioMeasure),
    IfcRatioMeasure(IfcRatioMeasure),
    IfcPositivePlaneAngleMeasure(IfcPositivePlaneAngleMeasure),
    IfcPlaneAngleMeasure(IfcPlaneAngleMeasure),
    IfcParameterValue(IfcParameterValue),
    IfcNumericMeasure(IfcNumericMeasure),
    IfcMassMeasure(IfcMassMeasure),
    IfcPositiveLengthMeasure(IfcPositiveLengthMeasure),
    IfcLengthMeasure(IfcLengthMeasure),
    IfcElectricCurrentMeasure(IfcElectricCurrentMeasure),
    IfcDescriptiveMeasure(IfcDescriptiveMeasure),
    IfcCountMeasure(IfcCountMeasure),
    IfcContextDependentMeasure(IfcContextDependentMeasure),
    IfcAreaMeasure(IfcAreaMeasure),
    IfcAmountOfSubstanceMeasure(IfcAmountOfSubstanceMeasure),
    IfcLuminousIntensityMeasure(IfcLuminousIntensityMeasure),
    IfcNormalisedRatioMeasure(IfcNormalisedRatioMeasure),
    IfcComplexNumber(IfcComplexNumber),
}
impl Default for IfcMeasureValue {
    fn default() -> Self {
        IfcMeasureValue::IfcVolumeMeasure(IfcVolumeMeasure::default())
    }
}
impl From<Parameter> for IfcMeasureValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCVOLUMEMEASURE" => {
                    IfcMeasureValue::IfcVolumeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCTIMEMEASURE" => {
                    IfcMeasureValue::IfcTimeMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCTHERMODYNAMICTEMPERATUREMEASURE" => IfcMeasureValue::IfcThermodynamicTemperatureMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSOLIDANGLEMEASURE" => {
                    IfcMeasureValue::IfcSolidAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCPOSITIVERATIOMEASURE" => IfcMeasureValue::IfcPositiveRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCRATIOMEASURE" => {
                    IfcMeasureValue::IfcRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCPOSITIVEPLANEANGLEMEASURE" => IfcMeasureValue::IfcPositivePlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCPLANEANGLEMEASURE" => {
                    IfcMeasureValue::IfcPlaneAngleMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCPARAMETERVALUE" => {
                    IfcMeasureValue::IfcParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCNUMERICMEASURE" => {
                    IfcMeasureValue::IfcNumericMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCMASSMEASURE" => {
                    IfcMeasureValue::IfcMassMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCPOSITIVELENGTHMEASURE" => IfcMeasureValue::IfcPositiveLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLENGTHMEASURE" => {
                    IfcMeasureValue::IfcLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCELECTRICCURRENTMEASURE" => IfcMeasureValue::IfcElectricCurrentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCDESCRIPTIVEMEASURE" => IfcMeasureValue::IfcDescriptiveMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCCOUNTMEASURE" => {
                    IfcMeasureValue::IfcCountMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCCONTEXTDEPENDENTMEASURE" => IfcMeasureValue::IfcContextDependentMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCAREAMEASURE" => {
                    IfcMeasureValue::IfcAreaMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCAMOUNTOFSUBSTANCEMEASURE" => IfcMeasureValue::IfcAmountOfSubstanceMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCLUMINOUSINTENSITYMEASURE" => IfcMeasureValue::IfcLuminousIntensityMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCNORMALISEDRATIOMEASURE" => IfcMeasureValue::IfcNormalisedRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCCOMPLEXNUMBER" => {
                    IfcMeasureValue::IfcComplexNumber(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcMetricValueSelect {
    EntityRef(EntityRef),
    IfcDateTimeSelect(IfcDateTimeSelect),
    IfcMeasureWithUnit(EntityRef),
    IfcTable(EntityRef),
    IfcText(IfcText),
    IfcTimeSeries(EntityRef),
    IfcCostValue(EntityRef),
}
impl Default for IfcMetricValueSelect {
    fn default() -> Self {
        IfcMetricValueSelect::IfcDateTimeSelect(IfcDateTimeSelect::default())
    }
}
impl From<Parameter> for IfcMetricValueSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCCALENDARDATE" | "IFCLOCALTIME" | "IFCDATEANDTIME" => IfcMetricValueSelect::IfcDateTimeSelect(
                    IfcDateTimeSelect::from(Parameter::TypedParameter(TypedParameter {
                        type_name: typed_parameter.type_name,
                        parameters: typed_parameter.parameters,
                    })),
                ),
                "IFCTEXT" => {
                    IfcMetricValueSelect::IfcText(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcMetricValueSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcObjectReferenceSelect {
    EntityRef(EntityRef),
    IfcMaterial(EntityRef),
    IfcPerson(EntityRef),
    IfcDateAndTime(EntityRef),
    IfcMaterialList(EntityRef),
    IfcOrganization(EntityRef),
    IfcCalendarDate(EntityRef),
    IfcLocalTime(EntityRef),
    IfcPersonAndOrganization(EntityRef),
    IfcMaterialLayer(EntityRef),
    IfcExternalReference(EntityRef),
    IfcTimeSeries(EntityRef),
    IfcAddress(EntityRef),
    IfcAppliedValue(EntityRef),
}
impl Default for IfcObjectReferenceSelect {
    fn default() -> Self {
        IfcObjectReferenceSelect::IfcMaterial(EntityRef::default())
    }
}
impl From<Parameter> for IfcObjectReferenceSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcObjectReferenceSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcOrientationSelect {
    IfcPlaneAngleMeasure(IfcPlaneAngleMeasure),
    IfcDirection(EntityRef),
}
impl Default for IfcOrientationSelect {
    fn default() -> Self {
        IfcOrientationSelect::IfcPlaneAngleMeasure(IfcPlaneAngleMeasure::default())
    }
}
impl From<Parameter> for IfcOrientationSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCPLANEANGLEMEASURE" => IfcOrientationSelect::IfcPlaneAngleMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcOrientationSelect::IfcDirection(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcPointOrVertexPoint {
    EntityRef(EntityRef),
    IfcPoint(EntityRef),
    IfcVertexPoint(EntityRef),
}
impl Default for IfcPointOrVertexPoint {
    fn default() -> Self {
        IfcPointOrVertexPoint::IfcPoint(EntityRef::default())
    }
}
impl From<Parameter> for IfcPointOrVertexPoint {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcPointOrVertexPoint::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcPresentationStyleSelect {
    EntityRef(EntityRef),
    IfcNullStyle(IfcNullStyle),
    IfcCurveStyle(EntityRef),
    IfcSymbolStyle(EntityRef),
    IfcFillAreaStyle(EntityRef),
    IfcTextStyle(EntityRef),
    IfcSurfaceStyle(EntityRef),
}
impl Default for IfcPresentationStyleSelect {
    fn default() -> Self {
        IfcPresentationStyleSelect::IfcNullStyle(IfcNullStyle::default())
    }
}
impl From<Parameter> for IfcPresentationStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCNULLSTYLE" => IfcPresentationStyleSelect::IfcNullStyle(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcPresentationStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcShell {
    EntityRef(EntityRef),
    IfcClosedShell(EntityRef),
    IfcOpenShell(EntityRef),
}
impl Default for IfcShell {
    fn default() -> Self {
        IfcShell::IfcClosedShell(EntityRef::default())
    }
}
impl From<Parameter> for IfcShell {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcShell::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSimpleValue {
    IfcInteger(IfcInteger),
    IfcReal(IfcReal),
    IfcBoolean(IfcBoolean),
    IfcIdentifier(IfcIdentifier),
    IfcText(IfcText),
    IfcLabel(IfcLabel),
    IfcLogical(IfcLogical),
}
impl Default for IfcSimpleValue {
    fn default() -> Self {
        IfcSimpleValue::IfcInteger(IfcInteger::default())
    }
}
impl From<Parameter> for IfcSimpleValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCINTEGER" => {
                    IfcSimpleValue::IfcInteger(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCREAL" => IfcSimpleValue::IfcReal(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFCBOOLEAN" => {
                    IfcSimpleValue::IfcBoolean(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCIDENTIFIER" => {
                    IfcSimpleValue::IfcIdentifier(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCTEXT" => IfcSimpleValue::IfcText(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFCLABEL" => IfcSimpleValue::IfcLabel(typed_parameter.parameters.into_iter().next().unwrap().into()),
                "IFCLOGICAL" => {
                    IfcSimpleValue::IfcLogical(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSizeSelect {
    IfcRatioMeasure(IfcRatioMeasure),
    IfcLengthMeasure(IfcLengthMeasure),
    IfcDescriptiveMeasure(IfcDescriptiveMeasure),
    IfcPositiveLengthMeasure(IfcPositiveLengthMeasure),
    IfcNormalisedRatioMeasure(IfcNormalisedRatioMeasure),
    IfcPositiveRatioMeasure(IfcPositiveRatioMeasure),
}
impl Default for IfcSizeSelect {
    fn default() -> Self {
        IfcSizeSelect::IfcRatioMeasure(IfcRatioMeasure::default())
    }
}
impl From<Parameter> for IfcSizeSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCRATIOMEASURE" => {
                    IfcSizeSelect::IfcRatioMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCLENGTHMEASURE" => {
                    IfcSizeSelect::IfcLengthMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCDESCRIPTIVEMEASURE" => {
                    IfcSizeSelect::IfcDescriptiveMeasure(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                "IFCPOSITIVELENGTHMEASURE" => IfcSizeSelect::IfcPositiveLengthMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCNORMALISEDRATIOMEASURE" => IfcSizeSelect::IfcNormalisedRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCPOSITIVERATIOMEASURE" => IfcSizeSelect::IfcPositiveRatioMeasure(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSpecularHighlightSelect {
    IfcSpecularExponent(IfcSpecularExponent),
    IfcSpecularRoughness(IfcSpecularRoughness),
}
impl Default for IfcSpecularHighlightSelect {
    fn default() -> Self {
        IfcSpecularHighlightSelect::IfcSpecularExponent(IfcSpecularExponent::default())
    }
}
impl From<Parameter> for IfcSpecularHighlightSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCSPECULAREXPONENT" => IfcSpecularHighlightSelect::IfcSpecularExponent(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                "IFCSPECULARROUGHNESS" => IfcSpecularHighlightSelect::IfcSpecularRoughness(
                    typed_parameter.parameters.into_iter().next().unwrap().into(),
                ),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcStructuralActivityAssignmentSelect {
    EntityRef(EntityRef),
    IfcStructuralItem(EntityRef),
    IfcElement(EntityRef),
}
impl Default for IfcStructuralActivityAssignmentSelect {
    fn default() -> Self {
        IfcStructuralActivityAssignmentSelect::IfcStructuralItem(EntityRef::default())
    }
}
impl From<Parameter> for IfcStructuralActivityAssignmentSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcStructuralActivityAssignmentSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSurfaceOrFaceSurface {
    EntityRef(EntityRef),
    IfcSurface(EntityRef),
    IfcFaceSurface(EntityRef),
    IfcFaceBasedSurfaceModel(EntityRef),
}
impl Default for IfcSurfaceOrFaceSurface {
    fn default() -> Self {
        IfcSurfaceOrFaceSurface::IfcSurface(EntityRef::default())
    }
}
impl From<Parameter> for IfcSurfaceOrFaceSurface {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcSurfaceOrFaceSurface::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcSurfaceStyleElementSelect {
    EntityRef(EntityRef),
    IfcSurfaceStyleShading(EntityRef),
    IfcSurfaceStyleLighting(EntityRef),
    IfcSurfaceStyleWithTextures(EntityRef),
    IfcExternallyDefinedSurfaceStyle(EntityRef),
    IfcSurfaceStyleRefraction(EntityRef),
}
impl Default for IfcSurfaceStyleElementSelect {
    fn default() -> Self {
        IfcSurfaceStyleElementSelect::IfcSurfaceStyleShading(EntityRef::default())
    }
}
impl From<Parameter> for IfcSurfaceStyleElementSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcSurfaceStyleElementSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcSymbolStyleSelect {
    IfcColour(IfcColour),
}
impl Default for IfcSymbolStyleSelect {
    fn default() -> Self {
        IfcSymbolStyleSelect::IfcColour(IfcColour::default())
    }
}
impl From<Parameter> for IfcSymbolStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCCOLOURSPECIFICATION" | "IFCPREDEFINEDCOLOUR" => {
                    IfcSymbolStyleSelect::IfcColour(IfcColour::from(Parameter::TypedParameter(TypedParameter {
                        type_name: typed_parameter.type_name,
                        parameters: typed_parameter.parameters,
                    })))
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcTextFontSelect {
    EntityRef(EntityRef),
    IfcPreDefinedTextFont(EntityRef),
    IfcExternallyDefinedTextFont(EntityRef),
}
impl Default for IfcTextFontSelect {
    fn default() -> Self {
        IfcTextFontSelect::IfcPreDefinedTextFont(EntityRef::default())
    }
}
impl From<Parameter> for IfcTextFontSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcTextFontSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcTextStyleSelect {
    EntityRef(EntityRef),
    IfcTextStyleWithBoxCharacteristics(EntityRef),
    IfcTextStyleTextModel(EntityRef),
}
impl Default for IfcTextStyleSelect {
    fn default() -> Self {
        IfcTextStyleSelect::IfcTextStyleWithBoxCharacteristics(EntityRef::default())
    }
}
impl From<Parameter> for IfcTextStyleSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcTextStyleSelect::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcTrimmingSelect {
    IfcCartesianPoint(EntityRef),
    IfcParameterValue(IfcParameterValue),
}
impl Default for IfcTrimmingSelect {
    fn default() -> Self {
        IfcTrimmingSelect::IfcCartesianPoint(EntityRef::default())
    }
}
impl From<Parameter> for IfcTrimmingSelect {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCPARAMETERVALUE" => {
                    IfcTrimmingSelect::IfcParameterValue(typed_parameter.parameters.into_iter().next().unwrap().into())
                }
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcTrimmingSelect::IfcCartesianPoint(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Eq, PartialEq, Hash, Debug)]
pub enum IfcUnit {
    EntityRef(EntityRef),
    IfcDerivedUnit(EntityRef),
    IfcNamedUnit(EntityRef),
    IfcMonetaryUnit(EntityRef),
}
impl Default for IfcUnit {
    fn default() -> Self {
        IfcUnit::IfcDerivedUnit(EntityRef::default())
    }
}
impl From<Parameter> for IfcUnit {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcUnit::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcValue {
    IfcMeasureValue(IfcMeasureValue),
    IfcSimpleValue(IfcSimpleValue),
    IfcDerivedMeasureValue(IfcDerivedMeasureValue),
}
impl Default for IfcValue {
    fn default() -> Self {
        IfcValue::IfcMeasureValue(IfcMeasureValue::default())
    }
}
impl From<Parameter> for IfcValue {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::TypedParameter(typed_parameter) => match typed_parameter.type_name.as_str() {
                "IFCVOLUMEMEASURE"
                | "IFCTIMEMEASURE"
                | "IFCTHERMODYNAMICTEMPERATUREMEASURE"
                | "IFCSOLIDANGLEMEASURE"
                | "IFCPOSITIVERATIOMEASURE"
                | "IFCRATIOMEASURE"
                | "IFCPOSITIVEPLANEANGLEMEASURE"
                | "IFCPLANEANGLEMEASURE"
                | "IFCPARAMETERVALUE"
                | "IFCNUMERICMEASURE"
                | "IFCMASSMEASURE"
                | "IFCPOSITIVELENGTHMEASURE"
                | "IFCLENGTHMEASURE"
                | "IFCELECTRICCURRENTMEASURE"
                | "IFCDESCRIPTIVEMEASURE"
                | "IFCCOUNTMEASURE"
                | "IFCCONTEXTDEPENDENTMEASURE"
                | "IFCAREAMEASURE"
                | "IFCAMOUNTOFSUBSTANCEMEASURE"
                | "IFCLUMINOUSINTENSITYMEASURE"
                | "IFCNORMALISEDRATIOMEASURE"
                | "IFCCOMPLEXNUMBER" => {
                    IfcValue::IfcMeasureValue(IfcMeasureValue::from(Parameter::TypedParameter(TypedParameter {
                        type_name: typed_parameter.type_name,
                        parameters: typed_parameter.parameters,
                    })))
                }
                "IFCINTEGER" | "IFCREAL" | "IFCBOOLEAN" | "IFCIDENTIFIER" | "IFCTEXT" | "IFCLABEL" | "IFCLOGICAL" => {
                    IfcValue::IfcSimpleValue(IfcSimpleValue::from(Parameter::TypedParameter(TypedParameter {
                        type_name: typed_parameter.type_name,
                        parameters: typed_parameter.parameters,
                    })))
                }
                "IFCVOLUMETRICFLOWRATEMEASURE"
                | "IFCTIMESTAMP"
                | "IFCTHERMALTRANSMITTANCEMEASURE"
                | "IFCTHERMALRESISTANCEMEASURE"
                | "IFCTHERMALADMITTANCEMEASURE"
                | "IFCPRESSUREMEASURE"
                | "IFCPOWERMEASURE"
                | "IFCMASSFLOWRATEMEASURE"
                | "IFCMASSDENSITYMEASURE"
                | "IFCLINEARVELOCITYMEASURE"
                | "IFCKINEMATICVISCOSITYMEASURE"
                | "IFCINTEGERCOUNTRATEMEASURE"
                | "IFCHEATFLUXDENSITYMEASURE"
                | "IFCFREQUENCYMEASURE"
                | "IFCENERGYMEASURE"
                | "IFCELECTRICVOLTAGEMEASURE"
                | "IFCDYNAMICVISCOSITYMEASURE"
                | "IFCCOMPOUNDPLANEANGLEMEASURE"
                | "IFCANGULARVELOCITYMEASURE"
                | "IFCTHERMALCONDUCTIVITYMEASURE"
                | "IFCMOLECULARWEIGHTMEASURE"
                | "IFCVAPORPERMEABILITYMEASURE"
                | "IFCMOISTUREDIFFUSIVITYMEASURE"
                | "IFCISOTHERMALMOISTURECAPACITYMEASURE"
                | "IFCSPECIFICHEATCAPACITYMEASURE"
                | "IFCMONETARYMEASURE"
                | "IFCMAGNETICFLUXDENSITYMEASURE"
                | "IFCMAGNETICFLUXMEASURE"
                | "IFCLUMINOUSFLUXMEASURE"
                | "IFCFORCEMEASURE"
                | "IFCINDUCTANCEMEASURE"
                | "IFCILLUMINANCEMEASURE"
                | "IFCELECTRICRESISTANCEMEASURE"
                | "IFCELECTRICCONDUCTANCEMEASURE"
                | "IFCELECTRICCHARGEMEASURE"
                | "IFCDOSEEQUIVALENTMEASURE"
                | "IFCELECTRICCAPACITANCEMEASURE"
                | "IFCABSORBEDDOSEMEASURE"
                | "IFCRADIOACTIVITYMEASURE"
                | "IFCROTATIONALFREQUENCYMEASURE"
                | "IFCTORQUEMEASURE"
                | "IFCACCELERATIONMEASURE"
                | "IFCLINEARFORCEMEASURE"
                | "IFCLINEARSTIFFNESSMEASURE"
                | "IFCMODULUSOFSUBGRADEREACTIONMEASURE"
                | "IFCMODULUSOFELASTICITYMEASURE"
                | "IFCMOMENTOFINERTIAMEASURE"
                | "IFCPLANARFORCEMEASURE"
                | "IFCROTATIONALSTIFFNESSMEASURE"
                | "IFCSHEARMODULUSMEASURE"
                | "IFCLINEARMOMENTMEASURE"
                | "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE"
                | "IFCCURVATUREMEASURE"
                | "IFCMASSPERLENGTHMEASURE"
                | "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE"
                | "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE"
                | "IFCROTATIONALMASSMEASURE"
                | "IFCSECTIONALAREAINTEGRALMEASURE"
                | "IFCSECTIONMODULUSMEASURE"
                | "IFCTEMPERATUREGRADIENTMEASURE"
                | "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE"
                | "IFCWARPINGCONSTANTMEASURE"
                | "IFCWARPINGMOMENTMEASURE"
                | "IFCSOUNDPOWERMEASURE"
                | "IFCSOUNDPRESSUREMEASURE"
                | "IFCHEATINGVALUEMEASURE"
                | "IFCPHMEASURE"
                | "IFCIONCONCENTRATIONMEASURE" => IfcValue::IfcDerivedMeasureValue(IfcDerivedMeasureValue::from(
                    Parameter::TypedParameter(TypedParameter {
                        type_name: typed_parameter.type_name,
                        parameters: typed_parameter.parameters,
                    }),
                )),
                _ => panic!("parameter type is not recognized: {}", typed_parameter.type_name),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
#[derive(Debug)]
pub enum IfcVectorOrDirection {
    EntityRef(EntityRef),
    IfcDirection(EntityRef),
    IfcVector(EntityRef),
}
impl Default for IfcVectorOrDirection {
    fn default() -> Self {
        IfcVectorOrDirection::IfcDirection(EntityRef::default())
    }
}
impl From<Parameter> for IfcVectorOrDirection {
    fn from(parameter: Parameter) -> Self {
        match parameter {
            Parameter::UnTypedParameter(untyped_parameter) => match untyped_parameter {
                UnTypedParameter::EntityRef(id) => IfcVectorOrDirection::EntityRef(EntityRef(id)),
                _ => panic!("parameter is not an instance"),
            },
            _ => panic!("parameter is not recognized"),
        }
    }
}
pub trait IIfc2DCompositeCurve: IIfcCompositeCurve {}
#[derive(Default, Debug)]
pub struct Ifc2DCompositeCurve {
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IIfcRepresentationItem for Ifc2DCompositeCurve {}
impl IIfcGeometricRepresentationItem for Ifc2DCompositeCurve {}
impl IIfcCurve for Ifc2DCompositeCurve {}
impl IIfcBoundedCurve for Ifc2DCompositeCurve {}
impl IIfcCompositeCurve for Ifc2DCompositeCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IIfc2DCompositeCurve for Ifc2DCompositeCurve {}
impl Ifc2DCompositeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = Ifc2DCompositeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.segments = parameter.into(),
                1usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActionRequest: IIfcControl {
    fn request_id(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcActionRequest {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    request_id: IfcIdentifier,
}
impl IIfcRoot for IfcActionRequest {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActionRequest {}
impl IIfcObject for IfcActionRequest {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcActionRequest {}
impl IIfcActionRequest for IfcActionRequest {
    fn request_id(&self) -> &IfcIdentifier {
        &self.request_id
    }
}
impl IfcActionRequest {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActionRequest::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.request_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActor: IIfcObject {
    fn the_actor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcActor {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    the_actor: EntityRef,
}
impl IIfcRoot for IfcActor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActor {}
impl IIfcObject for IfcActor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcActor for IfcActor {
    fn the_actor(&self) -> &EntityRef {
        &self.the_actor
    }
}
impl IfcActor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.the_actor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActorRole {
    fn role(&self) -> &IfcRoleEnum;
    fn user_defined_role(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcActorRole {
    role: IfcRoleEnum,
    user_defined_role: Option<IfcLabel>,
    description: Option<IfcText>,
}
impl IIfcActorRole for IfcActorRole {
    fn role(&self) -> &IfcRoleEnum {
        &self.role
    }
    fn user_defined_role(&self) -> &Option<IfcLabel> {
        &self.user_defined_role
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcActorRole {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActorRole::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.role = parameter.into(),
                1usize => {
                    entity.user_defined_role = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcActuatorType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcActuatorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcActuatorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcActuatorTypeEnum,
}
impl IIfcRoot for IfcActuatorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcActuatorType {}
impl IIfcTypeObject for IfcActuatorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcActuatorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcActuatorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcActuatorType {}
impl IIfcDistributionControlElementType for IfcActuatorType {}
impl IIfcActuatorType for IfcActuatorType {
    fn predefined_type(&self) -> &IfcActuatorTypeEnum {
        &self.predefined_type
    }
}
impl IfcActuatorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcActuatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAddress {
    fn purpose(&self) -> &Option<IfcAddressTypeEnum>;
    fn description(&self) -> &Option<IfcText>;
    fn user_defined_purpose(&self) -> &Option<IfcLabel>;
}
pub trait IIfcAirTerminalBoxType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcAirTerminalBoxTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAirTerminalBoxType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAirTerminalBoxTypeEnum,
}
impl IIfcRoot for IfcAirTerminalBoxType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirTerminalBoxType {}
impl IIfcTypeObject for IfcAirTerminalBoxType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAirTerminalBoxType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAirTerminalBoxType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAirTerminalBoxType {}
impl IIfcDistributionFlowElementType for IfcAirTerminalBoxType {}
impl IIfcFlowControllerType for IfcAirTerminalBoxType {}
impl IIfcAirTerminalBoxType for IfcAirTerminalBoxType {
    fn predefined_type(&self) -> &IfcAirTerminalBoxTypeEnum {
        &self.predefined_type
    }
}
impl IfcAirTerminalBoxType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalBoxType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcAirTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAirTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAirTerminalTypeEnum,
}
impl IIfcRoot for IfcAirTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirTerminalType {}
impl IIfcTypeObject for IfcAirTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAirTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAirTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAirTerminalType {}
impl IIfcDistributionFlowElementType for IfcAirTerminalType {}
impl IIfcFlowTerminalType for IfcAirTerminalType {}
impl IIfcAirTerminalType for IfcAirTerminalType {
    fn predefined_type(&self) -> &IfcAirTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcAirTerminalType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAirToAirHeatRecoveryType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcAirToAirHeatRecoveryTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAirToAirHeatRecoveryType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAirToAirHeatRecoveryTypeEnum,
}
impl IIfcRoot for IfcAirToAirHeatRecoveryType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAirToAirHeatRecoveryType {}
impl IIfcTypeObject for IfcAirToAirHeatRecoveryType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAirToAirHeatRecoveryType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAirToAirHeatRecoveryType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAirToAirHeatRecoveryType {}
impl IIfcDistributionFlowElementType for IfcAirToAirHeatRecoveryType {}
impl IIfcEnergyConversionDeviceType for IfcAirToAirHeatRecoveryType {}
impl IIfcAirToAirHeatRecoveryType for IfcAirToAirHeatRecoveryType {
    fn predefined_type(&self) -> &IfcAirToAirHeatRecoveryTypeEnum {
        &self.predefined_type
    }
}
impl IfcAirToAirHeatRecoveryType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAirToAirHeatRecoveryType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAlarmType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcAlarmTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcAlarmType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcAlarmTypeEnum,
}
impl IIfcRoot for IfcAlarmType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAlarmType {}
impl IIfcTypeObject for IfcAlarmType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcAlarmType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcAlarmType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcAlarmType {}
impl IIfcDistributionControlElementType for IfcAlarmType {}
impl IIfcAlarmType for IfcAlarmType {
    fn predefined_type(&self) -> &IfcAlarmTypeEnum {
        &self.predefined_type
    }
}
impl IfcAlarmType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAlarmType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAngularDimension: IIfcDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct IfcAngularDimension {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcAngularDimension {}
impl IIfcGeometricRepresentationItem for IfcAngularDimension {}
impl IIfcDraughtingCallout for IfcAngularDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IIfcDimensionCurveDirectedCallout for IfcAngularDimension {}
impl IIfcAngularDimension for IfcAngularDimension {}
impl IfcAngularDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAngularDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotation: IIfcProduct {}
#[derive(Default, Debug)]
pub struct IfcAnnotation {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
}
impl IIfcRoot for IfcAnnotation {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAnnotation {}
impl IIfcObject for IfcAnnotation {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcAnnotation {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcAnnotation for IfcAnnotation {}
impl IfcAnnotation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationCurveOccurrence: IIfcAnnotationOccurrence {}
#[derive(Default, Debug)]
pub struct IfcAnnotationCurveOccurrence {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcAnnotationCurveOccurrence {}
impl IIfcStyledItem for IfcAnnotationCurveOccurrence {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcAnnotationCurveOccurrence {}
impl IIfcAnnotationCurveOccurrence for IfcAnnotationCurveOccurrence {}
impl IfcAnnotationCurveOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationCurveOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationFillArea: IIfcGeometricRepresentationItem {
    fn outer_boundary(&self) -> &EntityRef;
    fn inner_boundaries(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcAnnotationFillArea {
    outer_boundary: EntityRef,
    inner_boundaries: Option<HashSet<EntityRef>>,
}
impl IIfcRepresentationItem for IfcAnnotationFillArea {}
impl IIfcGeometricRepresentationItem for IfcAnnotationFillArea {}
impl IIfcAnnotationFillArea for IfcAnnotationFillArea {
    fn outer_boundary(&self) -> &EntityRef {
        &self.outer_boundary
    }
    fn inner_boundaries(&self) -> &Option<HashSet<EntityRef>> {
        &self.inner_boundaries
    }
}
impl IfcAnnotationFillArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationFillArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer_boundary = parameter.into(),
                1usize => {
                    entity.inner_boundaries = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationFillAreaOccurrence: IIfcAnnotationOccurrence {
    fn fill_style_target(&self) -> &Option<EntityRef>;
    fn global_or_local(&self) -> &Option<IfcGlobalOrLocalEnum>;
}
#[derive(Default, Debug)]
pub struct IfcAnnotationFillAreaOccurrence {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
    fill_style_target: Option<EntityRef>,
    global_or_local: Option<IfcGlobalOrLocalEnum>,
}
impl IIfcRepresentationItem for IfcAnnotationFillAreaOccurrence {}
impl IIfcStyledItem for IfcAnnotationFillAreaOccurrence {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcAnnotationFillAreaOccurrence {}
impl IIfcAnnotationFillAreaOccurrence for IfcAnnotationFillAreaOccurrence {
    fn fill_style_target(&self) -> &Option<EntityRef> {
        &self.fill_style_target
    }
    fn global_or_local(&self) -> &Option<IfcGlobalOrLocalEnum> {
        &self.global_or_local
    }
}
impl IfcAnnotationFillAreaOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationFillAreaOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.fill_style_target = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.global_or_local = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationOccurrence: IIfcStyledItem {}
pub trait IIfcAnnotationSurface: IIfcGeometricRepresentationItem {
    fn item(&self) -> &EntityRef;
    fn texture_coordinates(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAnnotationSurface {
    item: EntityRef,
    texture_coordinates: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAnnotationSurface {}
impl IIfcGeometricRepresentationItem for IfcAnnotationSurface {}
impl IIfcAnnotationSurface for IfcAnnotationSurface {
    fn item(&self) -> &EntityRef {
        &self.item
    }
    fn texture_coordinates(&self) -> &Option<EntityRef> {
        &self.texture_coordinates
    }
}
impl IfcAnnotationSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.item = parameter.into(),
                1usize => {
                    entity.texture_coordinates = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationSurfaceOccurrence: IIfcAnnotationOccurrence {}
#[derive(Default, Debug)]
pub struct IfcAnnotationSurfaceOccurrence {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcAnnotationSurfaceOccurrence {}
impl IIfcStyledItem for IfcAnnotationSurfaceOccurrence {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcAnnotationSurfaceOccurrence {}
impl IIfcAnnotationSurfaceOccurrence for IfcAnnotationSurfaceOccurrence {}
impl IfcAnnotationSurfaceOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationSurfaceOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationSymbolOccurrence: IIfcAnnotationOccurrence {}
#[derive(Default, Debug)]
pub struct IfcAnnotationSymbolOccurrence {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcAnnotationSymbolOccurrence {}
impl IIfcStyledItem for IfcAnnotationSymbolOccurrence {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcAnnotationSymbolOccurrence {}
impl IIfcAnnotationSymbolOccurrence for IfcAnnotationSymbolOccurrence {}
impl IfcAnnotationSymbolOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationSymbolOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAnnotationTextOccurrence: IIfcAnnotationOccurrence {}
#[derive(Default, Debug)]
pub struct IfcAnnotationTextOccurrence {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcAnnotationTextOccurrence {}
impl IIfcStyledItem for IfcAnnotationTextOccurrence {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcAnnotationTextOccurrence {}
impl IIfcAnnotationTextOccurrence for IfcAnnotationTextOccurrence {}
impl IfcAnnotationTextOccurrence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAnnotationTextOccurrence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApplication {
    fn application_developer(&self) -> &EntityRef;
    fn version(&self) -> &IfcLabel;
    fn application_full_name(&self) -> &IfcLabel;
    fn application_identifier(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcApplication {
    application_developer: EntityRef,
    version: IfcLabel,
    application_full_name: IfcLabel,
    application_identifier: IfcIdentifier,
}
impl IIfcApplication for IfcApplication {
    fn application_developer(&self) -> &EntityRef {
        &self.application_developer
    }
    fn version(&self) -> &IfcLabel {
        &self.version
    }
    fn application_full_name(&self) -> &IfcLabel {
        &self.application_full_name
    }
    fn application_identifier(&self) -> &IfcIdentifier {
        &self.application_identifier
    }
}
impl IfcApplication {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApplication::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.application_developer = parameter.into(),
                1usize => entity.version = parameter.into(),
                2usize => entity.application_full_name = parameter.into(),
                3usize => entity.application_identifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAppliedValue {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn applied_value(&self) -> &Option<IfcAppliedValueSelect>;
    fn unit_basis(&self) -> &Option<EntityRef>;
    fn applicable_date(&self) -> &Option<EntityRef>;
    fn fixed_until_date(&self) -> &Option<EntityRef>;
}
pub trait IIfcAppliedValueRelationship {
    fn component_of_total(&self) -> &EntityRef;
    fn components(&self) -> &HashSet<EntityRef>;
    fn arithmetic_operator(&self) -> &IfcArithmeticOperatorEnum;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcAppliedValueRelationship {
    component_of_total: EntityRef,
    components: HashSet<EntityRef>,
    arithmetic_operator: IfcArithmeticOperatorEnum,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
}
impl IIfcAppliedValueRelationship for IfcAppliedValueRelationship {
    fn component_of_total(&self) -> &EntityRef {
        &self.component_of_total
    }
    fn components(&self) -> &HashSet<EntityRef> {
        &self.components
    }
    fn arithmetic_operator(&self) -> &IfcArithmeticOperatorEnum {
        &self.arithmetic_operator
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcAppliedValueRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAppliedValueRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.component_of_total = parameter.into(),
                1usize => entity.components = parameter.into(),
                2usize => entity.arithmetic_operator = parameter.into(),
                3usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApproval {
    fn description(&self) -> &Option<IfcText>;
    fn approval_date_time(&self) -> &EntityRef;
    fn approval_status(&self) -> &Option<IfcLabel>;
    fn approval_level(&self) -> &Option<IfcLabel>;
    fn approval_qualifier(&self) -> &Option<IfcText>;
    fn name(&self) -> &IfcLabel;
    fn identifier(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcApproval {
    description: Option<IfcText>,
    approval_date_time: EntityRef,
    approval_status: Option<IfcLabel>,
    approval_level: Option<IfcLabel>,
    approval_qualifier: Option<IfcText>,
    name: IfcLabel,
    identifier: IfcIdentifier,
}
impl IIfcApproval for IfcApproval {
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn approval_date_time(&self) -> &EntityRef {
        &self.approval_date_time
    }
    fn approval_status(&self) -> &Option<IfcLabel> {
        &self.approval_status
    }
    fn approval_level(&self) -> &Option<IfcLabel> {
        &self.approval_level
    }
    fn approval_qualifier(&self) -> &Option<IfcText> {
        &self.approval_qualifier
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn identifier(&self) -> &IfcIdentifier {
        &self.identifier
    }
}
impl IfcApproval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApproval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.approval_date_time = parameter.into(),
                2usize => {
                    entity.approval_status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.approval_level = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.approval_qualifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.name = parameter.into(),
                6usize => entity.identifier = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApprovalActorRelationship {
    fn actor(&self) -> &EntityRef;
    fn approval(&self) -> &EntityRef;
    fn role(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcApprovalActorRelationship {
    actor: EntityRef,
    approval: EntityRef,
    role: EntityRef,
}
impl IIfcApprovalActorRelationship for IfcApprovalActorRelationship {
    fn actor(&self) -> &EntityRef {
        &self.actor
    }
    fn approval(&self) -> &EntityRef {
        &self.approval
    }
    fn role(&self) -> &EntityRef {
        &self.role
    }
}
impl IfcApprovalActorRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApprovalActorRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.actor = parameter.into(),
                1usize => entity.approval = parameter.into(),
                2usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApprovalPropertyRelationship {
    fn approved_properties(&self) -> &HashSet<EntityRef>;
    fn approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcApprovalPropertyRelationship {
    approved_properties: HashSet<EntityRef>,
    approval: EntityRef,
}
impl IIfcApprovalPropertyRelationship for IfcApprovalPropertyRelationship {
    fn approved_properties(&self) -> &HashSet<EntityRef> {
        &self.approved_properties
    }
    fn approval(&self) -> &EntityRef {
        &self.approval
    }
}
impl IfcApprovalPropertyRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApprovalPropertyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.approved_properties = parameter.into(),
                1usize => entity.approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcApprovalRelationship {
    fn related_approval(&self) -> &EntityRef;
    fn relating_approval(&self) -> &EntityRef;
    fn description(&self) -> &Option<IfcText>;
    fn name(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcApprovalRelationship {
    related_approval: EntityRef,
    relating_approval: EntityRef,
    description: Option<IfcText>,
    name: IfcLabel,
}
impl IIfcApprovalRelationship for IfcApprovalRelationship {
    fn related_approval(&self) -> &EntityRef {
        &self.related_approval
    }
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IfcApprovalRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcApprovalRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.related_approval = parameter.into(),
                1usize => entity.relating_approval = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcArbitraryClosedProfileDef: IIfcProfileDef {
    fn outer_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcArbitraryClosedProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    outer_curve: EntityRef,
}
impl IIfcProfileDef for IfcArbitraryClosedProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryClosedProfileDef for IfcArbitraryClosedProfileDef {
    fn outer_curve(&self) -> &EntityRef {
        &self.outer_curve
    }
}
impl IfcArbitraryClosedProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryClosedProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.outer_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcArbitraryOpenProfileDef: IIfcProfileDef {
    fn curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcArbitraryOpenProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    curve: EntityRef,
}
impl IIfcProfileDef for IfcArbitraryOpenProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryOpenProfileDef for IfcArbitraryOpenProfileDef {
    fn curve(&self) -> &EntityRef {
        &self.curve
    }
}
impl IfcArbitraryOpenProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryOpenProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcArbitraryProfileDefWithVoids: IIfcArbitraryClosedProfileDef {
    fn inner_curves(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcArbitraryProfileDefWithVoids {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    outer_curve: EntityRef,
    inner_curves: HashSet<EntityRef>,
}
impl IIfcProfileDef for IfcArbitraryProfileDefWithVoids {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryClosedProfileDef for IfcArbitraryProfileDefWithVoids {
    fn outer_curve(&self) -> &EntityRef {
        &self.outer_curve
    }
}
impl IIfcArbitraryProfileDefWithVoids for IfcArbitraryProfileDefWithVoids {
    fn inner_curves(&self) -> &HashSet<EntityRef> {
        &self.inner_curves
    }
}
impl IfcArbitraryProfileDefWithVoids {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcArbitraryProfileDefWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.outer_curve = parameter.into(),
                3usize => entity.inner_curves = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAsset: IIfcGroup {
    fn asset_id(&self) -> &IfcIdentifier;
    fn original_value(&self) -> &EntityRef;
    fn current_value(&self) -> &EntityRef;
    fn total_replacement_cost(&self) -> &EntityRef;
    fn owner(&self) -> &EntityRef;
    fn user(&self) -> &EntityRef;
    fn responsible_person(&self) -> &EntityRef;
    fn incorporation_date(&self) -> &EntityRef;
    fn depreciated_value(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcAsset {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    asset_id: IfcIdentifier,
    original_value: EntityRef,
    current_value: EntityRef,
    total_replacement_cost: EntityRef,
    owner: EntityRef,
    user: EntityRef,
    responsible_person: EntityRef,
    incorporation_date: EntityRef,
    depreciated_value: EntityRef,
}
impl IIfcRoot for IfcAsset {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcAsset {}
impl IIfcObject for IfcAsset {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcAsset {}
impl IIfcAsset for IfcAsset {
    fn asset_id(&self) -> &IfcIdentifier {
        &self.asset_id
    }
    fn original_value(&self) -> &EntityRef {
        &self.original_value
    }
    fn current_value(&self) -> &EntityRef {
        &self.current_value
    }
    fn total_replacement_cost(&self) -> &EntityRef {
        &self.total_replacement_cost
    }
    fn owner(&self) -> &EntityRef {
        &self.owner
    }
    fn user(&self) -> &EntityRef {
        &self.user
    }
    fn responsible_person(&self) -> &EntityRef {
        &self.responsible_person
    }
    fn incorporation_date(&self) -> &EntityRef {
        &self.incorporation_date
    }
    fn depreciated_value(&self) -> &EntityRef {
        &self.depreciated_value
    }
}
impl IfcAsset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAsset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.asset_id = parameter.into(),
                6usize => entity.original_value = parameter.into(),
                7usize => entity.current_value = parameter.into(),
                8usize => entity.total_replacement_cost = parameter.into(),
                9usize => entity.owner = parameter.into(),
                10usize => entity.user = parameter.into(),
                11usize => entity.responsible_person = parameter.into(),
                12usize => entity.incorporation_date = parameter.into(),
                13usize => entity.depreciated_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAsymmetricIShapeProfileDef: IIfcIShapeProfileDef {
    fn top_flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn top_flange_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn top_flange_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcAsymmetricIShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    overall_width: IfcPositiveLengthMeasure,
    overall_depth: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
    top_flange_width: IfcPositiveLengthMeasure,
    top_flange_thickness: Option<IfcPositiveLengthMeasure>,
    top_flange_fillet_radius: Option<IfcPositiveLengthMeasure>,
    centre_of_gravity_in_y: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcAsymmetricIShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcAsymmetricIShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcIShapeProfileDef for IfcAsymmetricIShapeProfileDef {
    fn overall_width(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_width
    }
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_depth
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
}
impl IIfcAsymmetricIShapeProfileDef for IfcAsymmetricIShapeProfileDef {
    fn top_flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.top_flange_width
    }
    fn top_flange_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.top_flange_thickness
    }
    fn top_flange_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.top_flange_fillet_radius
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IfcAsymmetricIShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAsymmetricIShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.overall_width = parameter.into(),
                4usize => entity.overall_depth = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.top_flange_width = parameter.into(),
                9usize => {
                    entity.top_flange_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.top_flange_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAxis1Placement: IIfcPlacement {
    fn axis(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAxis1Placement {
    location: EntityRef,
    axis: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAxis1Placement {}
impl IIfcGeometricRepresentationItem for IfcAxis1Placement {}
impl IIfcPlacement for IfcAxis1Placement {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IIfcAxis1Placement for IfcAxis1Placement {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
}
impl IfcAxis1Placement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis1Placement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location = parameter.into(),
                1usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAxis2Placement2D: IIfcPlacement {
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAxis2Placement2D {
    location: EntityRef,
    ref_direction: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAxis2Placement2D {}
impl IIfcGeometricRepresentationItem for IfcAxis2Placement2D {}
impl IIfcPlacement for IfcAxis2Placement2D {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IIfcAxis2Placement2D for IfcAxis2Placement2D {
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl IfcAxis2Placement2D {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis2Placement2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location = parameter.into(),
                1usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcAxis2Placement3D: IIfcPlacement {
    fn axis(&self) -> &Option<EntityRef>;
    fn ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcAxis2Placement3D {
    location: EntityRef,
    axis: Option<EntityRef>,
    ref_direction: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcAxis2Placement3D {}
impl IIfcGeometricRepresentationItem for IfcAxis2Placement3D {}
impl IIfcPlacement for IfcAxis2Placement3D {
    fn location(&self) -> &EntityRef {
        &self.location
    }
}
impl IIfcAxis2Placement3D for IfcAxis2Placement3D {
    fn axis(&self) -> &Option<EntityRef> {
        &self.axis
    }
    fn ref_direction(&self) -> &Option<EntityRef> {
        &self.ref_direction
    }
}
impl IfcAxis2Placement3D {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcAxis2Placement3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location = parameter.into(),
                1usize => {
                    entity.axis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBSplineCurve: IIfcBoundedCurve {
    fn degree(&self) -> i64;
    fn control_points_list(&self) -> &Vec<EntityRef>;
    fn curve_form(&self) -> &IfcBSplineCurveForm;
    fn closed_curve(&self) -> Option<bool>;
    fn self_intersect(&self) -> Option<bool>;
}
pub trait IIfcBeam: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcBeam {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcBeam {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBeam {}
impl IIfcObject for IfcBeam {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBeam {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBeam {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcBeam {}
impl IIfcBeam for IfcBeam {}
impl IfcBeam {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeam::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBeamType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcBeamTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBeamType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBeamTypeEnum,
}
impl IIfcRoot for IfcBeamType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBeamType {}
impl IIfcTypeObject for IfcBeamType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBeamType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBeamType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcBeamType {}
impl IIfcBeamType for IfcBeamType {
    fn predefined_type(&self) -> &IfcBeamTypeEnum {
        &self.predefined_type
    }
}
impl IfcBeamType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBeamType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBezierCurve: IIfcBSplineCurve {}
#[derive(Default, Debug)]
pub struct IfcBezierCurve {
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: IfcBSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
}
impl IIfcRepresentationItem for IfcBezierCurve {}
impl IIfcGeometricRepresentationItem for IfcBezierCurve {}
impl IIfcCurve for IfcBezierCurve {}
impl IIfcBoundedCurve for IfcBezierCurve {}
impl IIfcBSplineCurve for IfcBezierCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &IfcBSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IIfcBezierCurve for IfcBezierCurve {}
impl IfcBezierCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBezierCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.degree = parameter.into(),
                1usize => entity.control_points_list = parameter.into(),
                2usize => entity.curve_form = parameter.into(),
                3usize => entity.closed_curve = parameter.into(),
                4usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBlobTexture: IIfcSurfaceTexture {
    fn raster_format(&self) -> &IfcIdentifier;
    fn raster_code(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcBlobTexture {
    repeat_s: bool,
    repeat_t: bool,
    texture_type: IfcSurfaceTextureEnum,
    texture_transform: Option<EntityRef>,
    raster_format: IfcIdentifier,
    raster_code: bool,
}
impl IIfcSurfaceTexture for IfcBlobTexture {
    fn repeat_s(&self) -> bool {
        self.repeat_s
    }
    fn repeat_t(&self) -> bool {
        self.repeat_t
    }
    fn texture_type(&self) -> &IfcSurfaceTextureEnum {
        &self.texture_type
    }
    fn texture_transform(&self) -> &Option<EntityRef> {
        &self.texture_transform
    }
}
impl IIfcBlobTexture for IfcBlobTexture {
    fn raster_format(&self) -> &IfcIdentifier {
        &self.raster_format
    }
    fn raster_code(&self) -> bool {
        self.raster_code
    }
}
impl IfcBlobTexture {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBlobTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_s = parameter.into(),
                1usize => entity.repeat_t = parameter.into(),
                2usize => entity.texture_type = parameter.into(),
                3usize => {
                    entity.texture_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.raster_format = parameter.into(),
                5usize => entity.raster_code = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBlock: IIfcCsgPrimitive3D {
    fn x_length(&self) -> &IfcPositiveLengthMeasure;
    fn y_length(&self) -> &IfcPositiveLengthMeasure;
    fn z_length(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcBlock {
    position: EntityRef,
    x_length: IfcPositiveLengthMeasure,
    y_length: IfcPositiveLengthMeasure,
    z_length: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcBlock {}
impl IIfcGeometricRepresentationItem for IfcBlock {}
impl IIfcCsgPrimitive3D for IfcBlock {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcBlock for IfcBlock {
    fn x_length(&self) -> &IfcPositiveLengthMeasure {
        &self.x_length
    }
    fn y_length(&self) -> &IfcPositiveLengthMeasure {
        &self.y_length
    }
    fn z_length(&self) -> &IfcPositiveLengthMeasure {
        &self.z_length
    }
}
impl IfcBlock {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBlock::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.x_length = parameter.into(),
                2usize => entity.y_length = parameter.into(),
                3usize => entity.z_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoilerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcBoilerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBoilerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBoilerTypeEnum,
}
impl IIfcRoot for IfcBoilerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBoilerType {}
impl IIfcTypeObject for IfcBoilerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBoilerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBoilerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcBoilerType {}
impl IIfcDistributionFlowElementType for IfcBoilerType {}
impl IIfcEnergyConversionDeviceType for IfcBoilerType {}
impl IIfcBoilerType for IfcBoilerType {
    fn predefined_type(&self) -> &IfcBoilerTypeEnum {
        &self.predefined_type
    }
}
impl IfcBoilerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoilerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBooleanClippingResult: IIfcBooleanResult {}
#[derive(Default, Debug)]
pub struct IfcBooleanClippingResult {
    operator: IfcBooleanOperator,
    first_operand: EntityRef,
    second_operand: EntityRef,
}
impl IIfcRepresentationItem for IfcBooleanClippingResult {}
impl IIfcGeometricRepresentationItem for IfcBooleanClippingResult {}
impl IIfcBooleanResult for IfcBooleanClippingResult {
    fn operator(&self) -> &IfcBooleanOperator {
        &self.operator
    }
    fn first_operand(&self) -> &EntityRef {
        &self.first_operand
    }
    fn second_operand(&self) -> &EntityRef {
        &self.second_operand
    }
}
impl IIfcBooleanClippingResult for IfcBooleanClippingResult {}
impl IfcBooleanClippingResult {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBooleanClippingResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operator = parameter.into(),
                1usize => entity.first_operand = parameter.into(),
                2usize => entity.second_operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBooleanResult: IIfcGeometricRepresentationItem {
    fn operator(&self) -> &IfcBooleanOperator;
    fn first_operand(&self) -> &EntityRef;
    fn second_operand(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcBooleanResult {
    operator: IfcBooleanOperator,
    first_operand: EntityRef,
    second_operand: EntityRef,
}
impl IIfcRepresentationItem for IfcBooleanResult {}
impl IIfcGeometricRepresentationItem for IfcBooleanResult {}
impl IIfcBooleanResult for IfcBooleanResult {
    fn operator(&self) -> &IfcBooleanOperator {
        &self.operator
    }
    fn first_operand(&self) -> &EntityRef {
        &self.first_operand
    }
    fn second_operand(&self) -> &EntityRef {
        &self.second_operand
    }
}
impl IfcBooleanResult {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBooleanResult::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.operator = parameter.into(),
                1usize => entity.first_operand = parameter.into(),
                2usize => entity.second_operand = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryCondition {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcBoundaryEdgeCondition: IIfcBoundaryCondition {
    fn linear_stiffness_by_length_x(&self) -> &Option<IfcModulusOfLinearSubgradeReactionMeasure>;
    fn linear_stiffness_by_length_y(&self) -> &Option<IfcModulusOfLinearSubgradeReactionMeasure>;
    fn linear_stiffness_by_length_z(&self) -> &Option<IfcModulusOfLinearSubgradeReactionMeasure>;
    fn rotational_stiffness_by_length_x(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionMeasure>;
    fn rotational_stiffness_by_length_y(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionMeasure>;
    fn rotational_stiffness_by_length_z(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryEdgeCondition {
    name: Option<IfcLabel>,
    linear_stiffness_by_length_x: Option<IfcModulusOfLinearSubgradeReactionMeasure>,
    linear_stiffness_by_length_y: Option<IfcModulusOfLinearSubgradeReactionMeasure>,
    linear_stiffness_by_length_z: Option<IfcModulusOfLinearSubgradeReactionMeasure>,
    rotational_stiffness_by_length_x: Option<IfcModulusOfRotationalSubgradeReactionMeasure>,
    rotational_stiffness_by_length_y: Option<IfcModulusOfRotationalSubgradeReactionMeasure>,
    rotational_stiffness_by_length_z: Option<IfcModulusOfRotationalSubgradeReactionMeasure>,
}
impl IIfcBoundaryCondition for IfcBoundaryEdgeCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryEdgeCondition for IfcBoundaryEdgeCondition {
    fn linear_stiffness_by_length_x(&self) -> &Option<IfcModulusOfLinearSubgradeReactionMeasure> {
        &self.linear_stiffness_by_length_x
    }
    fn linear_stiffness_by_length_y(&self) -> &Option<IfcModulusOfLinearSubgradeReactionMeasure> {
        &self.linear_stiffness_by_length_y
    }
    fn linear_stiffness_by_length_z(&self) -> &Option<IfcModulusOfLinearSubgradeReactionMeasure> {
        &self.linear_stiffness_by_length_z
    }
    fn rotational_stiffness_by_length_x(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionMeasure> {
        &self.rotational_stiffness_by_length_x
    }
    fn rotational_stiffness_by_length_y(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionMeasure> {
        &self.rotational_stiffness_by_length_y
    }
    fn rotational_stiffness_by_length_z(&self) -> &Option<IfcModulusOfRotationalSubgradeReactionMeasure> {
        &self.rotational_stiffness_by_length_z
    }
}
impl IfcBoundaryEdgeCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryEdgeCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_stiffness_by_length_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_stiffness_by_length_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_stiffness_by_length_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_by_length_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_by_length_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_stiffness_by_length_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryFaceCondition: IIfcBoundaryCondition {
    fn linear_stiffness_by_area_x(&self) -> &Option<IfcModulusOfSubgradeReactionMeasure>;
    fn linear_stiffness_by_area_y(&self) -> &Option<IfcModulusOfSubgradeReactionMeasure>;
    fn linear_stiffness_by_area_z(&self) -> &Option<IfcModulusOfSubgradeReactionMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryFaceCondition {
    name: Option<IfcLabel>,
    linear_stiffness_by_area_x: Option<IfcModulusOfSubgradeReactionMeasure>,
    linear_stiffness_by_area_y: Option<IfcModulusOfSubgradeReactionMeasure>,
    linear_stiffness_by_area_z: Option<IfcModulusOfSubgradeReactionMeasure>,
}
impl IIfcBoundaryCondition for IfcBoundaryFaceCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryFaceCondition for IfcBoundaryFaceCondition {
    fn linear_stiffness_by_area_x(&self) -> &Option<IfcModulusOfSubgradeReactionMeasure> {
        &self.linear_stiffness_by_area_x
    }
    fn linear_stiffness_by_area_y(&self) -> &Option<IfcModulusOfSubgradeReactionMeasure> {
        &self.linear_stiffness_by_area_y
    }
    fn linear_stiffness_by_area_z(&self) -> &Option<IfcModulusOfSubgradeReactionMeasure> {
        &self.linear_stiffness_by_area_z
    }
}
impl IfcBoundaryFaceCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryFaceCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_stiffness_by_area_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_stiffness_by_area_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_stiffness_by_area_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryNodeCondition: IIfcBoundaryCondition {
    fn linear_stiffness_x(&self) -> &Option<IfcLinearStiffnessMeasure>;
    fn linear_stiffness_y(&self) -> &Option<IfcLinearStiffnessMeasure>;
    fn linear_stiffness_z(&self) -> &Option<IfcLinearStiffnessMeasure>;
    fn rotational_stiffness_x(&self) -> &Option<IfcRotationalStiffnessMeasure>;
    fn rotational_stiffness_y(&self) -> &Option<IfcRotationalStiffnessMeasure>;
    fn rotational_stiffness_z(&self) -> &Option<IfcRotationalStiffnessMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryNodeCondition {
    name: Option<IfcLabel>,
    linear_stiffness_x: Option<IfcLinearStiffnessMeasure>,
    linear_stiffness_y: Option<IfcLinearStiffnessMeasure>,
    linear_stiffness_z: Option<IfcLinearStiffnessMeasure>,
    rotational_stiffness_x: Option<IfcRotationalStiffnessMeasure>,
    rotational_stiffness_y: Option<IfcRotationalStiffnessMeasure>,
    rotational_stiffness_z: Option<IfcRotationalStiffnessMeasure>,
}
impl IIfcBoundaryCondition for IfcBoundaryNodeCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryNodeCondition for IfcBoundaryNodeCondition {
    fn linear_stiffness_x(&self) -> &Option<IfcLinearStiffnessMeasure> {
        &self.linear_stiffness_x
    }
    fn linear_stiffness_y(&self) -> &Option<IfcLinearStiffnessMeasure> {
        &self.linear_stiffness_y
    }
    fn linear_stiffness_z(&self) -> &Option<IfcLinearStiffnessMeasure> {
        &self.linear_stiffness_z
    }
    fn rotational_stiffness_x(&self) -> &Option<IfcRotationalStiffnessMeasure> {
        &self.rotational_stiffness_x
    }
    fn rotational_stiffness_y(&self) -> &Option<IfcRotationalStiffnessMeasure> {
        &self.rotational_stiffness_y
    }
    fn rotational_stiffness_z(&self) -> &Option<IfcRotationalStiffnessMeasure> {
        &self.rotational_stiffness_z
    }
}
impl IfcBoundaryNodeCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryNodeCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundaryNodeConditionWarping: IIfcBoundaryNodeCondition {
    fn warping_stiffness(&self) -> &Option<IfcWarpingMomentMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcBoundaryNodeConditionWarping {
    name: Option<IfcLabel>,
    linear_stiffness_x: Option<IfcLinearStiffnessMeasure>,
    linear_stiffness_y: Option<IfcLinearStiffnessMeasure>,
    linear_stiffness_z: Option<IfcLinearStiffnessMeasure>,
    rotational_stiffness_x: Option<IfcRotationalStiffnessMeasure>,
    rotational_stiffness_y: Option<IfcRotationalStiffnessMeasure>,
    rotational_stiffness_z: Option<IfcRotationalStiffnessMeasure>,
    warping_stiffness: Option<IfcWarpingMomentMeasure>,
}
impl IIfcBoundaryCondition for IfcBoundaryNodeConditionWarping {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcBoundaryNodeCondition for IfcBoundaryNodeConditionWarping {
    fn linear_stiffness_x(&self) -> &Option<IfcLinearStiffnessMeasure> {
        &self.linear_stiffness_x
    }
    fn linear_stiffness_y(&self) -> &Option<IfcLinearStiffnessMeasure> {
        &self.linear_stiffness_y
    }
    fn linear_stiffness_z(&self) -> &Option<IfcLinearStiffnessMeasure> {
        &self.linear_stiffness_z
    }
    fn rotational_stiffness_x(&self) -> &Option<IfcRotationalStiffnessMeasure> {
        &self.rotational_stiffness_x
    }
    fn rotational_stiffness_y(&self) -> &Option<IfcRotationalStiffnessMeasure> {
        &self.rotational_stiffness_y
    }
    fn rotational_stiffness_z(&self) -> &Option<IfcRotationalStiffnessMeasure> {
        &self.rotational_stiffness_z
    }
}
impl IIfcBoundaryNodeConditionWarping for IfcBoundaryNodeConditionWarping {
    fn warping_stiffness(&self) -> &Option<IfcWarpingMomentMeasure> {
        &self.warping_stiffness
    }
}
impl IfcBoundaryNodeConditionWarping {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundaryNodeConditionWarping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_stiffness_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_stiffness_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_stiffness_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.warping_stiffness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoundedCurve: IIfcCurve {}
pub trait IIfcBoundedSurface: IIfcSurface {}
#[derive(Default, Debug)]
pub struct IfcBoundedSurface {}
impl IIfcRepresentationItem for IfcBoundedSurface {}
impl IIfcGeometricRepresentationItem for IfcBoundedSurface {}
impl IIfcSurface for IfcBoundedSurface {}
impl IIfcBoundedSurface for IfcBoundedSurface {}
impl IfcBoundedSurface {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        IfcBoundedSurface::default()
    }
}
pub trait IIfcBoundingBox: IIfcGeometricRepresentationItem {
    fn corner(&self) -> &EntityRef;
    fn x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn y_dim(&self) -> &IfcPositiveLengthMeasure;
    fn z_dim(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcBoundingBox {
    corner: EntityRef,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    z_dim: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcBoundingBox {}
impl IIfcGeometricRepresentationItem for IfcBoundingBox {}
impl IIfcBoundingBox for IfcBoundingBox {
    fn corner(&self) -> &EntityRef {
        &self.corner
    }
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
    fn z_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.z_dim
    }
}
impl IfcBoundingBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoundingBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.corner = parameter.into(),
                1usize => entity.x_dim = parameter.into(),
                2usize => entity.y_dim = parameter.into(),
                3usize => entity.z_dim = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBoxedHalfSpace: IIfcHalfSpaceSolid {
    fn enclosure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcBoxedHalfSpace {
    base_surface: EntityRef,
    agreement_flag: bool,
    enclosure: EntityRef,
}
impl IIfcRepresentationItem for IfcBoxedHalfSpace {}
impl IIfcGeometricRepresentationItem for IfcBoxedHalfSpace {}
impl IIfcHalfSpaceSolid for IfcBoxedHalfSpace {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl IIfcBoxedHalfSpace for IfcBoxedHalfSpace {
    fn enclosure(&self) -> &EntityRef {
        &self.enclosure
    }
}
impl IfcBoxedHalfSpace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBoxedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.base_surface = parameter.into(),
                1usize => entity.agreement_flag = parameter.into(),
                2usize => entity.enclosure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuilding: IIfcSpatialStructureElement {
    fn elevation_of_ref_height(&self) -> &Option<IfcLengthMeasure>;
    fn elevation_of_terrain(&self) -> &Option<IfcLengthMeasure>;
    fn building_address(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcBuilding {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: IfcElementCompositionEnum,
    elevation_of_ref_height: Option<IfcLengthMeasure>,
    elevation_of_terrain: Option<IfcLengthMeasure>,
    building_address: Option<EntityRef>,
}
impl IIfcRoot for IfcBuilding {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuilding {}
impl IIfcObject for IfcBuilding {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuilding {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialStructureElement for IfcBuilding {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn composition_type(&self) -> &IfcElementCompositionEnum {
        &self.composition_type
    }
}
impl IIfcBuilding for IfcBuilding {
    fn elevation_of_ref_height(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation_of_ref_height
    }
    fn elevation_of_terrain(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation_of_terrain
    }
    fn building_address(&self) -> &Option<EntityRef> {
        &self.building_address
    }
}
impl IfcBuilding {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuilding::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.composition_type = parameter.into(),
                9usize => {
                    entity.elevation_of_ref_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.elevation_of_terrain = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.building_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElement: IIfcElement {}
pub trait IIfcBuildingElementComponent: IIfcBuildingElement {}
pub trait IIfcBuildingElementPart: IIfcBuildingElementComponent {}
#[derive(Default, Debug)]
pub struct IfcBuildingElementPart {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcBuildingElementPart {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementPart {}
impl IIfcObject for IfcBuildingElementPart {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuildingElementPart {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBuildingElementPart {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcBuildingElementPart {}
impl IIfcBuildingElementComponent for IfcBuildingElementPart {}
impl IIfcBuildingElementPart for IfcBuildingElementPart {}
impl IfcBuildingElementPart {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementPart::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementProxy: IIfcBuildingElement {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum>;
}
#[derive(Default, Debug)]
pub struct IfcBuildingElementProxy {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    composition_type: Option<IfcElementCompositionEnum>,
}
impl IIfcRoot for IfcBuildingElementProxy {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementProxy {}
impl IIfcObject for IfcBuildingElementProxy {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuildingElementProxy {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcBuildingElementProxy {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcBuildingElementProxy {}
impl IIfcBuildingElementProxy for IfcBuildingElementProxy {
    fn composition_type(&self) -> &Option<IfcElementCompositionEnum> {
        &self.composition_type
    }
}
impl IfcBuildingElementProxy {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementProxy::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.composition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementProxyType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcBuildingElementProxyTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcBuildingElementProxyType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcBuildingElementProxyTypeEnum,
}
impl IIfcRoot for IfcBuildingElementProxyType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingElementProxyType {}
impl IIfcTypeObject for IfcBuildingElementProxyType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcBuildingElementProxyType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcBuildingElementProxyType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcBuildingElementProxyType {}
impl IIfcBuildingElementProxyType for IfcBuildingElementProxyType {
    fn predefined_type(&self) -> &IfcBuildingElementProxyTypeEnum {
        &self.predefined_type
    }
}
impl IfcBuildingElementProxyType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingElementProxyType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcBuildingElementType: IIfcElementType {}
pub trait IIfcBuildingStorey: IIfcSpatialStructureElement {
    fn elevation(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcBuildingStorey {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: IfcElementCompositionEnum,
    elevation: Option<IfcLengthMeasure>,
}
impl IIfcRoot for IfcBuildingStorey {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcBuildingStorey {}
impl IIfcObject for IfcBuildingStorey {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcBuildingStorey {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialStructureElement for IfcBuildingStorey {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn composition_type(&self) -> &IfcElementCompositionEnum {
        &self.composition_type
    }
}
impl IIfcBuildingStorey for IfcBuildingStorey {
    fn elevation(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation
    }
}
impl IfcBuildingStorey {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcBuildingStorey::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.composition_type = parameter.into(),
                9usize => {
                    entity.elevation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn width(&self) -> &IfcPositiveLengthMeasure;
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn girth(&self) -> &IfcPositiveLengthMeasure;
    fn internal_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn centre_of_gravity_in_x(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcCShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    depth: IfcPositiveLengthMeasure,
    width: IfcPositiveLengthMeasure,
    wall_thickness: IfcPositiveLengthMeasure,
    girth: IfcPositiveLengthMeasure,
    internal_fillet_radius: Option<IfcPositiveLengthMeasure>,
    centre_of_gravity_in_x: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcCShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCShapeProfileDef for IfcCShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn width(&self) -> &IfcPositiveLengthMeasure {
        &self.width
    }
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.wall_thickness
    }
    fn girth(&self) -> &IfcPositiveLengthMeasure {
        &self.girth
    }
    fn internal_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.internal_fillet_radius
    }
    fn centre_of_gravity_in_x(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_x
    }
}
impl IfcCShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.width = parameter.into(),
                5usize => entity.wall_thickness = parameter.into(),
                6usize => entity.girth = parameter.into(),
                7usize => {
                    entity.internal_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.centre_of_gravity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableCarrierFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcCableCarrierFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableCarrierFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableCarrierFittingTypeEnum,
}
impl IIfcRoot for IfcCableCarrierFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableCarrierFittingType {}
impl IIfcTypeObject for IfcCableCarrierFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableCarrierFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableCarrierFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableCarrierFittingType {}
impl IIfcDistributionFlowElementType for IfcCableCarrierFittingType {}
impl IIfcFlowFittingType for IfcCableCarrierFittingType {}
impl IIfcCableCarrierFittingType for IfcCableCarrierFittingType {
    fn predefined_type(&self) -> &IfcCableCarrierFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableCarrierFittingType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableCarrierSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcCableCarrierSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableCarrierSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableCarrierSegmentTypeEnum,
}
impl IIfcRoot for IfcCableCarrierSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableCarrierSegmentType {}
impl IIfcTypeObject for IfcCableCarrierSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableCarrierSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableCarrierSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableCarrierSegmentType {}
impl IIfcDistributionFlowElementType for IfcCableCarrierSegmentType {}
impl IIfcFlowSegmentType for IfcCableCarrierSegmentType {}
impl IIfcCableCarrierSegmentType for IfcCableCarrierSegmentType {
    fn predefined_type(&self) -> &IfcCableCarrierSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableCarrierSegmentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableCarrierSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCableSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcCableSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCableSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCableSegmentTypeEnum,
}
impl IIfcRoot for IfcCableSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCableSegmentType {}
impl IIfcTypeObject for IfcCableSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCableSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCableSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCableSegmentType {}
impl IIfcDistributionFlowElementType for IfcCableSegmentType {}
impl IIfcFlowSegmentType for IfcCableSegmentType {}
impl IIfcCableSegmentType for IfcCableSegmentType {
    fn predefined_type(&self) -> &IfcCableSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcCableSegmentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCableSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCalendarDate {
    fn day_component(&self) -> &IfcDayInMonthNumber;
    fn month_component(&self) -> &IfcMonthInYearNumber;
    fn year_component(&self) -> &IfcYearNumber;
}
#[derive(Default, Debug)]
pub struct IfcCalendarDate {
    day_component: IfcDayInMonthNumber,
    month_component: IfcMonthInYearNumber,
    year_component: IfcYearNumber,
}
impl IIfcCalendarDate for IfcCalendarDate {
    fn day_component(&self) -> &IfcDayInMonthNumber {
        &self.day_component
    }
    fn month_component(&self) -> &IfcMonthInYearNumber {
        &self.month_component
    }
    fn year_component(&self) -> &IfcYearNumber {
        &self.year_component
    }
}
impl IfcCalendarDate {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCalendarDate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.day_component = parameter.into(),
                1usize => entity.month_component = parameter.into(),
                2usize => entity.year_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianPoint: IIfcPoint {
    fn coordinates(&self) -> &Vec<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianPoint {
    coordinates: Vec<IfcLengthMeasure>,
}
impl IIfcRepresentationItem for IfcCartesianPoint {}
impl IIfcGeometricRepresentationItem for IfcCartesianPoint {}
impl IIfcPoint for IfcCartesianPoint {}
impl IIfcCartesianPoint for IfcCartesianPoint {
    fn coordinates(&self) -> &Vec<IfcLengthMeasure> {
        &self.coordinates
    }
}
impl IfcCartesianPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator: IIfcGeometricRepresentationItem {
    fn axis1(&self) -> &Option<EntityRef>;
    fn axis2(&self) -> &Option<EntityRef>;
    fn local_origin(&self) -> &EntityRef;
    fn scale(&self) -> Option<Real>;
}
pub trait IIfcCartesianTransformationOperator2D: IIfcCartesianTransformationOperator {}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator2D {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator2D {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator2D {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator2D {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl IIfcCartesianTransformationOperator2D for IfcCartesianTransformationOperator2D {}
impl IfcCartesianTransformationOperator2D {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator2DnonUniform: IIfcCartesianTransformationOperator2D {
    fn scale2(&self) -> Option<Real>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator2DnonUniform {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
    scale2: Option<Real>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator2DnonUniform {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator2DnonUniform {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator2DnonUniform {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl IIfcCartesianTransformationOperator2D for IfcCartesianTransformationOperator2DnonUniform {}
impl IIfcCartesianTransformationOperator2DnonUniform for IfcCartesianTransformationOperator2DnonUniform {
    fn scale2(&self) -> Option<Real> {
        self.scale2
    }
}
impl IfcCartesianTransformationOperator2DnonUniform {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator2DnonUniform::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.scale2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator3D: IIfcCartesianTransformationOperator {
    fn axis3(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator3D {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
    axis3: Option<EntityRef>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator3D {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator3D {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator3D {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl IIfcCartesianTransformationOperator3D for IfcCartesianTransformationOperator3D {
    fn axis3(&self) -> &Option<EntityRef> {
        &self.axis3
    }
}
impl IfcCartesianTransformationOperator3D {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCartesianTransformationOperator3DnonUniform: IIfcCartesianTransformationOperator3D {
    fn scale2(&self) -> Option<Real>;
    fn scale3(&self) -> Option<Real>;
}
#[derive(Default, Debug)]
pub struct IfcCartesianTransformationOperator3DnonUniform {
    axis1: Option<EntityRef>,
    axis2: Option<EntityRef>,
    local_origin: EntityRef,
    scale: Option<Real>,
    axis3: Option<EntityRef>,
    scale2: Option<Real>,
    scale3: Option<Real>,
}
impl IIfcRepresentationItem for IfcCartesianTransformationOperator3DnonUniform {}
impl IIfcGeometricRepresentationItem for IfcCartesianTransformationOperator3DnonUniform {}
impl IIfcCartesianTransformationOperator for IfcCartesianTransformationOperator3DnonUniform {
    fn axis1(&self) -> &Option<EntityRef> {
        &self.axis1
    }
    fn axis2(&self) -> &Option<EntityRef> {
        &self.axis2
    }
    fn local_origin(&self) -> &EntityRef {
        &self.local_origin
    }
    fn scale(&self) -> Option<Real> {
        self.scale
    }
}
impl IIfcCartesianTransformationOperator3D for IfcCartesianTransformationOperator3DnonUniform {
    fn axis3(&self) -> &Option<EntityRef> {
        &self.axis3
    }
}
impl IIfcCartesianTransformationOperator3DnonUniform for IfcCartesianTransformationOperator3DnonUniform {
    fn scale2(&self) -> Option<Real> {
        self.scale2
    }
    fn scale3(&self) -> Option<Real> {
        self.scale3
    }
}
impl IfcCartesianTransformationOperator3DnonUniform {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCartesianTransformationOperator3DnonUniform::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis1 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.axis2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.local_origin = parameter.into(),
                3usize => {
                    entity.scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.axis3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.scale2 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.scale3 = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCenterLineProfileDef: IIfcArbitraryOpenProfileDef {
    fn thickness(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCenterLineProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    curve: EntityRef,
    thickness: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcCenterLineProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcArbitraryOpenProfileDef for IfcCenterLineProfileDef {
    fn curve(&self) -> &EntityRef {
        &self.curve
    }
}
impl IIfcCenterLineProfileDef for IfcCenterLineProfileDef {
    fn thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.thickness
    }
}
impl IfcCenterLineProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCenterLineProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.curve = parameter.into(),
                3usize => entity.thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcChamferEdgeFeature: IIfcEdgeFeature {
    fn width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn height(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcChamferEdgeFeature {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    feature_length: Option<IfcPositiveLengthMeasure>,
    width: Option<IfcPositiveLengthMeasure>,
    height: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcChamferEdgeFeature {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcChamferEdgeFeature {}
impl IIfcObject for IfcChamferEdgeFeature {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcChamferEdgeFeature {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcChamferEdgeFeature {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcChamferEdgeFeature {}
impl IIfcFeatureElementSubtraction for IfcChamferEdgeFeature {}
impl IIfcEdgeFeature for IfcChamferEdgeFeature {
    fn feature_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.feature_length
    }
}
impl IIfcChamferEdgeFeature for IfcChamferEdgeFeature {
    fn width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.width
    }
    fn height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.height
    }
}
impl IfcChamferEdgeFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChamferEdgeFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.feature_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcChillerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcChillerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcChillerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcChillerTypeEnum,
}
impl IIfcRoot for IfcChillerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcChillerType {}
impl IIfcTypeObject for IfcChillerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcChillerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcChillerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcChillerType {}
impl IIfcDistributionFlowElementType for IfcChillerType {}
impl IIfcEnergyConversionDeviceType for IfcChillerType {}
impl IIfcChillerType for IfcChillerType {
    fn predefined_type(&self) -> &IfcChillerTypeEnum {
        &self.predefined_type
    }
}
impl IfcChillerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcChillerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCircle: IIfcConic {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCircle {
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcCircle {}
impl IIfcGeometricRepresentationItem for IfcCircle {}
impl IIfcCurve for IfcCircle {}
impl IIfcConic for IfcCircle {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCircle for IfcCircle {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcCircle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCircleHollowProfileDef: IIfcCircleProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCircleHollowProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
    wall_thickness: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcCircleHollowProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCircleHollowProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCircleProfileDef for IfcCircleHollowProfileDef {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IIfcCircleHollowProfileDef for IfcCircleHollowProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.wall_thickness
    }
}
impl IfcCircleHollowProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircleHollowProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.radius = parameter.into(),
                4usize => entity.wall_thickness = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCircleProfileDef: IIfcParameterizedProfileDef {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCircleProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcCircleProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCircleProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCircleProfileDef for IfcCircleProfileDef {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcCircleProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCircleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassification {
    fn source(&self) -> &IfcLabel;
    fn edition(&self) -> &IfcLabel;
    fn edition_date(&self) -> &Option<EntityRef>;
    fn name(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcClassification {
    source: IfcLabel,
    edition: IfcLabel,
    edition_date: Option<EntityRef>,
    name: IfcLabel,
}
impl IIfcClassification for IfcClassification {
    fn source(&self) -> &IfcLabel {
        &self.source
    }
    fn edition(&self) -> &IfcLabel {
        &self.edition
    }
    fn edition_date(&self) -> &Option<EntityRef> {
        &self.edition_date
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IfcClassification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.source = parameter.into(),
                1usize => entity.edition = parameter.into(),
                2usize => {
                    entity.edition_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassificationItem {
    fn notation(&self) -> &EntityRef;
    fn item_of(&self) -> &Option<EntityRef>;
    fn title(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcClassificationItem {
    notation: EntityRef,
    item_of: Option<EntityRef>,
    title: IfcLabel,
}
impl IIfcClassificationItem for IfcClassificationItem {
    fn notation(&self) -> &EntityRef {
        &self.notation
    }
    fn item_of(&self) -> &Option<EntityRef> {
        &self.item_of
    }
    fn title(&self) -> &IfcLabel {
        &self.title
    }
}
impl IfcClassificationItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.notation = parameter.into(),
                1usize => {
                    entity.item_of = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.title = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassificationItemRelationship {
    fn relating_item(&self) -> &EntityRef;
    fn related_items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcClassificationItemRelationship {
    relating_item: EntityRef,
    related_items: HashSet<EntityRef>,
}
impl IIfcClassificationItemRelationship for IfcClassificationItemRelationship {
    fn relating_item(&self) -> &EntityRef {
        &self.relating_item
    }
    fn related_items(&self) -> &HashSet<EntityRef> {
        &self.related_items
    }
}
impl IfcClassificationItemRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationItemRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_item = parameter.into(),
                1usize => entity.related_items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassificationNotation {
    fn notation_facets(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcClassificationNotation {
    notation_facets: HashSet<EntityRef>,
}
impl IIfcClassificationNotation for IfcClassificationNotation {
    fn notation_facets(&self) -> &HashSet<EntityRef> {
        &self.notation_facets
    }
}
impl IfcClassificationNotation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationNotation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.notation_facets = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassificationNotationFacet {
    fn notation_value(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcClassificationNotationFacet {
    notation_value: IfcLabel,
}
impl IIfcClassificationNotationFacet for IfcClassificationNotationFacet {
    fn notation_value(&self) -> &IfcLabel {
        &self.notation_value
    }
}
impl IfcClassificationNotationFacet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationNotationFacet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.notation_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClassificationReference: IIfcExternalReference {
    fn referenced_source(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcClassificationReference {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
    referenced_source: Option<EntityRef>,
}
impl IIfcExternalReference for IfcClassificationReference {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcClassificationReference for IfcClassificationReference {
    fn referenced_source(&self) -> &Option<EntityRef> {
        &self.referenced_source
    }
}
impl IfcClassificationReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClassificationReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.referenced_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcClosedShell: IIfcConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct IfcClosedShell {
    cfs_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcClosedShell {}
impl IIfcTopologicalRepresentationItem for IfcClosedShell {}
impl IIfcConnectedFaceSet for IfcClosedShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IIfcClosedShell for IfcClosedShell {}
impl IfcClosedShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcClosedShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoilType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCoilTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCoilType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCoilTypeEnum,
}
impl IIfcRoot for IfcCoilType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoilType {}
impl IIfcTypeObject for IfcCoilType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCoilType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCoilType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCoilType {}
impl IIfcDistributionFlowElementType for IfcCoilType {}
impl IIfcEnergyConversionDeviceType for IfcCoilType {}
impl IIfcCoilType for IfcCoilType {
    fn predefined_type(&self) -> &IfcCoilTypeEnum {
        &self.predefined_type
    }
}
impl IfcCoilType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoilType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColourRgb: IIfcColourSpecification {
    fn red(&self) -> &IfcNormalisedRatioMeasure;
    fn green(&self) -> &IfcNormalisedRatioMeasure;
    fn blue(&self) -> &IfcNormalisedRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcColourRgb {
    name: Option<IfcLabel>,
    red: IfcNormalisedRatioMeasure,
    green: IfcNormalisedRatioMeasure,
    blue: IfcNormalisedRatioMeasure,
}
impl IIfcColourSpecification for IfcColourRgb {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcColourRgb for IfcColourRgb {
    fn red(&self) -> &IfcNormalisedRatioMeasure {
        &self.red
    }
    fn green(&self) -> &IfcNormalisedRatioMeasure {
        &self.green
    }
    fn blue(&self) -> &IfcNormalisedRatioMeasure {
        &self.blue
    }
}
impl IfcColourRgb {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColourRgb::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.red = parameter.into(),
                2usize => entity.green = parameter.into(),
                3usize => entity.blue = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColourSpecification {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcColumn: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcColumn {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcColumn {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcColumn {}
impl IIfcObject for IfcColumn {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcColumn {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcColumn {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcColumn {}
impl IIfcColumn for IfcColumn {}
impl IfcColumn {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumn::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcColumnType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcColumnTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcColumnType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcColumnTypeEnum,
}
impl IIfcRoot for IfcColumnType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcColumnType {}
impl IIfcTypeObject for IfcColumnType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcColumnType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcColumnType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcColumnType {}
impl IIfcColumnType for IfcColumnType {
    fn predefined_type(&self) -> &IfcColumnTypeEnum {
        &self.predefined_type
    }
}
impl IfcColumnType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcColumnType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcComplexProperty: IIfcProperty {
    fn usage_name(&self) -> &IfcIdentifier;
    fn has_properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcComplexProperty {
    name: IfcIdentifier,
    description: Option<IfcText>,
    usage_name: IfcIdentifier,
    has_properties: HashSet<EntityRef>,
}
impl IIfcProperty for IfcComplexProperty {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcComplexProperty for IfcComplexProperty {
    fn usage_name(&self) -> &IfcIdentifier {
        &self.usage_name
    }
    fn has_properties(&self) -> &HashSet<EntityRef> {
        &self.has_properties
    }
}
impl IfcComplexProperty {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcComplexProperty::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.usage_name = parameter.into(),
                3usize => entity.has_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeCurve: IIfcBoundedCurve {
    fn segments(&self) -> &Vec<EntityRef>;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct IfcCompositeCurve {
    segments: Vec<EntityRef>,
    self_intersect: Option<bool>,
}
impl IIfcRepresentationItem for IfcCompositeCurve {}
impl IIfcGeometricRepresentationItem for IfcCompositeCurve {}
impl IIfcCurve for IfcCompositeCurve {}
impl IIfcBoundedCurve for IfcCompositeCurve {}
impl IIfcCompositeCurve for IfcCompositeCurve {
    fn segments(&self) -> &Vec<EntityRef> {
        &self.segments
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IfcCompositeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.segments = parameter.into(),
                1usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeCurveSegment: IIfcGeometricRepresentationItem {
    fn transition(&self) -> &IfcTransitionCode;
    fn same_sense(&self) -> bool;
    fn parent_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcCompositeCurveSegment {
    transition: IfcTransitionCode,
    same_sense: bool,
    parent_curve: EntityRef,
}
impl IIfcRepresentationItem for IfcCompositeCurveSegment {}
impl IIfcGeometricRepresentationItem for IfcCompositeCurveSegment {}
impl IIfcCompositeCurveSegment for IfcCompositeCurveSegment {
    fn transition(&self) -> &IfcTransitionCode {
        &self.transition
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
    fn parent_curve(&self) -> &EntityRef {
        &self.parent_curve
    }
}
impl IfcCompositeCurveSegment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeCurveSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.transition = parameter.into(),
                1usize => entity.same_sense = parameter.into(),
                2usize => entity.parent_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompositeProfileDef: IIfcProfileDef {
    fn profiles(&self) -> &HashSet<EntityRef>;
    fn label(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcCompositeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    profiles: HashSet<EntityRef>,
    label: Option<IfcLabel>,
}
impl IIfcProfileDef for IfcCompositeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcCompositeProfileDef for IfcCompositeProfileDef {
    fn profiles(&self) -> &HashSet<EntityRef> {
        &self.profiles
    }
    fn label(&self) -> &Option<IfcLabel> {
        &self.label
    }
}
impl IfcCompositeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompositeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.profiles = parameter.into(),
                3usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCompressorType: IIfcFlowMovingDeviceType {
    fn predefined_type(&self) -> &IfcCompressorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCompressorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCompressorTypeEnum,
}
impl IIfcRoot for IfcCompressorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCompressorType {}
impl IIfcTypeObject for IfcCompressorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCompressorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCompressorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCompressorType {}
impl IIfcDistributionFlowElementType for IfcCompressorType {}
impl IIfcFlowMovingDeviceType for IfcCompressorType {}
impl IIfcCompressorType for IfcCompressorType {
    fn predefined_type(&self) -> &IfcCompressorTypeEnum {
        &self.predefined_type
    }
}
impl IfcCompressorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCompressorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCondenserType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCondenserTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCondenserType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCondenserTypeEnum,
}
impl IIfcRoot for IfcCondenserType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCondenserType {}
impl IIfcTypeObject for IfcCondenserType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCondenserType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCondenserType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCondenserType {}
impl IIfcDistributionFlowElementType for IfcCondenserType {}
impl IIfcEnergyConversionDeviceType for IfcCondenserType {}
impl IIfcCondenserType for IfcCondenserType {
    fn predefined_type(&self) -> &IfcCondenserTypeEnum {
        &self.predefined_type
    }
}
impl IfcCondenserType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCondenserType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCondition: IIfcGroup {}
#[derive(Default, Debug)]
pub struct IfcCondition {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcCondition {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCondition {}
impl IIfcObject for IfcCondition {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcCondition {}
impl IIfcCondition for IfcCondition {}
impl IfcCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConditionCriterion: IIfcControl {
    fn criterion(&self) -> &IfcConditionCriterionSelect;
    fn criterion_date_time(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcConditionCriterion {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    criterion: IfcConditionCriterionSelect,
    criterion_date_time: EntityRef,
}
impl IIfcRoot for IfcConditionCriterion {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConditionCriterion {}
impl IIfcObject for IfcConditionCriterion {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcConditionCriterion {}
impl IIfcConditionCriterion for IfcConditionCriterion {
    fn criterion(&self) -> &IfcConditionCriterionSelect {
        &self.criterion
    }
    fn criterion_date_time(&self) -> &EntityRef {
        &self.criterion_date_time
    }
}
impl IfcConditionCriterion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConditionCriterion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.criterion = parameter.into(),
                6usize => entity.criterion_date_time = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConic: IIfcCurve {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcConnectedFaceSet: IIfcTopologicalRepresentationItem {
    fn cfs_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectedFaceSet {
    cfs_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcConnectedFaceSet {}
impl IIfcTopologicalRepresentationItem for IfcConnectedFaceSet {}
impl IIfcConnectedFaceSet for IfcConnectedFaceSet {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IfcConnectedFaceSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectedFaceSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionCurveGeometry: IIfcConnectionGeometry {
    fn curve_on_relating_element(&self) -> &EntityRef;
    fn curve_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionCurveGeometry {
    curve_on_relating_element: EntityRef,
    curve_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionCurveGeometry {}
impl IIfcConnectionCurveGeometry for IfcConnectionCurveGeometry {
    fn curve_on_relating_element(&self) -> &EntityRef {
        &self.curve_on_relating_element
    }
    fn curve_on_related_element(&self) -> &Option<EntityRef> {
        &self.curve_on_related_element
    }
}
impl IfcConnectionCurveGeometry {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionCurveGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.curve_on_relating_element = parameter.into(),
                1usize => {
                    entity.curve_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionGeometry {}
pub trait IIfcConnectionPointEccentricity: IIfcConnectionPointGeometry {
    fn eccentricity_in_x(&self) -> &Option<IfcLengthMeasure>;
    fn eccentricity_in_y(&self) -> &Option<IfcLengthMeasure>;
    fn eccentricity_in_z(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionPointEccentricity {
    point_on_relating_element: EntityRef,
    point_on_related_element: Option<EntityRef>,
    eccentricity_in_x: Option<IfcLengthMeasure>,
    eccentricity_in_y: Option<IfcLengthMeasure>,
    eccentricity_in_z: Option<IfcLengthMeasure>,
}
impl IIfcConnectionGeometry for IfcConnectionPointEccentricity {}
impl IIfcConnectionPointGeometry for IfcConnectionPointEccentricity {
    fn point_on_relating_element(&self) -> &EntityRef {
        &self.point_on_relating_element
    }
    fn point_on_related_element(&self) -> &Option<EntityRef> {
        &self.point_on_related_element
    }
}
impl IIfcConnectionPointEccentricity for IfcConnectionPointEccentricity {
    fn eccentricity_in_x(&self) -> &Option<IfcLengthMeasure> {
        &self.eccentricity_in_x
    }
    fn eccentricity_in_y(&self) -> &Option<IfcLengthMeasure> {
        &self.eccentricity_in_y
    }
    fn eccentricity_in_z(&self) -> &Option<IfcLengthMeasure> {
        &self.eccentricity_in_z
    }
}
impl IfcConnectionPointEccentricity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionPointEccentricity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.point_on_relating_element = parameter.into(),
                1usize => {
                    entity.point_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.eccentricity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.eccentricity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.eccentricity_in_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionPointGeometry: IIfcConnectionGeometry {
    fn point_on_relating_element(&self) -> &EntityRef;
    fn point_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionPointGeometry {
    point_on_relating_element: EntityRef,
    point_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionPointGeometry {}
impl IIfcConnectionPointGeometry for IfcConnectionPointGeometry {
    fn point_on_relating_element(&self) -> &EntityRef {
        &self.point_on_relating_element
    }
    fn point_on_related_element(&self) -> &Option<EntityRef> {
        &self.point_on_related_element
    }
}
impl IfcConnectionPointGeometry {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionPointGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.point_on_relating_element = parameter.into(),
                1usize => {
                    entity.point_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionPortGeometry: IIfcConnectionGeometry {
    fn location_at_relating_element(&self) -> &EntityRef;
    fn location_at_related_element(&self) -> &Option<EntityRef>;
    fn profile_of_port(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcConnectionPortGeometry {
    location_at_relating_element: EntityRef,
    location_at_related_element: Option<EntityRef>,
    profile_of_port: EntityRef,
}
impl IIfcConnectionGeometry for IfcConnectionPortGeometry {}
impl IIfcConnectionPortGeometry for IfcConnectionPortGeometry {
    fn location_at_relating_element(&self) -> &EntityRef {
        &self.location_at_relating_element
    }
    fn location_at_related_element(&self) -> &Option<EntityRef> {
        &self.location_at_related_element
    }
    fn profile_of_port(&self) -> &EntityRef {
        &self.profile_of_port
    }
}
impl IfcConnectionPortGeometry {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionPortGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.location_at_relating_element = parameter.into(),
                1usize => {
                    entity.location_at_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.profile_of_port = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConnectionSurfaceGeometry: IIfcConnectionGeometry {
    fn surface_on_relating_element(&self) -> &EntityRef;
    fn surface_on_related_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConnectionSurfaceGeometry {
    surface_on_relating_element: EntityRef,
    surface_on_related_element: Option<EntityRef>,
}
impl IIfcConnectionGeometry for IfcConnectionSurfaceGeometry {}
impl IIfcConnectionSurfaceGeometry for IfcConnectionSurfaceGeometry {
    fn surface_on_relating_element(&self) -> &EntityRef {
        &self.surface_on_relating_element
    }
    fn surface_on_related_element(&self) -> &Option<EntityRef> {
        &self.surface_on_related_element
    }
}
impl IfcConnectionSurfaceGeometry {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConnectionSurfaceGeometry::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.surface_on_relating_element = parameter.into(),
                1usize => {
                    entity.surface_on_related_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstraint {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn constraint_grade(&self) -> &IfcConstraintEnum;
    fn constraint_source(&self) -> &Option<IfcLabel>;
    fn creating_actor(&self) -> &Option<EntityRef>;
    fn creation_time(&self) -> &Option<EntityRef>;
    fn user_defined_grade(&self) -> &Option<IfcLabel>;
}
pub trait IIfcConstraintAggregationRelationship {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn relating_constraint(&self) -> &EntityRef;
    fn related_constraints(&self) -> &Vec<EntityRef>;
    fn logical_aggregator(&self) -> &IfcLogicalOperatorEnum;
}
#[derive(Default, Debug)]
pub struct IfcConstraintAggregationRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_constraint: EntityRef,
    related_constraints: Vec<EntityRef>,
    logical_aggregator: IfcLogicalOperatorEnum,
}
impl IIfcConstraintAggregationRelationship for IfcConstraintAggregationRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn relating_constraint(&self) -> &EntityRef {
        &self.relating_constraint
    }
    fn related_constraints(&self) -> &Vec<EntityRef> {
        &self.related_constraints
    }
    fn logical_aggregator(&self) -> &IfcLogicalOperatorEnum {
        &self.logical_aggregator
    }
}
impl IfcConstraintAggregationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstraintAggregationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_constraint = parameter.into(),
                3usize => entity.related_constraints = parameter.into(),
                4usize => entity.logical_aggregator = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstraintClassificationRelationship {
    fn classified_constraint(&self) -> &EntityRef;
    fn related_classifications(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConstraintClassificationRelationship {
    classified_constraint: EntityRef,
    related_classifications: HashSet<EntityRef>,
}
impl IIfcConstraintClassificationRelationship for IfcConstraintClassificationRelationship {
    fn classified_constraint(&self) -> &EntityRef {
        &self.classified_constraint
    }
    fn related_classifications(&self) -> &HashSet<EntityRef> {
        &self.related_classifications
    }
}
impl IfcConstraintClassificationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstraintClassificationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.classified_constraint = parameter.into(),
                1usize => entity.related_classifications = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstraintRelationship {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn relating_constraint(&self) -> &EntityRef;
    fn related_constraints(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcConstraintRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_constraint: EntityRef,
    related_constraints: HashSet<EntityRef>,
}
impl IIfcConstraintRelationship for IfcConstraintRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn relating_constraint(&self) -> &EntityRef {
        &self.relating_constraint
    }
    fn related_constraints(&self) -> &HashSet<EntityRef> {
        &self.related_constraints
    }
}
impl IfcConstraintRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstraintRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_constraint = parameter.into(),
                3usize => entity.related_constraints = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionEquipmentResource: IIfcConstructionResource {}
#[derive(Default, Debug)]
pub struct IfcConstructionEquipmentResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    resource_identifier: Option<IfcIdentifier>,
    resource_group: Option<IfcLabel>,
    resource_consumption: Option<IfcResourceConsumptionEnum>,
    base_quantity: Option<EntityRef>,
}
impl IIfcRoot for IfcConstructionEquipmentResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionEquipmentResource {}
impl IIfcObject for IfcConstructionEquipmentResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcConstructionEquipmentResource {}
impl IIfcConstructionResource for IfcConstructionEquipmentResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier> {
        &self.resource_identifier
    }
    fn resource_group(&self) -> &Option<IfcLabel> {
        &self.resource_group
    }
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum> {
        &self.resource_consumption
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionEquipmentResource for IfcConstructionEquipmentResource {}
impl IfcConstructionEquipmentResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionEquipmentResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.resource_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.resource_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.resource_consumption = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionMaterialResource: IIfcConstructionResource {
    fn suppliers(&self) -> &Option<HashSet<EntityRef>>;
    fn usage_ratio(&self) -> &Option<IfcRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcConstructionMaterialResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    resource_identifier: Option<IfcIdentifier>,
    resource_group: Option<IfcLabel>,
    resource_consumption: Option<IfcResourceConsumptionEnum>,
    base_quantity: Option<EntityRef>,
    suppliers: Option<HashSet<EntityRef>>,
    usage_ratio: Option<IfcRatioMeasure>,
}
impl IIfcRoot for IfcConstructionMaterialResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionMaterialResource {}
impl IIfcObject for IfcConstructionMaterialResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcConstructionMaterialResource {}
impl IIfcConstructionResource for IfcConstructionMaterialResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier> {
        &self.resource_identifier
    }
    fn resource_group(&self) -> &Option<IfcLabel> {
        &self.resource_group
    }
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum> {
        &self.resource_consumption
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionMaterialResource for IfcConstructionMaterialResource {
    fn suppliers(&self) -> &Option<HashSet<EntityRef>> {
        &self.suppliers
    }
    fn usage_ratio(&self) -> &Option<IfcRatioMeasure> {
        &self.usage_ratio
    }
}
impl IfcConstructionMaterialResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionMaterialResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.resource_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.resource_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.resource_consumption = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.suppliers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.usage_ratio = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionProductResource: IIfcConstructionResource {}
#[derive(Default, Debug)]
pub struct IfcConstructionProductResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    resource_identifier: Option<IfcIdentifier>,
    resource_group: Option<IfcLabel>,
    resource_consumption: Option<IfcResourceConsumptionEnum>,
    base_quantity: Option<EntityRef>,
}
impl IIfcRoot for IfcConstructionProductResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcConstructionProductResource {}
impl IIfcObject for IfcConstructionProductResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcConstructionProductResource {}
impl IIfcConstructionResource for IfcConstructionProductResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier> {
        &self.resource_identifier
    }
    fn resource_group(&self) -> &Option<IfcLabel> {
        &self.resource_group
    }
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum> {
        &self.resource_consumption
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcConstructionProductResource for IfcConstructionProductResource {}
impl IfcConstructionProductResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConstructionProductResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.resource_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.resource_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.resource_consumption = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConstructionResource: IIfcResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier>;
    fn resource_group(&self) -> &Option<IfcLabel>;
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum>;
    fn base_quantity(&self) -> &Option<EntityRef>;
}
pub trait IIfcContextDependentUnit: IIfcNamedUnit {
    fn name(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcContextDependentUnit {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    name: IfcLabel,
}
impl IIfcNamedUnit for IfcContextDependentUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcContextDependentUnit for IfcContextDependentUnit {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IfcContextDependentUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcContextDependentUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcControl: IIfcObject {}
pub trait IIfcControllerType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcControllerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcControllerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcControllerTypeEnum,
}
impl IIfcRoot for IfcControllerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcControllerType {}
impl IIfcTypeObject for IfcControllerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcControllerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcControllerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcControllerType {}
impl IIfcDistributionControlElementType for IfcControllerType {}
impl IIfcControllerType for IfcControllerType {
    fn predefined_type(&self) -> &IfcControllerTypeEnum {
        &self.predefined_type
    }
}
impl IfcControllerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcControllerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcConversionBasedUnit: IIfcNamedUnit {
    fn name(&self) -> &IfcLabel;
    fn conversion_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcConversionBasedUnit {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    name: IfcLabel,
    conversion_factor: EntityRef,
}
impl IIfcNamedUnit for IfcConversionBasedUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcConversionBasedUnit for IfcConversionBasedUnit {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn conversion_factor(&self) -> &EntityRef {
        &self.conversion_factor
    }
}
impl IfcConversionBasedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcConversionBasedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => entity.name = parameter.into(),
                3usize => entity.conversion_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCooledBeamType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCooledBeamTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCooledBeamType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCooledBeamTypeEnum,
}
impl IIfcRoot for IfcCooledBeamType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCooledBeamType {}
impl IIfcTypeObject for IfcCooledBeamType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCooledBeamType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCooledBeamType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCooledBeamType {}
impl IIfcDistributionFlowElementType for IfcCooledBeamType {}
impl IIfcEnergyConversionDeviceType for IfcCooledBeamType {}
impl IIfcCooledBeamType for IfcCooledBeamType {
    fn predefined_type(&self) -> &IfcCooledBeamTypeEnum {
        &self.predefined_type
    }
}
impl IfcCooledBeamType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCooledBeamType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoolingTowerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcCoolingTowerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCoolingTowerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCoolingTowerTypeEnum,
}
impl IIfcRoot for IfcCoolingTowerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoolingTowerType {}
impl IIfcTypeObject for IfcCoolingTowerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCoolingTowerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCoolingTowerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcCoolingTowerType {}
impl IIfcDistributionFlowElementType for IfcCoolingTowerType {}
impl IIfcEnergyConversionDeviceType for IfcCoolingTowerType {}
impl IIfcCoolingTowerType for IfcCoolingTowerType {
    fn predefined_type(&self) -> &IfcCoolingTowerTypeEnum {
        &self.predefined_type
    }
}
impl IfcCoolingTowerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoolingTowerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoordinatedUniversalTimeOffset {
    fn hour_offset(&self) -> &IfcHourInDay;
    fn minute_offset(&self) -> &Option<IfcMinuteInHour>;
    fn sense(&self) -> &IfcAheadOrBehind;
}
#[derive(Default, Debug)]
pub struct IfcCoordinatedUniversalTimeOffset {
    hour_offset: IfcHourInDay,
    minute_offset: Option<IfcMinuteInHour>,
    sense: IfcAheadOrBehind,
}
impl IIfcCoordinatedUniversalTimeOffset for IfcCoordinatedUniversalTimeOffset {
    fn hour_offset(&self) -> &IfcHourInDay {
        &self.hour_offset
    }
    fn minute_offset(&self) -> &Option<IfcMinuteInHour> {
        &self.minute_offset
    }
    fn sense(&self) -> &IfcAheadOrBehind {
        &self.sense
    }
}
impl IfcCoordinatedUniversalTimeOffset {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoordinatedUniversalTimeOffset::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hour_offset = parameter.into(),
                1usize => {
                    entity.minute_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCostItem: IIfcControl {}
#[derive(Default, Debug)]
pub struct IfcCostItem {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcCostItem {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCostItem {}
impl IIfcObject for IfcCostItem {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcCostItem {}
impl IIfcCostItem for IfcCostItem {}
impl IfcCostItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCostSchedule: IIfcControl {
    fn submitted_by(&self) -> &Option<EntityRef>;
    fn prepared_by(&self) -> &Option<EntityRef>;
    fn submitted_on(&self) -> &Option<EntityRef>;
    fn status(&self) -> &Option<IfcLabel>;
    fn target_users(&self) -> &Option<HashSet<EntityRef>>;
    fn update_date(&self) -> &Option<EntityRef>;
    fn id(&self) -> &IfcIdentifier;
    fn predefined_type(&self) -> &IfcCostScheduleTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCostSchedule {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    submitted_by: Option<EntityRef>,
    prepared_by: Option<EntityRef>,
    submitted_on: Option<EntityRef>,
    status: Option<IfcLabel>,
    target_users: Option<HashSet<EntityRef>>,
    update_date: Option<EntityRef>,
    id: IfcIdentifier,
    predefined_type: IfcCostScheduleTypeEnum,
}
impl IIfcRoot for IfcCostSchedule {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCostSchedule {}
impl IIfcObject for IfcCostSchedule {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcCostSchedule {}
impl IIfcCostSchedule for IfcCostSchedule {
    fn submitted_by(&self) -> &Option<EntityRef> {
        &self.submitted_by
    }
    fn prepared_by(&self) -> &Option<EntityRef> {
        &self.prepared_by
    }
    fn submitted_on(&self) -> &Option<EntityRef> {
        &self.submitted_on
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn target_users(&self) -> &Option<HashSet<EntityRef>> {
        &self.target_users
    }
    fn update_date(&self) -> &Option<EntityRef> {
        &self.update_date
    }
    fn id(&self) -> &IfcIdentifier {
        &self.id
    }
    fn predefined_type(&self) -> &IfcCostScheduleTypeEnum {
        &self.predefined_type
    }
}
impl IfcCostSchedule {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.submitted_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.prepared_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.submitted_on = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.target_users = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.update_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.id = parameter.into(),
                12usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCostValue: IIfcAppliedValue {
    fn cost_type(&self) -> &IfcLabel;
    fn condition(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcCostValue {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applied_value: Option<IfcAppliedValueSelect>,
    unit_basis: Option<EntityRef>,
    applicable_date: Option<EntityRef>,
    fixed_until_date: Option<EntityRef>,
    cost_type: IfcLabel,
    condition: Option<IfcText>,
}
impl IIfcAppliedValue for IfcCostValue {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn applied_value(&self) -> &Option<IfcAppliedValueSelect> {
        &self.applied_value
    }
    fn unit_basis(&self) -> &Option<EntityRef> {
        &self.unit_basis
    }
    fn applicable_date(&self) -> &Option<EntityRef> {
        &self.applicable_date
    }
    fn fixed_until_date(&self) -> &Option<EntityRef> {
        &self.fixed_until_date
    }
}
impl IIfcCostValue for IfcCostValue {
    fn cost_type(&self) -> &IfcLabel {
        &self.cost_type
    }
    fn condition(&self) -> &Option<IfcText> {
        &self.condition
    }
}
impl IfcCostValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCostValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.applied_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit_basis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.fixed_until_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.cost_type = parameter.into(),
                7usize => {
                    entity.condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCovering: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcCoveringTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcCovering {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcCoveringTypeEnum>,
}
impl IIfcRoot for IfcCovering {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCovering {}
impl IIfcObject for IfcCovering {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCovering {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCovering {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcCovering {}
impl IIfcCovering for IfcCovering {
    fn predefined_type(&self) -> &Option<IfcCoveringTypeEnum> {
        &self.predefined_type
    }
}
impl IfcCovering {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCovering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCoveringType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcCoveringTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCoveringType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCoveringTypeEnum,
}
impl IIfcRoot for IfcCoveringType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCoveringType {}
impl IIfcTypeObject for IfcCoveringType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCoveringType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCoveringType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcCoveringType {}
impl IIfcCoveringType for IfcCoveringType {
    fn predefined_type(&self) -> &IfcCoveringTypeEnum {
        &self.predefined_type
    }
}
impl IfcCoveringType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCoveringType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCraneRailAShapeProfileDef: IIfcParameterizedProfileDef {
    fn overall_height(&self) -> &IfcPositiveLengthMeasure;
    fn base_width2(&self) -> &IfcPositiveLengthMeasure;
    fn radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn head_width(&self) -> &IfcPositiveLengthMeasure;
    fn head_depth2(&self) -> &IfcPositiveLengthMeasure;
    fn head_depth3(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn base_width4(&self) -> &IfcPositiveLengthMeasure;
    fn base_depth1(&self) -> &IfcPositiveLengthMeasure;
    fn base_depth2(&self) -> &IfcPositiveLengthMeasure;
    fn base_depth3(&self) -> &IfcPositiveLengthMeasure;
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcCraneRailAShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    overall_height: IfcPositiveLengthMeasure,
    base_width2: IfcPositiveLengthMeasure,
    radius: Option<IfcPositiveLengthMeasure>,
    head_width: IfcPositiveLengthMeasure,
    head_depth2: IfcPositiveLengthMeasure,
    head_depth3: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    base_width4: IfcPositiveLengthMeasure,
    base_depth1: IfcPositiveLengthMeasure,
    base_depth2: IfcPositiveLengthMeasure,
    base_depth3: IfcPositiveLengthMeasure,
    centre_of_gravity_in_y: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcCraneRailAShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCraneRailAShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCraneRailAShapeProfileDef for IfcCraneRailAShapeProfileDef {
    fn overall_height(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_height
    }
    fn base_width2(&self) -> &IfcPositiveLengthMeasure {
        &self.base_width2
    }
    fn radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.radius
    }
    fn head_width(&self) -> &IfcPositiveLengthMeasure {
        &self.head_width
    }
    fn head_depth2(&self) -> &IfcPositiveLengthMeasure {
        &self.head_depth2
    }
    fn head_depth3(&self) -> &IfcPositiveLengthMeasure {
        &self.head_depth3
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn base_width4(&self) -> &IfcPositiveLengthMeasure {
        &self.base_width4
    }
    fn base_depth1(&self) -> &IfcPositiveLengthMeasure {
        &self.base_depth1
    }
    fn base_depth2(&self) -> &IfcPositiveLengthMeasure {
        &self.base_depth2
    }
    fn base_depth3(&self) -> &IfcPositiveLengthMeasure {
        &self.base_depth3
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IfcCraneRailAShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCraneRailAShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.overall_height = parameter.into(),
                4usize => entity.base_width2 = parameter.into(),
                5usize => {
                    entity.radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.head_width = parameter.into(),
                7usize => entity.head_depth2 = parameter.into(),
                8usize => entity.head_depth3 = parameter.into(),
                9usize => entity.web_thickness = parameter.into(),
                10usize => entity.base_width4 = parameter.into(),
                11usize => entity.base_depth1 = parameter.into(),
                12usize => entity.base_depth2 = parameter.into(),
                13usize => entity.base_depth3 = parameter.into(),
                14usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCraneRailFShapeProfileDef: IIfcParameterizedProfileDef {
    fn overall_height(&self) -> &IfcPositiveLengthMeasure;
    fn head_width(&self) -> &IfcPositiveLengthMeasure;
    fn radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn head_depth2(&self) -> &IfcPositiveLengthMeasure;
    fn head_depth3(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn base_depth1(&self) -> &IfcPositiveLengthMeasure;
    fn base_depth2(&self) -> &IfcPositiveLengthMeasure;
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcCraneRailFShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    overall_height: IfcPositiveLengthMeasure,
    head_width: IfcPositiveLengthMeasure,
    radius: Option<IfcPositiveLengthMeasure>,
    head_depth2: IfcPositiveLengthMeasure,
    head_depth3: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    base_depth1: IfcPositiveLengthMeasure,
    base_depth2: IfcPositiveLengthMeasure,
    centre_of_gravity_in_y: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcCraneRailFShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcCraneRailFShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcCraneRailFShapeProfileDef for IfcCraneRailFShapeProfileDef {
    fn overall_height(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_height
    }
    fn head_width(&self) -> &IfcPositiveLengthMeasure {
        &self.head_width
    }
    fn radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.radius
    }
    fn head_depth2(&self) -> &IfcPositiveLengthMeasure {
        &self.head_depth2
    }
    fn head_depth3(&self) -> &IfcPositiveLengthMeasure {
        &self.head_depth3
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn base_depth1(&self) -> &IfcPositiveLengthMeasure {
        &self.base_depth1
    }
    fn base_depth2(&self) -> &IfcPositiveLengthMeasure {
        &self.base_depth2
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IfcCraneRailFShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCraneRailFShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.overall_height = parameter.into(),
                4usize => entity.head_width = parameter.into(),
                5usize => {
                    entity.radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.head_depth2 = parameter.into(),
                7usize => entity.head_depth3 = parameter.into(),
                8usize => entity.web_thickness = parameter.into(),
                9usize => entity.base_depth1 = parameter.into(),
                10usize => entity.base_depth2 = parameter.into(),
                11usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCrewResource: IIfcConstructionResource {}
#[derive(Default, Debug)]
pub struct IfcCrewResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    resource_identifier: Option<IfcIdentifier>,
    resource_group: Option<IfcLabel>,
    resource_consumption: Option<IfcResourceConsumptionEnum>,
    base_quantity: Option<EntityRef>,
}
impl IIfcRoot for IfcCrewResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCrewResource {}
impl IIfcObject for IfcCrewResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcCrewResource {}
impl IIfcConstructionResource for IfcCrewResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier> {
        &self.resource_identifier
    }
    fn resource_group(&self) -> &Option<IfcLabel> {
        &self.resource_group
    }
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum> {
        &self.resource_consumption
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcCrewResource for IfcCrewResource {}
impl IfcCrewResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCrewResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.resource_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.resource_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.resource_consumption = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCsgPrimitive3D: IIfcGeometricRepresentationItem {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcCsgSolid: IIfcSolidModel {
    fn tree_root_expression(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcCsgSolid {
    tree_root_expression: EntityRef,
}
impl IIfcRepresentationItem for IfcCsgSolid {}
impl IIfcGeometricRepresentationItem for IfcCsgSolid {}
impl IIfcSolidModel for IfcCsgSolid {}
impl IIfcCsgSolid for IfcCsgSolid {
    fn tree_root_expression(&self) -> &EntityRef {
        &self.tree_root_expression
    }
}
impl IfcCsgSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCsgSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tree_root_expression = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurrencyRelationship {
    fn relating_monetary_unit(&self) -> &EntityRef;
    fn related_monetary_unit(&self) -> &EntityRef;
    fn exchange_rate(&self) -> &IfcPositiveRatioMeasure;
    fn rate_date_time(&self) -> &EntityRef;
    fn rate_source(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurrencyRelationship {
    relating_monetary_unit: EntityRef,
    related_monetary_unit: EntityRef,
    exchange_rate: IfcPositiveRatioMeasure,
    rate_date_time: EntityRef,
    rate_source: Option<EntityRef>,
}
impl IIfcCurrencyRelationship for IfcCurrencyRelationship {
    fn relating_monetary_unit(&self) -> &EntityRef {
        &self.relating_monetary_unit
    }
    fn related_monetary_unit(&self) -> &EntityRef {
        &self.related_monetary_unit
    }
    fn exchange_rate(&self) -> &IfcPositiveRatioMeasure {
        &self.exchange_rate
    }
    fn rate_date_time(&self) -> &EntityRef {
        &self.rate_date_time
    }
    fn rate_source(&self) -> &Option<EntityRef> {
        &self.rate_source
    }
}
impl IfcCurrencyRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurrencyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_monetary_unit = parameter.into(),
                1usize => entity.related_monetary_unit = parameter.into(),
                2usize => entity.exchange_rate = parameter.into(),
                3usize => entity.rate_date_time = parameter.into(),
                4usize => {
                    entity.rate_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurtainWall: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcCurtainWall {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcCurtainWall {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCurtainWall {}
impl IIfcObject for IfcCurtainWall {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcCurtainWall {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcCurtainWall {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcCurtainWall {}
impl IIfcCurtainWall for IfcCurtainWall {}
impl IfcCurtainWall {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurtainWall::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurtainWallType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcCurtainWallTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcCurtainWallType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcCurtainWallTypeEnum,
}
impl IIfcRoot for IfcCurtainWallType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcCurtainWallType {}
impl IIfcTypeObject for IfcCurtainWallType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcCurtainWallType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcCurtainWallType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcCurtainWallType {}
impl IIfcCurtainWallType for IfcCurtainWallType {
    fn predefined_type(&self) -> &IfcCurtainWallTypeEnum {
        &self.predefined_type
    }
}
impl IfcCurtainWallType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurtainWallType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurve: IIfcGeometricRepresentationItem {}
pub trait IIfcCurveBoundedPlane: IIfcBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn outer_boundary(&self) -> &EntityRef;
    fn inner_boundaries(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurveBoundedPlane {
    basis_surface: EntityRef,
    outer_boundary: EntityRef,
    inner_boundaries: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcCurveBoundedPlane {}
impl IIfcGeometricRepresentationItem for IfcCurveBoundedPlane {}
impl IIfcSurface for IfcCurveBoundedPlane {}
impl IIfcBoundedSurface for IfcCurveBoundedPlane {}
impl IIfcCurveBoundedPlane for IfcCurveBoundedPlane {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn outer_boundary(&self) -> &EntityRef {
        &self.outer_boundary
    }
    fn inner_boundaries(&self) -> &HashSet<EntityRef> {
        &self.inner_boundaries
    }
}
impl IfcCurveBoundedPlane {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveBoundedPlane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.outer_boundary = parameter.into(),
                2usize => entity.inner_boundaries = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyle: IIfcPresentationStyle {
    fn curve_font(&self) -> &Option<EntityRef>;
    fn curve_width(&self) -> &Option<IfcSizeSelect>;
    fn curve_colour(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyle {
    name: Option<IfcLabel>,
    curve_font: Option<EntityRef>,
    curve_width: Option<IfcSizeSelect>,
    curve_colour: Option<EntityRef>,
}
impl IIfcPresentationStyle for IfcCurveStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcCurveStyle for IfcCurveStyle {
    fn curve_font(&self) -> &Option<EntityRef> {
        &self.curve_font
    }
    fn curve_width(&self) -> &Option<IfcSizeSelect> {
        &self.curve_width
    }
    fn curve_colour(&self) -> &Option<EntityRef> {
        &self.curve_colour
    }
}
impl IfcCurveStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.curve_font = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.curve_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.curve_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyleFont {
    fn name(&self) -> &Option<IfcLabel>;
    fn pattern_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyleFont {
    name: Option<IfcLabel>,
    pattern_list: Vec<EntityRef>,
}
impl IIfcCurveStyleFont for IfcCurveStyleFont {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn pattern_list(&self) -> &Vec<EntityRef> {
        &self.pattern_list
    }
}
impl IfcCurveStyleFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyleFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.pattern_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyleFontAndScaling {
    fn name(&self) -> &Option<IfcLabel>;
    fn curve_font(&self) -> &EntityRef;
    fn curve_font_scaling(&self) -> &IfcPositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyleFontAndScaling {
    name: Option<IfcLabel>,
    curve_font: EntityRef,
    curve_font_scaling: IfcPositiveRatioMeasure,
}
impl IIfcCurveStyleFontAndScaling for IfcCurveStyleFontAndScaling {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn curve_font(&self) -> &EntityRef {
        &self.curve_font
    }
    fn curve_font_scaling(&self) -> &IfcPositiveRatioMeasure {
        &self.curve_font_scaling
    }
}
impl IfcCurveStyleFontAndScaling {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyleFontAndScaling::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.curve_font = parameter.into(),
                2usize => entity.curve_font_scaling = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcCurveStyleFontPattern {
    fn visible_segment_length(&self) -> &IfcLengthMeasure;
    fn invisible_segment_length(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcCurveStyleFontPattern {
    visible_segment_length: IfcLengthMeasure,
    invisible_segment_length: IfcPositiveLengthMeasure,
}
impl IIfcCurveStyleFontPattern for IfcCurveStyleFontPattern {
    fn visible_segment_length(&self) -> &IfcLengthMeasure {
        &self.visible_segment_length
    }
    fn invisible_segment_length(&self) -> &IfcPositiveLengthMeasure {
        &self.invisible_segment_length
    }
}
impl IfcCurveStyleFontPattern {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcCurveStyleFontPattern::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.visible_segment_length = parameter.into(),
                1usize => entity.invisible_segment_length = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDamperType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcDamperTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDamperType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDamperTypeEnum,
}
impl IIfcRoot for IfcDamperType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDamperType {}
impl IIfcTypeObject for IfcDamperType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDamperType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDamperType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDamperType {}
impl IIfcDistributionFlowElementType for IfcDamperType {}
impl IIfcFlowControllerType for IfcDamperType {}
impl IIfcDamperType for IfcDamperType {
    fn predefined_type(&self) -> &IfcDamperTypeEnum {
        &self.predefined_type
    }
}
impl IfcDamperType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDamperType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDateAndTime {
    fn date_component(&self) -> &EntityRef;
    fn time_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcDateAndTime {
    date_component: EntityRef,
    time_component: EntityRef,
}
impl IIfcDateAndTime for IfcDateAndTime {
    fn date_component(&self) -> &EntityRef {
        &self.date_component
    }
    fn time_component(&self) -> &EntityRef {
        &self.time_component
    }
}
impl IfcDateAndTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDateAndTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.date_component = parameter.into(),
                1usize => entity.time_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDefinedSymbol: IIfcGeometricRepresentationItem {
    fn definition(&self) -> &EntityRef;
    fn target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcDefinedSymbol {
    definition: EntityRef,
    target: EntityRef,
}
impl IIfcRepresentationItem for IfcDefinedSymbol {}
impl IIfcGeometricRepresentationItem for IfcDefinedSymbol {}
impl IIfcDefinedSymbol for IfcDefinedSymbol {
    fn definition(&self) -> &EntityRef {
        &self.definition
    }
    fn target(&self) -> &EntityRef {
        &self.target
    }
}
impl IfcDefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.definition = parameter.into(),
                1usize => entity.target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDerivedProfileDef: IIfcProfileDef {
    fn parent_profile(&self) -> &EntityRef;
    fn operator(&self) -> &EntityRef;
    fn label(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDerivedProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    parent_profile: EntityRef,
    operator: EntityRef,
    label: Option<IfcLabel>,
}
impl IIfcProfileDef for IfcDerivedProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcDerivedProfileDef for IfcDerivedProfileDef {
    fn parent_profile(&self) -> &EntityRef {
        &self.parent_profile
    }
    fn operator(&self) -> &EntityRef {
        &self.operator
    }
    fn label(&self) -> &Option<IfcLabel> {
        &self.label
    }
}
impl IfcDerivedProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.parent_profile = parameter.into(),
                3usize => entity.operator = parameter.into(),
                4usize => {
                    entity.label = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef>;
    fn unit_type(&self) -> &IfcDerivedUnitEnum;
    fn user_defined_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDerivedUnit {
    elements: HashSet<EntityRef>,
    unit_type: IfcDerivedUnitEnum,
    user_defined_type: Option<IfcLabel>,
}
impl IIfcDerivedUnit for IfcDerivedUnit {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
    fn unit_type(&self) -> &IfcDerivedUnitEnum {
        &self.unit_type
    }
    fn user_defined_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_type
    }
}
impl IfcDerivedUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => {
                    entity.user_defined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDerivedUnitElement {
    fn unit(&self) -> &EntityRef;
    fn exponent(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IfcDerivedUnitElement {
    unit: EntityRef,
    exponent: i64,
}
impl IIfcDerivedUnitElement for IfcDerivedUnitElement {
    fn unit(&self) -> &EntityRef {
        &self.unit
    }
    fn exponent(&self) -> i64 {
        self.exponent
    }
}
impl IfcDerivedUnitElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDerivedUnitElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.unit = parameter.into(),
                1usize => entity.exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDiameterDimension: IIfcDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct IfcDiameterDimension {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcDiameterDimension {}
impl IIfcGeometricRepresentationItem for IfcDiameterDimension {}
impl IIfcDraughtingCallout for IfcDiameterDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IIfcDimensionCurveDirectedCallout for IfcDiameterDimension {}
impl IIfcDiameterDimension for IfcDiameterDimension {}
impl IfcDiameterDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiameterDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionCalloutRelationship: IIfcDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct IfcDimensionCalloutRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IIfcDraughtingCalloutRelationship for IfcDimensionCalloutRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IIfcDimensionCalloutRelationship for IfcDimensionCalloutRelationship {}
impl IfcDimensionCalloutRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionCalloutRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionCurve: IIfcAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct IfcDimensionCurve {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcDimensionCurve {}
impl IIfcStyledItem for IfcDimensionCurve {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcDimensionCurve {}
impl IIfcAnnotationCurveOccurrence for IfcDimensionCurve {}
impl IIfcDimensionCurve for IfcDimensionCurve {}
impl IfcDimensionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionCurveDirectedCallout: IIfcDraughtingCallout {}
#[derive(Default, Debug)]
pub struct IfcDimensionCurveDirectedCallout {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcDimensionCurveDirectedCallout {}
impl IIfcGeometricRepresentationItem for IfcDimensionCurveDirectedCallout {}
impl IIfcDraughtingCallout for IfcDimensionCurveDirectedCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IIfcDimensionCurveDirectedCallout for IfcDimensionCurveDirectedCallout {}
impl IfcDimensionCurveDirectedCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionCurveDirectedCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionCurveTerminator: IIfcTerminatorSymbol {
    fn role(&self) -> &IfcDimensionExtentUsage;
}
#[derive(Default, Debug)]
pub struct IfcDimensionCurveTerminator {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
    annotated_curve: EntityRef,
    role: IfcDimensionExtentUsage,
}
impl IIfcRepresentationItem for IfcDimensionCurveTerminator {}
impl IIfcStyledItem for IfcDimensionCurveTerminator {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcDimensionCurveTerminator {}
impl IIfcAnnotationSymbolOccurrence for IfcDimensionCurveTerminator {}
impl IIfcTerminatorSymbol for IfcDimensionCurveTerminator {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl IIfcDimensionCurveTerminator for IfcDimensionCurveTerminator {
    fn role(&self) -> &IfcDimensionExtentUsage {
        &self.role
    }
}
impl IfcDimensionCurveTerminator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionCurveTerminator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.annotated_curve = parameter.into(),
                4usize => entity.role = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionPair: IIfcDraughtingCalloutRelationship {}
#[derive(Default, Debug)]
pub struct IfcDimensionPair {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IIfcDraughtingCalloutRelationship for IfcDimensionPair {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IIfcDimensionPair for IfcDimensionPair {}
impl IfcDimensionPair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionPair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDimensionalExponents {
    fn length_exponent(&self) -> i64;
    fn mass_exponent(&self) -> i64;
    fn time_exponent(&self) -> i64;
    fn electric_current_exponent(&self) -> i64;
    fn thermodynamic_temperature_exponent(&self) -> i64;
    fn amount_of_substance_exponent(&self) -> i64;
    fn luminous_intensity_exponent(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IfcDimensionalExponents {
    length_exponent: i64,
    mass_exponent: i64,
    time_exponent: i64,
    electric_current_exponent: i64,
    thermodynamic_temperature_exponent: i64,
    amount_of_substance_exponent: i64,
    luminous_intensity_exponent: i64,
}
impl IIfcDimensionalExponents for IfcDimensionalExponents {
    fn length_exponent(&self) -> i64 {
        self.length_exponent
    }
    fn mass_exponent(&self) -> i64 {
        self.mass_exponent
    }
    fn time_exponent(&self) -> i64 {
        self.time_exponent
    }
    fn electric_current_exponent(&self) -> i64 {
        self.electric_current_exponent
    }
    fn thermodynamic_temperature_exponent(&self) -> i64 {
        self.thermodynamic_temperature_exponent
    }
    fn amount_of_substance_exponent(&self) -> i64 {
        self.amount_of_substance_exponent
    }
    fn luminous_intensity_exponent(&self) -> i64 {
        self.luminous_intensity_exponent
    }
}
impl IfcDimensionalExponents {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDimensionalExponents::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.length_exponent = parameter.into(),
                1usize => entity.mass_exponent = parameter.into(),
                2usize => entity.time_exponent = parameter.into(),
                3usize => entity.electric_current_exponent = parameter.into(),
                4usize => entity.thermodynamic_temperature_exponent = parameter.into(),
                5usize => entity.amount_of_substance_exponent = parameter.into(),
                6usize => entity.luminous_intensity_exponent = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDirection: IIfcGeometricRepresentationItem {
    fn direction_ratios(&self) -> &Vec<Real>;
}
#[derive(Default, Debug)]
pub struct IfcDirection {
    direction_ratios: Vec<Real>,
}
impl IIfcRepresentationItem for IfcDirection {}
impl IIfcGeometricRepresentationItem for IfcDirection {}
impl IIfcDirection for IfcDirection {
    fn direction_ratios(&self) -> &Vec<Real> {
        &self.direction_ratios
    }
}
impl IfcDirection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDirection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.direction_ratios = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDiscreteAccessory: IIfcElementComponent {}
#[derive(Default, Debug)]
pub struct IfcDiscreteAccessory {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDiscreteAccessory {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDiscreteAccessory {}
impl IIfcObject for IfcDiscreteAccessory {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDiscreteAccessory {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDiscreteAccessory {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcDiscreteAccessory {}
impl IIfcDiscreteAccessory for IfcDiscreteAccessory {}
impl IfcDiscreteAccessory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiscreteAccessory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDiscreteAccessoryType: IIfcElementComponentType {}
#[derive(Default, Debug)]
pub struct IfcDiscreteAccessoryType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcDiscreteAccessoryType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDiscreteAccessoryType {}
impl IIfcTypeObject for IfcDiscreteAccessoryType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDiscreteAccessoryType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDiscreteAccessoryType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcDiscreteAccessoryType {}
impl IIfcDiscreteAccessoryType for IfcDiscreteAccessoryType {}
impl IfcDiscreteAccessoryType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDiscreteAccessoryType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionChamberElement: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcDistributionChamberElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionChamberElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionChamberElement {}
impl IIfcObject for IfcDistributionChamberElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionChamberElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionChamberElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionChamberElement {}
impl IIfcDistributionFlowElement for IfcDistributionChamberElement {}
impl IIfcDistributionChamberElement for IfcDistributionChamberElement {}
impl IfcDistributionChamberElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionChamberElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionChamberElementType: IIfcDistributionFlowElementType {
    fn predefined_type(&self) -> &IfcDistributionChamberElementTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDistributionChamberElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDistributionChamberElementTypeEnum,
}
impl IIfcRoot for IfcDistributionChamberElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionChamberElementType {}
impl IIfcTypeObject for IfcDistributionChamberElementType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDistributionChamberElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDistributionChamberElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDistributionChamberElementType {}
impl IIfcDistributionFlowElementType for IfcDistributionChamberElementType {}
impl IIfcDistributionChamberElementType for IfcDistributionChamberElementType {
    fn predefined_type(&self) -> &IfcDistributionChamberElementTypeEnum {
        &self.predefined_type
    }
}
impl IfcDistributionChamberElementType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionChamberElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionControlElement: IIfcDistributionElement {
    fn control_element_id(&self) -> &Option<IfcIdentifier>;
}
#[derive(Default, Debug)]
pub struct IfcDistributionControlElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    control_element_id: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionControlElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionControlElement {}
impl IIfcObject for IfcDistributionControlElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionControlElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionControlElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionControlElement {}
impl IIfcDistributionControlElement for IfcDistributionControlElement {
    fn control_element_id(&self) -> &Option<IfcIdentifier> {
        &self.control_element_id
    }
}
impl IfcDistributionControlElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionControlElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.control_element_id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionControlElementType: IIfcDistributionElementType {}
pub trait IIfcDistributionElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcDistributionElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionElement {}
impl IIfcObject for IfcDistributionElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionElement {}
impl IfcDistributionElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionElementType: IIfcElementType {}
#[derive(Default, Debug)]
pub struct IfcDistributionElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcDistributionElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionElementType {}
impl IIfcTypeObject for IfcDistributionElementType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDistributionElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDistributionElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDistributionElementType {}
impl IfcDistributionElementType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionFlowElement: IIfcDistributionElement {}
#[derive(Default, Debug)]
pub struct IfcDistributionFlowElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcDistributionFlowElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionFlowElement {}
impl IIfcObject for IfcDistributionFlowElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionFlowElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDistributionFlowElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcDistributionFlowElement {}
impl IIfcDistributionFlowElement for IfcDistributionFlowElement {}
impl IfcDistributionFlowElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionFlowElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDistributionFlowElementType: IIfcDistributionElementType {}
pub trait IIfcDistributionPort: IIfcPort {
    fn flow_direction(&self) -> &Option<IfcFlowDirectionEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDistributionPort {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    flow_direction: Option<IfcFlowDirectionEnum>,
}
impl IIfcRoot for IfcDistributionPort {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDistributionPort {}
impl IIfcObject for IfcDistributionPort {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDistributionPort {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcPort for IfcDistributionPort {}
impl IIfcDistributionPort for IfcDistributionPort {
    fn flow_direction(&self) -> &Option<IfcFlowDirectionEnum> {
        &self.flow_direction
    }
}
impl IfcDistributionPort {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDistributionPort::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.flow_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentElectronicFormat {
    fn file_extension(&self) -> &Option<IfcLabel>;
    fn mime_content_type(&self) -> &Option<IfcLabel>;
    fn mime_subtype(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDocumentElectronicFormat {
    file_extension: Option<IfcLabel>,
    mime_content_type: Option<IfcLabel>,
    mime_subtype: Option<IfcLabel>,
}
impl IIfcDocumentElectronicFormat for IfcDocumentElectronicFormat {
    fn file_extension(&self) -> &Option<IfcLabel> {
        &self.file_extension
    }
    fn mime_content_type(&self) -> &Option<IfcLabel> {
        &self.mime_content_type
    }
    fn mime_subtype(&self) -> &Option<IfcLabel> {
        &self.mime_subtype
    }
}
impl IfcDocumentElectronicFormat {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentElectronicFormat::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.file_extension = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.mime_content_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.mime_subtype = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentInformation {
    fn document_id(&self) -> &IfcIdentifier;
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn document_references(&self) -> &Option<HashSet<EntityRef>>;
    fn purpose(&self) -> &Option<IfcText>;
    fn intended_use(&self) -> &Option<IfcText>;
    fn scope(&self) -> &Option<IfcText>;
    fn revision(&self) -> &Option<IfcLabel>;
    fn document_owner(&self) -> &Option<EntityRef>;
    fn editors(&self) -> &Option<HashSet<EntityRef>>;
    fn creation_time(&self) -> &Option<EntityRef>;
    fn last_revision_time(&self) -> &Option<EntityRef>;
    fn electronic_format(&self) -> &Option<EntityRef>;
    fn valid_from(&self) -> &Option<EntityRef>;
    fn valid_until(&self) -> &Option<EntityRef>;
    fn confidentiality(&self) -> &Option<IfcDocumentConfidentialityEnum>;
    fn status(&self) -> &Option<IfcDocumentStatusEnum>;
}
#[derive(Default, Debug)]
pub struct IfcDocumentInformation {
    document_id: IfcIdentifier,
    name: IfcLabel,
    description: Option<IfcText>,
    document_references: Option<HashSet<EntityRef>>,
    purpose: Option<IfcText>,
    intended_use: Option<IfcText>,
    scope: Option<IfcText>,
    revision: Option<IfcLabel>,
    document_owner: Option<EntityRef>,
    editors: Option<HashSet<EntityRef>>,
    creation_time: Option<EntityRef>,
    last_revision_time: Option<EntityRef>,
    electronic_format: Option<EntityRef>,
    valid_from: Option<EntityRef>,
    valid_until: Option<EntityRef>,
    confidentiality: Option<IfcDocumentConfidentialityEnum>,
    status: Option<IfcDocumentStatusEnum>,
}
impl IIfcDocumentInformation for IfcDocumentInformation {
    fn document_id(&self) -> &IfcIdentifier {
        &self.document_id
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn document_references(&self) -> &Option<HashSet<EntityRef>> {
        &self.document_references
    }
    fn purpose(&self) -> &Option<IfcText> {
        &self.purpose
    }
    fn intended_use(&self) -> &Option<IfcText> {
        &self.intended_use
    }
    fn scope(&self) -> &Option<IfcText> {
        &self.scope
    }
    fn revision(&self) -> &Option<IfcLabel> {
        &self.revision
    }
    fn document_owner(&self) -> &Option<EntityRef> {
        &self.document_owner
    }
    fn editors(&self) -> &Option<HashSet<EntityRef>> {
        &self.editors
    }
    fn creation_time(&self) -> &Option<EntityRef> {
        &self.creation_time
    }
    fn last_revision_time(&self) -> &Option<EntityRef> {
        &self.last_revision_time
    }
    fn electronic_format(&self) -> &Option<EntityRef> {
        &self.electronic_format
    }
    fn valid_from(&self) -> &Option<EntityRef> {
        &self.valid_from
    }
    fn valid_until(&self) -> &Option<EntityRef> {
        &self.valid_until
    }
    fn confidentiality(&self) -> &Option<IfcDocumentConfidentialityEnum> {
        &self.confidentiality
    }
    fn status(&self) -> &Option<IfcDocumentStatusEnum> {
        &self.status
    }
}
impl IfcDocumentInformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentInformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.document_id = parameter.into(),
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.document_references = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.intended_use = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.scope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.revision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.document_owner = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.editors = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.creation_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.last_revision_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.electronic_format = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.valid_from = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.valid_until = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.confidentiality = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentInformationRelationship {
    fn relating_document(&self) -> &EntityRef;
    fn related_documents(&self) -> &HashSet<EntityRef>;
    fn relationship_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcDocumentInformationRelationship {
    relating_document: EntityRef,
    related_documents: HashSet<EntityRef>,
    relationship_type: Option<IfcLabel>,
}
impl IIfcDocumentInformationRelationship for IfcDocumentInformationRelationship {
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
    fn related_documents(&self) -> &HashSet<EntityRef> {
        &self.related_documents
    }
    fn relationship_type(&self) -> &Option<IfcLabel> {
        &self.relationship_type
    }
}
impl IfcDocumentInformationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentInformationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_document = parameter.into(),
                1usize => entity.related_documents = parameter.into(),
                2usize => {
                    entity.relationship_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDocumentReference: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcDocumentReference {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcDocumentReference {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcDocumentReference for IfcDocumentReference {}
impl IfcDocumentReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDocumentReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoor: IIfcBuildingElement {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcDoor {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    overall_height: Option<IfcPositiveLengthMeasure>,
    overall_width: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcDoor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDoor {}
impl IIfcObject for IfcDoor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcDoor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcDoor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcDoor {}
impl IIfcDoor for IfcDoor {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_height
    }
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_width
    }
}
impl IfcDoor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorLiningProperties: IIfcPropertySetDefinition {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn lining_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn threshold_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn threshold_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transom_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transom_offset(&self) -> &Option<IfcLengthMeasure>;
    fn lining_offset(&self) -> &Option<IfcLengthMeasure>;
    fn threshold_offset(&self) -> &Option<IfcLengthMeasure>;
    fn casing_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn casing_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcDoorLiningProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    lining_depth: Option<IfcPositiveLengthMeasure>,
    lining_thickness: Option<IfcPositiveLengthMeasure>,
    threshold_depth: Option<IfcPositiveLengthMeasure>,
    threshold_thickness: Option<IfcPositiveLengthMeasure>,
    transom_thickness: Option<IfcPositiveLengthMeasure>,
    transom_offset: Option<IfcLengthMeasure>,
    lining_offset: Option<IfcLengthMeasure>,
    threshold_offset: Option<IfcLengthMeasure>,
    casing_thickness: Option<IfcPositiveLengthMeasure>,
    casing_depth: Option<IfcPositiveLengthMeasure>,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcDoorLiningProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcDoorLiningProperties {}
impl IIfcPropertySetDefinition for IfcDoorLiningProperties {}
impl IIfcDoorLiningProperties for IfcDoorLiningProperties {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.lining_depth
    }
    fn lining_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.lining_thickness
    }
    fn threshold_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.threshold_depth
    }
    fn threshold_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.threshold_thickness
    }
    fn transom_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.transom_thickness
    }
    fn transom_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.transom_offset
    }
    fn lining_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.lining_offset
    }
    fn threshold_offset(&self) -> &Option<IfcLengthMeasure> {
        &self.threshold_offset
    }
    fn casing_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.casing_thickness
    }
    fn casing_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.casing_depth
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcDoorLiningProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorLiningProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.lining_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.lining_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.threshold_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.threshold_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.transom_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.lining_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.threshold_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.casing_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.casing_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorPanelProperties: IIfcPropertySetDefinition {
    fn panel_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn panel_operation(&self) -> &IfcDoorPanelOperationEnum;
    fn panel_width(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn panel_position(&self) -> &IfcDoorPanelPositionEnum;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcDoorPanelProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    panel_depth: Option<IfcPositiveLengthMeasure>,
    panel_operation: IfcDoorPanelOperationEnum,
    panel_width: Option<IfcNormalisedRatioMeasure>,
    panel_position: IfcDoorPanelPositionEnum,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcDoorPanelProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcDoorPanelProperties {}
impl IIfcPropertySetDefinition for IfcDoorPanelProperties {}
impl IIfcDoorPanelProperties for IfcDoorPanelProperties {
    fn panel_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.panel_depth
    }
    fn panel_operation(&self) -> &IfcDoorPanelOperationEnum {
        &self.panel_operation
    }
    fn panel_width(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.panel_width
    }
    fn panel_position(&self) -> &IfcDoorPanelPositionEnum {
        &self.panel_position
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcDoorPanelProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorPanelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.panel_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.panel_operation = parameter.into(),
                6usize => {
                    entity.panel_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.panel_position = parameter.into(),
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDoorStyle: IIfcTypeProduct {
    fn operation_type(&self) -> &IfcDoorStyleOperationEnum;
    fn construction_type(&self) -> &IfcDoorStyleConstructionEnum;
    fn parameter_takes_precedence(&self) -> bool;
    fn sizeable(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcDoorStyle {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    operation_type: IfcDoorStyleOperationEnum,
    construction_type: IfcDoorStyleConstructionEnum,
    parameter_takes_precedence: bool,
    sizeable: bool,
}
impl IIfcRoot for IfcDoorStyle {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDoorStyle {}
impl IIfcTypeObject for IfcDoorStyle {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDoorStyle {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcDoorStyle for IfcDoorStyle {
    fn operation_type(&self) -> &IfcDoorStyleOperationEnum {
        &self.operation_type
    }
    fn construction_type(&self) -> &IfcDoorStyleConstructionEnum {
        &self.construction_type
    }
    fn parameter_takes_precedence(&self) -> bool {
        self.parameter_takes_precedence
    }
    fn sizeable(&self) -> bool {
        self.sizeable
    }
}
impl IfcDoorStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDoorStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.operation_type = parameter.into(),
                9usize => entity.construction_type = parameter.into(),
                10usize => entity.parameter_takes_precedence = parameter.into(),
                11usize => entity.sizeable = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingCallout: IIfcGeometricRepresentationItem {
    fn contents(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcDraughtingCallout {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcDraughtingCallout {}
impl IIfcGeometricRepresentationItem for IfcDraughtingCallout {}
impl IIfcDraughtingCallout for IfcDraughtingCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IfcDraughtingCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingCalloutRelationship {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn relating_draughting_callout(&self) -> &EntityRef;
    fn related_draughting_callout(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcDraughtingCalloutRelationship {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_draughting_callout: EntityRef,
    related_draughting_callout: EntityRef,
}
impl IIfcDraughtingCalloutRelationship for IfcDraughtingCalloutRelationship {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn relating_draughting_callout(&self) -> &EntityRef {
        &self.relating_draughting_callout
    }
    fn related_draughting_callout(&self) -> &EntityRef {
        &self.related_draughting_callout
    }
}
impl IfcDraughtingCalloutRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingCalloutRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_draughting_callout = parameter.into(),
                3usize => entity.related_draughting_callout = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingPreDefinedColour: IIfcPreDefinedColour {}
#[derive(Default, Debug)]
pub struct IfcDraughtingPreDefinedColour {
    name: IfcLabel,
}
impl IIfcPreDefinedItem for IfcDraughtingPreDefinedColour {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedColour for IfcDraughtingPreDefinedColour {}
impl IIfcDraughtingPreDefinedColour for IfcDraughtingPreDefinedColour {}
impl IfcDraughtingPreDefinedColour {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingPreDefinedColour::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingPreDefinedCurveFont: IIfcPreDefinedCurveFont {}
#[derive(Default, Debug)]
pub struct IfcDraughtingPreDefinedCurveFont {
    name: IfcLabel,
}
impl IIfcPreDefinedItem for IfcDraughtingPreDefinedCurveFont {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedCurveFont for IfcDraughtingPreDefinedCurveFont {}
impl IIfcDraughtingPreDefinedCurveFont for IfcDraughtingPreDefinedCurveFont {}
impl IfcDraughtingPreDefinedCurveFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingPreDefinedCurveFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDraughtingPreDefinedTextFont: IIfcPreDefinedTextFont {}
#[derive(Default, Debug)]
pub struct IfcDraughtingPreDefinedTextFont {
    name: IfcLabel,
}
impl IIfcPreDefinedItem for IfcDraughtingPreDefinedTextFont {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedTextFont for IfcDraughtingPreDefinedTextFont {}
impl IIfcDraughtingPreDefinedTextFont for IfcDraughtingPreDefinedTextFont {}
impl IfcDraughtingPreDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDraughtingPreDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcDuctFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDuctFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDuctFittingTypeEnum,
}
impl IIfcRoot for IfcDuctFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctFittingType {}
impl IIfcTypeObject for IfcDuctFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDuctFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDuctFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDuctFittingType {}
impl IIfcDistributionFlowElementType for IfcDuctFittingType {}
impl IIfcFlowFittingType for IfcDuctFittingType {}
impl IIfcDuctFittingType for IfcDuctFittingType {
    fn predefined_type(&self) -> &IfcDuctFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcDuctFittingType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcDuctSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDuctSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDuctSegmentTypeEnum,
}
impl IIfcRoot for IfcDuctSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctSegmentType {}
impl IIfcTypeObject for IfcDuctSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDuctSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDuctSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDuctSegmentType {}
impl IIfcDistributionFlowElementType for IfcDuctSegmentType {}
impl IIfcFlowSegmentType for IfcDuctSegmentType {}
impl IIfcDuctSegmentType for IfcDuctSegmentType {
    fn predefined_type(&self) -> &IfcDuctSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcDuctSegmentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcDuctSilencerType: IIfcFlowTreatmentDeviceType {
    fn predefined_type(&self) -> &IfcDuctSilencerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcDuctSilencerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcDuctSilencerTypeEnum,
}
impl IIfcRoot for IfcDuctSilencerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcDuctSilencerType {}
impl IIfcTypeObject for IfcDuctSilencerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcDuctSilencerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcDuctSilencerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcDuctSilencerType {}
impl IIfcDistributionFlowElementType for IfcDuctSilencerType {}
impl IIfcFlowTreatmentDeviceType for IfcDuctSilencerType {}
impl IIfcDuctSilencerType for IfcDuctSilencerType {
    fn predefined_type(&self) -> &IfcDuctSilencerTypeEnum {
        &self.predefined_type
    }
}
impl IfcDuctSilencerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcDuctSilencerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEdge: IIfcTopologicalRepresentationItem {
    fn edge_start(&self) -> &EntityRef;
    fn edge_end(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcEdge {
    edge_start: EntityRef,
    edge_end: EntityRef,
}
impl IIfcRepresentationItem for IfcEdge {}
impl IIfcTopologicalRepresentationItem for IfcEdge {}
impl IIfcEdge for IfcEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IfcEdge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEdgeCurve: IIfcEdge {
    fn edge_geometry(&self) -> &EntityRef;
    fn same_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcEdgeCurve {
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_geometry: EntityRef,
    same_sense: bool,
}
impl IIfcRepresentationItem for IfcEdgeCurve {}
impl IIfcTopologicalRepresentationItem for IfcEdgeCurve {}
impl IIfcEdge for IfcEdgeCurve {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IIfcEdgeCurve for IfcEdgeCurve {
    fn edge_geometry(&self) -> &EntityRef {
        &self.edge_geometry
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IfcEdgeCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdgeCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                2usize => entity.edge_geometry = parameter.into(),
                3usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEdgeFeature: IIfcFeatureElementSubtraction {
    fn feature_length(&self) -> &Option<IfcPositiveLengthMeasure>;
}
pub trait IIfcEdgeLoop: IIfcLoop {
    fn edge_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcEdgeLoop {
    edge_list: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcEdgeLoop {}
impl IIfcTopologicalRepresentationItem for IfcEdgeLoop {}
impl IIfcLoop for IfcEdgeLoop {}
impl IIfcEdgeLoop for IfcEdgeLoop {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl IfcEdgeLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEdgeLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricApplianceType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcElectricApplianceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricApplianceType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricApplianceTypeEnum,
}
impl IIfcRoot for IfcElectricApplianceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricApplianceType {}
impl IIfcTypeObject for IfcElectricApplianceType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricApplianceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricApplianceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricApplianceType {}
impl IIfcDistributionFlowElementType for IfcElectricApplianceType {}
impl IIfcFlowTerminalType for IfcElectricApplianceType {}
impl IIfcElectricApplianceType for IfcElectricApplianceType {
    fn predefined_type(&self) -> &IfcElectricApplianceTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricApplianceType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricApplianceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricDistributionPoint: IIfcFlowController {
    fn distribution_point_function(&self) -> &IfcElectricDistributionPointFunctionEnum;
    fn user_defined_function(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcElectricDistributionPoint {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    distribution_point_function: IfcElectricDistributionPointFunctionEnum,
    user_defined_function: Option<IfcLabel>,
}
impl IIfcRoot for IfcElectricDistributionPoint {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricDistributionPoint {}
impl IIfcObject for IfcElectricDistributionPoint {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricDistributionPoint {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricDistributionPoint {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcElectricDistributionPoint {}
impl IIfcDistributionFlowElement for IfcElectricDistributionPoint {}
impl IIfcFlowController for IfcElectricDistributionPoint {}
impl IIfcElectricDistributionPoint for IfcElectricDistributionPoint {
    fn distribution_point_function(&self) -> &IfcElectricDistributionPointFunctionEnum {
        &self.distribution_point_function
    }
    fn user_defined_function(&self) -> &Option<IfcLabel> {
        &self.user_defined_function
    }
}
impl IfcElectricDistributionPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricDistributionPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.distribution_point_function = parameter.into(),
                9usize => {
                    entity.user_defined_function = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricFlowStorageDeviceType: IIfcFlowStorageDeviceType {
    fn predefined_type(&self) -> &IfcElectricFlowStorageDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricFlowStorageDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricFlowStorageDeviceTypeEnum,
}
impl IIfcRoot for IfcElectricFlowStorageDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricFlowStorageDeviceType {}
impl IIfcTypeObject for IfcElectricFlowStorageDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricFlowStorageDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricFlowStorageDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricFlowStorageDeviceType {}
impl IIfcDistributionFlowElementType for IfcElectricFlowStorageDeviceType {}
impl IIfcFlowStorageDeviceType for IfcElectricFlowStorageDeviceType {}
impl IIfcElectricFlowStorageDeviceType for IfcElectricFlowStorageDeviceType {
    fn predefined_type(&self) -> &IfcElectricFlowStorageDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricFlowStorageDeviceType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricFlowStorageDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricGeneratorType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcElectricGeneratorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricGeneratorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricGeneratorTypeEnum,
}
impl IIfcRoot for IfcElectricGeneratorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricGeneratorType {}
impl IIfcTypeObject for IfcElectricGeneratorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricGeneratorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricGeneratorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricGeneratorType {}
impl IIfcDistributionFlowElementType for IfcElectricGeneratorType {}
impl IIfcEnergyConversionDeviceType for IfcElectricGeneratorType {}
impl IIfcElectricGeneratorType for IfcElectricGeneratorType {
    fn predefined_type(&self) -> &IfcElectricGeneratorTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricGeneratorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricGeneratorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricHeaterType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcElectricHeaterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricHeaterType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricHeaterTypeEnum,
}
impl IIfcRoot for IfcElectricHeaterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricHeaterType {}
impl IIfcTypeObject for IfcElectricHeaterType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricHeaterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricHeaterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricHeaterType {}
impl IIfcDistributionFlowElementType for IfcElectricHeaterType {}
impl IIfcFlowTerminalType for IfcElectricHeaterType {}
impl IIfcElectricHeaterType for IfcElectricHeaterType {
    fn predefined_type(&self) -> &IfcElectricHeaterTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricHeaterType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricHeaterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricMotorType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcElectricMotorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricMotorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricMotorTypeEnum,
}
impl IIfcRoot for IfcElectricMotorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricMotorType {}
impl IIfcTypeObject for IfcElectricMotorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricMotorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricMotorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricMotorType {}
impl IIfcDistributionFlowElementType for IfcElectricMotorType {}
impl IIfcEnergyConversionDeviceType for IfcElectricMotorType {}
impl IIfcElectricMotorType for IfcElectricMotorType {
    fn predefined_type(&self) -> &IfcElectricMotorTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricMotorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricMotorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricTimeControlType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcElectricTimeControlTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElectricTimeControlType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcElectricTimeControlTypeEnum,
}
impl IIfcRoot for IfcElectricTimeControlType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricTimeControlType {}
impl IIfcTypeObject for IfcElectricTimeControlType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcElectricTimeControlType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcElectricTimeControlType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcElectricTimeControlType {}
impl IIfcDistributionFlowElementType for IfcElectricTimeControlType {}
impl IIfcFlowControllerType for IfcElectricTimeControlType {}
impl IIfcElectricTimeControlType for IfcElectricTimeControlType {
    fn predefined_type(&self) -> &IfcElectricTimeControlTypeEnum {
        &self.predefined_type
    }
}
impl IfcElectricTimeControlType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricTimeControlType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricalBaseProperties: IIfcEnergyProperties {
    fn electric_current_type(&self) -> &Option<IfcElectricCurrentEnum>;
    fn input_voltage(&self) -> &IfcElectricVoltageMeasure;
    fn input_frequency(&self) -> &IfcFrequencyMeasure;
    fn full_load_current(&self) -> &Option<IfcElectricCurrentMeasure>;
    fn minimum_circuit_current(&self) -> &Option<IfcElectricCurrentMeasure>;
    fn maximum_power_input(&self) -> &Option<IfcPowerMeasure>;
    fn rated_power_input(&self) -> &Option<IfcPowerMeasure>;
    fn input_phase(&self) -> i64;
}
#[derive(Default, Debug)]
pub struct IfcElectricalBaseProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    energy_sequence: Option<IfcEnergySequenceEnum>,
    user_defined_energy_sequence: Option<IfcLabel>,
    electric_current_type: Option<IfcElectricCurrentEnum>,
    input_voltage: IfcElectricVoltageMeasure,
    input_frequency: IfcFrequencyMeasure,
    full_load_current: Option<IfcElectricCurrentMeasure>,
    minimum_circuit_current: Option<IfcElectricCurrentMeasure>,
    maximum_power_input: Option<IfcPowerMeasure>,
    rated_power_input: Option<IfcPowerMeasure>,
    input_phase: i64,
}
impl IIfcRoot for IfcElectricalBaseProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcElectricalBaseProperties {}
impl IIfcPropertySetDefinition for IfcElectricalBaseProperties {}
impl IIfcEnergyProperties for IfcElectricalBaseProperties {
    fn energy_sequence(&self) -> &Option<IfcEnergySequenceEnum> {
        &self.energy_sequence
    }
    fn user_defined_energy_sequence(&self) -> &Option<IfcLabel> {
        &self.user_defined_energy_sequence
    }
}
impl IIfcElectricalBaseProperties for IfcElectricalBaseProperties {
    fn electric_current_type(&self) -> &Option<IfcElectricCurrentEnum> {
        &self.electric_current_type
    }
    fn input_voltage(&self) -> &IfcElectricVoltageMeasure {
        &self.input_voltage
    }
    fn input_frequency(&self) -> &IfcFrequencyMeasure {
        &self.input_frequency
    }
    fn full_load_current(&self) -> &Option<IfcElectricCurrentMeasure> {
        &self.full_load_current
    }
    fn minimum_circuit_current(&self) -> &Option<IfcElectricCurrentMeasure> {
        &self.minimum_circuit_current
    }
    fn maximum_power_input(&self) -> &Option<IfcPowerMeasure> {
        &self.maximum_power_input
    }
    fn rated_power_input(&self) -> &Option<IfcPowerMeasure> {
        &self.rated_power_input
    }
    fn input_phase(&self) -> i64 {
        self.input_phase
    }
}
impl IfcElectricalBaseProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricalBaseProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.energy_sequence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.user_defined_energy_sequence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.electric_current_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.input_voltage = parameter.into(),
                8usize => entity.input_frequency = parameter.into(),
                9usize => {
                    entity.full_load_current = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.minimum_circuit_current = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.maximum_power_input = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.rated_power_input = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => entity.input_phase = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricalCircuit: IIfcSystem {}
#[derive(Default, Debug)]
pub struct IfcElectricalCircuit {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcElectricalCircuit {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricalCircuit {}
impl IIfcObject for IfcElectricalCircuit {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcElectricalCircuit {}
impl IIfcSystem for IfcElectricalCircuit {}
impl IIfcElectricalCircuit for IfcElectricalCircuit {}
impl IfcElectricalCircuit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricalCircuit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElectricalElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcElectricalElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcElectricalElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElectricalElement {}
impl IIfcObject for IfcElectricalElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElectricalElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElectricalElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElectricalElement for IfcElectricalElement {}
impl IfcElectricalElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElectricalElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElement: IIfcProduct {
    fn tag(&self) -> &Option<IfcIdentifier>;
}
pub trait IIfcElementAssembly: IIfcElement {
    fn assembly_place(&self) -> &Option<IfcAssemblyPlaceEnum>;
    fn predefined_type(&self) -> &IfcElementAssemblyTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcElementAssembly {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    assembly_place: Option<IfcAssemblyPlaceEnum>,
    predefined_type: IfcElementAssemblyTypeEnum,
}
impl IIfcRoot for IfcElementAssembly {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcElementAssembly {}
impl IIfcObject for IfcElementAssembly {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcElementAssembly {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcElementAssembly {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementAssembly for IfcElementAssembly {
    fn assembly_place(&self) -> &Option<IfcAssemblyPlaceEnum> {
        &self.assembly_place
    }
    fn predefined_type(&self) -> &IfcElementAssemblyTypeEnum {
        &self.predefined_type
    }
}
impl IfcElementAssembly {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementAssembly::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.assembly_place = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElementComponent: IIfcElement {}
pub trait IIfcElementComponentType: IIfcElementType {}
pub trait IIfcElementQuantity: IIfcPropertySetDefinition {
    fn method_of_measurement(&self) -> &Option<IfcLabel>;
    fn quantities(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcElementQuantity {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    method_of_measurement: Option<IfcLabel>,
    quantities: HashSet<EntityRef>,
}
impl IIfcRoot for IfcElementQuantity {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcElementQuantity {}
impl IIfcPropertySetDefinition for IfcElementQuantity {}
impl IIfcElementQuantity for IfcElementQuantity {
    fn method_of_measurement(&self) -> &Option<IfcLabel> {
        &self.method_of_measurement
    }
    fn quantities(&self) -> &HashSet<EntityRef> {
        &self.quantities
    }
}
impl IfcElementQuantity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcElementQuantity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.method_of_measurement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.quantities = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcElementType: IIfcTypeProduct {
    fn element_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcElementarySurface: IIfcSurface {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcEllipse: IIfcConic {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure;
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcEllipse {
    position: EntityRef,
    semi_axis1: IfcPositiveLengthMeasure,
    semi_axis2: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcEllipse {}
impl IIfcGeometricRepresentationItem for IfcEllipse {}
impl IIfcCurve for IfcEllipse {}
impl IIfcConic for IfcEllipse {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcEllipse for IfcEllipse {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis1
    }
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis2
    }
}
impl IfcEllipse {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEllipse::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.semi_axis1 = parameter.into(),
                2usize => entity.semi_axis2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEllipseProfileDef: IIfcParameterizedProfileDef {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure;
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcEllipseProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    semi_axis1: IfcPositiveLengthMeasure,
    semi_axis2: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcEllipseProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcEllipseProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcEllipseProfileDef for IfcEllipseProfileDef {
    fn semi_axis1(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis1
    }
    fn semi_axis2(&self) -> &IfcPositiveLengthMeasure {
        &self.semi_axis2
    }
}
impl IfcEllipseProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEllipseProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.semi_axis1 = parameter.into(),
                4usize => entity.semi_axis2 = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEnergyConversionDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcEnergyConversionDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcEnergyConversionDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEnergyConversionDevice {}
impl IIfcObject for IfcEnergyConversionDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcEnergyConversionDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcEnergyConversionDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcEnergyConversionDevice {}
impl IIfcDistributionFlowElement for IfcEnergyConversionDevice {}
impl IIfcEnergyConversionDevice for IfcEnergyConversionDevice {}
impl IfcEnergyConversionDevice {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEnergyConversionDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEnergyConversionDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcEnergyProperties: IIfcPropertySetDefinition {
    fn energy_sequence(&self) -> &Option<IfcEnergySequenceEnum>;
    fn user_defined_energy_sequence(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcEnergyProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    energy_sequence: Option<IfcEnergySequenceEnum>,
    user_defined_energy_sequence: Option<IfcLabel>,
}
impl IIfcRoot for IfcEnergyProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcEnergyProperties {}
impl IIfcPropertySetDefinition for IfcEnergyProperties {}
impl IIfcEnergyProperties for IfcEnergyProperties {
    fn energy_sequence(&self) -> &Option<IfcEnergySequenceEnum> {
        &self.energy_sequence
    }
    fn user_defined_energy_sequence(&self) -> &Option<IfcLabel> {
        &self.user_defined_energy_sequence
    }
}
impl IfcEnergyProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEnergyProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.energy_sequence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.user_defined_energy_sequence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEnvironmentalImpactValue: IIfcAppliedValue {
    fn impact_type(&self) -> &IfcLabel;
    fn category(&self) -> &IfcEnvironmentalImpactCategoryEnum;
    fn user_defined_category(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcEnvironmentalImpactValue {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applied_value: Option<IfcAppliedValueSelect>,
    unit_basis: Option<EntityRef>,
    applicable_date: Option<EntityRef>,
    fixed_until_date: Option<EntityRef>,
    impact_type: IfcLabel,
    category: IfcEnvironmentalImpactCategoryEnum,
    user_defined_category: Option<IfcLabel>,
}
impl IIfcAppliedValue for IfcEnvironmentalImpactValue {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn applied_value(&self) -> &Option<IfcAppliedValueSelect> {
        &self.applied_value
    }
    fn unit_basis(&self) -> &Option<EntityRef> {
        &self.unit_basis
    }
    fn applicable_date(&self) -> &Option<EntityRef> {
        &self.applicable_date
    }
    fn fixed_until_date(&self) -> &Option<EntityRef> {
        &self.fixed_until_date
    }
}
impl IIfcEnvironmentalImpactValue for IfcEnvironmentalImpactValue {
    fn impact_type(&self) -> &IfcLabel {
        &self.impact_type
    }
    fn category(&self) -> &IfcEnvironmentalImpactCategoryEnum {
        &self.category
    }
    fn user_defined_category(&self) -> &Option<IfcLabel> {
        &self.user_defined_category
    }
}
impl IfcEnvironmentalImpactValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEnvironmentalImpactValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.applied_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit_basis = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.fixed_until_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.impact_type = parameter.into(),
                7usize => entity.category = parameter.into(),
                8usize => {
                    entity.user_defined_category = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEquipmentElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcEquipmentElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcEquipmentElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEquipmentElement {}
impl IIfcObject for IfcEquipmentElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcEquipmentElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcEquipmentElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcEquipmentElement for IfcEquipmentElement {}
impl IfcEquipmentElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEquipmentElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEquipmentStandard: IIfcControl {}
#[derive(Default, Debug)]
pub struct IfcEquipmentStandard {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcEquipmentStandard {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEquipmentStandard {}
impl IIfcObject for IfcEquipmentStandard {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcEquipmentStandard {}
impl IIfcEquipmentStandard for IfcEquipmentStandard {}
impl IfcEquipmentStandard {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEquipmentStandard::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvaporativeCoolerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcEvaporativeCoolerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcEvaporativeCoolerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcEvaporativeCoolerTypeEnum,
}
impl IIfcRoot for IfcEvaporativeCoolerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvaporativeCoolerType {}
impl IIfcTypeObject for IfcEvaporativeCoolerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcEvaporativeCoolerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcEvaporativeCoolerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcEvaporativeCoolerType {}
impl IIfcDistributionFlowElementType for IfcEvaporativeCoolerType {}
impl IIfcEnergyConversionDeviceType for IfcEvaporativeCoolerType {}
impl IIfcEvaporativeCoolerType for IfcEvaporativeCoolerType {
    fn predefined_type(&self) -> &IfcEvaporativeCoolerTypeEnum {
        &self.predefined_type
    }
}
impl IfcEvaporativeCoolerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporativeCoolerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcEvaporatorType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcEvaporatorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcEvaporatorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcEvaporatorTypeEnum,
}
impl IIfcRoot for IfcEvaporatorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcEvaporatorType {}
impl IIfcTypeObject for IfcEvaporatorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcEvaporatorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcEvaporatorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcEvaporatorType {}
impl IIfcDistributionFlowElementType for IfcEvaporatorType {}
impl IIfcEnergyConversionDeviceType for IfcEvaporatorType {}
impl IIfcEvaporatorType for IfcEvaporatorType {
    fn predefined_type(&self) -> &IfcEvaporatorTypeEnum {
        &self.predefined_type
    }
}
impl IfcEvaporatorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcEvaporatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExtendedMaterialProperties: IIfcMaterialProperties {
    fn extended_properties(&self) -> &HashSet<EntityRef>;
    fn description(&self) -> &Option<IfcText>;
    fn name(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcExtendedMaterialProperties {
    material: EntityRef,
    extended_properties: HashSet<EntityRef>,
    description: Option<IfcText>,
    name: IfcLabel,
}
impl IIfcMaterialProperties for IfcExtendedMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcExtendedMaterialProperties for IfcExtendedMaterialProperties {
    fn extended_properties(&self) -> &HashSet<EntityRef> {
        &self.extended_properties
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IfcExtendedMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExtendedMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => entity.extended_properties = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternalReference {
    fn location(&self) -> &Option<IfcLabel>;
    fn item_reference(&self) -> &Option<IfcIdentifier>;
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcExternallyDefinedHatchStyle: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedHatchStyle {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedHatchStyle {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedHatchStyle for IfcExternallyDefinedHatchStyle {}
impl IfcExternallyDefinedHatchStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedHatchStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternallyDefinedSurfaceStyle: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedSurfaceStyle {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedSurfaceStyle {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedSurfaceStyle for IfcExternallyDefinedSurfaceStyle {}
impl IfcExternallyDefinedSurfaceStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedSurfaceStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternallyDefinedSymbol: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedSymbol {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedSymbol {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedSymbol for IfcExternallyDefinedSymbol {}
impl IfcExternallyDefinedSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExternallyDefinedTextFont: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcExternallyDefinedTextFont {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcExternallyDefinedTextFont {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcExternallyDefinedTextFont for IfcExternallyDefinedTextFont {}
impl IfcExternallyDefinedTextFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExternallyDefinedTextFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcExtrudedAreaSolid: IIfcSweptAreaSolid {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcExtrudedAreaSolid {
    swept_area: EntityRef,
    position: EntityRef,
    extruded_direction: EntityRef,
    depth: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcExtrudedAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcExtrudedAreaSolid {}
impl IIfcSolidModel for IfcExtrudedAreaSolid {}
impl IIfcSweptAreaSolid for IfcExtrudedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcExtrudedAreaSolid for IfcExtrudedAreaSolid {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
}
impl IfcExtrudedAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcExtrudedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFace: IIfcTopologicalRepresentationItem {
    fn bounds(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFace {
    bounds: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcFace {}
impl IIfcTopologicalRepresentationItem for IfcFace {}
impl IIfcFace for IfcFace {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IfcFace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bounds = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceBasedSurfaceModel: IIfcGeometricRepresentationItem {
    fn fbsm_faces(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFaceBasedSurfaceModel {
    fbsm_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcFaceBasedSurfaceModel {}
impl IIfcGeometricRepresentationItem for IfcFaceBasedSurfaceModel {}
impl IIfcFaceBasedSurfaceModel for IfcFaceBasedSurfaceModel {
    fn fbsm_faces(&self) -> &HashSet<EntityRef> {
        &self.fbsm_faces
    }
}
impl IfcFaceBasedSurfaceModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.fbsm_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceBound: IIfcTopologicalRepresentationItem {
    fn bound(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcFaceBound {
    bound: EntityRef,
    orientation: bool,
}
impl IIfcRepresentationItem for IfcFaceBound {}
impl IIfcTopologicalRepresentationItem for IfcFaceBound {}
impl IIfcFaceBound for IfcFaceBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IfcFaceBound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bound = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceOuterBound: IIfcFaceBound {}
#[derive(Default, Debug)]
pub struct IfcFaceOuterBound {
    bound: EntityRef,
    orientation: bool,
}
impl IIfcRepresentationItem for IfcFaceOuterBound {}
impl IIfcTopologicalRepresentationItem for IfcFaceOuterBound {}
impl IIfcFaceBound for IfcFaceOuterBound {
    fn bound(&self) -> &EntityRef {
        &self.bound
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IIfcFaceOuterBound for IfcFaceOuterBound {}
impl IfcFaceOuterBound {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceOuterBound::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bound = parameter.into(),
                1usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFaceSurface: IIfcFace {
    fn face_surface(&self) -> &EntityRef;
    fn same_sense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcFaceSurface {
    bounds: HashSet<EntityRef>,
    face_surface: EntityRef,
    same_sense: bool,
}
impl IIfcRepresentationItem for IfcFaceSurface {}
impl IIfcTopologicalRepresentationItem for IfcFaceSurface {}
impl IIfcFace for IfcFaceSurface {
    fn bounds(&self) -> &HashSet<EntityRef> {
        &self.bounds
    }
}
impl IIfcFaceSurface for IfcFaceSurface {
    fn face_surface(&self) -> &EntityRef {
        &self.face_surface
    }
    fn same_sense(&self) -> bool {
        self.same_sense
    }
}
impl IfcFaceSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFaceSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.bounds = parameter.into(),
                1usize => entity.face_surface = parameter.into(),
                2usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFacetedBrep: IIfcManifoldSolidBrep {}
#[derive(Default, Debug)]
pub struct IfcFacetedBrep {
    outer: EntityRef,
}
impl IIfcRepresentationItem for IfcFacetedBrep {}
impl IIfcGeometricRepresentationItem for IfcFacetedBrep {}
impl IIfcSolidModel for IfcFacetedBrep {}
impl IIfcManifoldSolidBrep for IfcFacetedBrep {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IIfcFacetedBrep for IfcFacetedBrep {}
impl IfcFacetedBrep {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFacetedBrep::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFacetedBrepWithVoids: IIfcManifoldSolidBrep {
    fn voids(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFacetedBrepWithVoids {
    outer: EntityRef,
    voids: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcFacetedBrepWithVoids {}
impl IIfcGeometricRepresentationItem for IfcFacetedBrepWithVoids {}
impl IIfcSolidModel for IfcFacetedBrepWithVoids {}
impl IIfcManifoldSolidBrep for IfcFacetedBrepWithVoids {
    fn outer(&self) -> &EntityRef {
        &self.outer
    }
}
impl IIfcFacetedBrepWithVoids for IfcFacetedBrepWithVoids {
    fn voids(&self) -> &HashSet<EntityRef> {
        &self.voids
    }
}
impl IfcFacetedBrepWithVoids {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFacetedBrepWithVoids::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.outer = parameter.into(),
                1usize => entity.voids = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFailureConnectionCondition: IIfcStructuralConnectionCondition {
    fn tension_failure_x(&self) -> &Option<IfcForceMeasure>;
    fn tension_failure_y(&self) -> &Option<IfcForceMeasure>;
    fn tension_failure_z(&self) -> &Option<IfcForceMeasure>;
    fn compression_failure_x(&self) -> &Option<IfcForceMeasure>;
    fn compression_failure_y(&self) -> &Option<IfcForceMeasure>;
    fn compression_failure_z(&self) -> &Option<IfcForceMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcFailureConnectionCondition {
    name: Option<IfcLabel>,
    tension_failure_x: Option<IfcForceMeasure>,
    tension_failure_y: Option<IfcForceMeasure>,
    tension_failure_z: Option<IfcForceMeasure>,
    compression_failure_x: Option<IfcForceMeasure>,
    compression_failure_y: Option<IfcForceMeasure>,
    compression_failure_z: Option<IfcForceMeasure>,
}
impl IIfcStructuralConnectionCondition for IfcFailureConnectionCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcFailureConnectionCondition for IfcFailureConnectionCondition {
    fn tension_failure_x(&self) -> &Option<IfcForceMeasure> {
        &self.tension_failure_x
    }
    fn tension_failure_y(&self) -> &Option<IfcForceMeasure> {
        &self.tension_failure_y
    }
    fn tension_failure_z(&self) -> &Option<IfcForceMeasure> {
        &self.tension_failure_z
    }
    fn compression_failure_x(&self) -> &Option<IfcForceMeasure> {
        &self.compression_failure_x
    }
    fn compression_failure_y(&self) -> &Option<IfcForceMeasure> {
        &self.compression_failure_y
    }
    fn compression_failure_z(&self) -> &Option<IfcForceMeasure> {
        &self.compression_failure_z
    }
}
impl IfcFailureConnectionCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFailureConnectionCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.tension_failure_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.tension_failure_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.tension_failure_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.compression_failure_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.compression_failure_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.compression_failure_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFanType: IIfcFlowMovingDeviceType {
    fn predefined_type(&self) -> &IfcFanTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFanType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFanTypeEnum,
}
impl IIfcRoot for IfcFanType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFanType {}
impl IIfcTypeObject for IfcFanType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFanType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFanType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFanType {}
impl IIfcDistributionFlowElementType for IfcFanType {}
impl IIfcFlowMovingDeviceType for IfcFanType {}
impl IIfcFanType for IfcFanType {
    fn predefined_type(&self) -> &IfcFanTypeEnum {
        &self.predefined_type
    }
}
impl IfcFanType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFanType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFastener: IIfcElementComponent {}
#[derive(Default, Debug)]
pub struct IfcFastener {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFastener {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFastener {}
impl IIfcObject for IfcFastener {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFastener {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFastener {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcFastener {}
impl IIfcFastener for IfcFastener {}
impl IfcFastener {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFastener::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFastenerType: IIfcElementComponentType {}
#[derive(Default, Debug)]
pub struct IfcFastenerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcFastenerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFastenerType {}
impl IIfcTypeObject for IfcFastenerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFastenerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFastenerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcFastenerType {}
impl IIfcFastenerType for IfcFastenerType {}
impl IfcFastenerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFastenerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFeatureElement: IIfcElement {}
pub trait IIfcFeatureElementAddition: IIfcFeatureElement {}
pub trait IIfcFeatureElementSubtraction: IIfcFeatureElement {}
pub trait IIfcFillAreaStyle: IIfcPresentationStyle {
    fn fill_styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyle {
    name: Option<IfcLabel>,
    fill_styles: HashSet<EntityRef>,
}
impl IIfcPresentationStyle for IfcFillAreaStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcFillAreaStyle for IfcFillAreaStyle {
    fn fill_styles(&self) -> &HashSet<EntityRef> {
        &self.fill_styles
    }
}
impl IfcFillAreaStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.fill_styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFillAreaStyleHatching: IIfcGeometricRepresentationItem {
    fn hatch_line_appearance(&self) -> &EntityRef;
    fn start_of_next_hatch_line(&self) -> &IfcHatchLineDistanceSelect;
    fn point_of_reference_hatch_line(&self) -> &Option<EntityRef>;
    fn pattern_start(&self) -> &Option<EntityRef>;
    fn hatch_line_angle(&self) -> &IfcPlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyleHatching {
    hatch_line_appearance: EntityRef,
    start_of_next_hatch_line: IfcHatchLineDistanceSelect,
    point_of_reference_hatch_line: Option<EntityRef>,
    pattern_start: Option<EntityRef>,
    hatch_line_angle: IfcPlaneAngleMeasure,
}
impl IIfcRepresentationItem for IfcFillAreaStyleHatching {}
impl IIfcGeometricRepresentationItem for IfcFillAreaStyleHatching {}
impl IIfcFillAreaStyleHatching for IfcFillAreaStyleHatching {
    fn hatch_line_appearance(&self) -> &EntityRef {
        &self.hatch_line_appearance
    }
    fn start_of_next_hatch_line(&self) -> &IfcHatchLineDistanceSelect {
        &self.start_of_next_hatch_line
    }
    fn point_of_reference_hatch_line(&self) -> &Option<EntityRef> {
        &self.point_of_reference_hatch_line
    }
    fn pattern_start(&self) -> &Option<EntityRef> {
        &self.pattern_start
    }
    fn hatch_line_angle(&self) -> &IfcPlaneAngleMeasure {
        &self.hatch_line_angle
    }
}
impl IfcFillAreaStyleHatching {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyleHatching::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hatch_line_appearance = parameter.into(),
                1usize => entity.start_of_next_hatch_line = parameter.into(),
                2usize => {
                    entity.point_of_reference_hatch_line = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.pattern_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.hatch_line_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFillAreaStyleTileSymbolWithStyle: IIfcGeometricRepresentationItem {
    fn symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyleTileSymbolWithStyle {
    symbol: EntityRef,
}
impl IIfcRepresentationItem for IfcFillAreaStyleTileSymbolWithStyle {}
impl IIfcGeometricRepresentationItem for IfcFillAreaStyleTileSymbolWithStyle {}
impl IIfcFillAreaStyleTileSymbolWithStyle for IfcFillAreaStyleTileSymbolWithStyle {
    fn symbol(&self) -> &EntityRef {
        &self.symbol
    }
}
impl IfcFillAreaStyleTileSymbolWithStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyleTileSymbolWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFillAreaStyleTiles: IIfcGeometricRepresentationItem {
    fn tiling_pattern(&self) -> &EntityRef;
    fn tiles(&self) -> &HashSet<EntityRef>;
    fn tiling_scale(&self) -> &IfcPositiveRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcFillAreaStyleTiles {
    tiling_pattern: EntityRef,
    tiles: HashSet<EntityRef>,
    tiling_scale: IfcPositiveRatioMeasure,
}
impl IIfcRepresentationItem for IfcFillAreaStyleTiles {}
impl IIfcGeometricRepresentationItem for IfcFillAreaStyleTiles {}
impl IIfcFillAreaStyleTiles for IfcFillAreaStyleTiles {
    fn tiling_pattern(&self) -> &EntityRef {
        &self.tiling_pattern
    }
    fn tiles(&self) -> &HashSet<EntityRef> {
        &self.tiles
    }
    fn tiling_scale(&self) -> &IfcPositiveRatioMeasure {
        &self.tiling_scale
    }
}
impl IfcFillAreaStyleTiles {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFillAreaStyleTiles::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.tiling_pattern = parameter.into(),
                1usize => entity.tiles = parameter.into(),
                2usize => entity.tiling_scale = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFilterType: IIfcFlowTreatmentDeviceType {
    fn predefined_type(&self) -> &IfcFilterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFilterType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFilterTypeEnum,
}
impl IIfcRoot for IfcFilterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFilterType {}
impl IIfcTypeObject for IfcFilterType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFilterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFilterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFilterType {}
impl IIfcDistributionFlowElementType for IfcFilterType {}
impl IIfcFlowTreatmentDeviceType for IfcFilterType {}
impl IIfcFilterType for IfcFilterType {
    fn predefined_type(&self) -> &IfcFilterTypeEnum {
        &self.predefined_type
    }
}
impl IfcFilterType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFilterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFireSuppressionTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcFireSuppressionTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFireSuppressionTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFireSuppressionTerminalTypeEnum,
}
impl IIfcRoot for IfcFireSuppressionTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFireSuppressionTerminalType {}
impl IIfcTypeObject for IfcFireSuppressionTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFireSuppressionTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFireSuppressionTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFireSuppressionTerminalType {}
impl IIfcDistributionFlowElementType for IfcFireSuppressionTerminalType {}
impl IIfcFlowTerminalType for IfcFireSuppressionTerminalType {}
impl IIfcFireSuppressionTerminalType for IfcFireSuppressionTerminalType {
    fn predefined_type(&self) -> &IfcFireSuppressionTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcFireSuppressionTerminalType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFireSuppressionTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowController: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowController {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowController {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowController {}
impl IIfcObject for IfcFlowController {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowController {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowController {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowController {}
impl IIfcDistributionFlowElement for IfcFlowController {}
impl IIfcFlowController for IfcFlowController {}
impl IfcFlowController {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowController::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowControllerType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowFitting: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowFitting {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowFitting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowFitting {}
impl IIfcObject for IfcFlowFitting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowFitting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowFitting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowFitting {}
impl IIfcDistributionFlowElement for IfcFlowFitting {}
impl IIfcFlowFitting for IfcFlowFitting {}
impl IfcFlowFitting {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowFitting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowFittingType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowInstrumentType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcFlowInstrumentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFlowInstrumentType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFlowInstrumentTypeEnum,
}
impl IIfcRoot for IfcFlowInstrumentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowInstrumentType {}
impl IIfcTypeObject for IfcFlowInstrumentType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFlowInstrumentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFlowInstrumentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFlowInstrumentType {}
impl IIfcDistributionControlElementType for IfcFlowInstrumentType {}
impl IIfcFlowInstrumentType for IfcFlowInstrumentType {
    fn predefined_type(&self) -> &IfcFlowInstrumentTypeEnum {
        &self.predefined_type
    }
}
impl IfcFlowInstrumentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowInstrumentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMeterType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcFlowMeterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFlowMeterType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcFlowMeterTypeEnum,
}
impl IIfcRoot for IfcFlowMeterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowMeterType {}
impl IIfcTypeObject for IfcFlowMeterType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFlowMeterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFlowMeterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcFlowMeterType {}
impl IIfcDistributionFlowElementType for IfcFlowMeterType {}
impl IIfcFlowControllerType for IfcFlowMeterType {}
impl IIfcFlowMeterType for IfcFlowMeterType {
    fn predefined_type(&self) -> &IfcFlowMeterTypeEnum {
        &self.predefined_type
    }
}
impl IfcFlowMeterType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMeterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMovingDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowMovingDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowMovingDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowMovingDevice {}
impl IIfcObject for IfcFlowMovingDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowMovingDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowMovingDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowMovingDevice {}
impl IIfcDistributionFlowElement for IfcFlowMovingDevice {}
impl IIfcFlowMovingDevice for IfcFlowMovingDevice {}
impl IfcFlowMovingDevice {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowMovingDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowMovingDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowSegment: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowSegment {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowSegment {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowSegment {}
impl IIfcObject for IfcFlowSegment {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowSegment {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowSegment {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowSegment {}
impl IIfcDistributionFlowElement for IfcFlowSegment {}
impl IIfcFlowSegment for IfcFlowSegment {}
impl IfcFlowSegment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowSegment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowSegmentType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowStorageDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowStorageDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowStorageDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowStorageDevice {}
impl IIfcObject for IfcFlowStorageDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowStorageDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowStorageDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowStorageDevice {}
impl IIfcDistributionFlowElement for IfcFlowStorageDevice {}
impl IIfcFlowStorageDevice for IfcFlowStorageDevice {}
impl IfcFlowStorageDevice {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowStorageDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowStorageDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowTerminal: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowTerminal {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowTerminal {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowTerminal {}
impl IIfcObject for IfcFlowTerminal {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowTerminal {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowTerminal {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowTerminal {}
impl IIfcDistributionFlowElement for IfcFlowTerminal {}
impl IIfcFlowTerminal for IfcFlowTerminal {}
impl IfcFlowTerminal {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowTerminal::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowTerminalType: IIfcDistributionFlowElementType {}
pub trait IIfcFlowTreatmentDevice: IIfcDistributionFlowElement {}
#[derive(Default, Debug)]
pub struct IfcFlowTreatmentDevice {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFlowTreatmentDevice {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFlowTreatmentDevice {}
impl IIfcObject for IfcFlowTreatmentDevice {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFlowTreatmentDevice {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFlowTreatmentDevice {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcDistributionElement for IfcFlowTreatmentDevice {}
impl IIfcDistributionFlowElement for IfcFlowTreatmentDevice {}
impl IIfcFlowTreatmentDevice for IfcFlowTreatmentDevice {}
impl IfcFlowTreatmentDevice {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFlowTreatmentDevice::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFlowTreatmentDeviceType: IIfcDistributionFlowElementType {}
pub trait IIfcFluidFlowProperties: IIfcPropertySetDefinition {
    fn property_source(&self) -> &IfcPropertySourceEnum;
    fn flow_condition_time_series(&self) -> &Option<EntityRef>;
    fn velocity_time_series(&self) -> &Option<EntityRef>;
    fn flowrate_time_series(&self) -> &Option<EntityRef>;
    fn fluid(&self) -> &EntityRef;
    fn pressure_time_series(&self) -> &Option<EntityRef>;
    fn user_defined_property_source(&self) -> &Option<IfcLabel>;
    fn temperature_single_value(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn wet_bulb_temperature_single_value(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn wet_bulb_temperature_time_series(&self) -> &Option<EntityRef>;
    fn temperature_time_series(&self) -> &Option<EntityRef>;
    fn flowrate_single_value(&self) -> &Option<IfcDerivedMeasureValue>;
    fn flow_condition_single_value(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn velocity_single_value(&self) -> &Option<IfcLinearVelocityMeasure>;
    fn pressure_single_value(&self) -> &Option<IfcPressureMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcFluidFlowProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    property_source: IfcPropertySourceEnum,
    flow_condition_time_series: Option<EntityRef>,
    velocity_time_series: Option<EntityRef>,
    flowrate_time_series: Option<EntityRef>,
    fluid: EntityRef,
    pressure_time_series: Option<EntityRef>,
    user_defined_property_source: Option<IfcLabel>,
    temperature_single_value: Option<IfcThermodynamicTemperatureMeasure>,
    wet_bulb_temperature_single_value: Option<IfcThermodynamicTemperatureMeasure>,
    wet_bulb_temperature_time_series: Option<EntityRef>,
    temperature_time_series: Option<EntityRef>,
    flowrate_single_value: Option<IfcDerivedMeasureValue>,
    flow_condition_single_value: Option<IfcPositiveRatioMeasure>,
    velocity_single_value: Option<IfcLinearVelocityMeasure>,
    pressure_single_value: Option<IfcPressureMeasure>,
}
impl IIfcRoot for IfcFluidFlowProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcFluidFlowProperties {}
impl IIfcPropertySetDefinition for IfcFluidFlowProperties {}
impl IIfcFluidFlowProperties for IfcFluidFlowProperties {
    fn property_source(&self) -> &IfcPropertySourceEnum {
        &self.property_source
    }
    fn flow_condition_time_series(&self) -> &Option<EntityRef> {
        &self.flow_condition_time_series
    }
    fn velocity_time_series(&self) -> &Option<EntityRef> {
        &self.velocity_time_series
    }
    fn flowrate_time_series(&self) -> &Option<EntityRef> {
        &self.flowrate_time_series
    }
    fn fluid(&self) -> &EntityRef {
        &self.fluid
    }
    fn pressure_time_series(&self) -> &Option<EntityRef> {
        &self.pressure_time_series
    }
    fn user_defined_property_source(&self) -> &Option<IfcLabel> {
        &self.user_defined_property_source
    }
    fn temperature_single_value(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.temperature_single_value
    }
    fn wet_bulb_temperature_single_value(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.wet_bulb_temperature_single_value
    }
    fn wet_bulb_temperature_time_series(&self) -> &Option<EntityRef> {
        &self.wet_bulb_temperature_time_series
    }
    fn temperature_time_series(&self) -> &Option<EntityRef> {
        &self.temperature_time_series
    }
    fn flowrate_single_value(&self) -> &Option<IfcDerivedMeasureValue> {
        &self.flowrate_single_value
    }
    fn flow_condition_single_value(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.flow_condition_single_value
    }
    fn velocity_single_value(&self) -> &Option<IfcLinearVelocityMeasure> {
        &self.velocity_single_value
    }
    fn pressure_single_value(&self) -> &Option<IfcPressureMeasure> {
        &self.pressure_single_value
    }
}
impl IfcFluidFlowProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFluidFlowProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.property_source = parameter.into(),
                5usize => {
                    entity.flow_condition_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.velocity_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.flowrate_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.fluid = parameter.into(),
                9usize => {
                    entity.pressure_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.user_defined_property_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.temperature_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.wet_bulb_temperature_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.wet_bulb_temperature_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.temperature_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.flowrate_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.flow_condition_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.velocity_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.pressure_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFooting: IIfcBuildingElement {
    fn predefined_type(&self) -> &IfcFootingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcFooting {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: IfcFootingTypeEnum,
}
impl IIfcRoot for IfcFooting {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFooting {}
impl IIfcObject for IfcFooting {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFooting {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFooting {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcFooting {}
impl IIfcFooting for IfcFooting {
    fn predefined_type(&self) -> &IfcFootingTypeEnum {
        &self.predefined_type
    }
}
impl IfcFooting {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFooting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFuelProperties: IIfcMaterialProperties {
    fn combustion_temperature(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn carbon_content(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn lower_heating_value(&self) -> &Option<IfcHeatingValueMeasure>;
    fn higher_heating_value(&self) -> &Option<IfcHeatingValueMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcFuelProperties {
    material: EntityRef,
    combustion_temperature: Option<IfcThermodynamicTemperatureMeasure>,
    carbon_content: Option<IfcPositiveRatioMeasure>,
    lower_heating_value: Option<IfcHeatingValueMeasure>,
    higher_heating_value: Option<IfcHeatingValueMeasure>,
}
impl IIfcMaterialProperties for IfcFuelProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcFuelProperties for IfcFuelProperties {
    fn combustion_temperature(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.combustion_temperature
    }
    fn carbon_content(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.carbon_content
    }
    fn lower_heating_value(&self) -> &Option<IfcHeatingValueMeasure> {
        &self.lower_heating_value
    }
    fn higher_heating_value(&self) -> &Option<IfcHeatingValueMeasure> {
        &self.higher_heating_value
    }
}
impl IfcFuelProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFuelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.combustion_temperature = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.carbon_content = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.lower_heating_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.higher_heating_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnishingElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcFurnishingElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcFurnishingElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnishingElement {}
impl IIfcObject for IfcFurnishingElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcFurnishingElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcFurnishingElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFurnishingElement for IfcFurnishingElement {}
impl IfcFurnishingElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnishingElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnishingElementType: IIfcElementType {}
#[derive(Default, Debug)]
pub struct IfcFurnishingElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcFurnishingElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnishingElementType {}
impl IIfcTypeObject for IfcFurnishingElementType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFurnishingElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFurnishingElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcFurnishingElementType for IfcFurnishingElementType {}
impl IfcFurnishingElementType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnishingElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnitureStandard: IIfcControl {}
#[derive(Default, Debug)]
pub struct IfcFurnitureStandard {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcFurnitureStandard {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnitureStandard {}
impl IIfcObject for IfcFurnitureStandard {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcFurnitureStandard {}
impl IIfcFurnitureStandard for IfcFurnitureStandard {}
impl IfcFurnitureStandard {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnitureStandard::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcFurnitureType: IIfcFurnishingElementType {
    fn assembly_place(&self) -> &IfcAssemblyPlaceEnum;
}
#[derive(Default, Debug)]
pub struct IfcFurnitureType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    assembly_place: IfcAssemblyPlaceEnum,
}
impl IIfcRoot for IfcFurnitureType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcFurnitureType {}
impl IIfcTypeObject for IfcFurnitureType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcFurnitureType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcFurnitureType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcFurnishingElementType for IfcFurnitureType {}
impl IIfcFurnitureType for IfcFurnitureType {
    fn assembly_place(&self) -> &IfcAssemblyPlaceEnum {
        &self.assembly_place
    }
}
impl IfcFurnitureType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcFurnitureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.assembly_place = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGasTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcGasTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcGasTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcGasTerminalTypeEnum,
}
impl IIfcRoot for IfcGasTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGasTerminalType {}
impl IIfcTypeObject for IfcGasTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcGasTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcGasTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcGasTerminalType {}
impl IIfcDistributionFlowElementType for IfcGasTerminalType {}
impl IIfcFlowTerminalType for IfcGasTerminalType {}
impl IIfcGasTerminalType for IfcGasTerminalType {
    fn predefined_type(&self) -> &IfcGasTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcGasTerminalType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGasTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeneralMaterialProperties: IIfcMaterialProperties {
    fn molecular_weight(&self) -> &Option<IfcMolecularWeightMeasure>;
    fn porosity(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn mass_density(&self) -> &Option<IfcMassDensityMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcGeneralMaterialProperties {
    material: EntityRef,
    molecular_weight: Option<IfcMolecularWeightMeasure>,
    porosity: Option<IfcNormalisedRatioMeasure>,
    mass_density: Option<IfcMassDensityMeasure>,
}
impl IIfcMaterialProperties for IfcGeneralMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcGeneralMaterialProperties for IfcGeneralMaterialProperties {
    fn molecular_weight(&self) -> &Option<IfcMolecularWeightMeasure> {
        &self.molecular_weight
    }
    fn porosity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.porosity
    }
    fn mass_density(&self) -> &Option<IfcMassDensityMeasure> {
        &self.mass_density
    }
}
impl IfcGeneralMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeneralMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.molecular_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.porosity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.mass_density = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeneralProfileProperties: IIfcProfileProperties {
    fn physical_weight(&self) -> &Option<IfcMassPerLengthMeasure>;
    fn perimeter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn minimum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn maximum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcGeneralProfileProperties {
    profile_name: Option<IfcLabel>,
    profile_definition: Option<EntityRef>,
    physical_weight: Option<IfcMassPerLengthMeasure>,
    perimeter: Option<IfcPositiveLengthMeasure>,
    minimum_plate_thickness: Option<IfcPositiveLengthMeasure>,
    maximum_plate_thickness: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
}
impl IIfcProfileProperties for IfcGeneralProfileProperties {
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
    fn profile_definition(&self) -> &Option<EntityRef> {
        &self.profile_definition
    }
}
impl IIfcGeneralProfileProperties for IfcGeneralProfileProperties {
    fn physical_weight(&self) -> &Option<IfcMassPerLengthMeasure> {
        &self.physical_weight
    }
    fn perimeter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.perimeter
    }
    fn minimum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.minimum_plate_thickness
    }
    fn maximum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.maximum_plate_thickness
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
}
impl IfcGeneralProfileProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeneralProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.profile_definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.physical_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.perimeter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.minimum_plate_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.maximum_plate_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricCurveSet: IIfcGeometricSet {}
#[derive(Default, Debug)]
pub struct IfcGeometricCurveSet {
    elements: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcGeometricCurveSet {}
impl IIfcGeometricRepresentationItem for IfcGeometricCurveSet {}
impl IIfcGeometricSet for IfcGeometricCurveSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IIfcGeometricCurveSet for IfcGeometricCurveSet {}
impl IfcGeometricCurveSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricCurveSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricRepresentationContext: IIfcRepresentationContext {
    fn coordinate_space_dimension(&self) -> &IfcDimensionCount;
    fn precision(&self) -> Option<Real>;
    fn world_coordinate_system(&self) -> &EntityRef;
    fn true_north(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcGeometricRepresentationContext {
    context_identifier: Option<IfcLabel>,
    context_type: Option<IfcLabel>,
    coordinate_space_dimension: IfcDimensionCount,
    precision: Option<Real>,
    world_coordinate_system: EntityRef,
    true_north: Option<EntityRef>,
}
impl IIfcRepresentationContext for IfcGeometricRepresentationContext {
    fn context_identifier(&self) -> &Option<IfcLabel> {
        &self.context_identifier
    }
    fn context_type(&self) -> &Option<IfcLabel> {
        &self.context_type
    }
}
impl IIfcGeometricRepresentationContext for IfcGeometricRepresentationContext {
    fn coordinate_space_dimension(&self) -> &IfcDimensionCount {
        &self.coordinate_space_dimension
    }
    fn precision(&self) -> Option<Real> {
        self.precision
    }
    fn world_coordinate_system(&self) -> &EntityRef {
        &self.world_coordinate_system
    }
    fn true_north(&self) -> &Option<EntityRef> {
        &self.true_north
    }
}
impl IfcGeometricRepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.context_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.context_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.coordinate_space_dimension = parameter.into(),
                3usize => {
                    entity.precision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.world_coordinate_system = parameter.into(),
                5usize => {
                    entity.true_north = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricRepresentationItem: IIfcRepresentationItem {}
pub trait IIfcGeometricRepresentationSubContext: IIfcGeometricRepresentationContext {
    fn parent_context(&self) -> &EntityRef;
    fn target_scale(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn target_view(&self) -> &IfcGeometricProjectionEnum;
    fn user_defined_target_view(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcGeometricRepresentationSubContext {
    context_identifier: Option<IfcLabel>,
    context_type: Option<IfcLabel>,
    coordinate_space_dimension: IfcDimensionCount,
    precision: Option<Real>,
    world_coordinate_system: EntityRef,
    true_north: Option<EntityRef>,
    parent_context: EntityRef,
    target_scale: Option<IfcPositiveRatioMeasure>,
    target_view: IfcGeometricProjectionEnum,
    user_defined_target_view: Option<IfcLabel>,
}
impl IIfcRepresentationContext for IfcGeometricRepresentationSubContext {
    fn context_identifier(&self) -> &Option<IfcLabel> {
        &self.context_identifier
    }
    fn context_type(&self) -> &Option<IfcLabel> {
        &self.context_type
    }
}
impl IIfcGeometricRepresentationContext for IfcGeometricRepresentationSubContext {
    fn coordinate_space_dimension(&self) -> &IfcDimensionCount {
        &self.coordinate_space_dimension
    }
    fn precision(&self) -> Option<Real> {
        self.precision
    }
    fn world_coordinate_system(&self) -> &EntityRef {
        &self.world_coordinate_system
    }
    fn true_north(&self) -> &Option<EntityRef> {
        &self.true_north
    }
}
impl IIfcGeometricRepresentationSubContext for IfcGeometricRepresentationSubContext {
    fn parent_context(&self) -> &EntityRef {
        &self.parent_context
    }
    fn target_scale(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.target_scale
    }
    fn target_view(&self) -> &IfcGeometricProjectionEnum {
        &self.target_view
    }
    fn user_defined_target_view(&self) -> &Option<IfcLabel> {
        &self.user_defined_target_view
    }
}
impl IfcGeometricRepresentationSubContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricRepresentationSubContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.context_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.context_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.coordinate_space_dimension = parameter.into(),
                3usize => {
                    entity.precision = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.world_coordinate_system = parameter.into(),
                5usize => {
                    entity.true_north = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.parent_context = parameter.into(),
                7usize => {
                    entity.target_scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.target_view = parameter.into(),
                9usize => {
                    entity.user_defined_target_view = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGeometricSet: IIfcGeometricRepresentationItem {
    fn elements(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcGeometricSet {
    elements: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcGeometricSet {}
impl IIfcGeometricRepresentationItem for IfcGeometricSet {}
impl IIfcGeometricSet for IfcGeometricSet {
    fn elements(&self) -> &HashSet<EntityRef> {
        &self.elements
    }
}
impl IfcGeometricSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGeometricSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.elements = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGrid: IIfcProduct {
    fn u_axes(&self) -> &Vec<EntityRef>;
    fn v_axes(&self) -> &Vec<EntityRef>;
    fn w_axes(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcGrid {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    u_axes: Vec<EntityRef>,
    v_axes: Vec<EntityRef>,
    w_axes: Option<Vec<EntityRef>>,
}
impl IIfcRoot for IfcGrid {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGrid {}
impl IIfcObject for IfcGrid {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcGrid {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcGrid for IfcGrid {
    fn u_axes(&self) -> &Vec<EntityRef> {
        &self.u_axes
    }
    fn v_axes(&self) -> &Vec<EntityRef> {
        &self.v_axes
    }
    fn w_axes(&self) -> &Option<Vec<EntityRef>> {
        &self.w_axes
    }
}
impl IfcGrid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGrid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.u_axes = parameter.into(),
                8usize => entity.v_axes = parameter.into(),
                9usize => {
                    entity.w_axes = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGridAxis {
    fn axis_tag(&self) -> &Option<IfcLabel>;
    fn axis_curve(&self) -> &EntityRef;
    fn same_sense(&self) -> &IfcBoolean;
}
#[derive(Default, Debug)]
pub struct IfcGridAxis {
    axis_tag: Option<IfcLabel>,
    axis_curve: EntityRef,
    same_sense: IfcBoolean,
}
impl IIfcGridAxis for IfcGridAxis {
    fn axis_tag(&self) -> &Option<IfcLabel> {
        &self.axis_tag
    }
    fn axis_curve(&self) -> &EntityRef {
        &self.axis_curve
    }
    fn same_sense(&self) -> &IfcBoolean {
        &self.same_sense
    }
}
impl IfcGridAxis {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGridAxis::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.axis_tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.axis_curve = parameter.into(),
                2usize => entity.same_sense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGridPlacement: IIfcObjectPlacement {
    fn placement_location(&self) -> &EntityRef;
    fn placement_ref_direction(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcGridPlacement {
    placement_location: EntityRef,
    placement_ref_direction: Option<EntityRef>,
}
impl IIfcObjectPlacement for IfcGridPlacement {}
impl IIfcGridPlacement for IfcGridPlacement {
    fn placement_location(&self) -> &EntityRef {
        &self.placement_location
    }
    fn placement_ref_direction(&self) -> &Option<EntityRef> {
        &self.placement_ref_direction
    }
}
impl IfcGridPlacement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGridPlacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.placement_location = parameter.into(),
                1usize => {
                    entity.placement_ref_direction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcGroup: IIfcObject {}
#[derive(Default, Debug)]
pub struct IfcGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcGroup {}
impl IIfcObject for IfcGroup {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcGroup {}
impl IfcGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHalfSpaceSolid: IIfcGeometricRepresentationItem {
    fn base_surface(&self) -> &EntityRef;
    fn agreement_flag(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcHalfSpaceSolid {
    base_surface: EntityRef,
    agreement_flag: bool,
}
impl IIfcRepresentationItem for IfcHalfSpaceSolid {}
impl IIfcGeometricRepresentationItem for IfcHalfSpaceSolid {}
impl IIfcHalfSpaceSolid for IfcHalfSpaceSolid {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl IfcHalfSpaceSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHalfSpaceSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.base_surface = parameter.into(),
                1usize => entity.agreement_flag = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHeatExchangerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcHeatExchangerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcHeatExchangerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcHeatExchangerTypeEnum,
}
impl IIfcRoot for IfcHeatExchangerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcHeatExchangerType {}
impl IIfcTypeObject for IfcHeatExchangerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcHeatExchangerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcHeatExchangerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcHeatExchangerType {}
impl IIfcDistributionFlowElementType for IfcHeatExchangerType {}
impl IIfcEnergyConversionDeviceType for IfcHeatExchangerType {}
impl IIfcHeatExchangerType for IfcHeatExchangerType {
    fn predefined_type(&self) -> &IfcHeatExchangerTypeEnum {
        &self.predefined_type
    }
}
impl IfcHeatExchangerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHeatExchangerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHumidifierType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcHumidifierTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcHumidifierType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcHumidifierTypeEnum,
}
impl IIfcRoot for IfcHumidifierType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcHumidifierType {}
impl IIfcTypeObject for IfcHumidifierType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcHumidifierType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcHumidifierType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcHumidifierType {}
impl IIfcDistributionFlowElementType for IfcHumidifierType {}
impl IIfcEnergyConversionDeviceType for IfcHumidifierType {}
impl IIfcHumidifierType for IfcHumidifierType {
    fn predefined_type(&self) -> &IfcHumidifierTypeEnum {
        &self.predefined_type
    }
}
impl IfcHumidifierType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHumidifierType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcHygroscopicMaterialProperties: IIfcMaterialProperties {
    fn upper_vapor_resistance_factor(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn lower_vapor_resistance_factor(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn isothermal_moisture_capacity(&self) -> &Option<IfcIsothermalMoistureCapacityMeasure>;
    fn vapor_permeability(&self) -> &Option<IfcVaporPermeabilityMeasure>;
    fn moisture_diffusivity(&self) -> &Option<IfcMoistureDiffusivityMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcHygroscopicMaterialProperties {
    material: EntityRef,
    upper_vapor_resistance_factor: Option<IfcPositiveRatioMeasure>,
    lower_vapor_resistance_factor: Option<IfcPositiveRatioMeasure>,
    isothermal_moisture_capacity: Option<IfcIsothermalMoistureCapacityMeasure>,
    vapor_permeability: Option<IfcVaporPermeabilityMeasure>,
    moisture_diffusivity: Option<IfcMoistureDiffusivityMeasure>,
}
impl IIfcMaterialProperties for IfcHygroscopicMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcHygroscopicMaterialProperties for IfcHygroscopicMaterialProperties {
    fn upper_vapor_resistance_factor(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.upper_vapor_resistance_factor
    }
    fn lower_vapor_resistance_factor(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.lower_vapor_resistance_factor
    }
    fn isothermal_moisture_capacity(&self) -> &Option<IfcIsothermalMoistureCapacityMeasure> {
        &self.isothermal_moisture_capacity
    }
    fn vapor_permeability(&self) -> &Option<IfcVaporPermeabilityMeasure> {
        &self.vapor_permeability
    }
    fn moisture_diffusivity(&self) -> &Option<IfcMoistureDiffusivityMeasure> {
        &self.moisture_diffusivity
    }
}
impl IfcHygroscopicMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcHygroscopicMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.upper_vapor_resistance_factor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.lower_vapor_resistance_factor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.isothermal_moisture_capacity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.vapor_permeability = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.moisture_diffusivity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIShapeProfileDef: IIfcParameterizedProfileDef {
    fn overall_width(&self) -> &IfcPositiveLengthMeasure;
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcIShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    overall_width: IfcPositiveLengthMeasure,
    overall_depth: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcIShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcIShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcIShapeProfileDef for IfcIShapeProfileDef {
    fn overall_width(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_width
    }
    fn overall_depth(&self) -> &IfcPositiveLengthMeasure {
        &self.overall_depth
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
}
impl IfcIShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.overall_width = parameter.into(),
                4usize => entity.overall_depth = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcImageTexture: IIfcSurfaceTexture {
    fn url_reference(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcImageTexture {
    repeat_s: bool,
    repeat_t: bool,
    texture_type: IfcSurfaceTextureEnum,
    texture_transform: Option<EntityRef>,
    url_reference: IfcIdentifier,
}
impl IIfcSurfaceTexture for IfcImageTexture {
    fn repeat_s(&self) -> bool {
        self.repeat_s
    }
    fn repeat_t(&self) -> bool {
        self.repeat_t
    }
    fn texture_type(&self) -> &IfcSurfaceTextureEnum {
        &self.texture_type
    }
    fn texture_transform(&self) -> &Option<EntityRef> {
        &self.texture_transform
    }
}
impl IIfcImageTexture for IfcImageTexture {
    fn url_reference(&self) -> &IfcIdentifier {
        &self.url_reference
    }
}
impl IfcImageTexture {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcImageTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_s = parameter.into(),
                1usize => entity.repeat_t = parameter.into(),
                2usize => entity.texture_type = parameter.into(),
                3usize => {
                    entity.texture_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.url_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcInventory: IIfcGroup {
    fn inventory_type(&self) -> &IfcInventoryTypeEnum;
    fn jurisdiction(&self) -> &EntityRef;
    fn responsible_persons(&self) -> &HashSet<EntityRef>;
    fn last_update_date(&self) -> &EntityRef;
    fn current_value(&self) -> &Option<EntityRef>;
    fn original_value(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcInventory {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    inventory_type: IfcInventoryTypeEnum,
    jurisdiction: EntityRef,
    responsible_persons: HashSet<EntityRef>,
    last_update_date: EntityRef,
    current_value: Option<EntityRef>,
    original_value: Option<EntityRef>,
}
impl IIfcRoot for IfcInventory {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcInventory {}
impl IIfcObject for IfcInventory {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcInventory {}
impl IIfcInventory for IfcInventory {
    fn inventory_type(&self) -> &IfcInventoryTypeEnum {
        &self.inventory_type
    }
    fn jurisdiction(&self) -> &EntityRef {
        &self.jurisdiction
    }
    fn responsible_persons(&self) -> &HashSet<EntityRef> {
        &self.responsible_persons
    }
    fn last_update_date(&self) -> &EntityRef {
        &self.last_update_date
    }
    fn current_value(&self) -> &Option<EntityRef> {
        &self.current_value
    }
    fn original_value(&self) -> &Option<EntityRef> {
        &self.original_value
    }
}
impl IfcInventory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcInventory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.inventory_type = parameter.into(),
                6usize => entity.jurisdiction = parameter.into(),
                7usize => entity.responsible_persons = parameter.into(),
                8usize => entity.last_update_date = parameter.into(),
                9usize => {
                    entity.current_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.original_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIrregularTimeSeries: IIfcTimeSeries {
    fn values(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcIrregularTimeSeries {
    name: IfcLabel,
    description: Option<IfcText>,
    start_time: EntityRef,
    end_time: EntityRef,
    time_series_data_type: IfcTimeSeriesDataTypeEnum,
    data_origin: IfcDataOriginEnum,
    user_defined_data_origin: Option<IfcLabel>,
    unit: Option<EntityRef>,
    values: Vec<EntityRef>,
}
impl IIfcTimeSeries for IfcIrregularTimeSeries {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn start_time(&self) -> &EntityRef {
        &self.start_time
    }
    fn end_time(&self) -> &EntityRef {
        &self.end_time
    }
    fn time_series_data_type(&self) -> &IfcTimeSeriesDataTypeEnum {
        &self.time_series_data_type
    }
    fn data_origin(&self) -> &IfcDataOriginEnum {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcIrregularTimeSeries for IfcIrregularTimeSeries {
    fn values(&self) -> &Vec<EntityRef> {
        &self.values
    }
}
impl IfcIrregularTimeSeries {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIrregularTimeSeries::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.start_time = parameter.into(),
                3usize => entity.end_time = parameter.into(),
                4usize => entity.time_series_data_type = parameter.into(),
                5usize => entity.data_origin = parameter.into(),
                6usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcIrregularTimeSeriesValue {
    fn time_stamp(&self) -> &EntityRef;
    fn list_values(&self) -> &Vec<IfcValue>;
}
#[derive(Default, Debug)]
pub struct IfcIrregularTimeSeriesValue {
    time_stamp: EntityRef,
    list_values: Vec<IfcValue>,
}
impl IIfcIrregularTimeSeriesValue for IfcIrregularTimeSeriesValue {
    fn time_stamp(&self) -> &EntityRef {
        &self.time_stamp
    }
    fn list_values(&self) -> &Vec<IfcValue> {
        &self.list_values
    }
}
impl IfcIrregularTimeSeriesValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcIrregularTimeSeriesValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.time_stamp = parameter.into(),
                1usize => entity.list_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcJunctionBoxType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcJunctionBoxTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcJunctionBoxType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcJunctionBoxTypeEnum,
}
impl IIfcRoot for IfcJunctionBoxType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcJunctionBoxType {}
impl IIfcTypeObject for IfcJunctionBoxType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcJunctionBoxType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcJunctionBoxType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcJunctionBoxType {}
impl IIfcDistributionFlowElementType for IfcJunctionBoxType {}
impl IIfcFlowFittingType for IfcJunctionBoxType {}
impl IIfcJunctionBoxType for IfcJunctionBoxType {
    fn predefined_type(&self) -> &IfcJunctionBoxTypeEnum {
        &self.predefined_type
    }
}
impl IfcJunctionBoxType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcJunctionBoxType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn edge_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn leg_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn centre_of_gravity_in_x(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcLShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    depth: IfcPositiveLengthMeasure,
    width: Option<IfcPositiveLengthMeasure>,
    thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
    edge_radius: Option<IfcPositiveLengthMeasure>,
    leg_slope: Option<IfcPlaneAngleMeasure>,
    centre_of_gravity_in_x: Option<IfcPositiveLengthMeasure>,
    centre_of_gravity_in_y: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcLShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcLShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcLShapeProfileDef for IfcLShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.width
    }
    fn thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.thickness
    }
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
    fn edge_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.edge_radius
    }
    fn leg_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.leg_slope
    }
    fn centre_of_gravity_in_x(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_x
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IfcLShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => {
                    entity.width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.thickness = parameter.into(),
                6usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.leg_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.centre_of_gravity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLaborResource: IIfcConstructionResource {
    fn skill_set(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcLaborResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    resource_identifier: Option<IfcIdentifier>,
    resource_group: Option<IfcLabel>,
    resource_consumption: Option<IfcResourceConsumptionEnum>,
    base_quantity: Option<EntityRef>,
    skill_set: Option<IfcText>,
}
impl IIfcRoot for IfcLaborResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLaborResource {}
impl IIfcObject for IfcLaborResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcLaborResource {}
impl IIfcConstructionResource for IfcLaborResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier> {
        &self.resource_identifier
    }
    fn resource_group(&self) -> &Option<IfcLabel> {
        &self.resource_group
    }
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum> {
        &self.resource_consumption
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcLaborResource for IfcLaborResource {
    fn skill_set(&self) -> &Option<IfcText> {
        &self.skill_set
    }
}
impl IfcLaborResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLaborResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.resource_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.resource_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.resource_consumption = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.skill_set = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLampType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcLampTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcLampType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcLampTypeEnum,
}
impl IIfcRoot for IfcLampType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLampType {}
impl IIfcTypeObject for IfcLampType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcLampType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcLampType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcLampType {}
impl IIfcDistributionFlowElementType for IfcLampType {}
impl IIfcFlowTerminalType for IfcLampType {}
impl IIfcLampType for IfcLampType {
    fn predefined_type(&self) -> &IfcLampTypeEnum {
        &self.predefined_type
    }
}
impl IfcLampType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLampType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLibraryInformation {
    fn name(&self) -> &IfcLabel;
    fn version(&self) -> &Option<IfcLabel>;
    fn publisher(&self) -> &Option<EntityRef>;
    fn version_date(&self) -> &Option<EntityRef>;
    fn library_reference(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcLibraryInformation {
    name: IfcLabel,
    version: Option<IfcLabel>,
    publisher: Option<EntityRef>,
    version_date: Option<EntityRef>,
    library_reference: Option<HashSet<EntityRef>>,
}
impl IIfcLibraryInformation for IfcLibraryInformation {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn version(&self) -> &Option<IfcLabel> {
        &self.version
    }
    fn publisher(&self) -> &Option<EntityRef> {
        &self.publisher
    }
    fn version_date(&self) -> &Option<EntityRef> {
        &self.version_date
    }
    fn library_reference(&self) -> &Option<HashSet<EntityRef>> {
        &self.library_reference
    }
}
impl IfcLibraryInformation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLibraryInformation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.version = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.publisher = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.version_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.library_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLibraryReference: IIfcExternalReference {}
#[derive(Default, Debug)]
pub struct IfcLibraryReference {
    location: Option<IfcLabel>,
    item_reference: Option<IfcIdentifier>,
    name: Option<IfcLabel>,
}
impl IIfcExternalReference for IfcLibraryReference {
    fn location(&self) -> &Option<IfcLabel> {
        &self.location
    }
    fn item_reference(&self) -> &Option<IfcIdentifier> {
        &self.item_reference
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcLibraryReference for IfcLibraryReference {}
impl IfcLibraryReference {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLibraryReference::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.item_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightDistributionData {
    fn main_plane_angle(&self) -> &IfcPlaneAngleMeasure;
    fn secondary_plane_angle(&self) -> &Vec<IfcPlaneAngleMeasure>;
    fn luminous_intensity(&self) -> &Vec<IfcLuminousIntensityDistributionMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcLightDistributionData {
    main_plane_angle: IfcPlaneAngleMeasure,
    secondary_plane_angle: Vec<IfcPlaneAngleMeasure>,
    luminous_intensity: Vec<IfcLuminousIntensityDistributionMeasure>,
}
impl IIfcLightDistributionData for IfcLightDistributionData {
    fn main_plane_angle(&self) -> &IfcPlaneAngleMeasure {
        &self.main_plane_angle
    }
    fn secondary_plane_angle(&self) -> &Vec<IfcPlaneAngleMeasure> {
        &self.secondary_plane_angle
    }
    fn luminous_intensity(&self) -> &Vec<IfcLuminousIntensityDistributionMeasure> {
        &self.luminous_intensity
    }
}
impl IfcLightDistributionData {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightDistributionData::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.main_plane_angle = parameter.into(),
                1usize => entity.secondary_plane_angle = parameter.into(),
                2usize => entity.luminous_intensity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightFixtureType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcLightFixtureTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcLightFixtureType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcLightFixtureTypeEnum,
}
impl IIfcRoot for IfcLightFixtureType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcLightFixtureType {}
impl IIfcTypeObject for IfcLightFixtureType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcLightFixtureType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcLightFixtureType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcLightFixtureType {}
impl IIfcDistributionFlowElementType for IfcLightFixtureType {}
impl IIfcFlowTerminalType for IfcLightFixtureType {}
impl IIfcLightFixtureType for IfcLightFixtureType {
    fn predefined_type(&self) -> &IfcLightFixtureTypeEnum {
        &self.predefined_type
    }
}
impl IfcLightFixtureType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightFixtureType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightIntensityDistribution {
    fn light_distribution_curve(&self) -> &IfcLightDistributionCurveEnum;
    fn distribution_data(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcLightIntensityDistribution {
    light_distribution_curve: IfcLightDistributionCurveEnum,
    distribution_data: Vec<EntityRef>,
}
impl IIfcLightIntensityDistribution for IfcLightIntensityDistribution {
    fn light_distribution_curve(&self) -> &IfcLightDistributionCurveEnum {
        &self.light_distribution_curve
    }
    fn distribution_data(&self) -> &Vec<EntityRef> {
        &self.distribution_data
    }
}
impl IfcLightIntensityDistribution {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightIntensityDistribution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.light_distribution_curve = parameter.into(),
                1usize => entity.distribution_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSource: IIfcGeometricRepresentationItem {
    fn name(&self) -> &Option<IfcLabel>;
    fn light_colour(&self) -> &EntityRef;
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure>;
}
pub trait IIfcLightSourceAmbient: IIfcLightSource {}
#[derive(Default, Debug)]
pub struct IfcLightSourceAmbient {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
}
impl IIfcRepresentationItem for IfcLightSourceAmbient {}
impl IIfcGeometricRepresentationItem for IfcLightSourceAmbient {}
impl IIfcLightSource for IfcLightSourceAmbient {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourceAmbient for IfcLightSourceAmbient {}
impl IfcLightSourceAmbient {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceAmbient::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourceDirectional: IIfcLightSource {
    fn orientation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLightSourceDirectional {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    orientation: EntityRef,
}
impl IIfcRepresentationItem for IfcLightSourceDirectional {}
impl IIfcGeometricRepresentationItem for IfcLightSourceDirectional {}
impl IIfcLightSource for IfcLightSourceDirectional {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourceDirectional for IfcLightSourceDirectional {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
}
impl IfcLightSourceDirectional {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceDirectional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourceGoniometric: IIfcLightSource {
    fn position(&self) -> &EntityRef;
    fn colour_appearance(&self) -> &Option<EntityRef>;
    fn colour_temperature(&self) -> &IfcThermodynamicTemperatureMeasure;
    fn luminous_flux(&self) -> &IfcLuminousFluxMeasure;
    fn light_emission_source(&self) -> &IfcLightEmissionSourceEnum;
    fn light_distribution_data_source(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLightSourceGoniometric {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    position: EntityRef,
    colour_appearance: Option<EntityRef>,
    colour_temperature: IfcThermodynamicTemperatureMeasure,
    luminous_flux: IfcLuminousFluxMeasure,
    light_emission_source: IfcLightEmissionSourceEnum,
    light_distribution_data_source: EntityRef,
}
impl IIfcRepresentationItem for IfcLightSourceGoniometric {}
impl IIfcGeometricRepresentationItem for IfcLightSourceGoniometric {}
impl IIfcLightSource for IfcLightSourceGoniometric {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourceGoniometric for IfcLightSourceGoniometric {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn colour_appearance(&self) -> &Option<EntityRef> {
        &self.colour_appearance
    }
    fn colour_temperature(&self) -> &IfcThermodynamicTemperatureMeasure {
        &self.colour_temperature
    }
    fn luminous_flux(&self) -> &IfcLuminousFluxMeasure {
        &self.luminous_flux
    }
    fn light_emission_source(&self) -> &IfcLightEmissionSourceEnum {
        &self.light_emission_source
    }
    fn light_distribution_data_source(&self) -> &EntityRef {
        &self.light_distribution_data_source
    }
}
impl IfcLightSourceGoniometric {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceGoniometric::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.position = parameter.into(),
                5usize => {
                    entity.colour_appearance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.colour_temperature = parameter.into(),
                7usize => entity.luminous_flux = parameter.into(),
                8usize => entity.light_emission_source = parameter.into(),
                9usize => entity.light_distribution_data_source = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourcePositional: IIfcLightSource {
    fn position(&self) -> &EntityRef;
    fn radius(&self) -> &IfcPositiveLengthMeasure;
    fn constant_attenuation(&self) -> &IfcReal;
    fn distance_attenuation(&self) -> &IfcReal;
    fn quadric_attenuation(&self) -> &IfcReal;
}
#[derive(Default, Debug)]
pub struct IfcLightSourcePositional {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
    constant_attenuation: IfcReal,
    distance_attenuation: IfcReal,
    quadric_attenuation: IfcReal,
}
impl IIfcRepresentationItem for IfcLightSourcePositional {}
impl IIfcGeometricRepresentationItem for IfcLightSourcePositional {}
impl IIfcLightSource for IfcLightSourcePositional {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourcePositional for IfcLightSourcePositional {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn constant_attenuation(&self) -> &IfcReal {
        &self.constant_attenuation
    }
    fn distance_attenuation(&self) -> &IfcReal {
        &self.distance_attenuation
    }
    fn quadric_attenuation(&self) -> &IfcReal {
        &self.quadric_attenuation
    }
}
impl IfcLightSourcePositional {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourcePositional::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.position = parameter.into(),
                5usize => entity.radius = parameter.into(),
                6usize => entity.constant_attenuation = parameter.into(),
                7usize => entity.distance_attenuation = parameter.into(),
                8usize => entity.quadric_attenuation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLightSourceSpot: IIfcLightSourcePositional {
    fn orientation(&self) -> &EntityRef;
    fn concentration_exponent(&self) -> &Option<IfcReal>;
    fn spread_angle(&self) -> &IfcPositivePlaneAngleMeasure;
    fn beam_width_angle(&self) -> &IfcPositivePlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct IfcLightSourceSpot {
    name: Option<IfcLabel>,
    light_colour: EntityRef,
    ambient_intensity: Option<IfcNormalisedRatioMeasure>,
    intensity: Option<IfcNormalisedRatioMeasure>,
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
    constant_attenuation: IfcReal,
    distance_attenuation: IfcReal,
    quadric_attenuation: IfcReal,
    orientation: EntityRef,
    concentration_exponent: Option<IfcReal>,
    spread_angle: IfcPositivePlaneAngleMeasure,
    beam_width_angle: IfcPositivePlaneAngleMeasure,
}
impl IIfcRepresentationItem for IfcLightSourceSpot {}
impl IIfcGeometricRepresentationItem for IfcLightSourceSpot {}
impl IIfcLightSource for IfcLightSourceSpot {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn light_colour(&self) -> &EntityRef {
        &self.light_colour
    }
    fn ambient_intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.ambient_intensity
    }
    fn intensity(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.intensity
    }
}
impl IIfcLightSourcePositional for IfcLightSourceSpot {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn constant_attenuation(&self) -> &IfcReal {
        &self.constant_attenuation
    }
    fn distance_attenuation(&self) -> &IfcReal {
        &self.distance_attenuation
    }
    fn quadric_attenuation(&self) -> &IfcReal {
        &self.quadric_attenuation
    }
}
impl IIfcLightSourceSpot for IfcLightSourceSpot {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn concentration_exponent(&self) -> &Option<IfcReal> {
        &self.concentration_exponent
    }
    fn spread_angle(&self) -> &IfcPositivePlaneAngleMeasure {
        &self.spread_angle
    }
    fn beam_width_angle(&self) -> &IfcPositivePlaneAngleMeasure {
        &self.beam_width_angle
    }
}
impl IfcLightSourceSpot {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLightSourceSpot::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.light_colour = parameter.into(),
                2usize => {
                    entity.ambient_intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.intensity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.position = parameter.into(),
                5usize => entity.radius = parameter.into(),
                6usize => entity.constant_attenuation = parameter.into(),
                7usize => entity.distance_attenuation = parameter.into(),
                8usize => entity.quadric_attenuation = parameter.into(),
                9usize => entity.orientation = parameter.into(),
                10usize => {
                    entity.concentration_exponent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.spread_angle = parameter.into(),
                12usize => entity.beam_width_angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLine: IIfcCurve {
    fn pnt(&self) -> &EntityRef;
    fn dir(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLine {
    pnt: EntityRef,
    dir: EntityRef,
}
impl IIfcRepresentationItem for IfcLine {}
impl IIfcGeometricRepresentationItem for IfcLine {}
impl IIfcCurve for IfcLine {}
impl IIfcLine for IfcLine {
    fn pnt(&self) -> &EntityRef {
        &self.pnt
    }
    fn dir(&self) -> &EntityRef {
        &self.dir
    }
}
impl IfcLine {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.pnt = parameter.into(),
                1usize => entity.dir = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLinearDimension: IIfcDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct IfcLinearDimension {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcLinearDimension {}
impl IIfcGeometricRepresentationItem for IfcLinearDimension {}
impl IIfcDraughtingCallout for IfcLinearDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IIfcDimensionCurveDirectedCallout for IfcLinearDimension {}
impl IIfcLinearDimension for IfcLinearDimension {}
impl IfcLinearDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLinearDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLocalPlacement: IIfcObjectPlacement {
    fn placement_rel_to(&self) -> &Option<EntityRef>;
    fn relative_placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcLocalPlacement {
    placement_rel_to: Option<EntityRef>,
    relative_placement: EntityRef,
}
impl IIfcObjectPlacement for IfcLocalPlacement {}
impl IIfcLocalPlacement for IfcLocalPlacement {
    fn placement_rel_to(&self) -> &Option<EntityRef> {
        &self.placement_rel_to
    }
    fn relative_placement(&self) -> &EntityRef {
        &self.relative_placement
    }
}
impl IfcLocalPlacement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLocalPlacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.placement_rel_to = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.relative_placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLocalTime {
    fn hour_component(&self) -> &IfcHourInDay;
    fn minute_component(&self) -> &Option<IfcMinuteInHour>;
    fn second_component(&self) -> &Option<IfcSecondInMinute>;
    fn zone(&self) -> &Option<EntityRef>;
    fn daylight_saving_offset(&self) -> &Option<IfcDaylightSavingHour>;
}
#[derive(Default, Debug)]
pub struct IfcLocalTime {
    hour_component: IfcHourInDay,
    minute_component: Option<IfcMinuteInHour>,
    second_component: Option<IfcSecondInMinute>,
    zone: Option<EntityRef>,
    daylight_saving_offset: Option<IfcDaylightSavingHour>,
}
impl IIfcLocalTime for IfcLocalTime {
    fn hour_component(&self) -> &IfcHourInDay {
        &self.hour_component
    }
    fn minute_component(&self) -> &Option<IfcMinuteInHour> {
        &self.minute_component
    }
    fn second_component(&self) -> &Option<IfcSecondInMinute> {
        &self.second_component
    }
    fn zone(&self) -> &Option<EntityRef> {
        &self.zone
    }
    fn daylight_saving_offset(&self) -> &Option<IfcDaylightSavingHour> {
        &self.daylight_saving_offset
    }
}
impl IfcLocalTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcLocalTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.hour_component = parameter.into(),
                1usize => {
                    entity.minute_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.second_component = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.zone = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.daylight_saving_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcLoop: IIfcTopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct IfcLoop {}
impl IIfcRepresentationItem for IfcLoop {}
impl IIfcTopologicalRepresentationItem for IfcLoop {}
impl IIfcLoop for IfcLoop {}
impl IfcLoop {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        IfcLoop::default()
    }
}
pub trait IIfcManifoldSolidBrep: IIfcSolidModel {
    fn outer(&self) -> &EntityRef;
}
pub trait IIfcMappedItem: IIfcRepresentationItem {
    fn mapping_source(&self) -> &EntityRef;
    fn mapping_target(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMappedItem {
    mapping_source: EntityRef,
    mapping_target: EntityRef,
}
impl IIfcRepresentationItem for IfcMappedItem {}
impl IIfcMappedItem for IfcMappedItem {
    fn mapping_source(&self) -> &EntityRef {
        &self.mapping_source
    }
    fn mapping_target(&self) -> &EntityRef {
        &self.mapping_target
    }
}
impl IfcMappedItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMappedItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapping_source = parameter.into(),
                1usize => entity.mapping_target = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterial {
    fn name(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcMaterial {
    name: IfcLabel,
}
impl IIfcMaterial for IfcMaterial {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IfcMaterial {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterial::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialClassificationRelationship {
    fn material_classifications(&self) -> &HashSet<EntityRef>;
    fn classified_material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMaterialClassificationRelationship {
    material_classifications: HashSet<EntityRef>,
    classified_material: EntityRef,
}
impl IIfcMaterialClassificationRelationship for IfcMaterialClassificationRelationship {
    fn material_classifications(&self) -> &HashSet<EntityRef> {
        &self.material_classifications
    }
    fn classified_material(&self) -> &EntityRef {
        &self.classified_material
    }
}
impl IfcMaterialClassificationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialClassificationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material_classifications = parameter.into(),
                1usize => entity.classified_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialDefinitionRepresentation: IIfcProductRepresentation {
    fn represented_material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMaterialDefinitionRepresentation {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    representations: Vec<EntityRef>,
    represented_material: EntityRef,
}
impl IIfcProductRepresentation for IfcMaterialDefinitionRepresentation {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn representations(&self) -> &Vec<EntityRef> {
        &self.representations
    }
}
impl IIfcMaterialDefinitionRepresentation for IfcMaterialDefinitionRepresentation {
    fn represented_material(&self) -> &EntityRef {
        &self.represented_material
    }
}
impl IfcMaterialDefinitionRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialDefinitionRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.representations = parameter.into(),
                3usize => entity.represented_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayer {
    fn material(&self) -> &Option<EntityRef>;
    fn layer_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn is_ventilated(&self) -> &Option<IfcLogical>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayer {
    material: Option<EntityRef>,
    layer_thickness: IfcPositiveLengthMeasure,
    is_ventilated: Option<IfcLogical>,
}
impl IIfcMaterialLayer for IfcMaterialLayer {
    fn material(&self) -> &Option<EntityRef> {
        &self.material
    }
    fn layer_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.layer_thickness
    }
    fn is_ventilated(&self) -> &Option<IfcLogical> {
        &self.is_ventilated
    }
}
impl IfcMaterialLayer {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayer::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.material = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.layer_thickness = parameter.into(),
                2usize => {
                    entity.is_ventilated = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayerSet {
    fn material_layers(&self) -> &Vec<EntityRef>;
    fn layer_set_name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayerSet {
    material_layers: Vec<EntityRef>,
    layer_set_name: Option<IfcLabel>,
}
impl IIfcMaterialLayerSet for IfcMaterialLayerSet {
    fn material_layers(&self) -> &Vec<EntityRef> {
        &self.material_layers
    }
    fn layer_set_name(&self) -> &Option<IfcLabel> {
        &self.layer_set_name
    }
}
impl IfcMaterialLayerSet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayerSet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material_layers = parameter.into(),
                1usize => {
                    entity.layer_set_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialLayerSetUsage {
    fn for_layer_set(&self) -> &EntityRef;
    fn layer_set_direction(&self) -> &IfcLayerSetDirectionEnum;
    fn direction_sense(&self) -> &IfcDirectionSenseEnum;
    fn offset_from_reference_line(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcMaterialLayerSetUsage {
    for_layer_set: EntityRef,
    layer_set_direction: IfcLayerSetDirectionEnum,
    direction_sense: IfcDirectionSenseEnum,
    offset_from_reference_line: IfcLengthMeasure,
}
impl IIfcMaterialLayerSetUsage for IfcMaterialLayerSetUsage {
    fn for_layer_set(&self) -> &EntityRef {
        &self.for_layer_set
    }
    fn layer_set_direction(&self) -> &IfcLayerSetDirectionEnum {
        &self.layer_set_direction
    }
    fn direction_sense(&self) -> &IfcDirectionSenseEnum {
        &self.direction_sense
    }
    fn offset_from_reference_line(&self) -> &IfcLengthMeasure {
        &self.offset_from_reference_line
    }
}
impl IfcMaterialLayerSetUsage {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialLayerSetUsage::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.for_layer_set = parameter.into(),
                1usize => entity.layer_set_direction = parameter.into(),
                2usize => entity.direction_sense = parameter.into(),
                3usize => entity.offset_from_reference_line = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialList {
    fn materials(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcMaterialList {
    materials: Vec<EntityRef>,
}
impl IIfcMaterialList for IfcMaterialList {
    fn materials(&self) -> &Vec<EntityRef> {
        &self.materials
    }
}
impl IfcMaterialList {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMaterialList::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.materials = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMaterialProperties {
    fn material(&self) -> &EntityRef;
}
pub trait IIfcMeasureWithUnit {
    fn value_component(&self) -> &IfcValue;
    fn unit_component(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcMeasureWithUnit {
    value_component: IfcValue,
    unit_component: EntityRef,
}
impl IIfcMeasureWithUnit for IfcMeasureWithUnit {
    fn value_component(&self) -> &IfcValue {
        &self.value_component
    }
    fn unit_component(&self) -> &EntityRef {
        &self.unit_component
    }
}
impl IfcMeasureWithUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMeasureWithUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.value_component = parameter.into(),
                1usize => entity.unit_component = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalConcreteMaterialProperties: IIfcMechanicalMaterialProperties {
    fn compressive_strength(&self) -> &Option<IfcPressureMeasure>;
    fn max_aggregate_size(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn admixtures_description(&self) -> &Option<IfcText>;
    fn workability(&self) -> &Option<IfcText>;
    fn protective_pore_ratio(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn water_impermeability(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcMechanicalConcreteMaterialProperties {
    material: EntityRef,
    dynamic_viscosity: Option<IfcDynamicViscosityMeasure>,
    young_modulus: Option<IfcModulusOfElasticityMeasure>,
    shear_modulus: Option<IfcModulusOfElasticityMeasure>,
    poisson_ratio: Option<IfcPositiveRatioMeasure>,
    thermal_expansion_coefficient: Option<IfcThermalExpansionCoefficientMeasure>,
    compressive_strength: Option<IfcPressureMeasure>,
    max_aggregate_size: Option<IfcPositiveLengthMeasure>,
    admixtures_description: Option<IfcText>,
    workability: Option<IfcText>,
    protective_pore_ratio: Option<IfcNormalisedRatioMeasure>,
    water_impermeability: Option<IfcText>,
}
impl IIfcMaterialProperties for IfcMechanicalConcreteMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcMechanicalMaterialProperties for IfcMechanicalConcreteMaterialProperties {
    fn dynamic_viscosity(&self) -> &Option<IfcDynamicViscosityMeasure> {
        &self.dynamic_viscosity
    }
    fn young_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.young_modulus
    }
    fn shear_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.shear_modulus
    }
    fn poisson_ratio(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.poisson_ratio
    }
    fn thermal_expansion_coefficient(&self) -> &Option<IfcThermalExpansionCoefficientMeasure> {
        &self.thermal_expansion_coefficient
    }
}
impl IIfcMechanicalConcreteMaterialProperties for IfcMechanicalConcreteMaterialProperties {
    fn compressive_strength(&self) -> &Option<IfcPressureMeasure> {
        &self.compressive_strength
    }
    fn max_aggregate_size(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.max_aggregate_size
    }
    fn admixtures_description(&self) -> &Option<IfcText> {
        &self.admixtures_description
    }
    fn workability(&self) -> &Option<IfcText> {
        &self.workability
    }
    fn protective_pore_ratio(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.protective_pore_ratio
    }
    fn water_impermeability(&self) -> &Option<IfcText> {
        &self.water_impermeability
    }
}
impl IfcMechanicalConcreteMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalConcreteMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.dynamic_viscosity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.young_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.shear_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.poisson_ratio = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.thermal_expansion_coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.compressive_strength = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.max_aggregate_size = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.admixtures_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.workability = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.protective_pore_ratio = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.water_impermeability = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalFastener: IIfcFastener {
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn nominal_length(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMechanicalFastener {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    nominal_diameter: Option<IfcPositiveLengthMeasure>,
    nominal_length: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcMechanicalFastener {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMechanicalFastener {}
impl IIfcObject for IfcMechanicalFastener {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMechanicalFastener {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMechanicalFastener {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcElementComponent for IfcMechanicalFastener {}
impl IIfcFastener for IfcMechanicalFastener {}
impl IIfcMechanicalFastener for IfcMechanicalFastener {
    fn nominal_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_diameter
    }
    fn nominal_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_length
    }
}
impl IfcMechanicalFastener {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalFastener::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.nominal_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.nominal_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalFastenerType: IIfcFastenerType {}
#[derive(Default, Debug)]
pub struct IfcMechanicalFastenerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcMechanicalFastenerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMechanicalFastenerType {}
impl IIfcTypeObject for IfcMechanicalFastenerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMechanicalFastenerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMechanicalFastenerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcMechanicalFastenerType {}
impl IIfcFastenerType for IfcMechanicalFastenerType {}
impl IIfcMechanicalFastenerType for IfcMechanicalFastenerType {}
impl IfcMechanicalFastenerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalFastenerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalMaterialProperties: IIfcMaterialProperties {
    fn dynamic_viscosity(&self) -> &Option<IfcDynamicViscosityMeasure>;
    fn young_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure>;
    fn shear_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure>;
    fn poisson_ratio(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn thermal_expansion_coefficient(&self) -> &Option<IfcThermalExpansionCoefficientMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcMechanicalMaterialProperties {
    material: EntityRef,
    dynamic_viscosity: Option<IfcDynamicViscosityMeasure>,
    young_modulus: Option<IfcModulusOfElasticityMeasure>,
    shear_modulus: Option<IfcModulusOfElasticityMeasure>,
    poisson_ratio: Option<IfcPositiveRatioMeasure>,
    thermal_expansion_coefficient: Option<IfcThermalExpansionCoefficientMeasure>,
}
impl IIfcMaterialProperties for IfcMechanicalMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcMechanicalMaterialProperties for IfcMechanicalMaterialProperties {
    fn dynamic_viscosity(&self) -> &Option<IfcDynamicViscosityMeasure> {
        &self.dynamic_viscosity
    }
    fn young_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.young_modulus
    }
    fn shear_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.shear_modulus
    }
    fn poisson_ratio(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.poisson_ratio
    }
    fn thermal_expansion_coefficient(&self) -> &Option<IfcThermalExpansionCoefficientMeasure> {
        &self.thermal_expansion_coefficient
    }
}
impl IfcMechanicalMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.dynamic_viscosity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.young_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.shear_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.poisson_ratio = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.thermal_expansion_coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMechanicalSteelMaterialProperties: IIfcMechanicalMaterialProperties {
    fn yield_stress(&self) -> &Option<IfcPressureMeasure>;
    fn ultimate_stress(&self) -> &Option<IfcPressureMeasure>;
    fn ultimate_strain(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn hardening_module(&self) -> &Option<IfcModulusOfElasticityMeasure>;
    fn proportional_stress(&self) -> &Option<IfcPressureMeasure>;
    fn plastic_strain(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn relaxations(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcMechanicalSteelMaterialProperties {
    material: EntityRef,
    dynamic_viscosity: Option<IfcDynamicViscosityMeasure>,
    young_modulus: Option<IfcModulusOfElasticityMeasure>,
    shear_modulus: Option<IfcModulusOfElasticityMeasure>,
    poisson_ratio: Option<IfcPositiveRatioMeasure>,
    thermal_expansion_coefficient: Option<IfcThermalExpansionCoefficientMeasure>,
    yield_stress: Option<IfcPressureMeasure>,
    ultimate_stress: Option<IfcPressureMeasure>,
    ultimate_strain: Option<IfcPositiveRatioMeasure>,
    hardening_module: Option<IfcModulusOfElasticityMeasure>,
    proportional_stress: Option<IfcPressureMeasure>,
    plastic_strain: Option<IfcPositiveRatioMeasure>,
    relaxations: Option<HashSet<EntityRef>>,
}
impl IIfcMaterialProperties for IfcMechanicalSteelMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcMechanicalMaterialProperties for IfcMechanicalSteelMaterialProperties {
    fn dynamic_viscosity(&self) -> &Option<IfcDynamicViscosityMeasure> {
        &self.dynamic_viscosity
    }
    fn young_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.young_modulus
    }
    fn shear_modulus(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.shear_modulus
    }
    fn poisson_ratio(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.poisson_ratio
    }
    fn thermal_expansion_coefficient(&self) -> &Option<IfcThermalExpansionCoefficientMeasure> {
        &self.thermal_expansion_coefficient
    }
}
impl IIfcMechanicalSteelMaterialProperties for IfcMechanicalSteelMaterialProperties {
    fn yield_stress(&self) -> &Option<IfcPressureMeasure> {
        &self.yield_stress
    }
    fn ultimate_stress(&self) -> &Option<IfcPressureMeasure> {
        &self.ultimate_stress
    }
    fn ultimate_strain(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.ultimate_strain
    }
    fn hardening_module(&self) -> &Option<IfcModulusOfElasticityMeasure> {
        &self.hardening_module
    }
    fn proportional_stress(&self) -> &Option<IfcPressureMeasure> {
        &self.proportional_stress
    }
    fn plastic_strain(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.plastic_strain
    }
    fn relaxations(&self) -> &Option<HashSet<EntityRef>> {
        &self.relaxations
    }
}
impl IfcMechanicalSteelMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMechanicalSteelMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.dynamic_viscosity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.young_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.shear_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.poisson_ratio = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.thermal_expansion_coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.yield_stress = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.ultimate_stress = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.ultimate_strain = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.hardening_module = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.proportional_stress = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.plastic_strain = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.relaxations = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMember: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcMember {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMember {}
impl IIfcObject for IfcMember {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcMember {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcMember {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcMember {}
impl IIfcMember for IfcMember {}
impl IfcMember {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMemberType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcMemberTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcMemberType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcMemberTypeEnum,
}
impl IIfcRoot for IfcMemberType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMemberType {}
impl IIfcTypeObject for IfcMemberType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMemberType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMemberType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcMemberType {}
impl IIfcMemberType for IfcMemberType {
    fn predefined_type(&self) -> &IfcMemberTypeEnum {
        &self.predefined_type
    }
}
impl IfcMemberType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMemberType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMetric: IIfcConstraint {
    fn benchmark(&self) -> &IfcBenchmarkEnum;
    fn value_source(&self) -> &Option<IfcLabel>;
    fn data_value(&self) -> &IfcMetricValueSelect;
}
#[derive(Default, Debug)]
pub struct IfcMetric {
    name: IfcLabel,
    description: Option<IfcText>,
    constraint_grade: IfcConstraintEnum,
    constraint_source: Option<IfcLabel>,
    creating_actor: Option<EntityRef>,
    creation_time: Option<EntityRef>,
    user_defined_grade: Option<IfcLabel>,
    benchmark: IfcBenchmarkEnum,
    value_source: Option<IfcLabel>,
    data_value: IfcMetricValueSelect,
}
impl IIfcConstraint for IfcMetric {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn constraint_grade(&self) -> &IfcConstraintEnum {
        &self.constraint_grade
    }
    fn constraint_source(&self) -> &Option<IfcLabel> {
        &self.constraint_source
    }
    fn creating_actor(&self) -> &Option<EntityRef> {
        &self.creating_actor
    }
    fn creation_time(&self) -> &Option<EntityRef> {
        &self.creation_time
    }
    fn user_defined_grade(&self) -> &Option<IfcLabel> {
        &self.user_defined_grade
    }
}
impl IIfcMetric for IfcMetric {
    fn benchmark(&self) -> &IfcBenchmarkEnum {
        &self.benchmark
    }
    fn value_source(&self) -> &Option<IfcLabel> {
        &self.value_source
    }
    fn data_value(&self) -> &IfcMetricValueSelect {
        &self.data_value
    }
}
impl IfcMetric {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMetric::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.constraint_grade = parameter.into(),
                3usize => {
                    entity.constraint_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.creating_actor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.creation_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.user_defined_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.benchmark = parameter.into(),
                8usize => {
                    entity.value_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.data_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMonetaryUnit {
    fn currency(&self) -> &IfcCurrencyEnum;
}
#[derive(Default, Debug)]
pub struct IfcMonetaryUnit {
    currency: IfcCurrencyEnum,
}
impl IIfcMonetaryUnit for IfcMonetaryUnit {
    fn currency(&self) -> &IfcCurrencyEnum {
        &self.currency
    }
}
impl IfcMonetaryUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMonetaryUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.currency = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMotorConnectionType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcMotorConnectionTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcMotorConnectionType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcMotorConnectionTypeEnum,
}
impl IIfcRoot for IfcMotorConnectionType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMotorConnectionType {}
impl IIfcTypeObject for IfcMotorConnectionType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcMotorConnectionType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcMotorConnectionType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcMotorConnectionType {}
impl IIfcDistributionFlowElementType for IfcMotorConnectionType {}
impl IIfcEnergyConversionDeviceType for IfcMotorConnectionType {}
impl IIfcMotorConnectionType for IfcMotorConnectionType {
    fn predefined_type(&self) -> &IfcMotorConnectionTypeEnum {
        &self.predefined_type
    }
}
impl IfcMotorConnectionType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMotorConnectionType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcMove: IIfcTask {
    fn move_from(&self) -> &EntityRef;
    fn move_to(&self) -> &EntityRef;
    fn punch_list(&self) -> &Option<Vec<IfcText>>;
}
#[derive(Default, Debug)]
pub struct IfcMove {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    task_id: IfcIdentifier,
    status: Option<IfcLabel>,
    work_method: Option<IfcLabel>,
    is_milestone: bool,
    priority: Option<i64>,
    move_from: EntityRef,
    move_to: EntityRef,
    punch_list: Option<Vec<IfcText>>,
}
impl IIfcRoot for IfcMove {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcMove {}
impl IIfcObject for IfcMove {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcMove {}
impl IIfcTask for IfcMove {
    fn task_id(&self) -> &IfcIdentifier {
        &self.task_id
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn work_method(&self) -> &Option<IfcLabel> {
        &self.work_method
    }
    fn is_milestone(&self) -> bool {
        self.is_milestone
    }
    fn priority(&self) -> Option<i64> {
        self.priority
    }
}
impl IIfcMove for IfcMove {
    fn move_from(&self) -> &EntityRef {
        &self.move_from
    }
    fn move_to(&self) -> &EntityRef {
        &self.move_to
    }
    fn punch_list(&self) -> &Option<Vec<IfcText>> {
        &self.punch_list
    }
}
impl IfcMove {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcMove::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.task_id = parameter.into(),
                6usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.is_milestone = parameter.into(),
                9usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => entity.move_from = parameter.into(),
                11usize => entity.move_to = parameter.into(),
                12usize => {
                    entity.punch_list = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcNamedUnit {
    fn dimensions(&self) -> &EntityRef;
    fn unit_type(&self) -> &IfcUnitEnum;
}
pub trait IIfcObject: IIfcObjectDefinition {
    fn object_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcObjectDefinition: IIfcRoot {}
pub trait IIfcObjectPlacement {}
pub trait IIfcObjective: IIfcConstraint {
    fn benchmark_values(&self) -> &Option<EntityRef>;
    fn result_values(&self) -> &Option<EntityRef>;
    fn objective_qualifier(&self) -> &IfcObjectiveEnum;
    fn user_defined_qualifier(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcObjective {
    name: IfcLabel,
    description: Option<IfcText>,
    constraint_grade: IfcConstraintEnum,
    constraint_source: Option<IfcLabel>,
    creating_actor: Option<EntityRef>,
    creation_time: Option<EntityRef>,
    user_defined_grade: Option<IfcLabel>,
    benchmark_values: Option<EntityRef>,
    result_values: Option<EntityRef>,
    objective_qualifier: IfcObjectiveEnum,
    user_defined_qualifier: Option<IfcLabel>,
}
impl IIfcConstraint for IfcObjective {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn constraint_grade(&self) -> &IfcConstraintEnum {
        &self.constraint_grade
    }
    fn constraint_source(&self) -> &Option<IfcLabel> {
        &self.constraint_source
    }
    fn creating_actor(&self) -> &Option<EntityRef> {
        &self.creating_actor
    }
    fn creation_time(&self) -> &Option<EntityRef> {
        &self.creation_time
    }
    fn user_defined_grade(&self) -> &Option<IfcLabel> {
        &self.user_defined_grade
    }
}
impl IIfcObjective for IfcObjective {
    fn benchmark_values(&self) -> &Option<EntityRef> {
        &self.benchmark_values
    }
    fn result_values(&self) -> &Option<EntityRef> {
        &self.result_values
    }
    fn objective_qualifier(&self) -> &IfcObjectiveEnum {
        &self.objective_qualifier
    }
    fn user_defined_qualifier(&self) -> &Option<IfcLabel> {
        &self.user_defined_qualifier
    }
}
impl IfcObjective {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcObjective::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.constraint_grade = parameter.into(),
                3usize => {
                    entity.constraint_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.creating_actor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.creation_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.user_defined_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.benchmark_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.result_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.objective_qualifier = parameter.into(),
                10usize => {
                    entity.user_defined_qualifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOccupant: IIfcActor {
    fn predefined_type(&self) -> &IfcOccupantTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcOccupant {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    the_actor: EntityRef,
    predefined_type: IfcOccupantTypeEnum,
}
impl IIfcRoot for IfcOccupant {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOccupant {}
impl IIfcObject for IfcOccupant {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcActor for IfcOccupant {
    fn the_actor(&self) -> &EntityRef {
        &self.the_actor
    }
}
impl IIfcOccupant for IfcOccupant {
    fn predefined_type(&self) -> &IfcOccupantTypeEnum {
        &self.predefined_type
    }
}
impl IfcOccupant {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOccupant::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.the_actor = parameter.into(),
                6usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOffsetCurve2D: IIfcCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &IfcLengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
}
#[derive(Default, Debug)]
pub struct IfcOffsetCurve2D {
    basis_curve: EntityRef,
    distance: IfcLengthMeasure,
    self_intersect: Option<bool>,
}
impl IIfcRepresentationItem for IfcOffsetCurve2D {}
impl IIfcGeometricRepresentationItem for IfcOffsetCurve2D {}
impl IIfcCurve for IfcOffsetCurve2D {}
impl IIfcOffsetCurve2D for IfcOffsetCurve2D {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &IfcLengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IfcOffsetCurve2D {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOffsetCurve2D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.distance = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOffsetCurve3D: IIfcCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn distance(&self) -> &IfcLengthMeasure;
    fn self_intersect(&self) -> Option<bool>;
    fn ref_direction(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcOffsetCurve3D {
    basis_curve: EntityRef,
    distance: IfcLengthMeasure,
    self_intersect: Option<bool>,
    ref_direction: EntityRef,
}
impl IIfcRepresentationItem for IfcOffsetCurve3D {}
impl IIfcGeometricRepresentationItem for IfcOffsetCurve3D {}
impl IIfcCurve for IfcOffsetCurve3D {}
impl IIfcOffsetCurve3D for IfcOffsetCurve3D {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn distance(&self) -> &IfcLengthMeasure {
        &self.distance
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
    fn ref_direction(&self) -> &EntityRef {
        &self.ref_direction
    }
}
impl IfcOffsetCurve3D {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOffsetCurve3D::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.distance = parameter.into(),
                2usize => entity.self_intersect = parameter.into(),
                3usize => entity.ref_direction = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOneDirectionRepeatFactor: IIfcGeometricRepresentationItem {
    fn repeat_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcOneDirectionRepeatFactor {
    repeat_factor: EntityRef,
}
impl IIfcRepresentationItem for IfcOneDirectionRepeatFactor {}
impl IIfcGeometricRepresentationItem for IfcOneDirectionRepeatFactor {}
impl IIfcOneDirectionRepeatFactor for IfcOneDirectionRepeatFactor {
    fn repeat_factor(&self) -> &EntityRef {
        &self.repeat_factor
    }
}
impl IfcOneDirectionRepeatFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOneDirectionRepeatFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOpenShell: IIfcConnectedFaceSet {}
#[derive(Default, Debug)]
pub struct IfcOpenShell {
    cfs_faces: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcOpenShell {}
impl IIfcTopologicalRepresentationItem for IfcOpenShell {}
impl IIfcConnectedFaceSet for IfcOpenShell {
    fn cfs_faces(&self) -> &HashSet<EntityRef> {
        &self.cfs_faces
    }
}
impl IIfcOpenShell for IfcOpenShell {}
impl IfcOpenShell {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpenShell::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.cfs_faces = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOpeningElement: IIfcFeatureElementSubtraction {}
#[derive(Default, Debug)]
pub struct IfcOpeningElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcOpeningElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOpeningElement {}
impl IIfcObject for IfcOpeningElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcOpeningElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcOpeningElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcOpeningElement {}
impl IIfcFeatureElementSubtraction for IfcOpeningElement {}
impl IIfcOpeningElement for IfcOpeningElement {}
impl IfcOpeningElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpeningElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOpticalMaterialProperties: IIfcMaterialProperties {
    fn visible_transmittance(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn solar_transmittance(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn thermal_ir_transmittance(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn thermal_ir_emissivity_back(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn thermal_ir_emissivity_front(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn visible_reflectance_back(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn visible_reflectance_front(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn solar_reflectance_front(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn solar_reflectance_back(&self) -> &Option<IfcPositiveRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcOpticalMaterialProperties {
    material: EntityRef,
    visible_transmittance: Option<IfcPositiveRatioMeasure>,
    solar_transmittance: Option<IfcPositiveRatioMeasure>,
    thermal_ir_transmittance: Option<IfcPositiveRatioMeasure>,
    thermal_ir_emissivity_back: Option<IfcPositiveRatioMeasure>,
    thermal_ir_emissivity_front: Option<IfcPositiveRatioMeasure>,
    visible_reflectance_back: Option<IfcPositiveRatioMeasure>,
    visible_reflectance_front: Option<IfcPositiveRatioMeasure>,
    solar_reflectance_front: Option<IfcPositiveRatioMeasure>,
    solar_reflectance_back: Option<IfcPositiveRatioMeasure>,
}
impl IIfcMaterialProperties for IfcOpticalMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcOpticalMaterialProperties for IfcOpticalMaterialProperties {
    fn visible_transmittance(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.visible_transmittance
    }
    fn solar_transmittance(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.solar_transmittance
    }
    fn thermal_ir_transmittance(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.thermal_ir_transmittance
    }
    fn thermal_ir_emissivity_back(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.thermal_ir_emissivity_back
    }
    fn thermal_ir_emissivity_front(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.thermal_ir_emissivity_front
    }
    fn visible_reflectance_back(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.visible_reflectance_back
    }
    fn visible_reflectance_front(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.visible_reflectance_front
    }
    fn solar_reflectance_front(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.solar_reflectance_front
    }
    fn solar_reflectance_back(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.solar_reflectance_back
    }
}
impl IfcOpticalMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOpticalMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.visible_transmittance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.solar_transmittance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.thermal_ir_transmittance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.thermal_ir_emissivity_back = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.thermal_ir_emissivity_front = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.visible_reflectance_back = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.visible_reflectance_front = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.solar_reflectance_front = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.solar_reflectance_back = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrderAction: IIfcTask {
    fn action_id(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcOrderAction {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    task_id: IfcIdentifier,
    status: Option<IfcLabel>,
    work_method: Option<IfcLabel>,
    is_milestone: bool,
    priority: Option<i64>,
    action_id: IfcIdentifier,
}
impl IIfcRoot for IfcOrderAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOrderAction {}
impl IIfcObject for IfcOrderAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcOrderAction {}
impl IIfcTask for IfcOrderAction {
    fn task_id(&self) -> &IfcIdentifier {
        &self.task_id
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn work_method(&self) -> &Option<IfcLabel> {
        &self.work_method
    }
    fn is_milestone(&self) -> bool {
        self.is_milestone
    }
    fn priority(&self) -> Option<i64> {
        self.priority
    }
}
impl IIfcOrderAction for IfcOrderAction {
    fn action_id(&self) -> &IfcIdentifier {
        &self.action_id
    }
}
impl IfcOrderAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrderAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.task_id = parameter.into(),
                6usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.is_milestone = parameter.into(),
                9usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => entity.action_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrganization {
    fn id(&self) -> &Option<IfcIdentifier>;
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn roles(&self) -> &Option<Vec<EntityRef>>;
    fn addresses(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcOrganization {
    id: Option<IfcIdentifier>,
    name: IfcLabel,
    description: Option<IfcText>,
    roles: Option<Vec<EntityRef>>,
    addresses: Option<Vec<EntityRef>>,
}
impl IIfcOrganization for IfcOrganization {
    fn id(&self) -> &Option<IfcIdentifier> {
        &self.id
    }
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn roles(&self) -> &Option<Vec<EntityRef>> {
        &self.roles
    }
    fn addresses(&self) -> &Option<Vec<EntityRef>> {
        &self.addresses
    }
}
impl IfcOrganization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.name = parameter.into(),
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.roles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrganizationRelationship {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn relating_organization(&self) -> &EntityRef;
    fn related_organizations(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcOrganizationRelationship {
    name: IfcLabel,
    description: Option<IfcText>,
    relating_organization: EntityRef,
    related_organizations: HashSet<EntityRef>,
}
impl IIfcOrganizationRelationship for IfcOrganizationRelationship {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn relating_organization(&self) -> &EntityRef {
        &self.relating_organization
    }
    fn related_organizations(&self) -> &HashSet<EntityRef> {
        &self.related_organizations
    }
}
impl IfcOrganizationRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrganizationRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.relating_organization = parameter.into(),
                3usize => entity.related_organizations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOrientedEdge: IIfcEdge {
    fn edge_element(&self) -> &EntityRef;
    fn orientation(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcOrientedEdge {
    edge_start: EntityRef,
    edge_end: EntityRef,
    edge_element: EntityRef,
    orientation: bool,
}
impl IIfcRepresentationItem for IfcOrientedEdge {}
impl IIfcTopologicalRepresentationItem for IfcOrientedEdge {}
impl IIfcEdge for IfcOrientedEdge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IIfcOrientedEdge for IfcOrientedEdge {
    fn edge_element(&self) -> &EntityRef {
        &self.edge_element
    }
    fn orientation(&self) -> bool {
        self.orientation
    }
}
impl IfcOrientedEdge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOrientedEdge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                2usize => entity.edge_element = parameter.into(),
                3usize => entity.orientation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOutletType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcOutletTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcOutletType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcOutletTypeEnum,
}
impl IIfcRoot for IfcOutletType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcOutletType {}
impl IIfcTypeObject for IfcOutletType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcOutletType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcOutletType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcOutletType {}
impl IIfcDistributionFlowElementType for IfcOutletType {}
impl IIfcFlowTerminalType for IfcOutletType {}
impl IIfcOutletType for IfcOutletType {
    fn predefined_type(&self) -> &IfcOutletTypeEnum {
        &self.predefined_type
    }
}
impl IfcOutletType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOutletType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcOwnerHistory {
    fn owning_user(&self) -> &EntityRef;
    fn owning_application(&self) -> &EntityRef;
    fn state(&self) -> &Option<IfcStateEnum>;
    fn change_action(&self) -> &IfcChangeActionEnum;
    fn last_modified_date(&self) -> &Option<IfcTimeStamp>;
    fn last_modifying_user(&self) -> &Option<EntityRef>;
    fn last_modifying_application(&self) -> &Option<EntityRef>;
    fn creation_date(&self) -> &IfcTimeStamp;
}
#[derive(Default, Debug)]
pub struct IfcOwnerHistory {
    owning_user: EntityRef,
    owning_application: EntityRef,
    state: Option<IfcStateEnum>,
    change_action: IfcChangeActionEnum,
    last_modified_date: Option<IfcTimeStamp>,
    last_modifying_user: Option<EntityRef>,
    last_modifying_application: Option<EntityRef>,
    creation_date: IfcTimeStamp,
}
impl IIfcOwnerHistory for IfcOwnerHistory {
    fn owning_user(&self) -> &EntityRef {
        &self.owning_user
    }
    fn owning_application(&self) -> &EntityRef {
        &self.owning_application
    }
    fn state(&self) -> &Option<IfcStateEnum> {
        &self.state
    }
    fn change_action(&self) -> &IfcChangeActionEnum {
        &self.change_action
    }
    fn last_modified_date(&self) -> &Option<IfcTimeStamp> {
        &self.last_modified_date
    }
    fn last_modifying_user(&self) -> &Option<EntityRef> {
        &self.last_modifying_user
    }
    fn last_modifying_application(&self) -> &Option<EntityRef> {
        &self.last_modifying_application
    }
    fn creation_date(&self) -> &IfcTimeStamp {
        &self.creation_date
    }
}
impl IfcOwnerHistory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcOwnerHistory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.owning_user = parameter.into(),
                1usize => entity.owning_application = parameter.into(),
                2usize => {
                    entity.state = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.change_action = parameter.into(),
                4usize => {
                    entity.last_modified_date = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.last_modifying_user = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.last_modifying_application = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.creation_date = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcParameterizedProfileDef: IIfcProfileDef {
    fn position(&self) -> &EntityRef;
}
pub trait IIfcPath: IIfcTopologicalRepresentationItem {
    fn edge_list(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPath {
    edge_list: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcPath {}
impl IIfcTopologicalRepresentationItem for IfcPath {}
impl IIfcPath for IfcPath {
    fn edge_list(&self) -> &Vec<EntityRef> {
        &self.edge_list
    }
}
impl IfcPath {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPath::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_list = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPerformanceHistory: IIfcControl {
    fn life_cycle_phase(&self) -> &IfcLabel;
}
#[derive(Default, Debug)]
pub struct IfcPerformanceHistory {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    life_cycle_phase: IfcLabel,
}
impl IIfcRoot for IfcPerformanceHistory {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPerformanceHistory {}
impl IIfcObject for IfcPerformanceHistory {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcPerformanceHistory {}
impl IIfcPerformanceHistory for IfcPerformanceHistory {
    fn life_cycle_phase(&self) -> &IfcLabel {
        &self.life_cycle_phase
    }
}
impl IfcPerformanceHistory {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPerformanceHistory::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.life_cycle_phase = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPermeableCoveringProperties: IIfcPropertySetDefinition {
    fn operation_type(&self) -> &IfcPermeableCoveringOperationEnum;
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum;
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPermeableCoveringProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    operation_type: IfcPermeableCoveringOperationEnum,
    panel_position: IfcWindowPanelPositionEnum,
    frame_depth: Option<IfcPositiveLengthMeasure>,
    frame_thickness: Option<IfcPositiveLengthMeasure>,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcPermeableCoveringProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcPermeableCoveringProperties {}
impl IIfcPropertySetDefinition for IfcPermeableCoveringProperties {}
impl IIfcPermeableCoveringProperties for IfcPermeableCoveringProperties {
    fn operation_type(&self) -> &IfcPermeableCoveringOperationEnum {
        &self.operation_type
    }
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum {
        &self.panel_position
    }
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_depth
    }
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_thickness
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcPermeableCoveringProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPermeableCoveringProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.operation_type = parameter.into(),
                5usize => entity.panel_position = parameter.into(),
                6usize => {
                    entity.frame_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.frame_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPermit: IIfcControl {
    fn permit_id(&self) -> &IfcIdentifier;
}
#[derive(Default, Debug)]
pub struct IfcPermit {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    permit_id: IfcIdentifier,
}
impl IIfcRoot for IfcPermit {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPermit {}
impl IIfcObject for IfcPermit {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcPermit {}
impl IIfcPermit for IfcPermit {
    fn permit_id(&self) -> &IfcIdentifier {
        &self.permit_id
    }
}
impl IfcPermit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPermit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.permit_id = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPerson {
    fn id(&self) -> &Option<IfcIdentifier>;
    fn family_name(&self) -> &Option<IfcLabel>;
    fn given_name(&self) -> &Option<IfcLabel>;
    fn middle_names(&self) -> &Option<Vec<IfcLabel>>;
    fn prefix_titles(&self) -> &Option<Vec<IfcLabel>>;
    fn suffix_titles(&self) -> &Option<Vec<IfcLabel>>;
    fn roles(&self) -> &Option<Vec<EntityRef>>;
    fn addresses(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcPerson {
    id: Option<IfcIdentifier>,
    family_name: Option<IfcLabel>,
    given_name: Option<IfcLabel>,
    middle_names: Option<Vec<IfcLabel>>,
    prefix_titles: Option<Vec<IfcLabel>>,
    suffix_titles: Option<Vec<IfcLabel>>,
    roles: Option<Vec<EntityRef>>,
    addresses: Option<Vec<EntityRef>>,
}
impl IIfcPerson for IfcPerson {
    fn id(&self) -> &Option<IfcIdentifier> {
        &self.id
    }
    fn family_name(&self) -> &Option<IfcLabel> {
        &self.family_name
    }
    fn given_name(&self) -> &Option<IfcLabel> {
        &self.given_name
    }
    fn middle_names(&self) -> &Option<Vec<IfcLabel>> {
        &self.middle_names
    }
    fn prefix_titles(&self) -> &Option<Vec<IfcLabel>> {
        &self.prefix_titles
    }
    fn suffix_titles(&self) -> &Option<Vec<IfcLabel>> {
        &self.suffix_titles
    }
    fn roles(&self) -> &Option<Vec<EntityRef>> {
        &self.roles
    }
    fn addresses(&self) -> &Option<Vec<EntityRef>> {
        &self.addresses
    }
}
impl IfcPerson {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPerson::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.id = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.family_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.given_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.middle_names = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.prefix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.suffix_titles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.roles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPersonAndOrganization {
    fn the_person(&self) -> &EntityRef;
    fn the_organization(&self) -> &EntityRef;
    fn roles(&self) -> &Option<Vec<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcPersonAndOrganization {
    the_person: EntityRef,
    the_organization: EntityRef,
    roles: Option<Vec<EntityRef>>,
}
impl IIfcPersonAndOrganization for IfcPersonAndOrganization {
    fn the_person(&self) -> &EntityRef {
        &self.the_person
    }
    fn the_organization(&self) -> &EntityRef {
        &self.the_organization
    }
    fn roles(&self) -> &Option<Vec<EntityRef>> {
        &self.roles
    }
}
impl IfcPersonAndOrganization {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPersonAndOrganization::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.the_person = parameter.into(),
                1usize => entity.the_organization = parameter.into(),
                2usize => {
                    entity.roles = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPhysicalComplexQuantity: IIfcPhysicalQuantity {
    fn has_quantities(&self) -> &HashSet<EntityRef>;
    fn discrimination(&self) -> &IfcLabel;
    fn quality(&self) -> &Option<IfcLabel>;
    fn usage(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcPhysicalComplexQuantity {
    name: IfcLabel,
    description: Option<IfcText>,
    has_quantities: HashSet<EntityRef>,
    discrimination: IfcLabel,
    quality: Option<IfcLabel>,
    usage: Option<IfcLabel>,
}
impl IIfcPhysicalQuantity for IfcPhysicalComplexQuantity {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalComplexQuantity for IfcPhysicalComplexQuantity {
    fn has_quantities(&self) -> &HashSet<EntityRef> {
        &self.has_quantities
    }
    fn discrimination(&self) -> &IfcLabel {
        &self.discrimination
    }
    fn quality(&self) -> &Option<IfcLabel> {
        &self.quality
    }
    fn usage(&self) -> &Option<IfcLabel> {
        &self.usage
    }
}
impl IfcPhysicalComplexQuantity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPhysicalComplexQuantity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.has_quantities = parameter.into(),
                3usize => entity.discrimination = parameter.into(),
                4usize => {
                    entity.quality = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.usage = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPhysicalQuantity {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcPhysicalSimpleQuantity: IIfcPhysicalQuantity {
    fn unit(&self) -> &Option<EntityRef>;
}
pub trait IIfcPile: IIfcBuildingElement {
    fn predefined_type(&self) -> &IfcPileTypeEnum;
    fn construction_type(&self) -> &Option<IfcPileConstructionEnum>;
}
#[derive(Default, Debug)]
pub struct IfcPile {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: IfcPileTypeEnum,
    construction_type: Option<IfcPileConstructionEnum>,
}
impl IIfcRoot for IfcPile {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPile {}
impl IIfcObject for IfcPile {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPile {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPile {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcPile {}
impl IIfcPile for IfcPile {
    fn predefined_type(&self) -> &IfcPileTypeEnum {
        &self.predefined_type
    }
    fn construction_type(&self) -> &Option<IfcPileConstructionEnum> {
        &self.construction_type
    }
}
impl IfcPile {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPile::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.predefined_type = parameter.into(),
                9usize => {
                    entity.construction_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPipeFittingType: IIfcFlowFittingType {
    fn predefined_type(&self) -> &IfcPipeFittingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPipeFittingType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPipeFittingTypeEnum,
}
impl IIfcRoot for IfcPipeFittingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPipeFittingType {}
impl IIfcTypeObject for IfcPipeFittingType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPipeFittingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPipeFittingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcPipeFittingType {}
impl IIfcDistributionFlowElementType for IfcPipeFittingType {}
impl IIfcFlowFittingType for IfcPipeFittingType {}
impl IIfcPipeFittingType for IfcPipeFittingType {
    fn predefined_type(&self) -> &IfcPipeFittingTypeEnum {
        &self.predefined_type
    }
}
impl IfcPipeFittingType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeFittingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPipeSegmentType: IIfcFlowSegmentType {
    fn predefined_type(&self) -> &IfcPipeSegmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPipeSegmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPipeSegmentTypeEnum,
}
impl IIfcRoot for IfcPipeSegmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPipeSegmentType {}
impl IIfcTypeObject for IfcPipeSegmentType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPipeSegmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPipeSegmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcPipeSegmentType {}
impl IIfcDistributionFlowElementType for IfcPipeSegmentType {}
impl IIfcFlowSegmentType for IfcPipeSegmentType {}
impl IIfcPipeSegmentType for IfcPipeSegmentType {
    fn predefined_type(&self) -> &IfcPipeSegmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcPipeSegmentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPipeSegmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPixelTexture: IIfcSurfaceTexture {
    fn width(&self) -> &IfcInteger;
    fn height(&self) -> &IfcInteger;
    fn colour_components(&self) -> &IfcInteger;
    fn pixel(&self) -> &Vec<Unimplemented>;
}
#[derive(Default, Debug)]
pub struct IfcPixelTexture {
    repeat_s: bool,
    repeat_t: bool,
    texture_type: IfcSurfaceTextureEnum,
    texture_transform: Option<EntityRef>,
    width: IfcInteger,
    height: IfcInteger,
    colour_components: IfcInteger,
    pixel: Vec<Unimplemented>,
}
impl IIfcSurfaceTexture for IfcPixelTexture {
    fn repeat_s(&self) -> bool {
        self.repeat_s
    }
    fn repeat_t(&self) -> bool {
        self.repeat_t
    }
    fn texture_type(&self) -> &IfcSurfaceTextureEnum {
        &self.texture_type
    }
    fn texture_transform(&self) -> &Option<EntityRef> {
        &self.texture_transform
    }
}
impl IIfcPixelTexture for IfcPixelTexture {
    fn width(&self) -> &IfcInteger {
        &self.width
    }
    fn height(&self) -> &IfcInteger {
        &self.height
    }
    fn colour_components(&self) -> &IfcInteger {
        &self.colour_components
    }
    fn pixel(&self) -> &Vec<Unimplemented> {
        &self.pixel
    }
}
impl IfcPixelTexture {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPixelTexture::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_s = parameter.into(),
                1usize => entity.repeat_t = parameter.into(),
                2usize => entity.texture_type = parameter.into(),
                3usize => {
                    entity.texture_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.width = parameter.into(),
                5usize => entity.height = parameter.into(),
                6usize => entity.colour_components = parameter.into(),
                7usize => entity.pixel = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlacement: IIfcGeometricRepresentationItem {
    fn location(&self) -> &EntityRef;
}
pub trait IIfcPlanarBox: IIfcPlanarExtent {
    fn placement(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcPlanarBox {
    size_in_x: IfcLengthMeasure,
    size_in_y: IfcLengthMeasure,
    placement: EntityRef,
}
impl IIfcRepresentationItem for IfcPlanarBox {}
impl IIfcGeometricRepresentationItem for IfcPlanarBox {}
impl IIfcPlanarExtent for IfcPlanarBox {
    fn size_in_x(&self) -> &IfcLengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &IfcLengthMeasure {
        &self.size_in_y
    }
}
impl IIfcPlanarBox for IfcPlanarBox {
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
}
impl IfcPlanarBox {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlanarBox::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.size_in_x = parameter.into(),
                1usize => entity.size_in_y = parameter.into(),
                2usize => entity.placement = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlanarExtent: IIfcGeometricRepresentationItem {
    fn size_in_x(&self) -> &IfcLengthMeasure;
    fn size_in_y(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcPlanarExtent {
    size_in_x: IfcLengthMeasure,
    size_in_y: IfcLengthMeasure,
}
impl IIfcRepresentationItem for IfcPlanarExtent {}
impl IIfcGeometricRepresentationItem for IfcPlanarExtent {}
impl IIfcPlanarExtent for IfcPlanarExtent {
    fn size_in_x(&self) -> &IfcLengthMeasure {
        &self.size_in_x
    }
    fn size_in_y(&self) -> &IfcLengthMeasure {
        &self.size_in_y
    }
}
impl IfcPlanarExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlanarExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.size_in_x = parameter.into(),
                1usize => entity.size_in_y = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlane: IIfcElementarySurface {}
#[derive(Default, Debug)]
pub struct IfcPlane {
    position: EntityRef,
}
impl IIfcRepresentationItem for IfcPlane {}
impl IIfcGeometricRepresentationItem for IfcPlane {}
impl IIfcSurface for IfcPlane {}
impl IIfcElementarySurface for IfcPlane {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcPlane for IfcPlane {}
impl IfcPlane {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlane::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlate: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcPlate {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcPlate {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPlate {}
impl IIfcObject for IfcPlate {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcPlate {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcPlate {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcPlate {}
impl IIfcPlate for IfcPlate {}
impl IfcPlate {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlate::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPlateType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcPlateTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPlateType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPlateTypeEnum,
}
impl IIfcRoot for IfcPlateType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPlateType {}
impl IIfcTypeObject for IfcPlateType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPlateType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPlateType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcPlateType {}
impl IIfcPlateType for IfcPlateType {
    fn predefined_type(&self) -> &IfcPlateTypeEnum {
        &self.predefined_type
    }
}
impl IfcPlateType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPlateType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPoint: IIfcGeometricRepresentationItem {}
pub trait IIfcPointOnCurve: IIfcPoint {
    fn basis_curve(&self) -> &EntityRef;
    fn point_parameter(&self) -> &IfcParameterValue;
}
#[derive(Default, Debug)]
pub struct IfcPointOnCurve {
    basis_curve: EntityRef,
    point_parameter: IfcParameterValue,
}
impl IIfcRepresentationItem for IfcPointOnCurve {}
impl IIfcGeometricRepresentationItem for IfcPointOnCurve {}
impl IIfcPoint for IfcPointOnCurve {}
impl IIfcPointOnCurve for IfcPointOnCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn point_parameter(&self) -> &IfcParameterValue {
        &self.point_parameter
    }
}
impl IfcPointOnCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPointOnCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.point_parameter = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPointOnSurface: IIfcPoint {
    fn basis_surface(&self) -> &EntityRef;
    fn point_parameter_u(&self) -> &IfcParameterValue;
    fn point_parameter_v(&self) -> &IfcParameterValue;
}
#[derive(Default, Debug)]
pub struct IfcPointOnSurface {
    basis_surface: EntityRef,
    point_parameter_u: IfcParameterValue,
    point_parameter_v: IfcParameterValue,
}
impl IIfcRepresentationItem for IfcPointOnSurface {}
impl IIfcGeometricRepresentationItem for IfcPointOnSurface {}
impl IIfcPoint for IfcPointOnSurface {}
impl IIfcPointOnSurface for IfcPointOnSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn point_parameter_u(&self) -> &IfcParameterValue {
        &self.point_parameter_u
    }
    fn point_parameter_v(&self) -> &IfcParameterValue {
        &self.point_parameter_v
    }
}
impl IfcPointOnSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPointOnSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.point_parameter_u = parameter.into(),
                2usize => entity.point_parameter_v = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolyLoop: IIfcLoop {
    fn polygon(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPolyLoop {
    polygon: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcPolyLoop {}
impl IIfcTopologicalRepresentationItem for IfcPolyLoop {}
impl IIfcLoop for IfcPolyLoop {}
impl IIfcPolyLoop for IfcPolyLoop {
    fn polygon(&self) -> &Vec<EntityRef> {
        &self.polygon
    }
}
impl IfcPolyLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolyLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.polygon = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolygonalBoundedHalfSpace: IIfcHalfSpaceSolid {
    fn position(&self) -> &EntityRef;
    fn polygonal_boundary(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcPolygonalBoundedHalfSpace {
    base_surface: EntityRef,
    agreement_flag: bool,
    position: EntityRef,
    polygonal_boundary: EntityRef,
}
impl IIfcRepresentationItem for IfcPolygonalBoundedHalfSpace {}
impl IIfcGeometricRepresentationItem for IfcPolygonalBoundedHalfSpace {}
impl IIfcHalfSpaceSolid for IfcPolygonalBoundedHalfSpace {
    fn base_surface(&self) -> &EntityRef {
        &self.base_surface
    }
    fn agreement_flag(&self) -> bool {
        self.agreement_flag
    }
}
impl IIfcPolygonalBoundedHalfSpace for IfcPolygonalBoundedHalfSpace {
    fn position(&self) -> &EntityRef {
        &self.position
    }
    fn polygonal_boundary(&self) -> &EntityRef {
        &self.polygonal_boundary
    }
}
impl IfcPolygonalBoundedHalfSpace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolygonalBoundedHalfSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.base_surface = parameter.into(),
                1usize => entity.agreement_flag = parameter.into(),
                2usize => entity.position = parameter.into(),
                3usize => entity.polygonal_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPolyline: IIfcBoundedCurve {
    fn points(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPolyline {
    points: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcPolyline {}
impl IIfcGeometricRepresentationItem for IfcPolyline {}
impl IIfcCurve for IfcPolyline {}
impl IIfcBoundedCurve for IfcPolyline {}
impl IIfcPolyline for IfcPolyline {
    fn points(&self) -> &Vec<EntityRef> {
        &self.points
    }
}
impl IfcPolyline {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPolyline::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.points = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPort: IIfcProduct {}
pub trait IIfcPostalAddress: IIfcAddress {
    fn internal_location(&self) -> &Option<IfcLabel>;
    fn address_lines(&self) -> &Option<Vec<IfcLabel>>;
    fn postal_box(&self) -> &Option<IfcLabel>;
    fn town(&self) -> &Option<IfcLabel>;
    fn region(&self) -> &Option<IfcLabel>;
    fn postal_code(&self) -> &Option<IfcLabel>;
    fn country(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcPostalAddress {
    purpose: Option<IfcAddressTypeEnum>,
    description: Option<IfcText>,
    user_defined_purpose: Option<IfcLabel>,
    internal_location: Option<IfcLabel>,
    address_lines: Option<Vec<IfcLabel>>,
    postal_box: Option<IfcLabel>,
    town: Option<IfcLabel>,
    region: Option<IfcLabel>,
    postal_code: Option<IfcLabel>,
    country: Option<IfcLabel>,
}
impl IIfcAddress for IfcPostalAddress {
    fn purpose(&self) -> &Option<IfcAddressTypeEnum> {
        &self.purpose
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn user_defined_purpose(&self) -> &Option<IfcLabel> {
        &self.user_defined_purpose
    }
}
impl IIfcPostalAddress for IfcPostalAddress {
    fn internal_location(&self) -> &Option<IfcLabel> {
        &self.internal_location
    }
    fn address_lines(&self) -> &Option<Vec<IfcLabel>> {
        &self.address_lines
    }
    fn postal_box(&self) -> &Option<IfcLabel> {
        &self.postal_box
    }
    fn town(&self) -> &Option<IfcLabel> {
        &self.town
    }
    fn region(&self) -> &Option<IfcLabel> {
        &self.region
    }
    fn postal_code(&self) -> &Option<IfcLabel> {
        &self.postal_code
    }
    fn country(&self) -> &Option<IfcLabel> {
        &self.country
    }
}
impl IfcPostalAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPostalAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.internal_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.address_lines = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.postal_box = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.town = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.region = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.postal_code = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.country = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPreDefinedColour: IIfcPreDefinedItem {}
pub trait IIfcPreDefinedCurveFont: IIfcPreDefinedItem {}
pub trait IIfcPreDefinedDimensionSymbol: IIfcPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct IfcPreDefinedDimensionSymbol {
    name: IfcLabel,
}
impl IIfcPreDefinedItem for IfcPreDefinedDimensionSymbol {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedSymbol for IfcPreDefinedDimensionSymbol {}
impl IIfcPreDefinedDimensionSymbol for IfcPreDefinedDimensionSymbol {}
impl IfcPreDefinedDimensionSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPreDefinedDimensionSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPreDefinedItem {
    fn name(&self) -> &IfcLabel;
}
pub trait IIfcPreDefinedPointMarkerSymbol: IIfcPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct IfcPreDefinedPointMarkerSymbol {
    name: IfcLabel,
}
impl IIfcPreDefinedItem for IfcPreDefinedPointMarkerSymbol {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedSymbol for IfcPreDefinedPointMarkerSymbol {}
impl IIfcPreDefinedPointMarkerSymbol for IfcPreDefinedPointMarkerSymbol {}
impl IfcPreDefinedPointMarkerSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPreDefinedPointMarkerSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPreDefinedSymbol: IIfcPreDefinedItem {}
pub trait IIfcPreDefinedTerminatorSymbol: IIfcPreDefinedSymbol {}
#[derive(Default, Debug)]
pub struct IfcPreDefinedTerminatorSymbol {
    name: IfcLabel,
}
impl IIfcPreDefinedItem for IfcPreDefinedTerminatorSymbol {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedSymbol for IfcPreDefinedTerminatorSymbol {}
impl IIfcPreDefinedTerminatorSymbol for IfcPreDefinedTerminatorSymbol {}
impl IfcPreDefinedTerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPreDefinedTerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPreDefinedTextFont: IIfcPreDefinedItem {}
pub trait IIfcPresentationLayerAssignment {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn assigned_items(&self) -> &HashSet<EntityRef>;
    fn identifier(&self) -> &Option<IfcIdentifier>;
}
#[derive(Default, Debug)]
pub struct IfcPresentationLayerAssignment {
    name: IfcLabel,
    description: Option<IfcText>,
    assigned_items: HashSet<EntityRef>,
    identifier: Option<IfcIdentifier>,
}
impl IIfcPresentationLayerAssignment for IfcPresentationLayerAssignment {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn assigned_items(&self) -> &HashSet<EntityRef> {
        &self.assigned_items
    }
    fn identifier(&self) -> &Option<IfcIdentifier> {
        &self.identifier
    }
}
impl IfcPresentationLayerAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationLayerAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.assigned_items = parameter.into(),
                3usize => {
                    entity.identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPresentationLayerWithStyle: IIfcPresentationLayerAssignment {
    fn layer_on(&self) -> Option<bool>;
    fn layer_frozen(&self) -> Option<bool>;
    fn layer_blocked(&self) -> Option<bool>;
    fn layer_styles(&self) -> &HashSet<IfcPresentationStyleSelect>;
}
#[derive(Default, Debug)]
pub struct IfcPresentationLayerWithStyle {
    name: IfcLabel,
    description: Option<IfcText>,
    assigned_items: HashSet<EntityRef>,
    identifier: Option<IfcIdentifier>,
    layer_on: Option<bool>,
    layer_frozen: Option<bool>,
    layer_blocked: Option<bool>,
    layer_styles: HashSet<IfcPresentationStyleSelect>,
}
impl IIfcPresentationLayerAssignment for IfcPresentationLayerWithStyle {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn assigned_items(&self) -> &HashSet<EntityRef> {
        &self.assigned_items
    }
    fn identifier(&self) -> &Option<IfcIdentifier> {
        &self.identifier
    }
}
impl IIfcPresentationLayerWithStyle for IfcPresentationLayerWithStyle {
    fn layer_on(&self) -> Option<bool> {
        self.layer_on
    }
    fn layer_frozen(&self) -> Option<bool> {
        self.layer_frozen
    }
    fn layer_blocked(&self) -> Option<bool> {
        self.layer_blocked
    }
    fn layer_styles(&self) -> &HashSet<IfcPresentationStyleSelect> {
        &self.layer_styles
    }
}
impl IfcPresentationLayerWithStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationLayerWithStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.assigned_items = parameter.into(),
                3usize => {
                    entity.identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.layer_on = parameter.into(),
                5usize => entity.layer_frozen = parameter.into(),
                6usize => entity.layer_blocked = parameter.into(),
                7usize => entity.layer_styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPresentationStyle {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcPresentationStyleAssignment {
    fn styles(&self) -> &HashSet<IfcPresentationStyleSelect>;
}
#[derive(Default, Debug)]
pub struct IfcPresentationStyleAssignment {
    styles: HashSet<IfcPresentationStyleSelect>,
}
impl IIfcPresentationStyleAssignment for IfcPresentationStyleAssignment {
    fn styles(&self) -> &HashSet<IfcPresentationStyleSelect> {
        &self.styles
    }
}
impl IfcPresentationStyleAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPresentationStyleAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProcedure: IIfcProcess {
    fn procedure_id(&self) -> &IfcIdentifier;
    fn procedure_type(&self) -> &IfcProcedureTypeEnum;
    fn user_defined_procedure_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcProcedure {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    procedure_id: IfcIdentifier,
    procedure_type: IfcProcedureTypeEnum,
    user_defined_procedure_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcProcedure {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProcedure {}
impl IIfcObject for IfcProcedure {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcProcedure {}
impl IIfcProcedure for IfcProcedure {
    fn procedure_id(&self) -> &IfcIdentifier {
        &self.procedure_id
    }
    fn procedure_type(&self) -> &IfcProcedureTypeEnum {
        &self.procedure_type
    }
    fn user_defined_procedure_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_procedure_type
    }
}
impl IfcProcedure {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProcedure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.procedure_id = parameter.into(),
                6usize => entity.procedure_type = parameter.into(),
                7usize => {
                    entity.user_defined_procedure_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProcess: IIfcObject {}
pub trait IIfcProduct: IIfcObject {
    fn object_placement(&self) -> &Option<EntityRef>;
    fn representation(&self) -> &Option<EntityRef>;
}
pub trait IIfcProductDefinitionShape: IIfcProductRepresentation {}
#[derive(Default, Debug)]
pub struct IfcProductDefinitionShape {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    representations: Vec<EntityRef>,
}
impl IIfcProductRepresentation for IfcProductDefinitionShape {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn representations(&self) -> &Vec<EntityRef> {
        &self.representations
    }
}
impl IIfcProductDefinitionShape for IfcProductDefinitionShape {}
impl IfcProductDefinitionShape {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProductDefinitionShape::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.representations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProductRepresentation {
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn representations(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcProductRepresentation {
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    representations: Vec<EntityRef>,
}
impl IIfcProductRepresentation for IfcProductRepresentation {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn representations(&self) -> &Vec<EntityRef> {
        &self.representations
    }
}
impl IfcProductRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProductRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.representations = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProductsOfCombustionProperties: IIfcMaterialProperties {
    fn specific_heat_capacity(&self) -> &Option<IfcSpecificHeatCapacityMeasure>;
    fn n20_content(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn co_content(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn co2_content(&self) -> &Option<IfcPositiveRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcProductsOfCombustionProperties {
    material: EntityRef,
    specific_heat_capacity: Option<IfcSpecificHeatCapacityMeasure>,
    n20_content: Option<IfcPositiveRatioMeasure>,
    co_content: Option<IfcPositiveRatioMeasure>,
    co2_content: Option<IfcPositiveRatioMeasure>,
}
impl IIfcMaterialProperties for IfcProductsOfCombustionProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcProductsOfCombustionProperties for IfcProductsOfCombustionProperties {
    fn specific_heat_capacity(&self) -> &Option<IfcSpecificHeatCapacityMeasure> {
        &self.specific_heat_capacity
    }
    fn n20_content(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.n20_content
    }
    fn co_content(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.co_content
    }
    fn co2_content(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.co2_content
    }
}
impl IfcProductsOfCombustionProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProductsOfCombustionProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.specific_heat_capacity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.n20_content = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.co_content = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.co2_content = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum;
    fn profile_name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcProfileProperties {
    fn profile_name(&self) -> &Option<IfcLabel>;
    fn profile_definition(&self) -> &Option<EntityRef>;
}
pub trait IIfcProject: IIfcObject {
    fn long_name(&self) -> &Option<IfcLabel>;
    fn phase(&self) -> &Option<IfcLabel>;
    fn representation_contexts(&self) -> &HashSet<EntityRef>;
    fn units_in_context(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcProject {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    long_name: Option<IfcLabel>,
    phase: Option<IfcLabel>,
    representation_contexts: HashSet<EntityRef>,
    units_in_context: EntityRef,
}
impl IIfcRoot for IfcProject {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProject {}
impl IIfcObject for IfcProject {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProject for IfcProject {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn phase(&self) -> &Option<IfcLabel> {
        &self.phase
    }
    fn representation_contexts(&self) -> &HashSet<EntityRef> {
        &self.representation_contexts
    }
    fn units_in_context(&self) -> &EntityRef {
        &self.units_in_context
    }
}
impl IfcProject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.phase = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.representation_contexts = parameter.into(),
                8usize => entity.units_in_context = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectOrder: IIfcControl {
    fn id(&self) -> &IfcIdentifier;
    fn predefined_type(&self) -> &IfcProjectOrderTypeEnum;
    fn status(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcProjectOrder {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    id: IfcIdentifier,
    predefined_type: IfcProjectOrderTypeEnum,
    status: Option<IfcLabel>,
}
impl IIfcRoot for IfcProjectOrder {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProjectOrder {}
impl IIfcObject for IfcProjectOrder {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcProjectOrder {}
impl IIfcProjectOrder for IfcProjectOrder {
    fn id(&self) -> &IfcIdentifier {
        &self.id
    }
    fn predefined_type(&self) -> &IfcProjectOrderTypeEnum {
        &self.predefined_type
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
}
impl IfcProjectOrder {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectOrder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.id = parameter.into(),
                6usize => entity.predefined_type = parameter.into(),
                7usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectOrderRecord: IIfcControl {
    fn records(&self) -> &Vec<EntityRef>;
    fn predefined_type(&self) -> &IfcProjectOrderRecordTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcProjectOrderRecord {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    records: Vec<EntityRef>,
    predefined_type: IfcProjectOrderRecordTypeEnum,
}
impl IIfcRoot for IfcProjectOrderRecord {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProjectOrderRecord {}
impl IIfcObject for IfcProjectOrderRecord {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcProjectOrderRecord {}
impl IIfcProjectOrderRecord for IfcProjectOrderRecord {
    fn records(&self) -> &Vec<EntityRef> {
        &self.records
    }
    fn predefined_type(&self) -> &IfcProjectOrderRecordTypeEnum {
        &self.predefined_type
    }
}
impl IfcProjectOrderRecord {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectOrderRecord::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.records = parameter.into(),
                6usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectionCurve: IIfcAnnotationCurveOccurrence {}
#[derive(Default, Debug)]
pub struct IfcProjectionCurve {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcProjectionCurve {}
impl IIfcStyledItem for IfcProjectionCurve {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcProjectionCurve {}
impl IIfcAnnotationCurveOccurrence for IfcProjectionCurve {}
impl IIfcProjectionCurve for IfcProjectionCurve {}
impl IfcProjectionCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectionCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProjectionElement: IIfcFeatureElementAddition {}
#[derive(Default, Debug)]
pub struct IfcProjectionElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcProjectionElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProjectionElement {}
impl IIfcObject for IfcProjectionElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcProjectionElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcProjectionElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcProjectionElement {}
impl IIfcFeatureElementAddition for IfcProjectionElement {}
impl IIfcProjectionElement for IfcProjectionElement {}
impl IfcProjectionElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProjectionElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProperty {
    fn name(&self) -> &IfcIdentifier;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcPropertyBoundedValue: IIfcSimpleProperty {
    fn upper_bound_value(&self) -> &Option<IfcValue>;
    fn lower_bound_value(&self) -> &Option<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyBoundedValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    upper_bound_value: Option<IfcValue>,
    lower_bound_value: Option<IfcValue>,
    unit: Option<EntityRef>,
}
impl IIfcProperty for IfcPropertyBoundedValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyBoundedValue {}
impl IIfcPropertyBoundedValue for IfcPropertyBoundedValue {
    fn upper_bound_value(&self) -> &Option<IfcValue> {
        &self.upper_bound_value
    }
    fn lower_bound_value(&self) -> &Option<IfcValue> {
        &self.lower_bound_value
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertyBoundedValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyBoundedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.upper_bound_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.lower_bound_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyConstraintRelationship {
    fn relating_constraint(&self) -> &EntityRef;
    fn related_properties(&self) -> &HashSet<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyConstraintRelationship {
    relating_constraint: EntityRef,
    related_properties: HashSet<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
}
impl IIfcPropertyConstraintRelationship for IfcPropertyConstraintRelationship {
    fn relating_constraint(&self) -> &EntityRef {
        &self.relating_constraint
    }
    fn related_properties(&self) -> &HashSet<EntityRef> {
        &self.related_properties
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcPropertyConstraintRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyConstraintRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relating_constraint = parameter.into(),
                1usize => entity.related_properties = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyDefinition: IIfcRoot {}
pub trait IIfcPropertyDependencyRelationship {
    fn depending_property(&self) -> &EntityRef;
    fn dependant_property(&self) -> &EntityRef;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn expression(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyDependencyRelationship {
    depending_property: EntityRef,
    dependant_property: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    expression: Option<IfcText>,
}
impl IIfcPropertyDependencyRelationship for IfcPropertyDependencyRelationship {
    fn depending_property(&self) -> &EntityRef {
        &self.depending_property
    }
    fn dependant_property(&self) -> &EntityRef {
        &self.dependant_property
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn expression(&self) -> &Option<IfcText> {
        &self.expression
    }
}
impl IfcPropertyDependencyRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyDependencyRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.depending_property = parameter.into(),
                1usize => entity.dependant_property = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyEnumeratedValue: IIfcSimpleProperty {
    fn enumeration_values(&self) -> &Vec<IfcValue>;
    fn enumeration_reference(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyEnumeratedValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    enumeration_values: Vec<IfcValue>,
    enumeration_reference: Option<EntityRef>,
}
impl IIfcProperty for IfcPropertyEnumeratedValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyEnumeratedValue {}
impl IIfcPropertyEnumeratedValue for IfcPropertyEnumeratedValue {
    fn enumeration_values(&self) -> &Vec<IfcValue> {
        &self.enumeration_values
    }
    fn enumeration_reference(&self) -> &Option<EntityRef> {
        &self.enumeration_reference
    }
}
impl IfcPropertyEnumeratedValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyEnumeratedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.enumeration_values = parameter.into(),
                3usize => {
                    entity.enumeration_reference = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyEnumeration {
    fn name(&self) -> &IfcLabel;
    fn enumeration_values(&self) -> &Vec<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyEnumeration {
    name: IfcLabel,
    enumeration_values: Vec<IfcValue>,
    unit: Option<EntityRef>,
}
impl IIfcPropertyEnumeration for IfcPropertyEnumeration {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn enumeration_values(&self) -> &Vec<IfcValue> {
        &self.enumeration_values
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertyEnumeration {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyEnumeration::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.enumeration_values = parameter.into(),
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyListValue: IIfcSimpleProperty {
    fn list_values(&self) -> &Vec<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyListValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    list_values: Vec<IfcValue>,
    unit: Option<EntityRef>,
}
impl IIfcProperty for IfcPropertyListValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyListValue {}
impl IIfcPropertyListValue for IfcPropertyListValue {
    fn list_values(&self) -> &Vec<IfcValue> {
        &self.list_values
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertyListValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyListValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.list_values = parameter.into(),
                3usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyReferenceValue: IIfcSimpleProperty {
    fn usage_name(&self) -> &Option<IfcLabel>;
    fn property_reference(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcPropertyReferenceValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    usage_name: Option<IfcLabel>,
    property_reference: EntityRef,
}
impl IIfcProperty for IfcPropertyReferenceValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyReferenceValue {}
impl IIfcPropertyReferenceValue for IfcPropertyReferenceValue {
    fn usage_name(&self) -> &Option<IfcLabel> {
        &self.usage_name
    }
    fn property_reference(&self) -> &EntityRef {
        &self.property_reference
    }
}
impl IfcPropertyReferenceValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyReferenceValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.usage_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.property_reference = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertySet: IIfcPropertySetDefinition {
    fn has_properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertySet {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    has_properties: HashSet<EntityRef>,
}
impl IIfcRoot for IfcPropertySet {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcPropertySet {}
impl IIfcPropertySetDefinition for IfcPropertySet {}
impl IIfcPropertySet for IfcPropertySet {
    fn has_properties(&self) -> &HashSet<EntityRef> {
        &self.has_properties
    }
}
impl IfcPropertySet {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySet::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.has_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertySetDefinition: IIfcPropertyDefinition {}
pub trait IIfcPropertySingleValue: IIfcSimpleProperty {
    fn nominal_value(&self) -> &Option<IfcValue>;
    fn unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertySingleValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    nominal_value: Option<IfcValue>,
    unit: Option<EntityRef>,
}
impl IIfcProperty for IfcPropertySingleValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertySingleValue {}
impl IIfcPropertySingleValue for IfcPropertySingleValue {
    fn nominal_value(&self) -> &Option<IfcValue> {
        &self.nominal_value
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IfcPropertySingleValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertySingleValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.nominal_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPropertyTableValue: IIfcSimpleProperty {
    fn defining_values(&self) -> &Vec<IfcValue>;
    fn defined_values(&self) -> &Vec<IfcValue>;
    fn expression(&self) -> &Option<IfcText>;
    fn defining_unit(&self) -> &Option<EntityRef>;
    fn defined_unit(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcPropertyTableValue {
    name: IfcIdentifier,
    description: Option<IfcText>,
    defining_values: Vec<IfcValue>,
    defined_values: Vec<IfcValue>,
    expression: Option<IfcText>,
    defining_unit: Option<EntityRef>,
    defined_unit: Option<EntityRef>,
}
impl IIfcProperty for IfcPropertyTableValue {
    fn name(&self) -> &IfcIdentifier {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcSimpleProperty for IfcPropertyTableValue {}
impl IIfcPropertyTableValue for IfcPropertyTableValue {
    fn defining_values(&self) -> &Vec<IfcValue> {
        &self.defining_values
    }
    fn defined_values(&self) -> &Vec<IfcValue> {
        &self.defined_values
    }
    fn expression(&self) -> &Option<IfcText> {
        &self.expression
    }
    fn defining_unit(&self) -> &Option<EntityRef> {
        &self.defining_unit
    }
    fn defined_unit(&self) -> &Option<EntityRef> {
        &self.defined_unit
    }
}
impl IfcPropertyTableValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPropertyTableValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.defining_values = parameter.into(),
                3usize => entity.defined_values = parameter.into(),
                4usize => {
                    entity.expression = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.defining_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.defined_unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProtectiveDeviceType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcProtectiveDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcProtectiveDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcProtectiveDeviceTypeEnum,
}
impl IIfcRoot for IfcProtectiveDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProtectiveDeviceType {}
impl IIfcTypeObject for IfcProtectiveDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcProtectiveDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcProtectiveDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcProtectiveDeviceType {}
impl IIfcDistributionFlowElementType for IfcProtectiveDeviceType {}
impl IIfcFlowControllerType for IfcProtectiveDeviceType {}
impl IIfcProtectiveDeviceType for IfcProtectiveDeviceType {
    fn predefined_type(&self) -> &IfcProtectiveDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcProtectiveDeviceType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProtectiveDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcProxy: IIfcProduct {
    fn proxy_type(&self) -> &IfcObjectTypeEnum;
    fn tag(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcProxy {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    proxy_type: IfcObjectTypeEnum,
    tag: Option<IfcLabel>,
}
impl IIfcRoot for IfcProxy {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcProxy {}
impl IIfcObject for IfcProxy {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcProxy {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcProxy for IfcProxy {
    fn proxy_type(&self) -> &IfcObjectTypeEnum {
        &self.proxy_type
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IfcProxy {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcProxy::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.proxy_type = parameter.into(),
                8usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcPumpType: IIfcFlowMovingDeviceType {
    fn predefined_type(&self) -> &IfcPumpTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcPumpType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcPumpTypeEnum,
}
impl IIfcRoot for IfcPumpType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcPumpType {}
impl IIfcTypeObject for IfcPumpType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcPumpType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcPumpType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcPumpType {}
impl IIfcDistributionFlowElementType for IfcPumpType {}
impl IIfcFlowMovingDeviceType for IfcPumpType {}
impl IIfcPumpType for IfcPumpType {
    fn predefined_type(&self) -> &IfcPumpTypeEnum {
        &self.predefined_type
    }
}
impl IfcPumpType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcPumpType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityArea: IIfcPhysicalSimpleQuantity {
    fn area_value(&self) -> &IfcAreaMeasure;
}
#[derive(Default, Debug)]
pub struct IfcQuantityArea {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    area_value: IfcAreaMeasure,
}
impl IIfcPhysicalQuantity for IfcQuantityArea {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityArea {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityArea for IfcQuantityArea {
    fn area_value(&self) -> &IfcAreaMeasure {
        &self.area_value
    }
}
impl IfcQuantityArea {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityArea::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.area_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityCount: IIfcPhysicalSimpleQuantity {
    fn count_value(&self) -> &IfcCountMeasure;
}
#[derive(Default, Debug)]
pub struct IfcQuantityCount {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    count_value: IfcCountMeasure,
}
impl IIfcPhysicalQuantity for IfcQuantityCount {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityCount {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityCount for IfcQuantityCount {
    fn count_value(&self) -> &IfcCountMeasure {
        &self.count_value
    }
}
impl IfcQuantityCount {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityCount::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.count_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityLength: IIfcPhysicalSimpleQuantity {
    fn length_value(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcQuantityLength {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    length_value: IfcLengthMeasure,
}
impl IIfcPhysicalQuantity for IfcQuantityLength {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityLength {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityLength for IfcQuantityLength {
    fn length_value(&self) -> &IfcLengthMeasure {
        &self.length_value
    }
}
impl IfcQuantityLength {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityLength::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.length_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityTime: IIfcPhysicalSimpleQuantity {
    fn time_value(&self) -> &IfcTimeMeasure;
}
#[derive(Default, Debug)]
pub struct IfcQuantityTime {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    time_value: IfcTimeMeasure,
}
impl IIfcPhysicalQuantity for IfcQuantityTime {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityTime {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityTime for IfcQuantityTime {
    fn time_value(&self) -> &IfcTimeMeasure {
        &self.time_value
    }
}
impl IfcQuantityTime {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityTime::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.time_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityVolume: IIfcPhysicalSimpleQuantity {
    fn volume_value(&self) -> &IfcVolumeMeasure;
}
#[derive(Default, Debug)]
pub struct IfcQuantityVolume {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    volume_value: IfcVolumeMeasure,
}
impl IIfcPhysicalQuantity for IfcQuantityVolume {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityVolume {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityVolume for IfcQuantityVolume {
    fn volume_value(&self) -> &IfcVolumeMeasure {
        &self.volume_value
    }
}
impl IfcQuantityVolume {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityVolume::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.volume_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcQuantityWeight: IIfcPhysicalSimpleQuantity {
    fn weight_value(&self) -> &IfcMassMeasure;
}
#[derive(Default, Debug)]
pub struct IfcQuantityWeight {
    name: IfcLabel,
    description: Option<IfcText>,
    unit: Option<EntityRef>,
    weight_value: IfcMassMeasure,
}
impl IIfcPhysicalQuantity for IfcQuantityWeight {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPhysicalSimpleQuantity for IfcQuantityWeight {
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcQuantityWeight for IfcQuantityWeight {
    fn weight_value(&self) -> &IfcMassMeasure {
        &self.weight_value
    }
}
impl IfcQuantityWeight {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcQuantityWeight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.weight_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRadiusDimension: IIfcDimensionCurveDirectedCallout {}
#[derive(Default, Debug)]
pub struct IfcRadiusDimension {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcRadiusDimension {}
impl IIfcGeometricRepresentationItem for IfcRadiusDimension {}
impl IIfcDraughtingCallout for IfcRadiusDimension {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IIfcDimensionCurveDirectedCallout for IfcRadiusDimension {}
impl IIfcRadiusDimension for IfcRadiusDimension {}
impl IfcRadiusDimension {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRadiusDimension::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRailing: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcRailingTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcRailing {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcRailingTypeEnum>,
}
impl IIfcRoot for IfcRailing {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRailing {}
impl IIfcObject for IfcRailing {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRailing {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRailing {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRailing {}
impl IIfcRailing for IfcRailing {
    fn predefined_type(&self) -> &Option<IfcRailingTypeEnum> {
        &self.predefined_type
    }
}
impl IfcRailing {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRailing::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRailingType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcRailingTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRailingType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcRailingTypeEnum,
}
impl IIfcRoot for IfcRailingType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRailingType {}
impl IIfcTypeObject for IfcRailingType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcRailingType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcRailingType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcRailingType {}
impl IIfcRailingType for IfcRailingType {
    fn predefined_type(&self) -> &IfcRailingTypeEnum {
        &self.predefined_type
    }
}
impl IfcRailingType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRailingType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRamp: IIfcBuildingElement {
    fn shape_type(&self) -> &IfcRampTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRamp {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    shape_type: IfcRampTypeEnum,
}
impl IIfcRoot for IfcRamp {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRamp {}
impl IIfcObject for IfcRamp {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRamp {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRamp {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRamp {}
impl IIfcRamp for IfcRamp {
    fn shape_type(&self) -> &IfcRampTypeEnum {
        &self.shape_type
    }
}
impl IfcRamp {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRamp::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.shape_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRampFlight: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcRampFlight {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcRampFlight {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRampFlight {}
impl IIfcObject for IfcRampFlight {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRampFlight {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRampFlight {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRampFlight {}
impl IIfcRampFlight for IfcRampFlight {}
impl IfcRampFlight {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampFlight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRampFlightType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcRampFlightTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRampFlightType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcRampFlightTypeEnum,
}
impl IIfcRoot for IfcRampFlightType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRampFlightType {}
impl IIfcTypeObject for IfcRampFlightType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcRampFlightType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcRampFlightType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcRampFlightType {}
impl IIfcRampFlightType for IfcRampFlightType {
    fn predefined_type(&self) -> &IfcRampFlightTypeEnum {
        &self.predefined_type
    }
}
impl IfcRampFlightType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRampFlightType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRationalBezierCurve: IIfcBezierCurve {
    fn weights_data(&self) -> &Vec<Real>;
}
#[derive(Default, Debug)]
pub struct IfcRationalBezierCurve {
    degree: i64,
    control_points_list: Vec<EntityRef>,
    curve_form: IfcBSplineCurveForm,
    closed_curve: Option<bool>,
    self_intersect: Option<bool>,
    weights_data: Vec<Real>,
}
impl IIfcRepresentationItem for IfcRationalBezierCurve {}
impl IIfcGeometricRepresentationItem for IfcRationalBezierCurve {}
impl IIfcCurve for IfcRationalBezierCurve {}
impl IIfcBoundedCurve for IfcRationalBezierCurve {}
impl IIfcBSplineCurve for IfcRationalBezierCurve {
    fn degree(&self) -> i64 {
        self.degree
    }
    fn control_points_list(&self) -> &Vec<EntityRef> {
        &self.control_points_list
    }
    fn curve_form(&self) -> &IfcBSplineCurveForm {
        &self.curve_form
    }
    fn closed_curve(&self) -> Option<bool> {
        self.closed_curve
    }
    fn self_intersect(&self) -> Option<bool> {
        self.self_intersect
    }
}
impl IIfcBezierCurve for IfcRationalBezierCurve {}
impl IIfcRationalBezierCurve for IfcRationalBezierCurve {
    fn weights_data(&self) -> &Vec<Real> {
        &self.weights_data
    }
}
impl IfcRationalBezierCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRationalBezierCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.degree = parameter.into(),
                1usize => entity.control_points_list = parameter.into(),
                2usize => entity.curve_form = parameter.into(),
                3usize => entity.closed_curve = parameter.into(),
                4usize => entity.self_intersect = parameter.into(),
                5usize => entity.weights_data = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangleHollowProfileDef: IIfcRectangleProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn inner_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn outer_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcRectangleHollowProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    wall_thickness: IfcPositiveLengthMeasure,
    inner_fillet_radius: Option<IfcPositiveLengthMeasure>,
    outer_fillet_radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcRectangleHollowProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcRectangleHollowProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRectangleProfileDef for IfcRectangleHollowProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
}
impl IIfcRectangleHollowProfileDef for IfcRectangleHollowProfileDef {
    fn wall_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.wall_thickness
    }
    fn inner_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.inner_fillet_radius
    }
    fn outer_fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.outer_fillet_radius
    }
}
impl IfcRectangleHollowProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangleHollowProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.x_dim = parameter.into(),
                4usize => entity.y_dim = parameter.into(),
                5usize => entity.wall_thickness = parameter.into(),
                6usize => {
                    entity.inner_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.outer_fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangleProfileDef: IIfcParameterizedProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn y_dim(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRectangleProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcRectangleProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcRectangleProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRectangleProfileDef for IfcRectangleProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
}
impl IfcRectangleProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.x_dim = parameter.into(),
                4usize => entity.y_dim = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangularPyramid: IIfcCsgPrimitive3D {
    fn x_length(&self) -> &IfcPositiveLengthMeasure;
    fn y_length(&self) -> &IfcPositiveLengthMeasure;
    fn height(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRectangularPyramid {
    position: EntityRef,
    x_length: IfcPositiveLengthMeasure,
    y_length: IfcPositiveLengthMeasure,
    height: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcRectangularPyramid {}
impl IIfcGeometricRepresentationItem for IfcRectangularPyramid {}
impl IIfcCsgPrimitive3D for IfcRectangularPyramid {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRectangularPyramid for IfcRectangularPyramid {
    fn x_length(&self) -> &IfcPositiveLengthMeasure {
        &self.x_length
    }
    fn y_length(&self) -> &IfcPositiveLengthMeasure {
        &self.y_length
    }
    fn height(&self) -> &IfcPositiveLengthMeasure {
        &self.height
    }
}
impl IfcRectangularPyramid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangularPyramid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.x_length = parameter.into(),
                2usize => entity.y_length = parameter.into(),
                3usize => entity.height = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRectangularTrimmedSurface: IIfcBoundedSurface {
    fn basis_surface(&self) -> &EntityRef;
    fn u1(&self) -> &IfcParameterValue;
    fn v1(&self) -> &IfcParameterValue;
    fn u2(&self) -> &IfcParameterValue;
    fn v2(&self) -> &IfcParameterValue;
    fn usense(&self) -> bool;
    fn vsense(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcRectangularTrimmedSurface {
    basis_surface: EntityRef,
    u1: IfcParameterValue,
    v1: IfcParameterValue,
    u2: IfcParameterValue,
    v2: IfcParameterValue,
    usense: bool,
    vsense: bool,
}
impl IIfcRepresentationItem for IfcRectangularTrimmedSurface {}
impl IIfcGeometricRepresentationItem for IfcRectangularTrimmedSurface {}
impl IIfcSurface for IfcRectangularTrimmedSurface {}
impl IIfcBoundedSurface for IfcRectangularTrimmedSurface {}
impl IIfcRectangularTrimmedSurface for IfcRectangularTrimmedSurface {
    fn basis_surface(&self) -> &EntityRef {
        &self.basis_surface
    }
    fn u1(&self) -> &IfcParameterValue {
        &self.u1
    }
    fn v1(&self) -> &IfcParameterValue {
        &self.v1
    }
    fn u2(&self) -> &IfcParameterValue {
        &self.u2
    }
    fn v2(&self) -> &IfcParameterValue {
        &self.v2
    }
    fn usense(&self) -> bool {
        self.usense
    }
    fn vsense(&self) -> bool {
        self.vsense
    }
}
impl IfcRectangularTrimmedSurface {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRectangularTrimmedSurface::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_surface = parameter.into(),
                1usize => entity.u1 = parameter.into(),
                2usize => entity.v1 = parameter.into(),
                3usize => entity.u2 = parameter.into(),
                4usize => entity.v2 = parameter.into(),
                5usize => entity.usense = parameter.into(),
                6usize => entity.vsense = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReferencesValueDocument {
    fn referenced_document(&self) -> &EntityRef;
    fn referencing_values(&self) -> &HashSet<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcReferencesValueDocument {
    referenced_document: EntityRef,
    referencing_values: HashSet<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
}
impl IIfcReferencesValueDocument for IfcReferencesValueDocument {
    fn referenced_document(&self) -> &EntityRef {
        &self.referenced_document
    }
    fn referencing_values(&self) -> &HashSet<EntityRef> {
        &self.referencing_values
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IfcReferencesValueDocument {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReferencesValueDocument::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.referenced_document = parameter.into(),
                1usize => entity.referencing_values = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRegularTimeSeries: IIfcTimeSeries {
    fn time_step(&self) -> &IfcTimeMeasure;
    fn values(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRegularTimeSeries {
    name: IfcLabel,
    description: Option<IfcText>,
    start_time: EntityRef,
    end_time: EntityRef,
    time_series_data_type: IfcTimeSeriesDataTypeEnum,
    data_origin: IfcDataOriginEnum,
    user_defined_data_origin: Option<IfcLabel>,
    unit: Option<EntityRef>,
    time_step: IfcTimeMeasure,
    values: Vec<EntityRef>,
}
impl IIfcTimeSeries for IfcRegularTimeSeries {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn start_time(&self) -> &EntityRef {
        &self.start_time
    }
    fn end_time(&self) -> &EntityRef {
        &self.end_time
    }
    fn time_series_data_type(&self) -> &IfcTimeSeriesDataTypeEnum {
        &self.time_series_data_type
    }
    fn data_origin(&self) -> &IfcDataOriginEnum {
        &self.data_origin
    }
    fn user_defined_data_origin(&self) -> &Option<IfcLabel> {
        &self.user_defined_data_origin
    }
    fn unit(&self) -> &Option<EntityRef> {
        &self.unit
    }
}
impl IIfcRegularTimeSeries for IfcRegularTimeSeries {
    fn time_step(&self) -> &IfcTimeMeasure {
        &self.time_step
    }
    fn values(&self) -> &Vec<EntityRef> {
        &self.values
    }
}
impl IfcRegularTimeSeries {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRegularTimeSeries::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.start_time = parameter.into(),
                3usize => entity.end_time = parameter.into(),
                4usize => entity.time_series_data_type = parameter.into(),
                5usize => entity.data_origin = parameter.into(),
                6usize => {
                    entity.user_defined_data_origin = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.unit = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.time_step = parameter.into(),
                9usize => entity.values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcementBarProperties {
    fn total_cross_section_area(&self) -> &IfcAreaMeasure;
    fn steel_grade(&self) -> &IfcLabel;
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum>;
    fn effective_depth(&self) -> &Option<IfcLengthMeasure>;
    fn nominal_bar_diameter(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn bar_count(&self) -> &Option<IfcCountMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcementBarProperties {
    total_cross_section_area: IfcAreaMeasure,
    steel_grade: IfcLabel,
    bar_surface: Option<IfcReinforcingBarSurfaceEnum>,
    effective_depth: Option<IfcLengthMeasure>,
    nominal_bar_diameter: Option<IfcPositiveLengthMeasure>,
    bar_count: Option<IfcCountMeasure>,
}
impl IIfcReinforcementBarProperties for IfcReinforcementBarProperties {
    fn total_cross_section_area(&self) -> &IfcAreaMeasure {
        &self.total_cross_section_area
    }
    fn steel_grade(&self) -> &IfcLabel {
        &self.steel_grade
    }
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum> {
        &self.bar_surface
    }
    fn effective_depth(&self) -> &Option<IfcLengthMeasure> {
        &self.effective_depth
    }
    fn nominal_bar_diameter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.nominal_bar_diameter
    }
    fn bar_count(&self) -> &Option<IfcCountMeasure> {
        &self.bar_count
    }
}
impl IfcReinforcementBarProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcementBarProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.total_cross_section_area = parameter.into(),
                1usize => entity.steel_grade = parameter.into(),
                2usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.effective_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.nominal_bar_diameter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.bar_count = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcementDefinitionProperties: IIfcPropertySetDefinition {
    fn definition_type(&self) -> &Option<IfcLabel>;
    fn reinforcement_section_definitions(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcementDefinitionProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    definition_type: Option<IfcLabel>,
    reinforcement_section_definitions: Vec<EntityRef>,
}
impl IIfcRoot for IfcReinforcementDefinitionProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcReinforcementDefinitionProperties {}
impl IIfcPropertySetDefinition for IfcReinforcementDefinitionProperties {}
impl IIfcReinforcementDefinitionProperties for IfcReinforcementDefinitionProperties {
    fn definition_type(&self) -> &Option<IfcLabel> {
        &self.definition_type
    }
    fn reinforcement_section_definitions(&self) -> &Vec<EntityRef> {
        &self.reinforcement_section_definitions
    }
}
impl IfcReinforcementDefinitionProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcementDefinitionProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.definition_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.reinforcement_section_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcingBar: IIfcReinforcingElement {
    fn nominal_diameter(&self) -> &IfcPositiveLengthMeasure;
    fn cross_section_area(&self) -> &IfcAreaMeasure;
    fn bar_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn bar_role(&self) -> &IfcReinforcingBarRoleEnum;
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum>;
}
#[derive(Default, Debug)]
pub struct IfcReinforcingBar {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    nominal_diameter: IfcPositiveLengthMeasure,
    cross_section_area: IfcAreaMeasure,
    bar_length: Option<IfcPositiveLengthMeasure>,
    bar_role: IfcReinforcingBarRoleEnum,
    bar_surface: Option<IfcReinforcingBarSurfaceEnum>,
}
impl IIfcRoot for IfcReinforcingBar {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcReinforcingBar {}
impl IIfcObject for IfcReinforcingBar {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcReinforcingBar {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcReinforcingBar {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcReinforcingBar {}
impl IIfcBuildingElementComponent for IfcReinforcingBar {}
impl IIfcReinforcingElement for IfcReinforcingBar {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcReinforcingBar for IfcReinforcingBar {
    fn nominal_diameter(&self) -> &IfcPositiveLengthMeasure {
        &self.nominal_diameter
    }
    fn cross_section_area(&self) -> &IfcAreaMeasure {
        &self.cross_section_area
    }
    fn bar_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.bar_length
    }
    fn bar_role(&self) -> &IfcReinforcingBarRoleEnum {
        &self.bar_role
    }
    fn bar_surface(&self) -> &Option<IfcReinforcingBarSurfaceEnum> {
        &self.bar_surface
    }
}
impl IfcReinforcingBar {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingBar::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.nominal_diameter = parameter.into(),
                10usize => entity.cross_section_area = parameter.into(),
                11usize => {
                    entity.bar_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => entity.bar_role = parameter.into(),
                13usize => {
                    entity.bar_surface = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcReinforcingElement: IIfcBuildingElementComponent {
    fn steel_grade(&self) -> &Option<IfcLabel>;
}
pub trait IIfcReinforcingMesh: IIfcReinforcingElement {
    fn mesh_length(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn mesh_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn longitudinal_bar_nominal_diameter(&self) -> &IfcPositiveLengthMeasure;
    fn transverse_bar_nominal_diameter(&self) -> &IfcPositiveLengthMeasure;
    fn longitudinal_bar_cross_section_area(&self) -> &IfcAreaMeasure;
    fn transverse_bar_cross_section_area(&self) -> &IfcAreaMeasure;
    fn longitudinal_bar_spacing(&self) -> &IfcPositiveLengthMeasure;
    fn transverse_bar_spacing(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcReinforcingMesh {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    mesh_length: Option<IfcPositiveLengthMeasure>,
    mesh_width: Option<IfcPositiveLengthMeasure>,
    longitudinal_bar_nominal_diameter: IfcPositiveLengthMeasure,
    transverse_bar_nominal_diameter: IfcPositiveLengthMeasure,
    longitudinal_bar_cross_section_area: IfcAreaMeasure,
    transverse_bar_cross_section_area: IfcAreaMeasure,
    longitudinal_bar_spacing: IfcPositiveLengthMeasure,
    transverse_bar_spacing: IfcPositiveLengthMeasure,
}
impl IIfcRoot for IfcReinforcingMesh {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcReinforcingMesh {}
impl IIfcObject for IfcReinforcingMesh {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcReinforcingMesh {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcReinforcingMesh {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcReinforcingMesh {}
impl IIfcBuildingElementComponent for IfcReinforcingMesh {}
impl IIfcReinforcingElement for IfcReinforcingMesh {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcReinforcingMesh for IfcReinforcingMesh {
    fn mesh_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mesh_length
    }
    fn mesh_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mesh_width
    }
    fn longitudinal_bar_nominal_diameter(&self) -> &IfcPositiveLengthMeasure {
        &self.longitudinal_bar_nominal_diameter
    }
    fn transverse_bar_nominal_diameter(&self) -> &IfcPositiveLengthMeasure {
        &self.transverse_bar_nominal_diameter
    }
    fn longitudinal_bar_cross_section_area(&self) -> &IfcAreaMeasure {
        &self.longitudinal_bar_cross_section_area
    }
    fn transverse_bar_cross_section_area(&self) -> &IfcAreaMeasure {
        &self.transverse_bar_cross_section_area
    }
    fn longitudinal_bar_spacing(&self) -> &IfcPositiveLengthMeasure {
        &self.longitudinal_bar_spacing
    }
    fn transverse_bar_spacing(&self) -> &IfcPositiveLengthMeasure {
        &self.transverse_bar_spacing
    }
}
impl IfcReinforcingMesh {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcReinforcingMesh::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.mesh_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.mesh_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.longitudinal_bar_nominal_diameter = parameter.into(),
                12usize => entity.transverse_bar_nominal_diameter = parameter.into(),
                13usize => entity.longitudinal_bar_cross_section_area = parameter.into(),
                14usize => entity.transverse_bar_cross_section_area = parameter.into(),
                15usize => entity.longitudinal_bar_spacing = parameter.into(),
                16usize => entity.transverse_bar_spacing = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAggregates: IIfcRelDecomposes {}
#[derive(Default, Debug)]
pub struct IfcRelAggregates {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_object: EntityRef,
    related_objects: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelAggregates {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAggregates {}
impl IIfcRelDecomposes for IfcRelAggregates {
    fn relating_object(&self) -> &EntityRef {
        &self.relating_object
    }
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAggregates for IfcRelAggregates {}
impl IfcRelAggregates {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAggregates::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_object = parameter.into(),
                5usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssigns: IIfcRelationship {
    fn related_objects(&self) -> &HashSet<EntityRef>;
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum>;
}
pub trait IIfcRelAssignsTasks: IIfcRelAssignsToControl {
    fn time_for_task(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsTasks {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_control: EntityRef,
    time_for_task: Option<EntityRef>,
}
impl IIfcRoot for IfcRelAssignsTasks {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsTasks {}
impl IIfcRelAssigns for IfcRelAssignsTasks {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToControl for IfcRelAssignsTasks {
    fn relating_control(&self) -> &EntityRef {
        &self.relating_control
    }
}
impl IIfcRelAssignsTasks for IfcRelAssignsTasks {
    fn time_for_task(&self) -> &Option<EntityRef> {
        &self.time_for_task
    }
}
impl IfcRelAssignsTasks {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsTasks::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_control = parameter.into(),
                7usize => {
                    entity.time_for_task = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToActor: IIfcRelAssigns {
    fn relating_actor(&self) -> &EntityRef;
    fn acting_role(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToActor {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_actor: EntityRef,
    acting_role: Option<EntityRef>,
}
impl IIfcRoot for IfcRelAssignsToActor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToActor {}
impl IIfcRelAssigns for IfcRelAssignsToActor {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToActor for IfcRelAssignsToActor {
    fn relating_actor(&self) -> &EntityRef {
        &self.relating_actor
    }
    fn acting_role(&self) -> &Option<EntityRef> {
        &self.acting_role
    }
}
impl IfcRelAssignsToActor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToActor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_actor = parameter.into(),
                7usize => {
                    entity.acting_role = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToControl: IIfcRelAssigns {
    fn relating_control(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToControl {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_control: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToControl {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToControl {}
impl IIfcRelAssigns for IfcRelAssignsToControl {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToControl for IfcRelAssignsToControl {
    fn relating_control(&self) -> &EntityRef {
        &self.relating_control
    }
}
impl IfcRelAssignsToControl {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_control = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToGroup: IIfcRelAssigns {
    fn relating_group(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_group: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToGroup {}
impl IIfcRelAssigns for IfcRelAssignsToGroup {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToGroup for IfcRelAssignsToGroup {
    fn relating_group(&self) -> &EntityRef {
        &self.relating_group
    }
}
impl IfcRelAssignsToGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_group = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToProcess: IIfcRelAssigns {
    fn relating_process(&self) -> &EntityRef;
    fn quantity_in_process(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToProcess {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_process: EntityRef,
    quantity_in_process: Option<EntityRef>,
}
impl IIfcRoot for IfcRelAssignsToProcess {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToProcess {}
impl IIfcRelAssigns for IfcRelAssignsToProcess {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToProcess for IfcRelAssignsToProcess {
    fn relating_process(&self) -> &EntityRef {
        &self.relating_process
    }
    fn quantity_in_process(&self) -> &Option<EntityRef> {
        &self.quantity_in_process
    }
}
impl IfcRelAssignsToProcess {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProcess::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_process = parameter.into(),
                7usize => {
                    entity.quantity_in_process = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToProduct: IIfcRelAssigns {
    fn relating_product(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToProduct {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_product: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToProduct {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToProduct {}
impl IIfcRelAssigns for IfcRelAssignsToProduct {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToProduct for IfcRelAssignsToProduct {
    fn relating_product(&self) -> &EntityRef {
        &self.relating_product
    }
}
impl IfcRelAssignsToProduct {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProduct::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_product = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToProjectOrder: IIfcRelAssignsToControl {}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToProjectOrder {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_control: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToProjectOrder {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToProjectOrder {}
impl IIfcRelAssigns for IfcRelAssignsToProjectOrder {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToControl for IfcRelAssignsToProjectOrder {
    fn relating_control(&self) -> &EntityRef {
        &self.relating_control
    }
}
impl IIfcRelAssignsToProjectOrder for IfcRelAssignsToProjectOrder {}
impl IfcRelAssignsToProjectOrder {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToProjectOrder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_control = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssignsToResource: IIfcRelAssigns {
    fn relating_resource(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssignsToResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_resource: EntityRef,
}
impl IIfcRoot for IfcRelAssignsToResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssignsToResource {}
impl IIfcRelAssigns for IfcRelAssignsToResource {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToResource for IfcRelAssignsToResource {
    fn relating_resource(&self) -> &EntityRef {
        &self.relating_resource
    }
}
impl IfcRelAssignsToResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssignsToResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_resource = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociates: IIfcRelationship {
    fn related_objects(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociates {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelAssociates {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociates {}
impl IIfcRelAssociates for IfcRelAssociates {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IfcRelAssociates {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociates::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesAppliedValue: IIfcRelAssociates {
    fn relating_applied_value(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesAppliedValue {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_applied_value: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesAppliedValue {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesAppliedValue {}
impl IIfcRelAssociates for IfcRelAssociatesAppliedValue {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesAppliedValue for IfcRelAssociatesAppliedValue {
    fn relating_applied_value(&self) -> &EntityRef {
        &self.relating_applied_value
    }
}
impl IfcRelAssociatesAppliedValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesAppliedValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_applied_value = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesApproval: IIfcRelAssociates {
    fn relating_approval(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesApproval {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_approval: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesApproval {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesApproval {}
impl IIfcRelAssociates for IfcRelAssociatesApproval {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesApproval for IfcRelAssociatesApproval {
    fn relating_approval(&self) -> &EntityRef {
        &self.relating_approval
    }
}
impl IfcRelAssociatesApproval {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesApproval::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_approval = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesClassification: IIfcRelAssociates {
    fn relating_classification(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesClassification {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_classification: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesClassification {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesClassification {}
impl IIfcRelAssociates for IfcRelAssociatesClassification {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesClassification for IfcRelAssociatesClassification {
    fn relating_classification(&self) -> &EntityRef {
        &self.relating_classification
    }
}
impl IfcRelAssociatesClassification {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesClassification::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_classification = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesConstraint: IIfcRelAssociates {
    fn intent(&self) -> &IfcLabel;
    fn relating_constraint(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesConstraint {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    intent: IfcLabel,
    relating_constraint: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesConstraint {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesConstraint {}
impl IIfcRelAssociates for IfcRelAssociatesConstraint {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesConstraint for IfcRelAssociatesConstraint {
    fn intent(&self) -> &IfcLabel {
        &self.intent
    }
    fn relating_constraint(&self) -> &EntityRef {
        &self.relating_constraint
    }
}
impl IfcRelAssociatesConstraint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesConstraint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.intent = parameter.into(),
                6usize => entity.relating_constraint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesDocument: IIfcRelAssociates {
    fn relating_document(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesDocument {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_document: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesDocument {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesDocument {}
impl IIfcRelAssociates for IfcRelAssociatesDocument {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesDocument for IfcRelAssociatesDocument {
    fn relating_document(&self) -> &EntityRef {
        &self.relating_document
    }
}
impl IfcRelAssociatesDocument {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesDocument::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_document = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesLibrary: IIfcRelAssociates {
    fn relating_library(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesLibrary {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_library: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesLibrary {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesLibrary {}
impl IIfcRelAssociates for IfcRelAssociatesLibrary {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesLibrary for IfcRelAssociatesLibrary {
    fn relating_library(&self) -> &EntityRef {
        &self.relating_library
    }
}
impl IfcRelAssociatesLibrary {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesLibrary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_library = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesMaterial: IIfcRelAssociates {
    fn relating_material(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesMaterial {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_material: EntityRef,
}
impl IIfcRoot for IfcRelAssociatesMaterial {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesMaterial {}
impl IIfcRelAssociates for IfcRelAssociatesMaterial {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesMaterial for IfcRelAssociatesMaterial {
    fn relating_material(&self) -> &EntityRef {
        &self.relating_material
    }
}
impl IfcRelAssociatesMaterial {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesMaterial::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_material = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelAssociatesProfileProperties: IIfcRelAssociates {
    fn relating_profile_properties(&self) -> &EntityRef;
    fn profile_section_location(&self) -> &Option<EntityRef>;
    fn profile_orientation(&self) -> &Option<IfcOrientationSelect>;
}
#[derive(Default, Debug)]
pub struct IfcRelAssociatesProfileProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_profile_properties: EntityRef,
    profile_section_location: Option<EntityRef>,
    profile_orientation: Option<IfcOrientationSelect>,
}
impl IIfcRoot for IfcRelAssociatesProfileProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelAssociatesProfileProperties {}
impl IIfcRelAssociates for IfcRelAssociatesProfileProperties {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelAssociatesProfileProperties for IfcRelAssociatesProfileProperties {
    fn relating_profile_properties(&self) -> &EntityRef {
        &self.relating_profile_properties
    }
    fn profile_section_location(&self) -> &Option<EntityRef> {
        &self.profile_section_location
    }
    fn profile_orientation(&self) -> &Option<IfcOrientationSelect> {
        &self.profile_orientation
    }
}
impl IfcRelAssociatesProfileProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelAssociatesProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_profile_properties = parameter.into(),
                6usize => {
                    entity.profile_section_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.profile_orientation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnects: IIfcRelationship {}
pub trait IIfcRelConnectsElements: IIfcRelConnects {
    fn connection_geometry(&self) -> &Option<EntityRef>;
    fn relating_element(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsElements {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    connection_geometry: Option<EntityRef>,
    relating_element: EntityRef,
    related_element: EntityRef,
}
impl IIfcRoot for IfcRelConnectsElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsElements {}
impl IIfcRelConnects for IfcRelConnectsElements {}
impl IIfcRelConnectsElements for IfcRelConnectsElements {
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IfcRelConnectsElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.relating_element = parameter.into(),
                6usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsPathElements: IIfcRelConnectsElements {
    fn relating_priorities(&self) -> &Vec<i64>;
    fn related_priorities(&self) -> &Vec<i64>;
    fn related_connection_type(&self) -> &IfcConnectionTypeEnum;
    fn relating_connection_type(&self) -> &IfcConnectionTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsPathElements {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    connection_geometry: Option<EntityRef>,
    relating_element: EntityRef,
    related_element: EntityRef,
    relating_priorities: Vec<i64>,
    related_priorities: Vec<i64>,
    related_connection_type: IfcConnectionTypeEnum,
    relating_connection_type: IfcConnectionTypeEnum,
}
impl IIfcRoot for IfcRelConnectsPathElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsPathElements {}
impl IIfcRelConnects for IfcRelConnectsPathElements {}
impl IIfcRelConnectsElements for IfcRelConnectsPathElements {
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IIfcRelConnectsPathElements for IfcRelConnectsPathElements {
    fn relating_priorities(&self) -> &Vec<i64> {
        &self.relating_priorities
    }
    fn related_priorities(&self) -> &Vec<i64> {
        &self.related_priorities
    }
    fn related_connection_type(&self) -> &IfcConnectionTypeEnum {
        &self.related_connection_type
    }
    fn relating_connection_type(&self) -> &IfcConnectionTypeEnum {
        &self.relating_connection_type
    }
}
impl IfcRelConnectsPathElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPathElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.relating_element = parameter.into(),
                6usize => entity.related_element = parameter.into(),
                7usize => entity.relating_priorities = parameter.into(),
                8usize => entity.related_priorities = parameter.into(),
                9usize => entity.related_connection_type = parameter.into(),
                10usize => entity.relating_connection_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsPortToElement: IIfcRelConnects {
    fn relating_port(&self) -> &EntityRef;
    fn related_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsPortToElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_port: EntityRef,
    related_element: EntityRef,
}
impl IIfcRoot for IfcRelConnectsPortToElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsPortToElement {}
impl IIfcRelConnects for IfcRelConnectsPortToElement {}
impl IIfcRelConnectsPortToElement for IfcRelConnectsPortToElement {
    fn relating_port(&self) -> &EntityRef {
        &self.relating_port
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IfcRelConnectsPortToElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPortToElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_port = parameter.into(),
                5usize => entity.related_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsPorts: IIfcRelConnects {
    fn relating_port(&self) -> &EntityRef;
    fn related_port(&self) -> &EntityRef;
    fn realizing_element(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsPorts {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_port: EntityRef,
    related_port: EntityRef,
    realizing_element: Option<EntityRef>,
}
impl IIfcRoot for IfcRelConnectsPorts {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsPorts {}
impl IIfcRelConnects for IfcRelConnectsPorts {}
impl IIfcRelConnectsPorts for IfcRelConnectsPorts {
    fn relating_port(&self) -> &EntityRef {
        &self.relating_port
    }
    fn related_port(&self) -> &EntityRef {
        &self.related_port
    }
    fn realizing_element(&self) -> &Option<EntityRef> {
        &self.realizing_element
    }
}
impl IfcRelConnectsPorts {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsPorts::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_port = parameter.into(),
                5usize => entity.related_port = parameter.into(),
                6usize => {
                    entity.realizing_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsStructuralActivity: IIfcRelConnects {
    fn relating_element(&self) -> &EntityRef;
    fn related_structural_activity(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsStructuralActivity {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_element: EntityRef,
    related_structural_activity: EntityRef,
}
impl IIfcRoot for IfcRelConnectsStructuralActivity {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsStructuralActivity {}
impl IIfcRelConnects for IfcRelConnectsStructuralActivity {}
impl IIfcRelConnectsStructuralActivity for IfcRelConnectsStructuralActivity {
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_structural_activity(&self) -> &EntityRef {
        &self.related_structural_activity
    }
}
impl IfcRelConnectsStructuralActivity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralActivity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_element = parameter.into(),
                5usize => entity.related_structural_activity = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsStructuralElement: IIfcRelConnects {
    fn relating_element(&self) -> &EntityRef;
    fn related_structural_member(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsStructuralElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_element: EntityRef,
    related_structural_member: EntityRef,
}
impl IIfcRoot for IfcRelConnectsStructuralElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsStructuralElement {}
impl IIfcRelConnects for IfcRelConnectsStructuralElement {}
impl IIfcRelConnectsStructuralElement for IfcRelConnectsStructuralElement {
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_structural_member(&self) -> &EntityRef {
        &self.related_structural_member
    }
}
impl IfcRelConnectsStructuralElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_element = parameter.into(),
                5usize => entity.related_structural_member = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsStructuralMember: IIfcRelConnects {
    fn relating_structural_member(&self) -> &EntityRef;
    fn related_structural_connection(&self) -> &EntityRef;
    fn applied_condition(&self) -> &Option<EntityRef>;
    fn additional_conditions(&self) -> &Option<EntityRef>;
    fn supported_length(&self) -> &Option<IfcLengthMeasure>;
    fn condition_coordinate_system(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsStructuralMember {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_structural_member: EntityRef,
    related_structural_connection: EntityRef,
    applied_condition: Option<EntityRef>,
    additional_conditions: Option<EntityRef>,
    supported_length: Option<IfcLengthMeasure>,
    condition_coordinate_system: Option<EntityRef>,
}
impl IIfcRoot for IfcRelConnectsStructuralMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsStructuralMember {}
impl IIfcRelConnects for IfcRelConnectsStructuralMember {}
impl IIfcRelConnectsStructuralMember for IfcRelConnectsStructuralMember {
    fn relating_structural_member(&self) -> &EntityRef {
        &self.relating_structural_member
    }
    fn related_structural_connection(&self) -> &EntityRef {
        &self.related_structural_connection
    }
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
    fn additional_conditions(&self) -> &Option<EntityRef> {
        &self.additional_conditions
    }
    fn supported_length(&self) -> &Option<IfcLengthMeasure> {
        &self.supported_length
    }
    fn condition_coordinate_system(&self) -> &Option<EntityRef> {
        &self.condition_coordinate_system
    }
}
impl IfcRelConnectsStructuralMember {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsStructuralMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_structural_member = parameter.into(),
                5usize => entity.related_structural_connection = parameter.into(),
                6usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.additional_conditions = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.supported_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsWithEccentricity: IIfcRelConnectsStructuralMember {
    fn connection_constraint(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsWithEccentricity {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_structural_member: EntityRef,
    related_structural_connection: EntityRef,
    applied_condition: Option<EntityRef>,
    additional_conditions: Option<EntityRef>,
    supported_length: Option<IfcLengthMeasure>,
    condition_coordinate_system: Option<EntityRef>,
    connection_constraint: EntityRef,
}
impl IIfcRoot for IfcRelConnectsWithEccentricity {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsWithEccentricity {}
impl IIfcRelConnects for IfcRelConnectsWithEccentricity {}
impl IIfcRelConnectsStructuralMember for IfcRelConnectsWithEccentricity {
    fn relating_structural_member(&self) -> &EntityRef {
        &self.relating_structural_member
    }
    fn related_structural_connection(&self) -> &EntityRef {
        &self.related_structural_connection
    }
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
    fn additional_conditions(&self) -> &Option<EntityRef> {
        &self.additional_conditions
    }
    fn supported_length(&self) -> &Option<IfcLengthMeasure> {
        &self.supported_length
    }
    fn condition_coordinate_system(&self) -> &Option<EntityRef> {
        &self.condition_coordinate_system
    }
}
impl IIfcRelConnectsWithEccentricity for IfcRelConnectsWithEccentricity {
    fn connection_constraint(&self) -> &EntityRef {
        &self.connection_constraint
    }
}
impl IfcRelConnectsWithEccentricity {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsWithEccentricity::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_structural_member = parameter.into(),
                5usize => entity.related_structural_connection = parameter.into(),
                6usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.additional_conditions = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.supported_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.condition_coordinate_system = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => entity.connection_constraint = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelConnectsWithRealizingElements: IIfcRelConnectsElements {
    fn realizing_elements(&self) -> &HashSet<EntityRef>;
    fn connection_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcRelConnectsWithRealizingElements {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    connection_geometry: Option<EntityRef>,
    relating_element: EntityRef,
    related_element: EntityRef,
    realizing_elements: HashSet<EntityRef>,
    connection_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcRelConnectsWithRealizingElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelConnectsWithRealizingElements {}
impl IIfcRelConnects for IfcRelConnectsWithRealizingElements {}
impl IIfcRelConnectsElements for IfcRelConnectsWithRealizingElements {
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_element(&self) -> &EntityRef {
        &self.related_element
    }
}
impl IIfcRelConnectsWithRealizingElements for IfcRelConnectsWithRealizingElements {
    fn realizing_elements(&self) -> &HashSet<EntityRef> {
        &self.realizing_elements
    }
    fn connection_type(&self) -> &Option<IfcLabel> {
        &self.connection_type
    }
}
impl IfcRelConnectsWithRealizingElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelConnectsWithRealizingElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.relating_element = parameter.into(),
                6usize => entity.related_element = parameter.into(),
                7usize => entity.realizing_elements = parameter.into(),
                8usize => {
                    entity.connection_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelContainedInSpatialStructure: IIfcRelConnects {
    fn related_elements(&self) -> &HashSet<EntityRef>;
    fn relating_structure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelContainedInSpatialStructure {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_elements: HashSet<EntityRef>,
    relating_structure: EntityRef,
}
impl IIfcRoot for IfcRelContainedInSpatialStructure {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelContainedInSpatialStructure {}
impl IIfcRelConnects for IfcRelContainedInSpatialStructure {}
impl IIfcRelContainedInSpatialStructure for IfcRelContainedInSpatialStructure {
    fn related_elements(&self) -> &HashSet<EntityRef> {
        &self.related_elements
    }
    fn relating_structure(&self) -> &EntityRef {
        &self.relating_structure
    }
}
impl IfcRelContainedInSpatialStructure {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelContainedInSpatialStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_elements = parameter.into(),
                5usize => entity.relating_structure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelCoversBldgElements: IIfcRelConnects {
    fn relating_building_element(&self) -> &EntityRef;
    fn related_coverings(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelCoversBldgElements {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_building_element: EntityRef,
    related_coverings: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelCoversBldgElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelCoversBldgElements {}
impl IIfcRelConnects for IfcRelCoversBldgElements {}
impl IIfcRelCoversBldgElements for IfcRelCoversBldgElements {
    fn relating_building_element(&self) -> &EntityRef {
        &self.relating_building_element
    }
    fn related_coverings(&self) -> &HashSet<EntityRef> {
        &self.related_coverings
    }
}
impl IfcRelCoversBldgElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelCoversBldgElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_building_element = parameter.into(),
                5usize => entity.related_coverings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelCoversSpaces: IIfcRelConnects {
    fn related_space(&self) -> &EntityRef;
    fn related_coverings(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelCoversSpaces {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_space: EntityRef,
    related_coverings: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelCoversSpaces {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelCoversSpaces {}
impl IIfcRelConnects for IfcRelCoversSpaces {}
impl IIfcRelCoversSpaces for IfcRelCoversSpaces {
    fn related_space(&self) -> &EntityRef {
        &self.related_space
    }
    fn related_coverings(&self) -> &HashSet<EntityRef> {
        &self.related_coverings
    }
}
impl IfcRelCoversSpaces {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelCoversSpaces::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_space = parameter.into(),
                5usize => entity.related_coverings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDecomposes: IIfcRelationship {
    fn relating_object(&self) -> &EntityRef;
    fn related_objects(&self) -> &HashSet<EntityRef>;
}
pub trait IIfcRelDefines: IIfcRelationship {
    fn related_objects(&self) -> &HashSet<EntityRef>;
}
pub trait IIfcRelDefinesByProperties: IIfcRelDefines {
    fn relating_property_definition(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelDefinesByProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_property_definition: EntityRef,
}
impl IIfcRoot for IfcRelDefinesByProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDefinesByProperties {}
impl IIfcRelDefines for IfcRelDefinesByProperties {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelDefinesByProperties for IfcRelDefinesByProperties {
    fn relating_property_definition(&self) -> &EntityRef {
        &self.relating_property_definition
    }
}
impl IfcRelDefinesByProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_property_definition = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelDefinesByType: IIfcRelDefines {
    fn relating_type(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelDefinesByType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_type: EntityRef,
}
impl IIfcRoot for IfcRelDefinesByType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelDefinesByType {}
impl IIfcRelDefines for IfcRelDefinesByType {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelDefinesByType for IfcRelDefinesByType {
    fn relating_type(&self) -> &EntityRef {
        &self.relating_type
    }
}
impl IfcRelDefinesByType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelDefinesByType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelFillsElement: IIfcRelConnects {
    fn relating_opening_element(&self) -> &EntityRef;
    fn related_building_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelFillsElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_opening_element: EntityRef,
    related_building_element: EntityRef,
}
impl IIfcRoot for IfcRelFillsElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelFillsElement {}
impl IIfcRelConnects for IfcRelFillsElement {}
impl IIfcRelFillsElement for IfcRelFillsElement {
    fn relating_opening_element(&self) -> &EntityRef {
        &self.relating_opening_element
    }
    fn related_building_element(&self) -> &EntityRef {
        &self.related_building_element
    }
}
impl IfcRelFillsElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelFillsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_opening_element = parameter.into(),
                5usize => entity.related_building_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelFlowControlElements: IIfcRelConnects {
    fn related_control_elements(&self) -> &HashSet<EntityRef>;
    fn relating_flow_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelFlowControlElements {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_control_elements: HashSet<EntityRef>,
    relating_flow_element: EntityRef,
}
impl IIfcRoot for IfcRelFlowControlElements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelFlowControlElements {}
impl IIfcRelConnects for IfcRelFlowControlElements {}
impl IIfcRelFlowControlElements for IfcRelFlowControlElements {
    fn related_control_elements(&self) -> &HashSet<EntityRef> {
        &self.related_control_elements
    }
    fn relating_flow_element(&self) -> &EntityRef {
        &self.relating_flow_element
    }
}
impl IfcRelFlowControlElements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelFlowControlElements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_control_elements = parameter.into(),
                5usize => entity.relating_flow_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelInteractionRequirements: IIfcRelConnects {
    fn daily_interaction(&self) -> &Option<IfcCountMeasure>;
    fn importance_rating(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn location_of_interaction(&self) -> &Option<EntityRef>;
    fn related_space_program(&self) -> &EntityRef;
    fn relating_space_program(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelInteractionRequirements {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    daily_interaction: Option<IfcCountMeasure>,
    importance_rating: Option<IfcNormalisedRatioMeasure>,
    location_of_interaction: Option<EntityRef>,
    related_space_program: EntityRef,
    relating_space_program: EntityRef,
}
impl IIfcRoot for IfcRelInteractionRequirements {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelInteractionRequirements {}
impl IIfcRelConnects for IfcRelInteractionRequirements {}
impl IIfcRelInteractionRequirements for IfcRelInteractionRequirements {
    fn daily_interaction(&self) -> &Option<IfcCountMeasure> {
        &self.daily_interaction
    }
    fn importance_rating(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.importance_rating
    }
    fn location_of_interaction(&self) -> &Option<EntityRef> {
        &self.location_of_interaction
    }
    fn related_space_program(&self) -> &EntityRef {
        &self.related_space_program
    }
    fn relating_space_program(&self) -> &EntityRef {
        &self.relating_space_program
    }
}
impl IfcRelInteractionRequirements {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelInteractionRequirements::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.daily_interaction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.importance_rating = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.location_of_interaction = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.related_space_program = parameter.into(),
                8usize => entity.relating_space_program = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelNests: IIfcRelDecomposes {}
#[derive(Default, Debug)]
pub struct IfcRelNests {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_object: EntityRef,
    related_objects: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelNests {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelNests {}
impl IIfcRelDecomposes for IfcRelNests {
    fn relating_object(&self) -> &EntityRef {
        &self.relating_object
    }
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelNests for IfcRelNests {}
impl IfcRelNests {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelNests::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_object = parameter.into(),
                5usize => entity.related_objects = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelOccupiesSpaces: IIfcRelAssignsToActor {}
#[derive(Default, Debug)]
pub struct IfcRelOccupiesSpaces {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_actor: EntityRef,
    acting_role: Option<EntityRef>,
}
impl IIfcRoot for IfcRelOccupiesSpaces {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelOccupiesSpaces {}
impl IIfcRelAssigns for IfcRelOccupiesSpaces {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToActor for IfcRelOccupiesSpaces {
    fn relating_actor(&self) -> &EntityRef {
        &self.relating_actor
    }
    fn acting_role(&self) -> &Option<EntityRef> {
        &self.acting_role
    }
}
impl IIfcRelOccupiesSpaces for IfcRelOccupiesSpaces {}
impl IfcRelOccupiesSpaces {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelOccupiesSpaces::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_actor = parameter.into(),
                7usize => {
                    entity.acting_role = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelOverridesProperties: IIfcRelDefinesByProperties {
    fn overriding_properties(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelOverridesProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    relating_property_definition: EntityRef,
    overriding_properties: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelOverridesProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelOverridesProperties {}
impl IIfcRelDefines for IfcRelOverridesProperties {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
}
impl IIfcRelDefinesByProperties for IfcRelOverridesProperties {
    fn relating_property_definition(&self) -> &EntityRef {
        &self.relating_property_definition
    }
}
impl IIfcRelOverridesProperties for IfcRelOverridesProperties {
    fn overriding_properties(&self) -> &HashSet<EntityRef> {
        &self.overriding_properties
    }
}
impl IfcRelOverridesProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelOverridesProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => entity.relating_property_definition = parameter.into(),
                6usize => entity.overriding_properties = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelProjectsElement: IIfcRelConnects {
    fn relating_element(&self) -> &EntityRef;
    fn related_feature_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelProjectsElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_element: EntityRef,
    related_feature_element: EntityRef,
}
impl IIfcRoot for IfcRelProjectsElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelProjectsElement {}
impl IIfcRelConnects for IfcRelProjectsElement {}
impl IIfcRelProjectsElement for IfcRelProjectsElement {
    fn relating_element(&self) -> &EntityRef {
        &self.relating_element
    }
    fn related_feature_element(&self) -> &EntityRef {
        &self.related_feature_element
    }
}
impl IfcRelProjectsElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelProjectsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_element = parameter.into(),
                5usize => entity.related_feature_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelReferencedInSpatialStructure: IIfcRelConnects {
    fn related_elements(&self) -> &HashSet<EntityRef>;
    fn relating_structure(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelReferencedInSpatialStructure {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_elements: HashSet<EntityRef>,
    relating_structure: EntityRef,
}
impl IIfcRoot for IfcRelReferencedInSpatialStructure {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelReferencedInSpatialStructure {}
impl IIfcRelConnects for IfcRelReferencedInSpatialStructure {}
impl IIfcRelReferencedInSpatialStructure for IfcRelReferencedInSpatialStructure {
    fn related_elements(&self) -> &HashSet<EntityRef> {
        &self.related_elements
    }
    fn relating_structure(&self) -> &EntityRef {
        &self.relating_structure
    }
}
impl IfcRelReferencedInSpatialStructure {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelReferencedInSpatialStructure::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_elements = parameter.into(),
                5usize => entity.relating_structure = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSchedulesCostItems: IIfcRelAssignsToControl {}
#[derive(Default, Debug)]
pub struct IfcRelSchedulesCostItems {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    related_objects: HashSet<EntityRef>,
    related_objects_type: Option<IfcObjectTypeEnum>,
    relating_control: EntityRef,
}
impl IIfcRoot for IfcRelSchedulesCostItems {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSchedulesCostItems {}
impl IIfcRelAssigns for IfcRelSchedulesCostItems {
    fn related_objects(&self) -> &HashSet<EntityRef> {
        &self.related_objects
    }
    fn related_objects_type(&self) -> &Option<IfcObjectTypeEnum> {
        &self.related_objects_type
    }
}
impl IIfcRelAssignsToControl for IfcRelSchedulesCostItems {
    fn relating_control(&self) -> &EntityRef {
        &self.relating_control
    }
}
impl IIfcRelSchedulesCostItems for IfcRelSchedulesCostItems {}
impl IfcRelSchedulesCostItems {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSchedulesCostItems::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.related_objects = parameter.into(),
                5usize => {
                    entity.related_objects_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.relating_control = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSequence: IIfcRelConnects {
    fn relating_process(&self) -> &EntityRef;
    fn related_process(&self) -> &EntityRef;
    fn time_lag(&self) -> &IfcTimeMeasure;
    fn sequence_type(&self) -> &IfcSequenceEnum;
}
#[derive(Default, Debug)]
pub struct IfcRelSequence {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_process: EntityRef,
    related_process: EntityRef,
    time_lag: IfcTimeMeasure,
    sequence_type: IfcSequenceEnum,
}
impl IIfcRoot for IfcRelSequence {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSequence {}
impl IIfcRelConnects for IfcRelSequence {}
impl IIfcRelSequence for IfcRelSequence {
    fn relating_process(&self) -> &EntityRef {
        &self.relating_process
    }
    fn related_process(&self) -> &EntityRef {
        &self.related_process
    }
    fn time_lag(&self) -> &IfcTimeMeasure {
        &self.time_lag
    }
    fn sequence_type(&self) -> &IfcSequenceEnum {
        &self.sequence_type
    }
}
impl IfcRelSequence {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSequence::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_process = parameter.into(),
                5usize => entity.related_process = parameter.into(),
                6usize => entity.time_lag = parameter.into(),
                7usize => entity.sequence_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelServicesBuildings: IIfcRelConnects {
    fn relating_system(&self) -> &EntityRef;
    fn related_buildings(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRelServicesBuildings {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_system: EntityRef,
    related_buildings: HashSet<EntityRef>,
}
impl IIfcRoot for IfcRelServicesBuildings {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelServicesBuildings {}
impl IIfcRelConnects for IfcRelServicesBuildings {}
impl IIfcRelServicesBuildings for IfcRelServicesBuildings {
    fn relating_system(&self) -> &EntityRef {
        &self.relating_system
    }
    fn related_buildings(&self) -> &HashSet<EntityRef> {
        &self.related_buildings
    }
}
impl IfcRelServicesBuildings {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelServicesBuildings::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_system = parameter.into(),
                5usize => entity.related_buildings = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelSpaceBoundary: IIfcRelConnects {
    fn relating_space(&self) -> &EntityRef;
    fn related_building_element(&self) -> &Option<EntityRef>;
    fn connection_geometry(&self) -> &Option<EntityRef>;
    fn physical_or_virtual_boundary(&self) -> &IfcPhysicalOrVirtualEnum;
    fn internal_or_external_boundary(&self) -> &IfcInternalOrExternalEnum;
}
#[derive(Default, Debug)]
pub struct IfcRelSpaceBoundary {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_space: EntityRef,
    related_building_element: Option<EntityRef>,
    connection_geometry: Option<EntityRef>,
    physical_or_virtual_boundary: IfcPhysicalOrVirtualEnum,
    internal_or_external_boundary: IfcInternalOrExternalEnum,
}
impl IIfcRoot for IfcRelSpaceBoundary {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelSpaceBoundary {}
impl IIfcRelConnects for IfcRelSpaceBoundary {}
impl IIfcRelSpaceBoundary for IfcRelSpaceBoundary {
    fn relating_space(&self) -> &EntityRef {
        &self.relating_space
    }
    fn related_building_element(&self) -> &Option<EntityRef> {
        &self.related_building_element
    }
    fn connection_geometry(&self) -> &Option<EntityRef> {
        &self.connection_geometry
    }
    fn physical_or_virtual_boundary(&self) -> &IfcPhysicalOrVirtualEnum {
        &self.physical_or_virtual_boundary
    }
    fn internal_or_external_boundary(&self) -> &IfcInternalOrExternalEnum {
        &self.internal_or_external_boundary
    }
}
impl IfcRelSpaceBoundary {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelSpaceBoundary::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_space = parameter.into(),
                5usize => {
                    entity.related_building_element = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.connection_geometry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.physical_or_virtual_boundary = parameter.into(),
                8usize => entity.internal_or_external_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelVoidsElement: IIfcRelConnects {
    fn relating_building_element(&self) -> &EntityRef;
    fn related_opening_element(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRelVoidsElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    relating_building_element: EntityRef,
    related_opening_element: EntityRef,
}
impl IIfcRoot for IfcRelVoidsElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcRelationship for IfcRelVoidsElement {}
impl IIfcRelConnects for IfcRelVoidsElement {}
impl IIfcRelVoidsElement for IfcRelVoidsElement {
    fn relating_building_element(&self) -> &EntityRef {
        &self.relating_building_element
    }
    fn related_opening_element(&self) -> &EntityRef {
        &self.related_opening_element
    }
}
impl IfcRelVoidsElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelVoidsElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.relating_building_element = parameter.into(),
                5usize => entity.related_opening_element = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRelationship: IIfcRoot {}
pub trait IIfcRelaxation {
    fn relaxation_value(&self) -> &IfcNormalisedRatioMeasure;
    fn initial_stress(&self) -> &IfcNormalisedRatioMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRelaxation {
    relaxation_value: IfcNormalisedRatioMeasure,
    initial_stress: IfcNormalisedRatioMeasure,
}
impl IIfcRelaxation for IfcRelaxation {
    fn relaxation_value(&self) -> &IfcNormalisedRatioMeasure {
        &self.relaxation_value
    }
    fn initial_stress(&self) -> &IfcNormalisedRatioMeasure {
        &self.initial_stress
    }
}
impl IfcRelaxation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRelaxation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.relaxation_value = parameter.into(),
                1usize => entity.initial_stress = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRepresentation {
    fn context_of_items(&self) -> &EntityRef;
    fn representation_identifier(&self) -> &Option<IfcLabel>;
    fn representation_type(&self) -> &Option<IfcLabel>;
    fn items(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IfcRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRepresentationContext {
    fn context_identifier(&self) -> &Option<IfcLabel>;
    fn context_type(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcRepresentationContext {
    context_identifier: Option<IfcLabel>,
    context_type: Option<IfcLabel>,
}
impl IIfcRepresentationContext for IfcRepresentationContext {
    fn context_identifier(&self) -> &Option<IfcLabel> {
        &self.context_identifier
    }
    fn context_type(&self) -> &Option<IfcLabel> {
        &self.context_type
    }
}
impl IfcRepresentationContext {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRepresentationContext::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.context_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.context_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRepresentationItem {}
pub trait IIfcRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef;
    fn mapped_representation(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcRepresentationMap {
    mapping_origin: EntityRef,
    mapped_representation: EntityRef,
}
impl IIfcRepresentationMap for IfcRepresentationMap {
    fn mapping_origin(&self) -> &EntityRef {
        &self.mapping_origin
    }
    fn mapped_representation(&self) -> &EntityRef {
        &self.mapped_representation
    }
}
impl IfcRepresentationMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRepresentationMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mapping_origin = parameter.into(),
                1usize => entity.mapped_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcResource: IIfcObject {}
pub trait IIfcRevolvedAreaSolid: IIfcSweptAreaSolid {
    fn axis(&self) -> &EntityRef;
    fn angle(&self) -> &IfcPlaneAngleMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRevolvedAreaSolid {
    swept_area: EntityRef,
    position: EntityRef,
    axis: EntityRef,
    angle: IfcPlaneAngleMeasure,
}
impl IIfcRepresentationItem for IfcRevolvedAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcRevolvedAreaSolid {}
impl IIfcSolidModel for IfcRevolvedAreaSolid {}
impl IIfcSweptAreaSolid for IfcRevolvedAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRevolvedAreaSolid for IfcRevolvedAreaSolid {
    fn axis(&self) -> &EntityRef {
        &self.axis
    }
    fn angle(&self) -> &IfcPlaneAngleMeasure {
        &self.angle
    }
}
impl IfcRevolvedAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRevolvedAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.axis = parameter.into(),
                3usize => entity.angle = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRibPlateProfileProperties: IIfcProfileProperties {
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn rib_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn rib_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn rib_spacing(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn direction(&self) -> &IfcRibPlateDirectionEnum;
}
#[derive(Default, Debug)]
pub struct IfcRibPlateProfileProperties {
    profile_name: Option<IfcLabel>,
    profile_definition: Option<EntityRef>,
    thickness: Option<IfcPositiveLengthMeasure>,
    rib_height: Option<IfcPositiveLengthMeasure>,
    rib_width: Option<IfcPositiveLengthMeasure>,
    rib_spacing: Option<IfcPositiveLengthMeasure>,
    direction: IfcRibPlateDirectionEnum,
}
impl IIfcProfileProperties for IfcRibPlateProfileProperties {
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
    fn profile_definition(&self) -> &Option<EntityRef> {
        &self.profile_definition
    }
}
impl IIfcRibPlateProfileProperties for IfcRibPlateProfileProperties {
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.thickness
    }
    fn rib_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.rib_height
    }
    fn rib_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.rib_width
    }
    fn rib_spacing(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.rib_spacing
    }
    fn direction(&self) -> &IfcRibPlateDirectionEnum {
        &self.direction
    }
}
impl IfcRibPlateProfileProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRibPlateProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.profile_definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.rib_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rib_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rib_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.direction = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRightCircularCone: IIfcCsgPrimitive3D {
    fn height(&self) -> &IfcPositiveLengthMeasure;
    fn bottom_radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRightCircularCone {
    position: EntityRef,
    height: IfcPositiveLengthMeasure,
    bottom_radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcRightCircularCone {}
impl IIfcGeometricRepresentationItem for IfcRightCircularCone {}
impl IIfcCsgPrimitive3D for IfcRightCircularCone {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRightCircularCone for IfcRightCircularCone {
    fn height(&self) -> &IfcPositiveLengthMeasure {
        &self.height
    }
    fn bottom_radius(&self) -> &IfcPositiveLengthMeasure {
        &self.bottom_radius
    }
}
impl IfcRightCircularCone {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRightCircularCone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.height = parameter.into(),
                2usize => entity.bottom_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRightCircularCylinder: IIfcCsgPrimitive3D {
    fn height(&self) -> &IfcPositiveLengthMeasure;
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRightCircularCylinder {
    position: EntityRef,
    height: IfcPositiveLengthMeasure,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcRightCircularCylinder {}
impl IIfcGeometricRepresentationItem for IfcRightCircularCylinder {}
impl IIfcCsgPrimitive3D for IfcRightCircularCylinder {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRightCircularCylinder for IfcRightCircularCylinder {
    fn height(&self) -> &IfcPositiveLengthMeasure {
        &self.height
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcRightCircularCylinder {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRightCircularCylinder::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.height = parameter.into(),
                2usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRoof: IIfcBuildingElement {
    fn shape_type(&self) -> &IfcRoofTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcRoof {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    shape_type: IfcRoofTypeEnum,
}
impl IIfcRoot for IfcRoof {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRoof {}
impl IIfcObject for IfcRoof {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRoof {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRoof {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcRoof {}
impl IIfcRoof for IfcRoof {
    fn shape_type(&self) -> &IfcRoofTypeEnum {
        &self.shape_type
    }
}
impl IfcRoof {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoof::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.shape_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRoot {
    fn global_id(&self) -> &IfcGloballyUniqueId;
    fn owner_history(&self) -> &EntityRef;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
}
pub trait IIfcRoundedEdgeFeature: IIfcEdgeFeature {
    fn radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcRoundedEdgeFeature {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    feature_length: Option<IfcPositiveLengthMeasure>,
    radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcRoundedEdgeFeature {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcRoundedEdgeFeature {}
impl IIfcObject for IfcRoundedEdgeFeature {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcRoundedEdgeFeature {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcRoundedEdgeFeature {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcFeatureElement for IfcRoundedEdgeFeature {}
impl IIfcFeatureElementSubtraction for IfcRoundedEdgeFeature {}
impl IIfcEdgeFeature for IfcRoundedEdgeFeature {
    fn feature_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.feature_length
    }
}
impl IIfcRoundedEdgeFeature for IfcRoundedEdgeFeature {
    fn radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.radius
    }
}
impl IfcRoundedEdgeFeature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoundedEdgeFeature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.feature_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcRoundedRectangleProfileDef: IIfcRectangleProfileDef {
    fn rounding_radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcRoundedRectangleProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    rounding_radius: IfcPositiveLengthMeasure,
}
impl IIfcProfileDef for IfcRoundedRectangleProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcRoundedRectangleProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcRectangleProfileDef for IfcRoundedRectangleProfileDef {
    fn x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
}
impl IIfcRoundedRectangleProfileDef for IfcRoundedRectangleProfileDef {
    fn rounding_radius(&self) -> &IfcPositiveLengthMeasure {
        &self.rounding_radius
    }
}
impl IfcRoundedRectangleProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcRoundedRectangleProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.x_dim = parameter.into(),
                4usize => entity.y_dim = parameter.into(),
                5usize => entity.rounding_radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSiUnit: IIfcNamedUnit {
    fn prefix(&self) -> &Option<IfcSiPrefix>;
    fn name(&self) -> &IfcSiUnitName;
}
#[derive(Default, Debug)]
pub struct IfcSiUnit {
    dimensions: EntityRef,
    unit_type: IfcUnitEnum,
    prefix: Option<IfcSiPrefix>,
    name: IfcSiUnitName,
}
impl IIfcNamedUnit for IfcSiUnit {
    fn dimensions(&self) -> &EntityRef {
        &self.dimensions
    }
    fn unit_type(&self) -> &IfcUnitEnum {
        &self.unit_type
    }
}
impl IIfcSiUnit for IfcSiUnit {
    fn prefix(&self) -> &Option<IfcSiPrefix> {
        &self.prefix
    }
    fn name(&self) -> &IfcSiUnitName {
        &self.name
    }
}
impl IfcSiUnit {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSiUnit::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.dimensions = parameter.into(),
                1usize => entity.unit_type = parameter.into(),
                2usize => {
                    entity.prefix = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.name = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSanitaryTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcSanitaryTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSanitaryTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSanitaryTerminalTypeEnum,
}
impl IIfcRoot for IfcSanitaryTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSanitaryTerminalType {}
impl IIfcTypeObject for IfcSanitaryTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSanitaryTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSanitaryTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSanitaryTerminalType {}
impl IIfcDistributionFlowElementType for IfcSanitaryTerminalType {}
impl IIfcFlowTerminalType for IfcSanitaryTerminalType {}
impl IIfcSanitaryTerminalType for IfcSanitaryTerminalType {
    fn predefined_type(&self) -> &IfcSanitaryTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcSanitaryTerminalType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSanitaryTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcScheduleTimeControl: IIfcControl {
    fn actual_start(&self) -> &Option<EntityRef>;
    fn early_start(&self) -> &Option<EntityRef>;
    fn late_start(&self) -> &Option<EntityRef>;
    fn schedule_start(&self) -> &Option<EntityRef>;
    fn actual_finish(&self) -> &Option<EntityRef>;
    fn early_finish(&self) -> &Option<EntityRef>;
    fn late_finish(&self) -> &Option<EntityRef>;
    fn schedule_finish(&self) -> &Option<EntityRef>;
    fn schedule_duration(&self) -> &Option<IfcTimeMeasure>;
    fn actual_duration(&self) -> &Option<IfcTimeMeasure>;
    fn remaining_time(&self) -> &Option<IfcTimeMeasure>;
    fn free_float(&self) -> &Option<IfcTimeMeasure>;
    fn total_float(&self) -> &Option<IfcTimeMeasure>;
    fn is_critical(&self) -> Option<bool>;
    fn status_time(&self) -> &Option<EntityRef>;
    fn start_float(&self) -> &Option<IfcTimeMeasure>;
    fn finish_float(&self) -> &Option<IfcTimeMeasure>;
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcScheduleTimeControl {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    actual_start: Option<EntityRef>,
    early_start: Option<EntityRef>,
    late_start: Option<EntityRef>,
    schedule_start: Option<EntityRef>,
    actual_finish: Option<EntityRef>,
    early_finish: Option<EntityRef>,
    late_finish: Option<EntityRef>,
    schedule_finish: Option<EntityRef>,
    schedule_duration: Option<IfcTimeMeasure>,
    actual_duration: Option<IfcTimeMeasure>,
    remaining_time: Option<IfcTimeMeasure>,
    free_float: Option<IfcTimeMeasure>,
    total_float: Option<IfcTimeMeasure>,
    is_critical: Option<bool>,
    status_time: Option<EntityRef>,
    start_float: Option<IfcTimeMeasure>,
    finish_float: Option<IfcTimeMeasure>,
    completion: Option<IfcPositiveRatioMeasure>,
}
impl IIfcRoot for IfcScheduleTimeControl {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcScheduleTimeControl {}
impl IIfcObject for IfcScheduleTimeControl {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcScheduleTimeControl {}
impl IIfcScheduleTimeControl for IfcScheduleTimeControl {
    fn actual_start(&self) -> &Option<EntityRef> {
        &self.actual_start
    }
    fn early_start(&self) -> &Option<EntityRef> {
        &self.early_start
    }
    fn late_start(&self) -> &Option<EntityRef> {
        &self.late_start
    }
    fn schedule_start(&self) -> &Option<EntityRef> {
        &self.schedule_start
    }
    fn actual_finish(&self) -> &Option<EntityRef> {
        &self.actual_finish
    }
    fn early_finish(&self) -> &Option<EntityRef> {
        &self.early_finish
    }
    fn late_finish(&self) -> &Option<EntityRef> {
        &self.late_finish
    }
    fn schedule_finish(&self) -> &Option<EntityRef> {
        &self.schedule_finish
    }
    fn schedule_duration(&self) -> &Option<IfcTimeMeasure> {
        &self.schedule_duration
    }
    fn actual_duration(&self) -> &Option<IfcTimeMeasure> {
        &self.actual_duration
    }
    fn remaining_time(&self) -> &Option<IfcTimeMeasure> {
        &self.remaining_time
    }
    fn free_float(&self) -> &Option<IfcTimeMeasure> {
        &self.free_float
    }
    fn total_float(&self) -> &Option<IfcTimeMeasure> {
        &self.total_float
    }
    fn is_critical(&self) -> Option<bool> {
        self.is_critical
    }
    fn status_time(&self) -> &Option<EntityRef> {
        &self.status_time
    }
    fn start_float(&self) -> &Option<IfcTimeMeasure> {
        &self.start_float
    }
    fn finish_float(&self) -> &Option<IfcTimeMeasure> {
        &self.finish_float
    }
    fn completion(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.completion
    }
}
impl IfcScheduleTimeControl {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcScheduleTimeControl::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.actual_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.early_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.late_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.schedule_start = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.actual_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.early_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.late_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.schedule_finish = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.schedule_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.actual_duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.remaining_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.free_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.is_critical = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                19usize => {
                    entity.status_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                20usize => {
                    entity.start_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                21usize => {
                    entity.finish_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                22usize => {
                    entity.completion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSectionProperties {
    fn section_type(&self) -> &IfcSectionTypeEnum;
    fn start_profile(&self) -> &EntityRef;
    fn end_profile(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSectionProperties {
    section_type: IfcSectionTypeEnum,
    start_profile: EntityRef,
    end_profile: Option<EntityRef>,
}
impl IIfcSectionProperties for IfcSectionProperties {
    fn section_type(&self) -> &IfcSectionTypeEnum {
        &self.section_type
    }
    fn start_profile(&self) -> &EntityRef {
        &self.start_profile
    }
    fn end_profile(&self) -> &Option<EntityRef> {
        &self.end_profile
    }
}
impl IfcSectionProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSectionProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.section_type = parameter.into(),
                1usize => entity.start_profile = parameter.into(),
                2usize => {
                    entity.end_profile = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSectionReinforcementProperties {
    fn longitudinal_start_position(&self) -> &IfcLengthMeasure;
    fn longitudinal_end_position(&self) -> &IfcLengthMeasure;
    fn transverse_position(&self) -> &Option<IfcLengthMeasure>;
    fn reinforcement_role(&self) -> &IfcReinforcingBarRoleEnum;
    fn section_definition(&self) -> &EntityRef;
    fn cross_section_reinforcement_definitions(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSectionReinforcementProperties {
    longitudinal_start_position: IfcLengthMeasure,
    longitudinal_end_position: IfcLengthMeasure,
    transverse_position: Option<IfcLengthMeasure>,
    reinforcement_role: IfcReinforcingBarRoleEnum,
    section_definition: EntityRef,
    cross_section_reinforcement_definitions: HashSet<EntityRef>,
}
impl IIfcSectionReinforcementProperties for IfcSectionReinforcementProperties {
    fn longitudinal_start_position(&self) -> &IfcLengthMeasure {
        &self.longitudinal_start_position
    }
    fn longitudinal_end_position(&self) -> &IfcLengthMeasure {
        &self.longitudinal_end_position
    }
    fn transverse_position(&self) -> &Option<IfcLengthMeasure> {
        &self.transverse_position
    }
    fn reinforcement_role(&self) -> &IfcReinforcingBarRoleEnum {
        &self.reinforcement_role
    }
    fn section_definition(&self) -> &EntityRef {
        &self.section_definition
    }
    fn cross_section_reinforcement_definitions(&self) -> &HashSet<EntityRef> {
        &self.cross_section_reinforcement_definitions
    }
}
impl IfcSectionReinforcementProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSectionReinforcementProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.longitudinal_start_position = parameter.into(),
                1usize => entity.longitudinal_end_position = parameter.into(),
                2usize => {
                    entity.transverse_position = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.reinforcement_role = parameter.into(),
                4usize => entity.section_definition = parameter.into(),
                5usize => entity.cross_section_reinforcement_definitions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSectionedSpine: IIfcGeometricRepresentationItem {
    fn spine_curve(&self) -> &EntityRef;
    fn cross_sections(&self) -> &Vec<EntityRef>;
    fn cross_section_positions(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSectionedSpine {
    spine_curve: EntityRef,
    cross_sections: Vec<EntityRef>,
    cross_section_positions: Vec<EntityRef>,
}
impl IIfcRepresentationItem for IfcSectionedSpine {}
impl IIfcGeometricRepresentationItem for IfcSectionedSpine {}
impl IIfcSectionedSpine for IfcSectionedSpine {
    fn spine_curve(&self) -> &EntityRef {
        &self.spine_curve
    }
    fn cross_sections(&self) -> &Vec<EntityRef> {
        &self.cross_sections
    }
    fn cross_section_positions(&self) -> &Vec<EntityRef> {
        &self.cross_section_positions
    }
}
impl IfcSectionedSpine {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSectionedSpine::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.spine_curve = parameter.into(),
                1usize => entity.cross_sections = parameter.into(),
                2usize => entity.cross_section_positions = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSensorType: IIfcDistributionControlElementType {
    fn predefined_type(&self) -> &IfcSensorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSensorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSensorTypeEnum,
}
impl IIfcRoot for IfcSensorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSensorType {}
impl IIfcTypeObject for IfcSensorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSensorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSensorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSensorType {}
impl IIfcDistributionControlElementType for IfcSensorType {}
impl IIfcSensorType for IfcSensorType {
    fn predefined_type(&self) -> &IfcSensorTypeEnum {
        &self.predefined_type
    }
}
impl IfcSensorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSensorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcServiceLife: IIfcControl {
    fn service_life_type(&self) -> &IfcServiceLifeTypeEnum;
    fn service_life_duration(&self) -> &IfcTimeMeasure;
}
#[derive(Default, Debug)]
pub struct IfcServiceLife {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    service_life_type: IfcServiceLifeTypeEnum,
    service_life_duration: IfcTimeMeasure,
}
impl IIfcRoot for IfcServiceLife {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcServiceLife {}
impl IIfcObject for IfcServiceLife {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcServiceLife {}
impl IIfcServiceLife for IfcServiceLife {
    fn service_life_type(&self) -> &IfcServiceLifeTypeEnum {
        &self.service_life_type
    }
    fn service_life_duration(&self) -> &IfcTimeMeasure {
        &self.service_life_duration
    }
}
impl IfcServiceLife {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcServiceLife::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.service_life_type = parameter.into(),
                6usize => entity.service_life_duration = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcServiceLifeFactor: IIfcPropertySetDefinition {
    fn predefined_type(&self) -> &IfcServiceLifeFactorTypeEnum;
    fn upper_value(&self) -> &Option<IfcMeasureValue>;
    fn most_used_value(&self) -> &IfcMeasureValue;
    fn lower_value(&self) -> &Option<IfcMeasureValue>;
}
#[derive(Default, Debug)]
pub struct IfcServiceLifeFactor {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    predefined_type: IfcServiceLifeFactorTypeEnum,
    upper_value: Option<IfcMeasureValue>,
    most_used_value: IfcMeasureValue,
    lower_value: Option<IfcMeasureValue>,
}
impl IIfcRoot for IfcServiceLifeFactor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcServiceLifeFactor {}
impl IIfcPropertySetDefinition for IfcServiceLifeFactor {}
impl IIfcServiceLifeFactor for IfcServiceLifeFactor {
    fn predefined_type(&self) -> &IfcServiceLifeFactorTypeEnum {
        &self.predefined_type
    }
    fn upper_value(&self) -> &Option<IfcMeasureValue> {
        &self.upper_value
    }
    fn most_used_value(&self) -> &IfcMeasureValue {
        &self.most_used_value
    }
    fn lower_value(&self) -> &Option<IfcMeasureValue> {
        &self.lower_value
    }
}
impl IfcServiceLifeFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcServiceLifeFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.predefined_type = parameter.into(),
                5usize => {
                    entity.upper_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.most_used_value = parameter.into(),
                7usize => {
                    entity.lower_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShapeAspect {
    fn shape_representations(&self) -> &Vec<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
    fn description(&self) -> &Option<IfcText>;
    fn product_definitional(&self) -> Option<bool>;
    fn part_of_product_definition_shape(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcShapeAspect {
    shape_representations: Vec<EntityRef>,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    product_definitional: Option<bool>,
    part_of_product_definition_shape: EntityRef,
}
impl IIfcShapeAspect for IfcShapeAspect {
    fn shape_representations(&self) -> &Vec<EntityRef> {
        &self.shape_representations
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn product_definitional(&self) -> Option<bool> {
        self.product_definitional
    }
    fn part_of_product_definition_shape(&self) -> &EntityRef {
        &self.part_of_product_definition_shape
    }
}
impl IfcShapeAspect {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShapeAspect::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.shape_representations = parameter.into(),
                1usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.product_definitional = parameter.into(),
                4usize => entity.part_of_product_definition_shape = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShapeModel: IIfcRepresentation {}
pub trait IIfcShapeRepresentation: IIfcShapeModel {}
#[derive(Default, Debug)]
pub struct IfcShapeRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcShapeRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IIfcShapeModel for IfcShapeRepresentation {}
impl IIfcShapeRepresentation for IfcShapeRepresentation {}
impl IfcShapeRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShapeRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcShellBasedSurfaceModel: IIfcGeometricRepresentationItem {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcShellBasedSurfaceModel {
    sbsm_boundary: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcShellBasedSurfaceModel {}
impl IIfcGeometricRepresentationItem for IfcShellBasedSurfaceModel {}
impl IIfcShellBasedSurfaceModel for IfcShellBasedSurfaceModel {
    fn sbsm_boundary(&self) -> &HashSet<EntityRef> {
        &self.sbsm_boundary
    }
}
impl IfcShellBasedSurfaceModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcShellBasedSurfaceModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.sbsm_boundary = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSimpleProperty: IIfcProperty {}
pub trait IIfcSite: IIfcSpatialStructureElement {
    fn ref_latitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure>;
    fn ref_longitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure>;
    fn ref_elevation(&self) -> &Option<IfcLengthMeasure>;
    fn land_title_number(&self) -> &Option<IfcLabel>;
    fn site_address(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSite {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: IfcElementCompositionEnum,
    ref_latitude: Option<IfcCompoundPlaneAngleMeasure>,
    ref_longitude: Option<IfcCompoundPlaneAngleMeasure>,
    ref_elevation: Option<IfcLengthMeasure>,
    land_title_number: Option<IfcLabel>,
    site_address: Option<EntityRef>,
}
impl IIfcRoot for IfcSite {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSite {}
impl IIfcObject for IfcSite {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSite {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialStructureElement for IfcSite {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn composition_type(&self) -> &IfcElementCompositionEnum {
        &self.composition_type
    }
}
impl IIfcSite for IfcSite {
    fn ref_latitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure> {
        &self.ref_latitude
    }
    fn ref_longitude(&self) -> &Option<IfcCompoundPlaneAngleMeasure> {
        &self.ref_longitude
    }
    fn ref_elevation(&self) -> &Option<IfcLengthMeasure> {
        &self.ref_elevation
    }
    fn land_title_number(&self) -> &Option<IfcLabel> {
        &self.land_title_number
    }
    fn site_address(&self) -> &Option<EntityRef> {
        &self.site_address
    }
}
impl IfcSite {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSite::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.composition_type = parameter.into(),
                9usize => {
                    entity.ref_latitude = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.ref_longitude = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.ref_elevation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.land_title_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.site_address = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlab: IIfcBuildingElement {
    fn predefined_type(&self) -> &Option<IfcSlabTypeEnum>;
}
#[derive(Default, Debug)]
pub struct IfcSlab {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    predefined_type: Option<IfcSlabTypeEnum>,
}
impl IIfcRoot for IfcSlab {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSlab {}
impl IIfcObject for IfcSlab {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSlab {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcSlab {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcSlab {}
impl IIfcSlab for IfcSlab {
    fn predefined_type(&self) -> &Option<IfcSlabTypeEnum> {
        &self.predefined_type
    }
}
impl IfcSlab {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlab::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.predefined_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlabType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcSlabTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSlabType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSlabTypeEnum,
}
impl IIfcRoot for IfcSlabType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSlabType {}
impl IIfcTypeObject for IfcSlabType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSlabType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSlabType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcSlabType {}
impl IIfcSlabType for IfcSlabType {
    fn predefined_type(&self) -> &IfcSlabTypeEnum {
        &self.predefined_type
    }
}
impl IfcSlabType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlabType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSlippageConnectionCondition: IIfcStructuralConnectionCondition {
    fn slippage_x(&self) -> &Option<IfcLengthMeasure>;
    fn slippage_y(&self) -> &Option<IfcLengthMeasure>;
    fn slippage_z(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSlippageConnectionCondition {
    name: Option<IfcLabel>,
    slippage_x: Option<IfcLengthMeasure>,
    slippage_y: Option<IfcLengthMeasure>,
    slippage_z: Option<IfcLengthMeasure>,
}
impl IIfcStructuralConnectionCondition for IfcSlippageConnectionCondition {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcSlippageConnectionCondition for IfcSlippageConnectionCondition {
    fn slippage_x(&self) -> &Option<IfcLengthMeasure> {
        &self.slippage_x
    }
    fn slippage_y(&self) -> &Option<IfcLengthMeasure> {
        &self.slippage_y
    }
    fn slippage_z(&self) -> &Option<IfcLengthMeasure> {
        &self.slippage_z
    }
}
impl IfcSlippageConnectionCondition {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSlippageConnectionCondition::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.slippage_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.slippage_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.slippage_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSolidModel: IIfcGeometricRepresentationItem {}
pub trait IIfcSoundProperties: IIfcPropertySetDefinition {
    fn is_attenuating(&self) -> &IfcBoolean;
    fn sound_scale(&self) -> &Option<IfcSoundScaleEnum>;
    fn sound_values(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSoundProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    is_attenuating: IfcBoolean,
    sound_scale: Option<IfcSoundScaleEnum>,
    sound_values: Vec<EntityRef>,
}
impl IIfcRoot for IfcSoundProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcSoundProperties {}
impl IIfcPropertySetDefinition for IfcSoundProperties {}
impl IIfcSoundProperties for IfcSoundProperties {
    fn is_attenuating(&self) -> &IfcBoolean {
        &self.is_attenuating
    }
    fn sound_scale(&self) -> &Option<IfcSoundScaleEnum> {
        &self.sound_scale
    }
    fn sound_values(&self) -> &Vec<EntityRef> {
        &self.sound_values
    }
}
impl IfcSoundProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSoundProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.is_attenuating = parameter.into(),
                5usize => {
                    entity.sound_scale = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.sound_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSoundValue: IIfcPropertySetDefinition {
    fn sound_level_time_series(&self) -> &Option<EntityRef>;
    fn frequency(&self) -> &IfcFrequencyMeasure;
    fn sound_level_single_value(&self) -> &Option<IfcDerivedMeasureValue>;
}
#[derive(Default, Debug)]
pub struct IfcSoundValue {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    sound_level_time_series: Option<EntityRef>,
    frequency: IfcFrequencyMeasure,
    sound_level_single_value: Option<IfcDerivedMeasureValue>,
}
impl IIfcRoot for IfcSoundValue {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcSoundValue {}
impl IIfcPropertySetDefinition for IfcSoundValue {}
impl IIfcSoundValue for IfcSoundValue {
    fn sound_level_time_series(&self) -> &Option<EntityRef> {
        &self.sound_level_time_series
    }
    fn frequency(&self) -> &IfcFrequencyMeasure {
        &self.frequency
    }
    fn sound_level_single_value(&self) -> &Option<IfcDerivedMeasureValue> {
        &self.sound_level_single_value
    }
}
impl IfcSoundValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSoundValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.sound_level_time_series = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.frequency = parameter.into(),
                6usize => {
                    entity.sound_level_single_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpace: IIfcSpatialStructureElement {
    fn interior_or_exterior_space(&self) -> &IfcInternalOrExternalEnum;
    fn elevation_with_flooring(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcSpace {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    long_name: Option<IfcLabel>,
    composition_type: IfcElementCompositionEnum,
    interior_or_exterior_space: IfcInternalOrExternalEnum,
    elevation_with_flooring: Option<IfcLengthMeasure>,
}
impl IIfcRoot for IfcSpace {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpace {}
impl IIfcObject for IfcSpace {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcSpace {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcSpatialStructureElement for IfcSpace {
    fn long_name(&self) -> &Option<IfcLabel> {
        &self.long_name
    }
    fn composition_type(&self) -> &IfcElementCompositionEnum {
        &self.composition_type
    }
}
impl IIfcSpace for IfcSpace {
    fn interior_or_exterior_space(&self) -> &IfcInternalOrExternalEnum {
        &self.interior_or_exterior_space
    }
    fn elevation_with_flooring(&self) -> &Option<IfcLengthMeasure> {
        &self.elevation_with_flooring
    }
}
impl IfcSpace {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpace::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.long_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.composition_type = parameter.into(),
                9usize => entity.interior_or_exterior_space = parameter.into(),
                10usize => {
                    entity.elevation_with_flooring = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceHeaterType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcSpaceHeaterTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSpaceHeaterType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSpaceHeaterTypeEnum,
}
impl IIfcRoot for IfcSpaceHeaterType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpaceHeaterType {}
impl IIfcTypeObject for IfcSpaceHeaterType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSpaceHeaterType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSpaceHeaterType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSpaceHeaterType {}
impl IIfcDistributionFlowElementType for IfcSpaceHeaterType {}
impl IIfcEnergyConversionDeviceType for IfcSpaceHeaterType {}
impl IIfcSpaceHeaterType for IfcSpaceHeaterType {
    fn predefined_type(&self) -> &IfcSpaceHeaterTypeEnum {
        &self.predefined_type
    }
}
impl IfcSpaceHeaterType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceHeaterType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceProgram: IIfcControl {
    fn space_program_identifier(&self) -> &IfcIdentifier;
    fn max_required_area(&self) -> &Option<IfcAreaMeasure>;
    fn min_required_area(&self) -> &Option<IfcAreaMeasure>;
    fn requested_location(&self) -> &Option<EntityRef>;
    fn standard_required_area(&self) -> &IfcAreaMeasure;
}
#[derive(Default, Debug)]
pub struct IfcSpaceProgram {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    space_program_identifier: IfcIdentifier,
    max_required_area: Option<IfcAreaMeasure>,
    min_required_area: Option<IfcAreaMeasure>,
    requested_location: Option<EntityRef>,
    standard_required_area: IfcAreaMeasure,
}
impl IIfcRoot for IfcSpaceProgram {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpaceProgram {}
impl IIfcObject for IfcSpaceProgram {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcSpaceProgram {}
impl IIfcSpaceProgram for IfcSpaceProgram {
    fn space_program_identifier(&self) -> &IfcIdentifier {
        &self.space_program_identifier
    }
    fn max_required_area(&self) -> &Option<IfcAreaMeasure> {
        &self.max_required_area
    }
    fn min_required_area(&self) -> &Option<IfcAreaMeasure> {
        &self.min_required_area
    }
    fn requested_location(&self) -> &Option<EntityRef> {
        &self.requested_location
    }
    fn standard_required_area(&self) -> &IfcAreaMeasure {
        &self.standard_required_area
    }
}
impl IfcSpaceProgram {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceProgram::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.space_program_identifier = parameter.into(),
                6usize => {
                    entity.max_required_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.min_required_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.requested_location = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.standard_required_area = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceThermalLoadProperties: IIfcPropertySetDefinition {
    fn applicable_value_ratio(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn thermal_load_source(&self) -> &IfcThermalLoadSourceEnum;
    fn property_source(&self) -> &IfcPropertySourceEnum;
    fn source_description(&self) -> &Option<IfcText>;
    fn maximum_value(&self) -> &IfcPowerMeasure;
    fn minimum_value(&self) -> &Option<IfcPowerMeasure>;
    fn thermal_load_time_series_values(&self) -> &Option<EntityRef>;
    fn user_defined_thermal_load_source(&self) -> &Option<IfcLabel>;
    fn user_defined_property_source(&self) -> &Option<IfcLabel>;
    fn thermal_load_type(&self) -> &IfcThermalLoadTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSpaceThermalLoadProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_value_ratio: Option<IfcPositiveRatioMeasure>,
    thermal_load_source: IfcThermalLoadSourceEnum,
    property_source: IfcPropertySourceEnum,
    source_description: Option<IfcText>,
    maximum_value: IfcPowerMeasure,
    minimum_value: Option<IfcPowerMeasure>,
    thermal_load_time_series_values: Option<EntityRef>,
    user_defined_thermal_load_source: Option<IfcLabel>,
    user_defined_property_source: Option<IfcLabel>,
    thermal_load_type: IfcThermalLoadTypeEnum,
}
impl IIfcRoot for IfcSpaceThermalLoadProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcSpaceThermalLoadProperties {}
impl IIfcPropertySetDefinition for IfcSpaceThermalLoadProperties {}
impl IIfcSpaceThermalLoadProperties for IfcSpaceThermalLoadProperties {
    fn applicable_value_ratio(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.applicable_value_ratio
    }
    fn thermal_load_source(&self) -> &IfcThermalLoadSourceEnum {
        &self.thermal_load_source
    }
    fn property_source(&self) -> &IfcPropertySourceEnum {
        &self.property_source
    }
    fn source_description(&self) -> &Option<IfcText> {
        &self.source_description
    }
    fn maximum_value(&self) -> &IfcPowerMeasure {
        &self.maximum_value
    }
    fn minimum_value(&self) -> &Option<IfcPowerMeasure> {
        &self.minimum_value
    }
    fn thermal_load_time_series_values(&self) -> &Option<EntityRef> {
        &self.thermal_load_time_series_values
    }
    fn user_defined_thermal_load_source(&self) -> &Option<IfcLabel> {
        &self.user_defined_thermal_load_source
    }
    fn user_defined_property_source(&self) -> &Option<IfcLabel> {
        &self.user_defined_property_source
    }
    fn thermal_load_type(&self) -> &IfcThermalLoadTypeEnum {
        &self.thermal_load_type
    }
}
impl IfcSpaceThermalLoadProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceThermalLoadProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_value_ratio = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.thermal_load_source = parameter.into(),
                6usize => entity.property_source = parameter.into(),
                7usize => {
                    entity.source_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.maximum_value = parameter.into(),
                9usize => {
                    entity.minimum_value = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.thermal_load_time_series_values = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.user_defined_thermal_load_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.user_defined_property_source = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => entity.thermal_load_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpaceType: IIfcSpatialStructureElementType {
    fn predefined_type(&self) -> &IfcSpaceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSpaceType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSpaceTypeEnum,
}
impl IIfcRoot for IfcSpaceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSpaceType {}
impl IIfcTypeObject for IfcSpaceType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSpaceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSpaceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcSpatialStructureElementType for IfcSpaceType {}
impl IIfcSpaceType for IfcSpaceType {
    fn predefined_type(&self) -> &IfcSpaceTypeEnum {
        &self.predefined_type
    }
}
impl IfcSpaceType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSpaceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSpatialStructureElement: IIfcProduct {
    fn long_name(&self) -> &Option<IfcLabel>;
    fn composition_type(&self) -> &IfcElementCompositionEnum;
}
pub trait IIfcSpatialStructureElementType: IIfcElementType {}
pub trait IIfcSphere: IIfcCsgPrimitive3D {
    fn radius(&self) -> &IfcPositiveLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcSphere {
    position: EntityRef,
    radius: IfcPositiveLengthMeasure,
}
impl IIfcRepresentationItem for IfcSphere {}
impl IIfcGeometricRepresentationItem for IfcSphere {}
impl IIfcCsgPrimitive3D for IfcSphere {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcSphere for IfcSphere {
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
}
impl IfcSphere {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSphere::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.position = parameter.into(),
                1usize => entity.radius = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStackTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcStackTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStackTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcStackTerminalTypeEnum,
}
impl IIfcRoot for IfcStackTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStackTerminalType {}
impl IIfcTypeObject for IfcStackTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcStackTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcStackTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcStackTerminalType {}
impl IIfcDistributionFlowElementType for IfcStackTerminalType {}
impl IIfcFlowTerminalType for IfcStackTerminalType {}
impl IIfcStackTerminalType for IfcStackTerminalType {
    fn predefined_type(&self) -> &IfcStackTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcStackTerminalType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStackTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStair: IIfcBuildingElement {
    fn shape_type(&self) -> &IfcStairTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStair {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    shape_type: IfcStairTypeEnum,
}
impl IIfcRoot for IfcStair {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStair {}
impl IIfcObject for IfcStair {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStair {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcStair {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcStair {}
impl IIfcStair for IfcStair {
    fn shape_type(&self) -> &IfcStairTypeEnum {
        &self.shape_type
    }
}
impl IfcStair {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStair::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.shape_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStairFlight: IIfcBuildingElement {
    fn number_of_riser(&self) -> Option<i64>;
    fn number_of_treads(&self) -> Option<i64>;
    fn riser_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn tread_length(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStairFlight {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    number_of_riser: Option<i64>,
    number_of_treads: Option<i64>,
    riser_height: Option<IfcPositiveLengthMeasure>,
    tread_length: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcStairFlight {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStairFlight {}
impl IIfcObject for IfcStairFlight {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStairFlight {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcStairFlight {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcStairFlight {}
impl IIfcStairFlight for IfcStairFlight {
    fn number_of_riser(&self) -> Option<i64> {
        self.number_of_riser
    }
    fn number_of_treads(&self) -> Option<i64> {
        self.number_of_treads
    }
    fn riser_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.riser_height
    }
    fn tread_length(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.tread_length
    }
}
impl IfcStairFlight {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairFlight::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.number_of_riser = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.number_of_treads = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.riser_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.tread_length = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStairFlightType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcStairFlightTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStairFlightType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcStairFlightTypeEnum,
}
impl IIfcRoot for IfcStairFlightType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStairFlightType {}
impl IIfcTypeObject for IfcStairFlightType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcStairFlightType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcStairFlightType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcStairFlightType {}
impl IIfcStairFlightType for IfcStairFlightType {
    fn predefined_type(&self) -> &IfcStairFlightTypeEnum {
        &self.predefined_type
    }
}
impl IfcStairFlightType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStairFlightType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralAction: IIfcStructuralActivity {
    fn destabilizing_load(&self) -> bool;
    fn caused_by(&self) -> &Option<EntityRef>;
}
pub trait IIfcStructuralActivity: IIfcProduct {
    fn applied_load(&self) -> &EntityRef;
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum;
}
pub trait IIfcStructuralAnalysisModel: IIfcSystem {
    fn predefined_type(&self) -> &IfcAnalysisModelTypeEnum;
    fn orientation_of2_d_plane(&self) -> &Option<EntityRef>;
    fn loaded_by(&self) -> &Option<HashSet<EntityRef>>;
    fn has_results(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralAnalysisModel {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: IfcAnalysisModelTypeEnum,
    orientation_of2_d_plane: Option<EntityRef>,
    loaded_by: Option<HashSet<EntityRef>>,
    has_results: Option<HashSet<EntityRef>>,
}
impl IIfcRoot for IfcStructuralAnalysisModel {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralAnalysisModel {}
impl IIfcObject for IfcStructuralAnalysisModel {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralAnalysisModel {}
impl IIfcSystem for IfcStructuralAnalysisModel {}
impl IIfcStructuralAnalysisModel for IfcStructuralAnalysisModel {
    fn predefined_type(&self) -> &IfcAnalysisModelTypeEnum {
        &self.predefined_type
    }
    fn orientation_of2_d_plane(&self) -> &Option<EntityRef> {
        &self.orientation_of2_d_plane
    }
    fn loaded_by(&self) -> &Option<HashSet<EntityRef>> {
        &self.loaded_by
    }
    fn has_results(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_results
    }
}
impl IfcStructuralAnalysisModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralAnalysisModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.predefined_type = parameter.into(),
                6usize => {
                    entity.orientation_of2_d_plane = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.loaded_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.has_results = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralConnection: IIfcStructuralItem {
    fn applied_condition(&self) -> &Option<EntityRef>;
}
pub trait IIfcStructuralConnectionCondition {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcStructuralCurveConnection: IIfcStructuralConnection {}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_condition: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralCurveConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveConnection {}
impl IIfcObject for IfcStructuralCurveConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralCurveConnection {}
impl IIfcStructuralConnection for IfcStructuralCurveConnection {
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
}
impl IIfcStructuralCurveConnection for IfcStructuralCurveConnection {}
impl IfcStructuralCurveConnection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralCurveMember: IIfcStructuralMember {
    fn predefined_type(&self) -> &IfcStructuralCurveTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveMember {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralCurveTypeEnum,
}
impl IIfcRoot for IfcStructuralCurveMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveMember {}
impl IIfcObject for IfcStructuralCurveMember {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveMember {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralCurveMember {}
impl IIfcStructuralMember for IfcStructuralCurveMember {}
impl IIfcStructuralCurveMember for IfcStructuralCurveMember {
    fn predefined_type(&self) -> &IfcStructuralCurveTypeEnum {
        &self.predefined_type
    }
}
impl IfcStructuralCurveMember {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralCurveMemberVarying: IIfcStructuralCurveMember {}
#[derive(Default, Debug)]
pub struct IfcStructuralCurveMemberVarying {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralCurveTypeEnum,
}
impl IIfcRoot for IfcStructuralCurveMemberVarying {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralCurveMemberVarying {}
impl IIfcObject for IfcStructuralCurveMemberVarying {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralCurveMemberVarying {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralCurveMemberVarying {}
impl IIfcStructuralMember for IfcStructuralCurveMemberVarying {}
impl IIfcStructuralCurveMember for IfcStructuralCurveMemberVarying {
    fn predefined_type(&self) -> &IfcStructuralCurveTypeEnum {
        &self.predefined_type
    }
}
impl IIfcStructuralCurveMemberVarying for IfcStructuralCurveMemberVarying {}
impl IfcStructuralCurveMemberVarying {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralCurveMemberVarying::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralItem: IIfcProduct {}
pub trait IIfcStructuralLinearAction: IIfcStructuralAction {
    fn projected_or_true(&self) -> &IfcProjectedOrTrueLengthEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLinearAction {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: bool,
    caused_by: Option<EntityRef>,
    projected_or_true: IfcProjectedOrTrueLengthEnum,
}
impl IIfcRoot for IfcStructuralLinearAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralLinearAction {}
impl IIfcObject for IfcStructuralLinearAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralLinearAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralLinearAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralLinearAction {
    fn destabilizing_load(&self) -> bool {
        self.destabilizing_load
    }
    fn caused_by(&self) -> &Option<EntityRef> {
        &self.caused_by
    }
}
impl IIfcStructuralLinearAction for IfcStructuralLinearAction {
    fn projected_or_true(&self) -> &IfcProjectedOrTrueLengthEnum {
        &self.projected_or_true
    }
}
impl IfcStructuralLinearAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLinearAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.destabilizing_load = parameter.into(),
                10usize => {
                    entity.caused_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.projected_or_true = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLinearActionVarying: IIfcStructuralLinearAction {
    fn varying_applied_load_location(&self) -> &EntityRef;
    fn subsequent_applied_loads(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLinearActionVarying {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: bool,
    caused_by: Option<EntityRef>,
    projected_or_true: IfcProjectedOrTrueLengthEnum,
    varying_applied_load_location: EntityRef,
    subsequent_applied_loads: Vec<EntityRef>,
}
impl IIfcRoot for IfcStructuralLinearActionVarying {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralLinearActionVarying {}
impl IIfcObject for IfcStructuralLinearActionVarying {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralLinearActionVarying {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralLinearActionVarying {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralLinearActionVarying {
    fn destabilizing_load(&self) -> bool {
        self.destabilizing_load
    }
    fn caused_by(&self) -> &Option<EntityRef> {
        &self.caused_by
    }
}
impl IIfcStructuralLinearAction for IfcStructuralLinearActionVarying {
    fn projected_or_true(&self) -> &IfcProjectedOrTrueLengthEnum {
        &self.projected_or_true
    }
}
impl IIfcStructuralLinearActionVarying for IfcStructuralLinearActionVarying {
    fn varying_applied_load_location(&self) -> &EntityRef {
        &self.varying_applied_load_location
    }
    fn subsequent_applied_loads(&self) -> &Vec<EntityRef> {
        &self.subsequent_applied_loads
    }
}
impl IfcStructuralLinearActionVarying {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLinearActionVarying::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.destabilizing_load = parameter.into(),
                10usize => {
                    entity.caused_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.projected_or_true = parameter.into(),
                12usize => entity.varying_applied_load_location = parameter.into(),
                13usize => entity.subsequent_applied_loads = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoad {
    fn name(&self) -> &Option<IfcLabel>;
}
pub trait IIfcStructuralLoadGroup: IIfcGroup {
    fn predefined_type(&self) -> &IfcLoadGroupTypeEnum;
    fn action_type(&self) -> &IfcActionTypeEnum;
    fn action_source(&self) -> &IfcActionSourceTypeEnum;
    fn coefficient(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn purpose(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    predefined_type: IfcLoadGroupTypeEnum,
    action_type: IfcActionTypeEnum,
    action_source: IfcActionSourceTypeEnum,
    coefficient: Option<IfcPositiveRatioMeasure>,
    purpose: Option<IfcLabel>,
}
impl IIfcRoot for IfcStructuralLoadGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralLoadGroup {}
impl IIfcObject for IfcStructuralLoadGroup {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralLoadGroup {}
impl IIfcStructuralLoadGroup for IfcStructuralLoadGroup {
    fn predefined_type(&self) -> &IfcLoadGroupTypeEnum {
        &self.predefined_type
    }
    fn action_type(&self) -> &IfcActionTypeEnum {
        &self.action_type
    }
    fn action_source(&self) -> &IfcActionSourceTypeEnum {
        &self.action_source
    }
    fn coefficient(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.coefficient
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
}
impl IfcStructuralLoadGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.predefined_type = parameter.into(),
                6usize => entity.action_type = parameter.into(),
                7usize => entity.action_source = parameter.into(),
                8usize => {
                    entity.coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadLinearForce: IIfcStructuralLoadStatic {
    fn linear_force_x(&self) -> &Option<IfcLinearForceMeasure>;
    fn linear_force_y(&self) -> &Option<IfcLinearForceMeasure>;
    fn linear_force_z(&self) -> &Option<IfcLinearForceMeasure>;
    fn linear_moment_x(&self) -> &Option<IfcLinearMomentMeasure>;
    fn linear_moment_y(&self) -> &Option<IfcLinearMomentMeasure>;
    fn linear_moment_z(&self) -> &Option<IfcLinearMomentMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadLinearForce {
    name: Option<IfcLabel>,
    linear_force_x: Option<IfcLinearForceMeasure>,
    linear_force_y: Option<IfcLinearForceMeasure>,
    linear_force_z: Option<IfcLinearForceMeasure>,
    linear_moment_x: Option<IfcLinearMomentMeasure>,
    linear_moment_y: Option<IfcLinearMomentMeasure>,
    linear_moment_z: Option<IfcLinearMomentMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadLinearForce {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadLinearForce {}
impl IIfcStructuralLoadLinearForce for IfcStructuralLoadLinearForce {
    fn linear_force_x(&self) -> &Option<IfcLinearForceMeasure> {
        &self.linear_force_x
    }
    fn linear_force_y(&self) -> &Option<IfcLinearForceMeasure> {
        &self.linear_force_y
    }
    fn linear_force_z(&self) -> &Option<IfcLinearForceMeasure> {
        &self.linear_force_z
    }
    fn linear_moment_x(&self) -> &Option<IfcLinearMomentMeasure> {
        &self.linear_moment_x
    }
    fn linear_moment_y(&self) -> &Option<IfcLinearMomentMeasure> {
        &self.linear_moment_y
    }
    fn linear_moment_z(&self) -> &Option<IfcLinearMomentMeasure> {
        &self.linear_moment_z
    }
}
impl IfcStructuralLoadLinearForce {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadLinearForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.linear_force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.linear_force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.linear_force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.linear_moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.linear_moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.linear_moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadPlanarForce: IIfcStructuralLoadStatic {
    fn planar_force_x(&self) -> &Option<IfcPlanarForceMeasure>;
    fn planar_force_y(&self) -> &Option<IfcPlanarForceMeasure>;
    fn planar_force_z(&self) -> &Option<IfcPlanarForceMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadPlanarForce {
    name: Option<IfcLabel>,
    planar_force_x: Option<IfcPlanarForceMeasure>,
    planar_force_y: Option<IfcPlanarForceMeasure>,
    planar_force_z: Option<IfcPlanarForceMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadPlanarForce {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadPlanarForce {}
impl IIfcStructuralLoadPlanarForce for IfcStructuralLoadPlanarForce {
    fn planar_force_x(&self) -> &Option<IfcPlanarForceMeasure> {
        &self.planar_force_x
    }
    fn planar_force_y(&self) -> &Option<IfcPlanarForceMeasure> {
        &self.planar_force_y
    }
    fn planar_force_z(&self) -> &Option<IfcPlanarForceMeasure> {
        &self.planar_force_z
    }
}
impl IfcStructuralLoadPlanarForce {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadPlanarForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.planar_force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.planar_force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.planar_force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleDisplacement: IIfcStructuralLoadStatic {
    fn displacement_x(&self) -> &Option<IfcLengthMeasure>;
    fn displacement_y(&self) -> &Option<IfcLengthMeasure>;
    fn displacement_z(&self) -> &Option<IfcLengthMeasure>;
    fn rotational_displacement_rx(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn rotational_displacement_ry(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn rotational_displacement_rz(&self) -> &Option<IfcPlaneAngleMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleDisplacement {
    name: Option<IfcLabel>,
    displacement_x: Option<IfcLengthMeasure>,
    displacement_y: Option<IfcLengthMeasure>,
    displacement_z: Option<IfcLengthMeasure>,
    rotational_displacement_rx: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_ry: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_rz: Option<IfcPlaneAngleMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleDisplacement {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleDisplacement {}
impl IIfcStructuralLoadSingleDisplacement for IfcStructuralLoadSingleDisplacement {
    fn displacement_x(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_x
    }
    fn displacement_y(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_y
    }
    fn displacement_z(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_z
    }
    fn rotational_displacement_rx(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rx
    }
    fn rotational_displacement_ry(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_ry
    }
    fn rotational_displacement_rz(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rz
    }
}
impl IfcStructuralLoadSingleDisplacement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleDisplacement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.displacement_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.displacement_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.displacement_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_displacement_rx = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_displacement_ry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_displacement_rz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleDisplacementDistortion: IIfcStructuralLoadSingleDisplacement {
    fn distortion(&self) -> &Option<IfcCurvatureMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleDisplacementDistortion {
    name: Option<IfcLabel>,
    displacement_x: Option<IfcLengthMeasure>,
    displacement_y: Option<IfcLengthMeasure>,
    displacement_z: Option<IfcLengthMeasure>,
    rotational_displacement_rx: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_ry: Option<IfcPlaneAngleMeasure>,
    rotational_displacement_rz: Option<IfcPlaneAngleMeasure>,
    distortion: Option<IfcCurvatureMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleDisplacementDistortion {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleDisplacementDistortion {}
impl IIfcStructuralLoadSingleDisplacement for IfcStructuralLoadSingleDisplacementDistortion {
    fn displacement_x(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_x
    }
    fn displacement_y(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_y
    }
    fn displacement_z(&self) -> &Option<IfcLengthMeasure> {
        &self.displacement_z
    }
    fn rotational_displacement_rx(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rx
    }
    fn rotational_displacement_ry(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_ry
    }
    fn rotational_displacement_rz(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.rotational_displacement_rz
    }
}
impl IIfcStructuralLoadSingleDisplacementDistortion for IfcStructuralLoadSingleDisplacementDistortion {
    fn distortion(&self) -> &Option<IfcCurvatureMeasure> {
        &self.distortion
    }
}
impl IfcStructuralLoadSingleDisplacementDistortion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleDisplacementDistortion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.displacement_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.displacement_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.displacement_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.rotational_displacement_rx = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.rotational_displacement_ry = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.rotational_displacement_rz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.distortion = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleForce: IIfcStructuralLoadStatic {
    fn force_x(&self) -> &Option<IfcForceMeasure>;
    fn force_y(&self) -> &Option<IfcForceMeasure>;
    fn force_z(&self) -> &Option<IfcForceMeasure>;
    fn moment_x(&self) -> &Option<IfcTorqueMeasure>;
    fn moment_y(&self) -> &Option<IfcTorqueMeasure>;
    fn moment_z(&self) -> &Option<IfcTorqueMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleForce {
    name: Option<IfcLabel>,
    force_x: Option<IfcForceMeasure>,
    force_y: Option<IfcForceMeasure>,
    force_z: Option<IfcForceMeasure>,
    moment_x: Option<IfcTorqueMeasure>,
    moment_y: Option<IfcTorqueMeasure>,
    moment_z: Option<IfcTorqueMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleForce {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleForce {}
impl IIfcStructuralLoadSingleForce for IfcStructuralLoadSingleForce {
    fn force_x(&self) -> &Option<IfcForceMeasure> {
        &self.force_x
    }
    fn force_y(&self) -> &Option<IfcForceMeasure> {
        &self.force_y
    }
    fn force_z(&self) -> &Option<IfcForceMeasure> {
        &self.force_z
    }
    fn moment_x(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_x
    }
    fn moment_y(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_y
    }
    fn moment_z(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_z
    }
}
impl IfcStructuralLoadSingleForce {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleForce::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadSingleForceWarping: IIfcStructuralLoadSingleForce {
    fn warping_moment(&self) -> &Option<IfcWarpingMomentMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadSingleForceWarping {
    name: Option<IfcLabel>,
    force_x: Option<IfcForceMeasure>,
    force_y: Option<IfcForceMeasure>,
    force_z: Option<IfcForceMeasure>,
    moment_x: Option<IfcTorqueMeasure>,
    moment_y: Option<IfcTorqueMeasure>,
    moment_z: Option<IfcTorqueMeasure>,
    warping_moment: Option<IfcWarpingMomentMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadSingleForceWarping {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadSingleForceWarping {}
impl IIfcStructuralLoadSingleForce for IfcStructuralLoadSingleForceWarping {
    fn force_x(&self) -> &Option<IfcForceMeasure> {
        &self.force_x
    }
    fn force_y(&self) -> &Option<IfcForceMeasure> {
        &self.force_y
    }
    fn force_z(&self) -> &Option<IfcForceMeasure> {
        &self.force_z
    }
    fn moment_x(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_x
    }
    fn moment_y(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_y
    }
    fn moment_z(&self) -> &Option<IfcTorqueMeasure> {
        &self.moment_z
    }
}
impl IIfcStructuralLoadSingleForceWarping for IfcStructuralLoadSingleForceWarping {
    fn warping_moment(&self) -> &Option<IfcWarpingMomentMeasure> {
        &self.warping_moment
    }
}
impl IfcStructuralLoadSingleForceWarping {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadSingleForceWarping::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.force_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.force_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.force_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.moment_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.moment_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.moment_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.warping_moment = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralLoadStatic: IIfcStructuralLoad {}
pub trait IIfcStructuralLoadTemperature: IIfcStructuralLoadStatic {
    fn delta_t_constant(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn delta_t_y(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn delta_t_z(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralLoadTemperature {
    name: Option<IfcLabel>,
    delta_t_constant: Option<IfcThermodynamicTemperatureMeasure>,
    delta_t_y: Option<IfcThermodynamicTemperatureMeasure>,
    delta_t_z: Option<IfcThermodynamicTemperatureMeasure>,
}
impl IIfcStructuralLoad for IfcStructuralLoadTemperature {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcStructuralLoadStatic for IfcStructuralLoadTemperature {}
impl IIfcStructuralLoadTemperature for IfcStructuralLoadTemperature {
    fn delta_t_constant(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.delta_t_constant
    }
    fn delta_t_y(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.delta_t_y
    }
    fn delta_t_z(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.delta_t_z
    }
}
impl IfcStructuralLoadTemperature {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralLoadTemperature::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.delta_t_constant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.delta_t_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.delta_t_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralMember: IIfcStructuralItem {}
pub trait IIfcStructuralPlanarAction: IIfcStructuralAction {
    fn projected_or_true(&self) -> &IfcProjectedOrTrueLengthEnum;
}
#[derive(Default, Debug)]
pub struct IfcStructuralPlanarAction {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: bool,
    caused_by: Option<EntityRef>,
    projected_or_true: IfcProjectedOrTrueLengthEnum,
}
impl IIfcRoot for IfcStructuralPlanarAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPlanarAction {}
impl IIfcObject for IfcStructuralPlanarAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPlanarAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPlanarAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralPlanarAction {
    fn destabilizing_load(&self) -> bool {
        self.destabilizing_load
    }
    fn caused_by(&self) -> &Option<EntityRef> {
        &self.caused_by
    }
}
impl IIfcStructuralPlanarAction for IfcStructuralPlanarAction {
    fn projected_or_true(&self) -> &IfcProjectedOrTrueLengthEnum {
        &self.projected_or_true
    }
}
impl IfcStructuralPlanarAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPlanarAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.destabilizing_load = parameter.into(),
                10usize => {
                    entity.caused_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.projected_or_true = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPlanarActionVarying: IIfcStructuralPlanarAction {
    fn varying_applied_load_location(&self) -> &EntityRef;
    fn subsequent_applied_loads(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralPlanarActionVarying {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: bool,
    caused_by: Option<EntityRef>,
    projected_or_true: IfcProjectedOrTrueLengthEnum,
    varying_applied_load_location: EntityRef,
    subsequent_applied_loads: Vec<EntityRef>,
}
impl IIfcRoot for IfcStructuralPlanarActionVarying {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPlanarActionVarying {}
impl IIfcObject for IfcStructuralPlanarActionVarying {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPlanarActionVarying {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPlanarActionVarying {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralPlanarActionVarying {
    fn destabilizing_load(&self) -> bool {
        self.destabilizing_load
    }
    fn caused_by(&self) -> &Option<EntityRef> {
        &self.caused_by
    }
}
impl IIfcStructuralPlanarAction for IfcStructuralPlanarActionVarying {
    fn projected_or_true(&self) -> &IfcProjectedOrTrueLengthEnum {
        &self.projected_or_true
    }
}
impl IIfcStructuralPlanarActionVarying for IfcStructuralPlanarActionVarying {
    fn varying_applied_load_location(&self) -> &EntityRef {
        &self.varying_applied_load_location
    }
    fn subsequent_applied_loads(&self) -> &Vec<EntityRef> {
        &self.subsequent_applied_loads
    }
}
impl IfcStructuralPlanarActionVarying {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPlanarActionVarying::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.destabilizing_load = parameter.into(),
                10usize => {
                    entity.caused_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.projected_or_true = parameter.into(),
                12usize => entity.varying_applied_load_location = parameter.into(),
                13usize => entity.subsequent_applied_loads = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPointAction: IIfcStructuralAction {}
#[derive(Default, Debug)]
pub struct IfcStructuralPointAction {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
    destabilizing_load: bool,
    caused_by: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralPointAction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPointAction {}
impl IIfcObject for IfcStructuralPointAction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPointAction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPointAction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralAction for IfcStructuralPointAction {
    fn destabilizing_load(&self) -> bool {
        self.destabilizing_load
    }
    fn caused_by(&self) -> &Option<EntityRef> {
        &self.caused_by
    }
}
impl IIfcStructuralPointAction for IfcStructuralPointAction {}
impl IfcStructuralPointAction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointAction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                9usize => entity.destabilizing_load = parameter.into(),
                10usize => {
                    entity.caused_by = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPointConnection: IIfcStructuralConnection {}
#[derive(Default, Debug)]
pub struct IfcStructuralPointConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_condition: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralPointConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPointConnection {}
impl IIfcObject for IfcStructuralPointConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPointConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralPointConnection {}
impl IIfcStructuralConnection for IfcStructuralPointConnection {
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
}
impl IIfcStructuralPointConnection for IfcStructuralPointConnection {}
impl IfcStructuralPointConnection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralPointReaction: IIfcStructuralReaction {}
#[derive(Default, Debug)]
pub struct IfcStructuralPointReaction {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_load: EntityRef,
    global_or_local: IfcGlobalOrLocalEnum,
}
impl IIfcRoot for IfcStructuralPointReaction {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralPointReaction {}
impl IIfcObject for IfcStructuralPointReaction {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralPointReaction {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralActivity for IfcStructuralPointReaction {
    fn applied_load(&self) -> &EntityRef {
        &self.applied_load
    }
    fn global_or_local(&self) -> &IfcGlobalOrLocalEnum {
        &self.global_or_local
    }
}
impl IIfcStructuralReaction for IfcStructuralPointReaction {}
impl IIfcStructuralPointReaction for IfcStructuralPointReaction {}
impl IfcStructuralPointReaction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralPointReaction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.applied_load = parameter.into(),
                8usize => entity.global_or_local = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralProfileProperties: IIfcGeneralProfileProperties {
    fn torsional_constant_x(&self) -> &Option<IfcMomentOfInertiaMeasure>;
    fn moment_of_inertia_yz(&self) -> &Option<IfcMomentOfInertiaMeasure>;
    fn moment_of_inertia_y(&self) -> &Option<IfcMomentOfInertiaMeasure>;
    fn moment_of_inertia_z(&self) -> &Option<IfcMomentOfInertiaMeasure>;
    fn warping_constant(&self) -> &Option<IfcWarpingConstantMeasure>;
    fn shear_centre_z(&self) -> &Option<IfcLengthMeasure>;
    fn shear_centre_y(&self) -> &Option<IfcLengthMeasure>;
    fn shear_deformation_area_z(&self) -> &Option<IfcAreaMeasure>;
    fn shear_deformation_area_y(&self) -> &Option<IfcAreaMeasure>;
    fn maximum_section_modulus_y(&self) -> &Option<IfcSectionModulusMeasure>;
    fn minimum_section_modulus_y(&self) -> &Option<IfcSectionModulusMeasure>;
    fn maximum_section_modulus_z(&self) -> &Option<IfcSectionModulusMeasure>;
    fn minimum_section_modulus_z(&self) -> &Option<IfcSectionModulusMeasure>;
    fn torsional_section_modulus(&self) -> &Option<IfcSectionModulusMeasure>;
    fn centre_of_gravity_in_x(&self) -> &Option<IfcLengthMeasure>;
    fn centre_of_gravity_in_y(&self) -> &Option<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralProfileProperties {
    profile_name: Option<IfcLabel>,
    profile_definition: Option<EntityRef>,
    physical_weight: Option<IfcMassPerLengthMeasure>,
    perimeter: Option<IfcPositiveLengthMeasure>,
    minimum_plate_thickness: Option<IfcPositiveLengthMeasure>,
    maximum_plate_thickness: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
    torsional_constant_x: Option<IfcMomentOfInertiaMeasure>,
    moment_of_inertia_yz: Option<IfcMomentOfInertiaMeasure>,
    moment_of_inertia_y: Option<IfcMomentOfInertiaMeasure>,
    moment_of_inertia_z: Option<IfcMomentOfInertiaMeasure>,
    warping_constant: Option<IfcWarpingConstantMeasure>,
    shear_centre_z: Option<IfcLengthMeasure>,
    shear_centre_y: Option<IfcLengthMeasure>,
    shear_deformation_area_z: Option<IfcAreaMeasure>,
    shear_deformation_area_y: Option<IfcAreaMeasure>,
    maximum_section_modulus_y: Option<IfcSectionModulusMeasure>,
    minimum_section_modulus_y: Option<IfcSectionModulusMeasure>,
    maximum_section_modulus_z: Option<IfcSectionModulusMeasure>,
    minimum_section_modulus_z: Option<IfcSectionModulusMeasure>,
    torsional_section_modulus: Option<IfcSectionModulusMeasure>,
    centre_of_gravity_in_x: Option<IfcLengthMeasure>,
    centre_of_gravity_in_y: Option<IfcLengthMeasure>,
}
impl IIfcProfileProperties for IfcStructuralProfileProperties {
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
    fn profile_definition(&self) -> &Option<EntityRef> {
        &self.profile_definition
    }
}
impl IIfcGeneralProfileProperties for IfcStructuralProfileProperties {
    fn physical_weight(&self) -> &Option<IfcMassPerLengthMeasure> {
        &self.physical_weight
    }
    fn perimeter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.perimeter
    }
    fn minimum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.minimum_plate_thickness
    }
    fn maximum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.maximum_plate_thickness
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
}
impl IIfcStructuralProfileProperties for IfcStructuralProfileProperties {
    fn torsional_constant_x(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.torsional_constant_x
    }
    fn moment_of_inertia_yz(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.moment_of_inertia_yz
    }
    fn moment_of_inertia_y(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.moment_of_inertia_y
    }
    fn moment_of_inertia_z(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.moment_of_inertia_z
    }
    fn warping_constant(&self) -> &Option<IfcWarpingConstantMeasure> {
        &self.warping_constant
    }
    fn shear_centre_z(&self) -> &Option<IfcLengthMeasure> {
        &self.shear_centre_z
    }
    fn shear_centre_y(&self) -> &Option<IfcLengthMeasure> {
        &self.shear_centre_y
    }
    fn shear_deformation_area_z(&self) -> &Option<IfcAreaMeasure> {
        &self.shear_deformation_area_z
    }
    fn shear_deformation_area_y(&self) -> &Option<IfcAreaMeasure> {
        &self.shear_deformation_area_y
    }
    fn maximum_section_modulus_y(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.maximum_section_modulus_y
    }
    fn minimum_section_modulus_y(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.minimum_section_modulus_y
    }
    fn maximum_section_modulus_z(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.maximum_section_modulus_z
    }
    fn minimum_section_modulus_z(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.minimum_section_modulus_z
    }
    fn torsional_section_modulus(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.torsional_section_modulus
    }
    fn centre_of_gravity_in_x(&self) -> &Option<IfcLengthMeasure> {
        &self.centre_of_gravity_in_x
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IfcStructuralProfileProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.profile_definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.physical_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.perimeter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.minimum_plate_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.maximum_plate_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.torsional_constant_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.moment_of_inertia_yz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.moment_of_inertia_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.moment_of_inertia_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.warping_constant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.shear_centre_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.shear_centre_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.shear_deformation_area_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.shear_deformation_area_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.maximum_section_modulus_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.minimum_section_modulus_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.maximum_section_modulus_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                19usize => {
                    entity.minimum_section_modulus_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                20usize => {
                    entity.torsional_section_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                21usize => {
                    entity.centre_of_gravity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                22usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralReaction: IIfcStructuralActivity {}
pub trait IIfcStructuralResultGroup: IIfcGroup {
    fn theory_type(&self) -> &IfcAnalysisTheoryTypeEnum;
    fn result_for_load_group(&self) -> &Option<EntityRef>;
    fn is_linear(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcStructuralResultGroup {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    theory_type: IfcAnalysisTheoryTypeEnum,
    result_for_load_group: Option<EntityRef>,
    is_linear: bool,
}
impl IIfcRoot for IfcStructuralResultGroup {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralResultGroup {}
impl IIfcObject for IfcStructuralResultGroup {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcStructuralResultGroup {}
impl IIfcStructuralResultGroup for IfcStructuralResultGroup {
    fn theory_type(&self) -> &IfcAnalysisTheoryTypeEnum {
        &self.theory_type
    }
    fn result_for_load_group(&self) -> &Option<EntityRef> {
        &self.result_for_load_group
    }
    fn is_linear(&self) -> bool {
        self.is_linear
    }
}
impl IfcStructuralResultGroup {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralResultGroup::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.theory_type = parameter.into(),
                6usize => {
                    entity.result_for_load_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.is_linear = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSteelProfileProperties: IIfcStructuralProfileProperties {
    fn shear_area_z(&self) -> &Option<IfcAreaMeasure>;
    fn shear_area_y(&self) -> &Option<IfcAreaMeasure>;
    fn plastic_shape_factor_y(&self) -> &Option<IfcPositiveRatioMeasure>;
    fn plastic_shape_factor_z(&self) -> &Option<IfcPositiveRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralSteelProfileProperties {
    profile_name: Option<IfcLabel>,
    profile_definition: Option<EntityRef>,
    physical_weight: Option<IfcMassPerLengthMeasure>,
    perimeter: Option<IfcPositiveLengthMeasure>,
    minimum_plate_thickness: Option<IfcPositiveLengthMeasure>,
    maximum_plate_thickness: Option<IfcPositiveLengthMeasure>,
    cross_section_area: Option<IfcAreaMeasure>,
    torsional_constant_x: Option<IfcMomentOfInertiaMeasure>,
    moment_of_inertia_yz: Option<IfcMomentOfInertiaMeasure>,
    moment_of_inertia_y: Option<IfcMomentOfInertiaMeasure>,
    moment_of_inertia_z: Option<IfcMomentOfInertiaMeasure>,
    warping_constant: Option<IfcWarpingConstantMeasure>,
    shear_centre_z: Option<IfcLengthMeasure>,
    shear_centre_y: Option<IfcLengthMeasure>,
    shear_deformation_area_z: Option<IfcAreaMeasure>,
    shear_deformation_area_y: Option<IfcAreaMeasure>,
    maximum_section_modulus_y: Option<IfcSectionModulusMeasure>,
    minimum_section_modulus_y: Option<IfcSectionModulusMeasure>,
    maximum_section_modulus_z: Option<IfcSectionModulusMeasure>,
    minimum_section_modulus_z: Option<IfcSectionModulusMeasure>,
    torsional_section_modulus: Option<IfcSectionModulusMeasure>,
    centre_of_gravity_in_x: Option<IfcLengthMeasure>,
    centre_of_gravity_in_y: Option<IfcLengthMeasure>,
    shear_area_z: Option<IfcAreaMeasure>,
    shear_area_y: Option<IfcAreaMeasure>,
    plastic_shape_factor_y: Option<IfcPositiveRatioMeasure>,
    plastic_shape_factor_z: Option<IfcPositiveRatioMeasure>,
}
impl IIfcProfileProperties for IfcStructuralSteelProfileProperties {
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
    fn profile_definition(&self) -> &Option<EntityRef> {
        &self.profile_definition
    }
}
impl IIfcGeneralProfileProperties for IfcStructuralSteelProfileProperties {
    fn physical_weight(&self) -> &Option<IfcMassPerLengthMeasure> {
        &self.physical_weight
    }
    fn perimeter(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.perimeter
    }
    fn minimum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.minimum_plate_thickness
    }
    fn maximum_plate_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.maximum_plate_thickness
    }
    fn cross_section_area(&self) -> &Option<IfcAreaMeasure> {
        &self.cross_section_area
    }
}
impl IIfcStructuralProfileProperties for IfcStructuralSteelProfileProperties {
    fn torsional_constant_x(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.torsional_constant_x
    }
    fn moment_of_inertia_yz(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.moment_of_inertia_yz
    }
    fn moment_of_inertia_y(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.moment_of_inertia_y
    }
    fn moment_of_inertia_z(&self) -> &Option<IfcMomentOfInertiaMeasure> {
        &self.moment_of_inertia_z
    }
    fn warping_constant(&self) -> &Option<IfcWarpingConstantMeasure> {
        &self.warping_constant
    }
    fn shear_centre_z(&self) -> &Option<IfcLengthMeasure> {
        &self.shear_centre_z
    }
    fn shear_centre_y(&self) -> &Option<IfcLengthMeasure> {
        &self.shear_centre_y
    }
    fn shear_deformation_area_z(&self) -> &Option<IfcAreaMeasure> {
        &self.shear_deformation_area_z
    }
    fn shear_deformation_area_y(&self) -> &Option<IfcAreaMeasure> {
        &self.shear_deformation_area_y
    }
    fn maximum_section_modulus_y(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.maximum_section_modulus_y
    }
    fn minimum_section_modulus_y(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.minimum_section_modulus_y
    }
    fn maximum_section_modulus_z(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.maximum_section_modulus_z
    }
    fn minimum_section_modulus_z(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.minimum_section_modulus_z
    }
    fn torsional_section_modulus(&self) -> &Option<IfcSectionModulusMeasure> {
        &self.torsional_section_modulus
    }
    fn centre_of_gravity_in_x(&self) -> &Option<IfcLengthMeasure> {
        &self.centre_of_gravity_in_x
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IIfcStructuralSteelProfileProperties for IfcStructuralSteelProfileProperties {
    fn shear_area_z(&self) -> &Option<IfcAreaMeasure> {
        &self.shear_area_z
    }
    fn shear_area_y(&self) -> &Option<IfcAreaMeasure> {
        &self.shear_area_y
    }
    fn plastic_shape_factor_y(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.plastic_shape_factor_y
    }
    fn plastic_shape_factor_z(&self) -> &Option<IfcPositiveRatioMeasure> {
        &self.plastic_shape_factor_z
    }
}
impl IfcStructuralSteelProfileProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSteelProfileProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.profile_definition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.physical_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.perimeter = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.minimum_plate_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.maximum_plate_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.cross_section_area = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.torsional_constant_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.moment_of_inertia_yz = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.moment_of_inertia_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.moment_of_inertia_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.warping_constant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.shear_centre_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.shear_centre_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.shear_deformation_area_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.shear_deformation_area_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.maximum_section_modulus_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                17usize => {
                    entity.minimum_section_modulus_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                18usize => {
                    entity.maximum_section_modulus_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                19usize => {
                    entity.minimum_section_modulus_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                20usize => {
                    entity.torsional_section_modulus = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                21usize => {
                    entity.centre_of_gravity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                22usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                23usize => {
                    entity.shear_area_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                24usize => {
                    entity.shear_area_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                25usize => {
                    entity.plastic_shape_factor_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                26usize => {
                    entity.plastic_shape_factor_z = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceConnection: IIfcStructuralConnection {}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceConnection {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    applied_condition: Option<EntityRef>,
}
impl IIfcRoot for IfcStructuralSurfaceConnection {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceConnection {}
impl IIfcObject for IfcStructuralSurfaceConnection {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceConnection {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralSurfaceConnection {}
impl IIfcStructuralConnection for IfcStructuralSurfaceConnection {
    fn applied_condition(&self) -> &Option<EntityRef> {
        &self.applied_condition
    }
}
impl IIfcStructuralSurfaceConnection for IfcStructuralSurfaceConnection {}
impl IfcStructuralSurfaceConnection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceConnection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.applied_condition = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceMember: IIfcStructuralMember {
    fn predefined_type(&self) -> &IfcStructuralSurfaceTypeEnum;
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceMember {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralSurfaceTypeEnum,
    thickness: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcStructuralSurfaceMember {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceMember {}
impl IIfcObject for IfcStructuralSurfaceMember {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceMember {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralSurfaceMember {}
impl IIfcStructuralMember for IfcStructuralSurfaceMember {}
impl IIfcStructuralSurfaceMember for IfcStructuralSurfaceMember {
    fn predefined_type(&self) -> &IfcStructuralSurfaceTypeEnum {
        &self.predefined_type
    }
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.thickness
    }
}
impl IfcStructuralSurfaceMember {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceMember::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                8usize => {
                    entity.thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuralSurfaceMemberVarying: IIfcStructuralSurfaceMember {
    fn subsequent_thickness(&self) -> &Vec<IfcPositiveLengthMeasure>;
    fn varying_thickness_location(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcStructuralSurfaceMemberVarying {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    predefined_type: IfcStructuralSurfaceTypeEnum,
    thickness: Option<IfcPositiveLengthMeasure>,
    subsequent_thickness: Vec<IfcPositiveLengthMeasure>,
    varying_thickness_location: EntityRef,
}
impl IIfcRoot for IfcStructuralSurfaceMemberVarying {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcStructuralSurfaceMemberVarying {}
impl IIfcObject for IfcStructuralSurfaceMemberVarying {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcStructuralSurfaceMemberVarying {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcStructuralItem for IfcStructuralSurfaceMemberVarying {}
impl IIfcStructuralMember for IfcStructuralSurfaceMemberVarying {}
impl IIfcStructuralSurfaceMember for IfcStructuralSurfaceMemberVarying {
    fn predefined_type(&self) -> &IfcStructuralSurfaceTypeEnum {
        &self.predefined_type
    }
    fn thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.thickness
    }
}
impl IIfcStructuralSurfaceMemberVarying for IfcStructuralSurfaceMemberVarying {
    fn subsequent_thickness(&self) -> &Vec<IfcPositiveLengthMeasure> {
        &self.subsequent_thickness
    }
    fn varying_thickness_location(&self) -> &EntityRef {
        &self.varying_thickness_location
    }
}
impl IfcStructuralSurfaceMemberVarying {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuralSurfaceMemberVarying::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => entity.predefined_type = parameter.into(),
                8usize => {
                    entity.thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.subsequent_thickness = parameter.into(),
                10usize => entity.varying_thickness_location = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStructuredDimensionCallout: IIfcDraughtingCallout {}
#[derive(Default, Debug)]
pub struct IfcStructuredDimensionCallout {
    contents: HashSet<EntityRef>,
}
impl IIfcRepresentationItem for IfcStructuredDimensionCallout {}
impl IIfcGeometricRepresentationItem for IfcStructuredDimensionCallout {}
impl IIfcDraughtingCallout for IfcStructuredDimensionCallout {
    fn contents(&self) -> &HashSet<EntityRef> {
        &self.contents
    }
}
impl IIfcStructuredDimensionCallout for IfcStructuredDimensionCallout {}
impl IfcStructuredDimensionCallout {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStructuredDimensionCallout::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.contents = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStyleModel: IIfcRepresentation {}
pub trait IIfcStyledItem: IIfcRepresentationItem {
    fn item(&self) -> &Option<EntityRef>;
    fn styles(&self) -> &HashSet<EntityRef>;
    fn name(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcStyledItem {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
}
impl IIfcRepresentationItem for IfcStyledItem {}
impl IIfcStyledItem for IfcStyledItem {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IfcStyledItem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStyledItem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcStyledRepresentation: IIfcStyleModel {}
#[derive(Default, Debug)]
pub struct IfcStyledRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcStyledRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IIfcStyleModel for IfcStyledRepresentation {}
impl IIfcStyledRepresentation for IfcStyledRepresentation {}
impl IfcStyledRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcStyledRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSubContractResource: IIfcConstructionResource {
    fn sub_contractor(&self) -> &Option<EntityRef>;
    fn job_description(&self) -> &Option<IfcText>;
}
#[derive(Default, Debug)]
pub struct IfcSubContractResource {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    resource_identifier: Option<IfcIdentifier>,
    resource_group: Option<IfcLabel>,
    resource_consumption: Option<IfcResourceConsumptionEnum>,
    base_quantity: Option<EntityRef>,
    sub_contractor: Option<EntityRef>,
    job_description: Option<IfcText>,
}
impl IIfcRoot for IfcSubContractResource {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSubContractResource {}
impl IIfcObject for IfcSubContractResource {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcResource for IfcSubContractResource {}
impl IIfcConstructionResource for IfcSubContractResource {
    fn resource_identifier(&self) -> &Option<IfcIdentifier> {
        &self.resource_identifier
    }
    fn resource_group(&self) -> &Option<IfcLabel> {
        &self.resource_group
    }
    fn resource_consumption(&self) -> &Option<IfcResourceConsumptionEnum> {
        &self.resource_consumption
    }
    fn base_quantity(&self) -> &Option<EntityRef> {
        &self.base_quantity
    }
}
impl IIfcSubContractResource for IfcSubContractResource {
    fn sub_contractor(&self) -> &Option<EntityRef> {
        &self.sub_contractor
    }
    fn job_description(&self) -> &Option<IfcText> {
        &self.job_description
    }
}
impl IfcSubContractResource {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubContractResource::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.resource_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.resource_group = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.resource_consumption = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.base_quantity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.sub_contractor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.job_description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSubedge: IIfcEdge {
    fn parent_edge(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSubedge {
    edge_start: EntityRef,
    edge_end: EntityRef,
    parent_edge: EntityRef,
}
impl IIfcRepresentationItem for IfcSubedge {}
impl IIfcTopologicalRepresentationItem for IfcSubedge {}
impl IIfcEdge for IfcSubedge {
    fn edge_start(&self) -> &EntityRef {
        &self.edge_start
    }
    fn edge_end(&self) -> &EntityRef {
        &self.edge_end
    }
}
impl IIfcSubedge for IfcSubedge {
    fn parent_edge(&self) -> &EntityRef {
        &self.parent_edge
    }
}
impl IfcSubedge {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSubedge::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.edge_start = parameter.into(),
                1usize => entity.edge_end = parameter.into(),
                2usize => entity.parent_edge = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurface: IIfcGeometricRepresentationItem {}
pub trait IIfcSurfaceCurveSweptAreaSolid: IIfcSweptAreaSolid {
    fn directrix(&self) -> &EntityRef;
    fn start_param(&self) -> &IfcParameterValue;
    fn end_param(&self) -> &IfcParameterValue;
    fn reference_surface(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceCurveSweptAreaSolid {
    swept_area: EntityRef,
    position: EntityRef,
    directrix: EntityRef,
    start_param: IfcParameterValue,
    end_param: IfcParameterValue,
    reference_surface: EntityRef,
}
impl IIfcRepresentationItem for IfcSurfaceCurveSweptAreaSolid {}
impl IIfcGeometricRepresentationItem for IfcSurfaceCurveSweptAreaSolid {}
impl IIfcSolidModel for IfcSurfaceCurveSweptAreaSolid {}
impl IIfcSweptAreaSolid for IfcSurfaceCurveSweptAreaSolid {
    fn swept_area(&self) -> &EntityRef {
        &self.swept_area
    }
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcSurfaceCurveSweptAreaSolid for IfcSurfaceCurveSweptAreaSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn start_param(&self) -> &IfcParameterValue {
        &self.start_param
    }
    fn end_param(&self) -> &IfcParameterValue {
        &self.end_param
    }
    fn reference_surface(&self) -> &EntityRef {
        &self.reference_surface
    }
}
impl IfcSurfaceCurveSweptAreaSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceCurveSweptAreaSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_area = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.directrix = parameter.into(),
                3usize => entity.start_param = parameter.into(),
                4usize => entity.end_param = parameter.into(),
                5usize => entity.reference_surface = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceOfLinearExtrusion: IIfcSweptSurface {
    fn extruded_direction(&self) -> &EntityRef;
    fn depth(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceOfLinearExtrusion {
    swept_curve: EntityRef,
    position: EntityRef,
    extruded_direction: EntityRef,
    depth: IfcLengthMeasure,
}
impl IIfcRepresentationItem for IfcSurfaceOfLinearExtrusion {}
impl IIfcGeometricRepresentationItem for IfcSurfaceOfLinearExtrusion {}
impl IIfcSurface for IfcSurfaceOfLinearExtrusion {}
impl IIfcSweptSurface for IfcSurfaceOfLinearExtrusion {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcSurfaceOfLinearExtrusion for IfcSurfaceOfLinearExtrusion {
    fn extruded_direction(&self) -> &EntityRef {
        &self.extruded_direction
    }
    fn depth(&self) -> &IfcLengthMeasure {
        &self.depth
    }
}
impl IfcSurfaceOfLinearExtrusion {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceOfLinearExtrusion::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_curve = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.extruded_direction = parameter.into(),
                3usize => entity.depth = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceOfRevolution: IIfcSweptSurface {
    fn axis_position(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceOfRevolution {
    swept_curve: EntityRef,
    position: EntityRef,
    axis_position: EntityRef,
}
impl IIfcRepresentationItem for IfcSurfaceOfRevolution {}
impl IIfcGeometricRepresentationItem for IfcSurfaceOfRevolution {}
impl IIfcSurface for IfcSurfaceOfRevolution {}
impl IIfcSweptSurface for IfcSurfaceOfRevolution {
    fn swept_curve(&self) -> &EntityRef {
        &self.swept_curve
    }
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcSurfaceOfRevolution for IfcSurfaceOfRevolution {
    fn axis_position(&self) -> &EntityRef {
        &self.axis_position
    }
}
impl IfcSurfaceOfRevolution {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceOfRevolution::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.swept_curve = parameter.into(),
                1usize => entity.position = parameter.into(),
                2usize => entity.axis_position = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyle: IIfcPresentationStyle {
    fn side(&self) -> &IfcSurfaceSide;
    fn styles(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyle {
    name: Option<IfcLabel>,
    side: IfcSurfaceSide,
    styles: HashSet<EntityRef>,
}
impl IIfcPresentationStyle for IfcSurfaceStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcSurfaceStyle for IfcSurfaceStyle {
    fn side(&self) -> &IfcSurfaceSide {
        &self.side
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
}
impl IfcSurfaceStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.side = parameter.into(),
                2usize => entity.styles = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleLighting {
    fn diffuse_transmission_colour(&self) -> &EntityRef;
    fn diffuse_reflection_colour(&self) -> &EntityRef;
    fn transmission_colour(&self) -> &EntityRef;
    fn reflectance_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleLighting {
    diffuse_transmission_colour: EntityRef,
    diffuse_reflection_colour: EntityRef,
    transmission_colour: EntityRef,
    reflectance_colour: EntityRef,
}
impl IIfcSurfaceStyleLighting for IfcSurfaceStyleLighting {
    fn diffuse_transmission_colour(&self) -> &EntityRef {
        &self.diffuse_transmission_colour
    }
    fn diffuse_reflection_colour(&self) -> &EntityRef {
        &self.diffuse_reflection_colour
    }
    fn transmission_colour(&self) -> &EntityRef {
        &self.transmission_colour
    }
    fn reflectance_colour(&self) -> &EntityRef {
        &self.reflectance_colour
    }
}
impl IfcSurfaceStyleLighting {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleLighting::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.diffuse_transmission_colour = parameter.into(),
                1usize => entity.diffuse_reflection_colour = parameter.into(),
                2usize => entity.transmission_colour = parameter.into(),
                3usize => entity.reflectance_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleRefraction {
    fn refraction_index(&self) -> &Option<IfcReal>;
    fn dispersion_factor(&self) -> &Option<IfcReal>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleRefraction {
    refraction_index: Option<IfcReal>,
    dispersion_factor: Option<IfcReal>,
}
impl IIfcSurfaceStyleRefraction for IfcSurfaceStyleRefraction {
    fn refraction_index(&self) -> &Option<IfcReal> {
        &self.refraction_index
    }
    fn dispersion_factor(&self) -> &Option<IfcReal> {
        &self.dispersion_factor
    }
}
impl IfcSurfaceStyleRefraction {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleRefraction::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.refraction_index = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.dispersion_factor = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleRendering: IIfcSurfaceStyleShading {
    fn transparency(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn diffuse_colour(&self) -> &Option<IfcColourOrFactor>;
    fn transmission_colour(&self) -> &Option<IfcColourOrFactor>;
    fn diffuse_transmission_colour(&self) -> &Option<IfcColourOrFactor>;
    fn reflection_colour(&self) -> &Option<IfcColourOrFactor>;
    fn specular_colour(&self) -> &Option<IfcColourOrFactor>;
    fn specular_highlight(&self) -> &Option<IfcSpecularHighlightSelect>;
    fn reflectance_method(&self) -> &IfcReflectanceMethodEnum;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleRendering {
    surface_colour: EntityRef,
    transparency: Option<IfcNormalisedRatioMeasure>,
    diffuse_colour: Option<IfcColourOrFactor>,
    transmission_colour: Option<IfcColourOrFactor>,
    diffuse_transmission_colour: Option<IfcColourOrFactor>,
    reflection_colour: Option<IfcColourOrFactor>,
    specular_colour: Option<IfcColourOrFactor>,
    specular_highlight: Option<IfcSpecularHighlightSelect>,
    reflectance_method: IfcReflectanceMethodEnum,
}
impl IIfcSurfaceStyleShading for IfcSurfaceStyleRendering {
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
}
impl IIfcSurfaceStyleRendering for IfcSurfaceStyleRendering {
    fn transparency(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.transparency
    }
    fn diffuse_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.diffuse_colour
    }
    fn transmission_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.transmission_colour
    }
    fn diffuse_transmission_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.diffuse_transmission_colour
    }
    fn reflection_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.reflection_colour
    }
    fn specular_colour(&self) -> &Option<IfcColourOrFactor> {
        &self.specular_colour
    }
    fn specular_highlight(&self) -> &Option<IfcSpecularHighlightSelect> {
        &self.specular_highlight
    }
    fn reflectance_method(&self) -> &IfcReflectanceMethodEnum {
        &self.reflectance_method
    }
}
impl IfcSurfaceStyleRendering {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleRendering::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.surface_colour = parameter.into(),
                1usize => {
                    entity.transparency = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.diffuse_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.transmission_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.diffuse_transmission_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.reflection_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.specular_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.specular_highlight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.reflectance_method = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleShading {
    fn surface_colour(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleShading {
    surface_colour: EntityRef,
}
impl IIfcSurfaceStyleShading for IfcSurfaceStyleShading {
    fn surface_colour(&self) -> &EntityRef {
        &self.surface_colour
    }
}
impl IfcSurfaceStyleShading {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleShading::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.surface_colour = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceStyleWithTextures {
    fn textures(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcSurfaceStyleWithTextures {
    textures: Vec<EntityRef>,
}
impl IIfcSurfaceStyleWithTextures for IfcSurfaceStyleWithTextures {
    fn textures(&self) -> &Vec<EntityRef> {
        &self.textures
    }
}
impl IfcSurfaceStyleWithTextures {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSurfaceStyleWithTextures::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.textures = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSurfaceTexture {
    fn repeat_s(&self) -> bool;
    fn repeat_t(&self) -> bool;
    fn texture_type(&self) -> &IfcSurfaceTextureEnum;
    fn texture_transform(&self) -> &Option<EntityRef>;
}
pub trait IIfcSweptAreaSolid: IIfcSolidModel {
    fn swept_area(&self) -> &EntityRef;
    fn position(&self) -> &EntityRef;
}
pub trait IIfcSweptDiskSolid: IIfcSolidModel {
    fn directrix(&self) -> &EntityRef;
    fn radius(&self) -> &IfcPositiveLengthMeasure;
    fn inner_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn start_param(&self) -> &IfcParameterValue;
    fn end_param(&self) -> &IfcParameterValue;
}
#[derive(Default, Debug)]
pub struct IfcSweptDiskSolid {
    directrix: EntityRef,
    radius: IfcPositiveLengthMeasure,
    inner_radius: Option<IfcPositiveLengthMeasure>,
    start_param: IfcParameterValue,
    end_param: IfcParameterValue,
}
impl IIfcRepresentationItem for IfcSweptDiskSolid {}
impl IIfcGeometricRepresentationItem for IfcSweptDiskSolid {}
impl IIfcSolidModel for IfcSweptDiskSolid {}
impl IIfcSweptDiskSolid for IfcSweptDiskSolid {
    fn directrix(&self) -> &EntityRef {
        &self.directrix
    }
    fn radius(&self) -> &IfcPositiveLengthMeasure {
        &self.radius
    }
    fn inner_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.inner_radius
    }
    fn start_param(&self) -> &IfcParameterValue {
        &self.start_param
    }
    fn end_param(&self) -> &IfcParameterValue {
        &self.end_param
    }
}
impl IfcSweptDiskSolid {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSweptDiskSolid::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.directrix = parameter.into(),
                1usize => entity.radius = parameter.into(),
                2usize => {
                    entity.inner_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.start_param = parameter.into(),
                4usize => entity.end_param = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSweptSurface: IIfcSurface {
    fn swept_curve(&self) -> &EntityRef;
    fn position(&self) -> &EntityRef;
}
pub trait IIfcSwitchingDeviceType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcSwitchingDeviceTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcSwitchingDeviceType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcSwitchingDeviceTypeEnum,
}
impl IIfcRoot for IfcSwitchingDeviceType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSwitchingDeviceType {}
impl IIfcTypeObject for IfcSwitchingDeviceType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSwitchingDeviceType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSwitchingDeviceType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcSwitchingDeviceType {}
impl IIfcDistributionFlowElementType for IfcSwitchingDeviceType {}
impl IIfcFlowControllerType for IfcSwitchingDeviceType {}
impl IIfcSwitchingDeviceType for IfcSwitchingDeviceType {
    fn predefined_type(&self) -> &IfcSwitchingDeviceTypeEnum {
        &self.predefined_type
    }
}
impl IfcSwitchingDeviceType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSwitchingDeviceType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSymbolStyle: IIfcPresentationStyle {
    fn style_of_symbol(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcSymbolStyle {
    name: Option<IfcLabel>,
    style_of_symbol: EntityRef,
}
impl IIfcPresentationStyle for IfcSymbolStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcSymbolStyle for IfcSymbolStyle {
    fn style_of_symbol(&self) -> &EntityRef {
        &self.style_of_symbol
    }
}
impl IfcSymbolStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSymbolStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.style_of_symbol = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSystem: IIfcGroup {}
#[derive(Default, Debug)]
pub struct IfcSystem {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcSystem {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSystem {}
impl IIfcObject for IfcSystem {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcSystem {}
impl IIfcSystem for IfcSystem {}
impl IfcSystem {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystem::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcSystemFurnitureElementType: IIfcFurnishingElementType {}
#[derive(Default, Debug)]
pub struct IfcSystemFurnitureElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcSystemFurnitureElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcSystemFurnitureElementType {}
impl IIfcTypeObject for IfcSystemFurnitureElementType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcSystemFurnitureElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcSystemFurnitureElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcFurnishingElementType for IfcSystemFurnitureElementType {}
impl IIfcSystemFurnitureElementType for IfcSystemFurnitureElementType {}
impl IfcSystemFurnitureElementType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcSystemFurnitureElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn flange_edge_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn web_edge_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn web_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    depth: IfcPositiveLengthMeasure,
    flange_width: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
    flange_edge_radius: Option<IfcPositiveLengthMeasure>,
    web_edge_radius: Option<IfcPositiveLengthMeasure>,
    web_slope: Option<IfcPlaneAngleMeasure>,
    flange_slope: Option<IfcPlaneAngleMeasure>,
    centre_of_gravity_in_y: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcTShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcTShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcTShapeProfileDef for IfcTShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_width
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
    fn flange_edge_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.flange_edge_radius
    }
    fn web_edge_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.web_edge_radius
    }
    fn web_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.web_slope
    }
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.flange_slope
    }
    fn centre_of_gravity_in_y(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_y
    }
}
impl IfcTShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.flange_width = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.flange_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.web_edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.web_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.centre_of_gravity_in_y = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTable {
    fn name(&self) -> &String;
    fn rows(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcTable {
    name: String,
    rows: Vec<EntityRef>,
}
impl IIfcTable for IfcTable {
    fn name(&self) -> &String {
        &self.name
    }
    fn rows(&self) -> &Vec<EntityRef> {
        &self.rows
    }
}
impl IfcTable {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTable::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => entity.rows = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTableRow {
    fn row_cells(&self) -> &Vec<IfcValue>;
    fn is_heading(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcTableRow {
    row_cells: Vec<IfcValue>,
    is_heading: bool,
}
impl IIfcTableRow for IfcTableRow {
    fn row_cells(&self) -> &Vec<IfcValue> {
        &self.row_cells
    }
    fn is_heading(&self) -> bool {
        self.is_heading
    }
}
impl IfcTableRow {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTableRow::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.row_cells = parameter.into(),
                1usize => entity.is_heading = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTankType: IIfcFlowStorageDeviceType {
    fn predefined_type(&self) -> &IfcTankTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTankType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTankTypeEnum,
}
impl IIfcRoot for IfcTankType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTankType {}
impl IIfcTypeObject for IfcTankType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTankType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTankType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcTankType {}
impl IIfcDistributionFlowElementType for IfcTankType {}
impl IIfcFlowStorageDeviceType for IfcTankType {}
impl IIfcTankType for IfcTankType {
    fn predefined_type(&self) -> &IfcTankTypeEnum {
        &self.predefined_type
    }
}
impl IfcTankType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTankType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTask: IIfcProcess {
    fn task_id(&self) -> &IfcIdentifier;
    fn status(&self) -> &Option<IfcLabel>;
    fn work_method(&self) -> &Option<IfcLabel>;
    fn is_milestone(&self) -> bool;
    fn priority(&self) -> Option<i64>;
}
#[derive(Default, Debug)]
pub struct IfcTask {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    task_id: IfcIdentifier,
    status: Option<IfcLabel>,
    work_method: Option<IfcLabel>,
    is_milestone: bool,
    priority: Option<i64>,
}
impl IIfcRoot for IfcTask {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTask {}
impl IIfcObject for IfcTask {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProcess for IfcTask {}
impl IIfcTask for IfcTask {
    fn task_id(&self) -> &IfcIdentifier {
        &self.task_id
    }
    fn status(&self) -> &Option<IfcLabel> {
        &self.status
    }
    fn work_method(&self) -> &Option<IfcLabel> {
        &self.work_method
    }
    fn is_milestone(&self) -> bool {
        self.is_milestone
    }
    fn priority(&self) -> Option<i64> {
        self.priority
    }
}
impl IfcTask {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTask::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.task_id = parameter.into(),
                6usize => {
                    entity.status = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.work_method = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.is_milestone = parameter.into(),
                9usize => {
                    entity.priority = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTelecomAddress: IIfcAddress {
    fn telephone_numbers(&self) -> &Option<Vec<IfcLabel>>;
    fn facsimile_numbers(&self) -> &Option<Vec<IfcLabel>>;
    fn pager_number(&self) -> &Option<IfcLabel>;
    fn electronic_mail_addresses(&self) -> &Option<Vec<IfcLabel>>;
    fn www_home_page_url(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcTelecomAddress {
    purpose: Option<IfcAddressTypeEnum>,
    description: Option<IfcText>,
    user_defined_purpose: Option<IfcLabel>,
    telephone_numbers: Option<Vec<IfcLabel>>,
    facsimile_numbers: Option<Vec<IfcLabel>>,
    pager_number: Option<IfcLabel>,
    electronic_mail_addresses: Option<Vec<IfcLabel>>,
    www_home_page_url: Option<IfcLabel>,
}
impl IIfcAddress for IfcTelecomAddress {
    fn purpose(&self) -> &Option<IfcAddressTypeEnum> {
        &self.purpose
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
    fn user_defined_purpose(&self) -> &Option<IfcLabel> {
        &self.user_defined_purpose
    }
}
impl IIfcTelecomAddress for IfcTelecomAddress {
    fn telephone_numbers(&self) -> &Option<Vec<IfcLabel>> {
        &self.telephone_numbers
    }
    fn facsimile_numbers(&self) -> &Option<Vec<IfcLabel>> {
        &self.facsimile_numbers
    }
    fn pager_number(&self) -> &Option<IfcLabel> {
        &self.pager_number
    }
    fn electronic_mail_addresses(&self) -> &Option<Vec<IfcLabel>> {
        &self.electronic_mail_addresses
    }
    fn www_home_page_url(&self) -> &Option<IfcLabel> {
        &self.www_home_page_url
    }
}
impl IfcTelecomAddress {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTelecomAddress::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.user_defined_purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.telephone_numbers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.facsimile_numbers = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.pager_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.electronic_mail_addresses = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.www_home_page_url = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTendon: IIfcReinforcingElement {
    fn predefined_type(&self) -> &IfcTendonTypeEnum;
    fn nominal_diameter(&self) -> &IfcPositiveLengthMeasure;
    fn cross_section_area(&self) -> &IfcAreaMeasure;
    fn tension_force(&self) -> &Option<IfcForceMeasure>;
    fn pre_stress(&self) -> &Option<IfcPressureMeasure>;
    fn friction_coefficient(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn anchorage_slip(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn min_curvature_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTendon {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
    predefined_type: IfcTendonTypeEnum,
    nominal_diameter: IfcPositiveLengthMeasure,
    cross_section_area: IfcAreaMeasure,
    tension_force: Option<IfcForceMeasure>,
    pre_stress: Option<IfcPressureMeasure>,
    friction_coefficient: Option<IfcNormalisedRatioMeasure>,
    anchorage_slip: Option<IfcPositiveLengthMeasure>,
    min_curvature_radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcTendon {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTendon {}
impl IIfcObject for IfcTendon {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTendon {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTendon {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcTendon {}
impl IIfcBuildingElementComponent for IfcTendon {}
impl IIfcReinforcingElement for IfcTendon {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcTendon for IfcTendon {
    fn predefined_type(&self) -> &IfcTendonTypeEnum {
        &self.predefined_type
    }
    fn nominal_diameter(&self) -> &IfcPositiveLengthMeasure {
        &self.nominal_diameter
    }
    fn cross_section_area(&self) -> &IfcAreaMeasure {
        &self.cross_section_area
    }
    fn tension_force(&self) -> &Option<IfcForceMeasure> {
        &self.tension_force
    }
    fn pre_stress(&self) -> &Option<IfcPressureMeasure> {
        &self.pre_stress
    }
    fn friction_coefficient(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.friction_coefficient
    }
    fn anchorage_slip(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.anchorage_slip
    }
    fn min_curvature_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.min_curvature_radius
    }
}
impl IfcTendon {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendon::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                10usize => entity.nominal_diameter = parameter.into(),
                11usize => entity.cross_section_area = parameter.into(),
                12usize => {
                    entity.tension_force = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.pre_stress = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.friction_coefficient = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                15usize => {
                    entity.anchorage_slip = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                16usize => {
                    entity.min_curvature_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTendonAnchor: IIfcReinforcingElement {}
#[derive(Default, Debug)]
pub struct IfcTendonAnchor {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    steel_grade: Option<IfcLabel>,
}
impl IIfcRoot for IfcTendonAnchor {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTendonAnchor {}
impl IIfcObject for IfcTendonAnchor {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTendonAnchor {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTendonAnchor {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcTendonAnchor {}
impl IIfcBuildingElementComponent for IfcTendonAnchor {}
impl IIfcReinforcingElement for IfcTendonAnchor {
    fn steel_grade(&self) -> &Option<IfcLabel> {
        &self.steel_grade
    }
}
impl IIfcTendonAnchor for IfcTendonAnchor {}
impl IfcTendonAnchor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTendonAnchor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.steel_grade = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTerminatorSymbol: IIfcAnnotationSymbolOccurrence {
    fn annotated_curve(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcTerminatorSymbol {
    item: Option<EntityRef>,
    styles: HashSet<EntityRef>,
    name: Option<IfcLabel>,
    annotated_curve: EntityRef,
}
impl IIfcRepresentationItem for IfcTerminatorSymbol {}
impl IIfcStyledItem for IfcTerminatorSymbol {
    fn item(&self) -> &Option<EntityRef> {
        &self.item
    }
    fn styles(&self) -> &HashSet<EntityRef> {
        &self.styles
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcAnnotationOccurrence for IfcTerminatorSymbol {}
impl IIfcAnnotationSymbolOccurrence for IfcTerminatorSymbol {}
impl IIfcTerminatorSymbol for IfcTerminatorSymbol {
    fn annotated_curve(&self) -> &EntityRef {
        &self.annotated_curve
    }
}
impl IfcTerminatorSymbol {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTerminatorSymbol::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.item = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => entity.styles = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.annotated_curve = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextLiteral: IIfcGeometricRepresentationItem {
    fn literal(&self) -> &IfcPresentableText;
    fn placement(&self) -> &EntityRef;
    fn path(&self) -> &IfcTextPath;
}
#[derive(Default, Debug)]
pub struct IfcTextLiteral {
    literal: IfcPresentableText,
    placement: EntityRef,
    path: IfcTextPath,
}
impl IIfcRepresentationItem for IfcTextLiteral {}
impl IIfcGeometricRepresentationItem for IfcTextLiteral {}
impl IIfcTextLiteral for IfcTextLiteral {
    fn literal(&self) -> &IfcPresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn path(&self) -> &IfcTextPath {
        &self.path
    }
}
impl IfcTextLiteral {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextLiteral::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.literal = parameter.into(),
                1usize => entity.placement = parameter.into(),
                2usize => entity.path = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextLiteralWithExtent: IIfcTextLiteral {
    fn extent(&self) -> &EntityRef;
    fn box_alignment(&self) -> &IfcBoxAlignment;
}
#[derive(Default, Debug)]
pub struct IfcTextLiteralWithExtent {
    literal: IfcPresentableText,
    placement: EntityRef,
    path: IfcTextPath,
    extent: EntityRef,
    box_alignment: IfcBoxAlignment,
}
impl IIfcRepresentationItem for IfcTextLiteralWithExtent {}
impl IIfcGeometricRepresentationItem for IfcTextLiteralWithExtent {}
impl IIfcTextLiteral for IfcTextLiteralWithExtent {
    fn literal(&self) -> &IfcPresentableText {
        &self.literal
    }
    fn placement(&self) -> &EntityRef {
        &self.placement
    }
    fn path(&self) -> &IfcTextPath {
        &self.path
    }
}
impl IIfcTextLiteralWithExtent for IfcTextLiteralWithExtent {
    fn extent(&self) -> &EntityRef {
        &self.extent
    }
    fn box_alignment(&self) -> &IfcBoxAlignment {
        &self.box_alignment
    }
}
impl IfcTextLiteralWithExtent {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextLiteralWithExtent::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.literal = parameter.into(),
                1usize => entity.placement = parameter.into(),
                2usize => entity.path = parameter.into(),
                3usize => entity.extent = parameter.into(),
                4usize => entity.box_alignment = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyle: IIfcPresentationStyle {
    fn text_character_appearance(&self) -> &Option<EntityRef>;
    fn text_style(&self) -> &Option<EntityRef>;
    fn text_font_style(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcTextStyle {
    name: Option<IfcLabel>,
    text_character_appearance: Option<EntityRef>,
    text_style: Option<EntityRef>,
    text_font_style: EntityRef,
}
impl IIfcPresentationStyle for IfcTextStyle {
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
}
impl IIfcTextStyle for IfcTextStyle {
    fn text_character_appearance(&self) -> &Option<EntityRef> {
        &self.text_character_appearance
    }
    fn text_style(&self) -> &Option<EntityRef> {
        &self.text_style
    }
    fn text_font_style(&self) -> &EntityRef {
        &self.text_font_style
    }
}
impl IfcTextStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.text_character_appearance = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.text_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.text_font_style = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleFontModel: IIfcPreDefinedTextFont {
    fn font_family(&self) -> &Option<Vec<IfcTextFontName>>;
    fn font_style(&self) -> &Option<IfcFontStyle>;
    fn font_variant(&self) -> &Option<IfcFontVariant>;
    fn font_weight(&self) -> &Option<IfcFontWeight>;
    fn font_size(&self) -> &IfcSizeSelect;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleFontModel {
    name: IfcLabel,
    font_family: Option<Vec<IfcTextFontName>>,
    font_style: Option<IfcFontStyle>,
    font_variant: Option<IfcFontVariant>,
    font_weight: Option<IfcFontWeight>,
    font_size: IfcSizeSelect,
}
impl IIfcPreDefinedItem for IfcTextStyleFontModel {
    fn name(&self) -> &IfcLabel {
        &self.name
    }
}
impl IIfcPreDefinedTextFont for IfcTextStyleFontModel {}
impl IIfcTextStyleFontModel for IfcTextStyleFontModel {
    fn font_family(&self) -> &Option<Vec<IfcTextFontName>> {
        &self.font_family
    }
    fn font_style(&self) -> &Option<IfcFontStyle> {
        &self.font_style
    }
    fn font_variant(&self) -> &Option<IfcFontVariant> {
        &self.font_variant
    }
    fn font_weight(&self) -> &Option<IfcFontWeight> {
        &self.font_weight
    }
    fn font_size(&self) -> &IfcSizeSelect {
        &self.font_size
    }
}
impl IfcTextStyleFontModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleFontModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.name = parameter.into(),
                1usize => {
                    entity.font_family = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.font_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.font_variant = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.font_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.font_size = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleForDefinedFont {
    fn colour(&self) -> &EntityRef;
    fn background_colour(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleForDefinedFont {
    colour: EntityRef,
    background_colour: Option<EntityRef>,
}
impl IIfcTextStyleForDefinedFont for IfcTextStyleForDefinedFont {
    fn colour(&self) -> &EntityRef {
        &self.colour
    }
    fn background_colour(&self) -> &Option<EntityRef> {
        &self.background_colour
    }
}
impl IfcTextStyleForDefinedFont {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleForDefinedFont::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.colour = parameter.into(),
                1usize => {
                    entity.background_colour = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleTextModel {
    fn text_indent(&self) -> &Option<IfcSizeSelect>;
    fn text_align(&self) -> &Option<IfcTextAlignment>;
    fn text_decoration(&self) -> &Option<IfcTextDecoration>;
    fn letter_spacing(&self) -> &Option<IfcSizeSelect>;
    fn word_spacing(&self) -> &Option<IfcSizeSelect>;
    fn text_transform(&self) -> &Option<IfcTextTransformation>;
    fn line_height(&self) -> &Option<IfcSizeSelect>;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleTextModel {
    text_indent: Option<IfcSizeSelect>,
    text_align: Option<IfcTextAlignment>,
    text_decoration: Option<IfcTextDecoration>,
    letter_spacing: Option<IfcSizeSelect>,
    word_spacing: Option<IfcSizeSelect>,
    text_transform: Option<IfcTextTransformation>,
    line_height: Option<IfcSizeSelect>,
}
impl IIfcTextStyleTextModel for IfcTextStyleTextModel {
    fn text_indent(&self) -> &Option<IfcSizeSelect> {
        &self.text_indent
    }
    fn text_align(&self) -> &Option<IfcTextAlignment> {
        &self.text_align
    }
    fn text_decoration(&self) -> &Option<IfcTextDecoration> {
        &self.text_decoration
    }
    fn letter_spacing(&self) -> &Option<IfcSizeSelect> {
        &self.letter_spacing
    }
    fn word_spacing(&self) -> &Option<IfcSizeSelect> {
        &self.word_spacing
    }
    fn text_transform(&self) -> &Option<IfcTextTransformation> {
        &self.text_transform
    }
    fn line_height(&self) -> &Option<IfcSizeSelect> {
        &self.line_height
    }
}
impl IfcTextStyleTextModel {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleTextModel::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.text_indent = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.text_align = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.text_decoration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.letter_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.word_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.text_transform = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.line_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextStyleWithBoxCharacteristics {
    fn box_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn box_width(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn box_slant_angle(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn box_rotate_angle(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn character_spacing(&self) -> &Option<IfcSizeSelect>;
}
#[derive(Default, Debug)]
pub struct IfcTextStyleWithBoxCharacteristics {
    box_height: Option<IfcPositiveLengthMeasure>,
    box_width: Option<IfcPositiveLengthMeasure>,
    box_slant_angle: Option<IfcPlaneAngleMeasure>,
    box_rotate_angle: Option<IfcPlaneAngleMeasure>,
    character_spacing: Option<IfcSizeSelect>,
}
impl IIfcTextStyleWithBoxCharacteristics for IfcTextStyleWithBoxCharacteristics {
    fn box_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.box_height
    }
    fn box_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.box_width
    }
    fn box_slant_angle(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.box_slant_angle
    }
    fn box_rotate_angle(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.box_rotate_angle
    }
    fn character_spacing(&self) -> &Option<IfcSizeSelect> {
        &self.character_spacing
    }
}
impl IfcTextStyleWithBoxCharacteristics {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextStyleWithBoxCharacteristics::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => {
                    entity.box_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                1usize => {
                    entity.box_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.box_slant_angle = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.box_rotate_angle = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.character_spacing = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureCoordinate {}
pub trait IIfcTextureCoordinateGenerator: IIfcTextureCoordinate {
    fn mode(&self) -> &IfcLabel;
    fn parameter(&self) -> &Vec<IfcSimpleValue>;
}
#[derive(Default, Debug)]
pub struct IfcTextureCoordinateGenerator {
    mode: IfcLabel,
    parameter: Vec<IfcSimpleValue>,
}
impl IIfcTextureCoordinate for IfcTextureCoordinateGenerator {}
impl IIfcTextureCoordinateGenerator for IfcTextureCoordinateGenerator {
    fn mode(&self) -> &IfcLabel {
        &self.mode
    }
    fn parameter(&self) -> &Vec<IfcSimpleValue> {
        &self.parameter
    }
}
impl IfcTextureCoordinateGenerator {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureCoordinateGenerator::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.mode = parameter.into(),
                1usize => entity.parameter = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureMap: IIfcTextureCoordinate {
    fn texture_maps(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcTextureMap {
    texture_maps: HashSet<EntityRef>,
}
impl IIfcTextureCoordinate for IfcTextureMap {}
impl IIfcTextureMap for IfcTextureMap {
    fn texture_maps(&self) -> &HashSet<EntityRef> {
        &self.texture_maps
    }
}
impl IfcTextureMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.texture_maps = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTextureVertex {
    fn coordinates(&self) -> &Vec<IfcParameterValue>;
}
#[derive(Default, Debug)]
pub struct IfcTextureVertex {
    coordinates: Vec<IfcParameterValue>,
}
impl IIfcTextureVertex for IfcTextureVertex {
    fn coordinates(&self) -> &Vec<IfcParameterValue> {
        &self.coordinates
    }
}
impl IfcTextureVertex {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTextureVertex::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.coordinates = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcThermalMaterialProperties: IIfcMaterialProperties {
    fn specific_heat_capacity(&self) -> &Option<IfcSpecificHeatCapacityMeasure>;
    fn boiling_point(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn freezing_point(&self) -> &Option<IfcThermodynamicTemperatureMeasure>;
    fn thermal_conductivity(&self) -> &Option<IfcThermalConductivityMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcThermalMaterialProperties {
    material: EntityRef,
    specific_heat_capacity: Option<IfcSpecificHeatCapacityMeasure>,
    boiling_point: Option<IfcThermodynamicTemperatureMeasure>,
    freezing_point: Option<IfcThermodynamicTemperatureMeasure>,
    thermal_conductivity: Option<IfcThermalConductivityMeasure>,
}
impl IIfcMaterialProperties for IfcThermalMaterialProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcThermalMaterialProperties for IfcThermalMaterialProperties {
    fn specific_heat_capacity(&self) -> &Option<IfcSpecificHeatCapacityMeasure> {
        &self.specific_heat_capacity
    }
    fn boiling_point(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.boiling_point
    }
    fn freezing_point(&self) -> &Option<IfcThermodynamicTemperatureMeasure> {
        &self.freezing_point
    }
    fn thermal_conductivity(&self) -> &Option<IfcThermalConductivityMeasure> {
        &self.thermal_conductivity
    }
}
impl IfcThermalMaterialProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcThermalMaterialProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.specific_heat_capacity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.boiling_point = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.freezing_point = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.thermal_conductivity = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTimeSeries {
    fn name(&self) -> &IfcLabel;
    fn description(&self) -> &Option<IfcText>;
    fn start_time(&self) -> &EntityRef;
    fn end_time(&self) -> &EntityRef;
    fn time_series_data_type(&self) -> &IfcTimeSeriesDataTypeEnum;
    fn data_origin(&self) -> &IfcDataOriginEnum;
    fn user_defined_data_origin(&self) -> &Option<IfcLabel>;
    fn unit(&self) -> &Option<EntityRef>;
}
pub trait IIfcTimeSeriesReferenceRelationship {
    fn referenced_time_series(&self) -> &EntityRef;
    fn time_series_references(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcTimeSeriesReferenceRelationship {
    referenced_time_series: EntityRef,
    time_series_references: HashSet<EntityRef>,
}
impl IIfcTimeSeriesReferenceRelationship for IfcTimeSeriesReferenceRelationship {
    fn referenced_time_series(&self) -> &EntityRef {
        &self.referenced_time_series
    }
    fn time_series_references(&self) -> &HashSet<EntityRef> {
        &self.time_series_references
    }
}
impl IfcTimeSeriesReferenceRelationship {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTimeSeriesReferenceRelationship::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.referenced_time_series = parameter.into(),
                1usize => entity.time_series_references = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTimeSeriesSchedule: IIfcControl {
    fn applicable_dates(&self) -> &Option<Vec<EntityRef>>;
    fn time_series_schedule_type(&self) -> &IfcTimeSeriesScheduleTypeEnum;
    fn time_series(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcTimeSeriesSchedule {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    applicable_dates: Option<Vec<EntityRef>>,
    time_series_schedule_type: IfcTimeSeriesScheduleTypeEnum,
    time_series: EntityRef,
}
impl IIfcRoot for IfcTimeSeriesSchedule {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTimeSeriesSchedule {}
impl IIfcObject for IfcTimeSeriesSchedule {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcTimeSeriesSchedule {}
impl IIfcTimeSeriesSchedule for IfcTimeSeriesSchedule {
    fn applicable_dates(&self) -> &Option<Vec<EntityRef>> {
        &self.applicable_dates
    }
    fn time_series_schedule_type(&self) -> &IfcTimeSeriesScheduleTypeEnum {
        &self.time_series_schedule_type
    }
    fn time_series(&self) -> &EntityRef {
        &self.time_series
    }
}
impl IfcTimeSeriesSchedule {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTimeSeriesSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.applicable_dates = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => entity.time_series_schedule_type = parameter.into(),
                7usize => entity.time_series = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTimeSeriesValue {
    fn list_values(&self) -> &Vec<IfcValue>;
}
#[derive(Default, Debug)]
pub struct IfcTimeSeriesValue {
    list_values: Vec<IfcValue>,
}
impl IIfcTimeSeriesValue for IfcTimeSeriesValue {
    fn list_values(&self) -> &Vec<IfcValue> {
        &self.list_values
    }
}
impl IfcTimeSeriesValue {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTimeSeriesValue::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.list_values = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTopologicalRepresentationItem: IIfcRepresentationItem {}
pub trait IIfcTopologyRepresentation: IIfcShapeModel {}
#[derive(Default, Debug)]
pub struct IfcTopologyRepresentation {
    context_of_items: EntityRef,
    representation_identifier: Option<IfcLabel>,
    representation_type: Option<IfcLabel>,
    items: HashSet<EntityRef>,
}
impl IIfcRepresentation for IfcTopologyRepresentation {
    fn context_of_items(&self) -> &EntityRef {
        &self.context_of_items
    }
    fn representation_identifier(&self) -> &Option<IfcLabel> {
        &self.representation_identifier
    }
    fn representation_type(&self) -> &Option<IfcLabel> {
        &self.representation_type
    }
    fn items(&self) -> &HashSet<EntityRef> {
        &self.items
    }
}
impl IIfcShapeModel for IfcTopologyRepresentation {}
impl IIfcTopologyRepresentation for IfcTopologyRepresentation {}
impl IfcTopologyRepresentation {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTopologyRepresentation::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.context_of_items = parameter.into(),
                1usize => {
                    entity.representation_identifier = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.representation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => entity.items = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransformerType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcTransformerTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTransformerType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTransformerTypeEnum,
}
impl IIfcRoot for IfcTransformerType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransformerType {}
impl IIfcTypeObject for IfcTransformerType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTransformerType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTransformerType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcTransformerType {}
impl IIfcDistributionFlowElementType for IfcTransformerType {}
impl IIfcEnergyConversionDeviceType for IfcTransformerType {}
impl IIfcTransformerType for IfcTransformerType {
    fn predefined_type(&self) -> &IfcTransformerTypeEnum {
        &self.predefined_type
    }
}
impl IfcTransformerType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransformerType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransportElement: IIfcElement {
    fn operation_type(&self) -> &Option<IfcTransportElementTypeEnum>;
    fn capacity_by_weight(&self) -> &Option<IfcMassMeasure>;
    fn capacity_by_number(&self) -> &Option<IfcCountMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcTransportElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    operation_type: Option<IfcTransportElementTypeEnum>,
    capacity_by_weight: Option<IfcMassMeasure>,
    capacity_by_number: Option<IfcCountMeasure>,
}
impl IIfcRoot for IfcTransportElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransportElement {}
impl IIfcObject for IfcTransportElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcTransportElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcTransportElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcTransportElement for IfcTransportElement {
    fn operation_type(&self) -> &Option<IfcTransportElementTypeEnum> {
        &self.operation_type
    }
    fn capacity_by_weight(&self) -> &Option<IfcMassMeasure> {
        &self.capacity_by_weight
    }
    fn capacity_by_number(&self) -> &Option<IfcCountMeasure> {
        &self.capacity_by_number
    }
}
impl IfcTransportElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransportElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.operation_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.capacity_by_weight = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.capacity_by_number = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTransportElementType: IIfcElementType {
    fn predefined_type(&self) -> &IfcTransportElementTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTransportElementType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTransportElementTypeEnum,
}
impl IIfcRoot for IfcTransportElementType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTransportElementType {}
impl IIfcTypeObject for IfcTransportElementType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTransportElementType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTransportElementType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcTransportElementType for IfcTransportElementType {
    fn predefined_type(&self) -> &IfcTransportElementTypeEnum {
        &self.predefined_type
    }
}
impl IfcTransportElementType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTransportElementType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTrapeziumProfileDef: IIfcParameterizedProfileDef {
    fn bottom_x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn top_x_dim(&self) -> &IfcPositiveLengthMeasure;
    fn y_dim(&self) -> &IfcPositiveLengthMeasure;
    fn top_x_offset(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcTrapeziumProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    bottom_x_dim: IfcPositiveLengthMeasure,
    top_x_dim: IfcPositiveLengthMeasure,
    y_dim: IfcPositiveLengthMeasure,
    top_x_offset: IfcLengthMeasure,
}
impl IIfcProfileDef for IfcTrapeziumProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcTrapeziumProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcTrapeziumProfileDef for IfcTrapeziumProfileDef {
    fn bottom_x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.bottom_x_dim
    }
    fn top_x_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.top_x_dim
    }
    fn y_dim(&self) -> &IfcPositiveLengthMeasure {
        &self.y_dim
    }
    fn top_x_offset(&self) -> &IfcLengthMeasure {
        &self.top_x_offset
    }
}
impl IfcTrapeziumProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTrapeziumProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.bottom_x_dim = parameter.into(),
                4usize => entity.top_x_dim = parameter.into(),
                5usize => entity.y_dim = parameter.into(),
                6usize => entity.top_x_offset = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTrimmedCurve: IIfcBoundedCurve {
    fn basis_curve(&self) -> &EntityRef;
    fn trim1(&self) -> &HashSet<IfcTrimmingSelect>;
    fn trim2(&self) -> &HashSet<IfcTrimmingSelect>;
    fn sense_agreement(&self) -> bool;
    fn master_representation(&self) -> &IfcTrimmingPreference;
}
#[derive(Default, Debug)]
pub struct IfcTrimmedCurve {
    basis_curve: EntityRef,
    trim1: HashSet<IfcTrimmingSelect>,
    trim2: HashSet<IfcTrimmingSelect>,
    sense_agreement: bool,
    master_representation: IfcTrimmingPreference,
}
impl IIfcRepresentationItem for IfcTrimmedCurve {}
impl IIfcGeometricRepresentationItem for IfcTrimmedCurve {}
impl IIfcCurve for IfcTrimmedCurve {}
impl IIfcBoundedCurve for IfcTrimmedCurve {}
impl IIfcTrimmedCurve for IfcTrimmedCurve {
    fn basis_curve(&self) -> &EntityRef {
        &self.basis_curve
    }
    fn trim1(&self) -> &HashSet<IfcTrimmingSelect> {
        &self.trim1
    }
    fn trim2(&self) -> &HashSet<IfcTrimmingSelect> {
        &self.trim2
    }
    fn sense_agreement(&self) -> bool {
        self.sense_agreement
    }
    fn master_representation(&self) -> &IfcTrimmingPreference {
        &self.master_representation
    }
}
impl IfcTrimmedCurve {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTrimmedCurve::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.basis_curve = parameter.into(),
                1usize => entity.trim1 = parameter.into(),
                2usize => entity.trim2 = parameter.into(),
                3usize => entity.sense_agreement = parameter.into(),
                4usize => entity.master_representation = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTubeBundleType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcTubeBundleTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcTubeBundleType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcTubeBundleTypeEnum,
}
impl IIfcRoot for IfcTubeBundleType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTubeBundleType {}
impl IIfcTypeObject for IfcTubeBundleType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTubeBundleType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcTubeBundleType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcTubeBundleType {}
impl IIfcDistributionFlowElementType for IfcTubeBundleType {}
impl IIfcEnergyConversionDeviceType for IfcTubeBundleType {}
impl IIfcTubeBundleType for IfcTubeBundleType {
    fn predefined_type(&self) -> &IfcTubeBundleTypeEnum {
        &self.predefined_type
    }
}
impl IfcTubeBundleType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTubeBundleType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTwoDirectionRepeatFactor: IIfcOneDirectionRepeatFactor {
    fn second_repeat_factor(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcTwoDirectionRepeatFactor {
    repeat_factor: EntityRef,
    second_repeat_factor: EntityRef,
}
impl IIfcRepresentationItem for IfcTwoDirectionRepeatFactor {}
impl IIfcGeometricRepresentationItem for IfcTwoDirectionRepeatFactor {}
impl IIfcOneDirectionRepeatFactor for IfcTwoDirectionRepeatFactor {
    fn repeat_factor(&self) -> &EntityRef {
        &self.repeat_factor
    }
}
impl IIfcTwoDirectionRepeatFactor for IfcTwoDirectionRepeatFactor {
    fn second_repeat_factor(&self) -> &EntityRef {
        &self.second_repeat_factor
    }
}
impl IfcTwoDirectionRepeatFactor {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTwoDirectionRepeatFactor::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.repeat_factor = parameter.into(),
                1usize => entity.second_repeat_factor = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTypeObject: IIfcObjectDefinition {
    fn applicable_occurrence(&self) -> &Option<IfcLabel>;
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>>;
}
#[derive(Default, Debug)]
pub struct IfcTypeObject {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
}
impl IIfcRoot for IfcTypeObject {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTypeObject {}
impl IIfcTypeObject for IfcTypeObject {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IfcTypeObject {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTypeObject::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcTypeProduct: IIfcTypeObject {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>>;
    fn tag(&self) -> &Option<IfcLabel>;
}
#[derive(Default, Debug)]
pub struct IfcTypeProduct {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
}
impl IIfcRoot for IfcTypeProduct {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcTypeProduct {}
impl IIfcTypeObject for IfcTypeProduct {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcTypeProduct {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IfcTypeProduct {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcTypeProduct::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn edge_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure>;
    fn centre_of_gravity_in_x(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcUShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    depth: IfcPositiveLengthMeasure,
    flange_width: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
    edge_radius: Option<IfcPositiveLengthMeasure>,
    flange_slope: Option<IfcPlaneAngleMeasure>,
    centre_of_gravity_in_x: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcUShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcUShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcUShapeProfileDef for IfcUShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_width
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
    fn edge_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.edge_radius
    }
    fn flange_slope(&self) -> &Option<IfcPlaneAngleMeasure> {
        &self.flange_slope
    }
    fn centre_of_gravity_in_x(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.centre_of_gravity_in_x
    }
}
impl IfcUShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.flange_width = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.flange_slope = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.centre_of_gravity_in_x = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitAssignment {
    fn units(&self) -> &HashSet<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcUnitAssignment {
    units: HashSet<EntityRef>,
}
impl IIfcUnitAssignment for IfcUnitAssignment {
    fn units(&self) -> &HashSet<EntityRef> {
        &self.units
    }
}
impl IfcUnitAssignment {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitAssignment::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.units = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcUnitaryEquipmentType: IIfcEnergyConversionDeviceType {
    fn predefined_type(&self) -> &IfcUnitaryEquipmentTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcUnitaryEquipmentType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcUnitaryEquipmentTypeEnum,
}
impl IIfcRoot for IfcUnitaryEquipmentType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcUnitaryEquipmentType {}
impl IIfcTypeObject for IfcUnitaryEquipmentType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcUnitaryEquipmentType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcUnitaryEquipmentType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcUnitaryEquipmentType {}
impl IIfcDistributionFlowElementType for IfcUnitaryEquipmentType {}
impl IIfcEnergyConversionDeviceType for IfcUnitaryEquipmentType {}
impl IIfcUnitaryEquipmentType for IfcUnitaryEquipmentType {
    fn predefined_type(&self) -> &IfcUnitaryEquipmentTypeEnum {
        &self.predefined_type
    }
}
impl IfcUnitaryEquipmentType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcUnitaryEquipmentType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcValveType: IIfcFlowControllerType {
    fn predefined_type(&self) -> &IfcValveTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcValveType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcValveTypeEnum,
}
impl IIfcRoot for IfcValveType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcValveType {}
impl IIfcTypeObject for IfcValveType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcValveType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcValveType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcValveType {}
impl IIfcDistributionFlowElementType for IfcValveType {}
impl IIfcFlowControllerType for IfcValveType {}
impl IIfcValveType for IfcValveType {
    fn predefined_type(&self) -> &IfcValveTypeEnum {
        &self.predefined_type
    }
}
impl IfcValveType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcValveType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVector: IIfcGeometricRepresentationItem {
    fn orientation(&self) -> &EntityRef;
    fn magnitude(&self) -> &IfcLengthMeasure;
}
#[derive(Default, Debug)]
pub struct IfcVector {
    orientation: EntityRef,
    magnitude: IfcLengthMeasure,
}
impl IIfcRepresentationItem for IfcVector {}
impl IIfcGeometricRepresentationItem for IfcVector {}
impl IIfcVector for IfcVector {
    fn orientation(&self) -> &EntityRef {
        &self.orientation
    }
    fn magnitude(&self) -> &IfcLengthMeasure {
        &self.magnitude
    }
}
impl IfcVector {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVector::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.orientation = parameter.into(),
                1usize => entity.magnitude = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVertex: IIfcTopologicalRepresentationItem {}
#[derive(Default, Debug)]
pub struct IfcVertex {}
impl IIfcRepresentationItem for IfcVertex {}
impl IIfcTopologicalRepresentationItem for IfcVertex {}
impl IIfcVertex for IfcVertex {}
impl IfcVertex {
    pub fn form_parameters(_parameters: Vec<Parameter>) -> Self {
        IfcVertex::default()
    }
}
pub trait IIfcVertexBasedTextureMap {
    fn texture_vertices(&self) -> &Vec<EntityRef>;
    fn texture_points(&self) -> &Vec<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcVertexBasedTextureMap {
    texture_vertices: Vec<EntityRef>,
    texture_points: Vec<EntityRef>,
}
impl IIfcVertexBasedTextureMap for IfcVertexBasedTextureMap {
    fn texture_vertices(&self) -> &Vec<EntityRef> {
        &self.texture_vertices
    }
    fn texture_points(&self) -> &Vec<EntityRef> {
        &self.texture_points
    }
}
impl IfcVertexBasedTextureMap {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVertexBasedTextureMap::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.texture_vertices = parameter.into(),
                1usize => entity.texture_points = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVertexLoop: IIfcLoop {
    fn loop_vertex(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcVertexLoop {
    loop_vertex: EntityRef,
}
impl IIfcRepresentationItem for IfcVertexLoop {}
impl IIfcTopologicalRepresentationItem for IfcVertexLoop {}
impl IIfcLoop for IfcVertexLoop {}
impl IIfcVertexLoop for IfcVertexLoop {
    fn loop_vertex(&self) -> &EntityRef {
        &self.loop_vertex
    }
}
impl IfcVertexLoop {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVertexLoop::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.loop_vertex = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVertexPoint: IIfcVertex {
    fn vertex_geometry(&self) -> &EntityRef;
}
#[derive(Default, Debug)]
pub struct IfcVertexPoint {
    vertex_geometry: EntityRef,
}
impl IIfcRepresentationItem for IfcVertexPoint {}
impl IIfcTopologicalRepresentationItem for IfcVertexPoint {}
impl IIfcVertex for IfcVertexPoint {}
impl IIfcVertexPoint for IfcVertexPoint {
    fn vertex_geometry(&self) -> &EntityRef {
        &self.vertex_geometry
    }
}
impl IfcVertexPoint {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVertexPoint::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.vertex_geometry = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVibrationIsolatorType: IIfcDiscreteAccessoryType {
    fn predefined_type(&self) -> &IfcVibrationIsolatorTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcVibrationIsolatorType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcVibrationIsolatorTypeEnum,
}
impl IIfcRoot for IfcVibrationIsolatorType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcVibrationIsolatorType {}
impl IIfcTypeObject for IfcVibrationIsolatorType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcVibrationIsolatorType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcVibrationIsolatorType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcElementComponentType for IfcVibrationIsolatorType {}
impl IIfcDiscreteAccessoryType for IfcVibrationIsolatorType {}
impl IIfcVibrationIsolatorType for IfcVibrationIsolatorType {
    fn predefined_type(&self) -> &IfcVibrationIsolatorTypeEnum {
        &self.predefined_type
    }
}
impl IfcVibrationIsolatorType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVibrationIsolatorType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVirtualElement: IIfcElement {}
#[derive(Default, Debug)]
pub struct IfcVirtualElement {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcVirtualElement {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcVirtualElement {}
impl IIfcObject for IfcVirtualElement {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcVirtualElement {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcVirtualElement {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcVirtualElement for IfcVirtualElement {}
impl IfcVirtualElement {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVirtualElement::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcVirtualGridIntersection {
    fn intersecting_axes(&self) -> &Vec<EntityRef>;
    fn offset_distances(&self) -> &Vec<IfcLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcVirtualGridIntersection {
    intersecting_axes: Vec<EntityRef>,
    offset_distances: Vec<IfcLengthMeasure>,
}
impl IIfcVirtualGridIntersection for IfcVirtualGridIntersection {
    fn intersecting_axes(&self) -> &Vec<EntityRef> {
        &self.intersecting_axes
    }
    fn offset_distances(&self) -> &Vec<IfcLengthMeasure> {
        &self.offset_distances
    }
}
impl IfcVirtualGridIntersection {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcVirtualGridIntersection::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.intersecting_axes = parameter.into(),
                1usize => entity.offset_distances = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWall: IIfcBuildingElement {}
#[derive(Default, Debug)]
pub struct IfcWall {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcWall {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWall {}
impl IIfcObject for IfcWall {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWall {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWall {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWall {}
impl IIfcWall for IfcWall {}
impl IfcWall {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWall::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWallStandardCase: IIfcWall {}
#[derive(Default, Debug)]
pub struct IfcWallStandardCase {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
}
impl IIfcRoot for IfcWallStandardCase {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWallStandardCase {}
impl IIfcObject for IfcWallStandardCase {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWallStandardCase {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWallStandardCase {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWallStandardCase {}
impl IIfcWall for IfcWallStandardCase {}
impl IIfcWallStandardCase for IfcWallStandardCase {}
impl IfcWallStandardCase {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWallStandardCase::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWallType: IIfcBuildingElementType {
    fn predefined_type(&self) -> &IfcWallTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcWallType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcWallTypeEnum,
}
impl IIfcRoot for IfcWallType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWallType {}
impl IIfcTypeObject for IfcWallType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWallType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcWallType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcBuildingElementType for IfcWallType {}
impl IIfcWallType for IfcWallType {
    fn predefined_type(&self) -> &IfcWallTypeEnum {
        &self.predefined_type
    }
}
impl IfcWallType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWallType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWasteTerminalType: IIfcFlowTerminalType {
    fn predefined_type(&self) -> &IfcWasteTerminalTypeEnum;
}
#[derive(Default, Debug)]
pub struct IfcWasteTerminalType {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    element_type: Option<IfcLabel>,
    predefined_type: IfcWasteTerminalTypeEnum,
}
impl IIfcRoot for IfcWasteTerminalType {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWasteTerminalType {}
impl IIfcTypeObject for IfcWasteTerminalType {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWasteTerminalType {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcElementType for IfcWasteTerminalType {
    fn element_type(&self) -> &Option<IfcLabel> {
        &self.element_type
    }
}
impl IIfcDistributionElementType for IfcWasteTerminalType {}
impl IIfcDistributionFlowElementType for IfcWasteTerminalType {}
impl IIfcFlowTerminalType for IfcWasteTerminalType {}
impl IIfcWasteTerminalType for IfcWasteTerminalType {
    fn predefined_type(&self) -> &IfcWasteTerminalTypeEnum {
        &self.predefined_type
    }
}
impl IfcWasteTerminalType {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWasteTerminalType::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.element_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => entity.predefined_type = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWaterProperties: IIfcMaterialProperties {
    fn is_potable(&self) -> Option<bool>;
    fn hardness(&self) -> &Option<IfcIonConcentrationMeasure>;
    fn alkalinity_concentration(&self) -> &Option<IfcIonConcentrationMeasure>;
    fn acidity_concentration(&self) -> &Option<IfcIonConcentrationMeasure>;
    fn impurities_content(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn ph_level(&self) -> &Option<IfcPhMeasure>;
    fn dissolved_solids_content(&self) -> &Option<IfcNormalisedRatioMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcWaterProperties {
    material: EntityRef,
    is_potable: Option<bool>,
    hardness: Option<IfcIonConcentrationMeasure>,
    alkalinity_concentration: Option<IfcIonConcentrationMeasure>,
    acidity_concentration: Option<IfcIonConcentrationMeasure>,
    impurities_content: Option<IfcNormalisedRatioMeasure>,
    ph_level: Option<IfcPhMeasure>,
    dissolved_solids_content: Option<IfcNormalisedRatioMeasure>,
}
impl IIfcMaterialProperties for IfcWaterProperties {
    fn material(&self) -> &EntityRef {
        &self.material
    }
}
impl IIfcWaterProperties for IfcWaterProperties {
    fn is_potable(&self) -> Option<bool> {
        self.is_potable
    }
    fn hardness(&self) -> &Option<IfcIonConcentrationMeasure> {
        &self.hardness
    }
    fn alkalinity_concentration(&self) -> &Option<IfcIonConcentrationMeasure> {
        &self.alkalinity_concentration
    }
    fn acidity_concentration(&self) -> &Option<IfcIonConcentrationMeasure> {
        &self.acidity_concentration
    }
    fn impurities_content(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.impurities_content
    }
    fn ph_level(&self) -> &Option<IfcPhMeasure> {
        &self.ph_level
    }
    fn dissolved_solids_content(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.dissolved_solids_content
    }
}
impl IfcWaterProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWaterProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.material = parameter.into(),
                1usize => {
                    entity.is_potable = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => {
                    entity.hardness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.alkalinity_concentration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.acidity_concentration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.impurities_content = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.ph_level = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.dissolved_solids_content = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindow: IIfcBuildingElement {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcWindow {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    object_placement: Option<EntityRef>,
    representation: Option<EntityRef>,
    tag: Option<IfcIdentifier>,
    overall_height: Option<IfcPositiveLengthMeasure>,
    overall_width: Option<IfcPositiveLengthMeasure>,
}
impl IIfcRoot for IfcWindow {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWindow {}
impl IIfcObject for IfcWindow {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcProduct for IfcWindow {
    fn object_placement(&self) -> &Option<EntityRef> {
        &self.object_placement
    }
    fn representation(&self) -> &Option<EntityRef> {
        &self.representation
    }
}
impl IIfcElement for IfcWindow {
    fn tag(&self) -> &Option<IfcIdentifier> {
        &self.tag
    }
}
impl IIfcBuildingElement for IfcWindow {}
impl IIfcWindow for IfcWindow {
    fn overall_height(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_height
    }
    fn overall_width(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.overall_width
    }
}
impl IfcWindow {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindow::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.object_placement = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.overall_height = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.overall_width = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowLiningProperties: IIfcPropertySetDefinition {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn lining_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn transom_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn mullion_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn first_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn second_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn first_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn second_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcWindowLiningProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    lining_depth: Option<IfcPositiveLengthMeasure>,
    lining_thickness: Option<IfcPositiveLengthMeasure>,
    transom_thickness: Option<IfcPositiveLengthMeasure>,
    mullion_thickness: Option<IfcPositiveLengthMeasure>,
    first_transom_offset: Option<IfcNormalisedRatioMeasure>,
    second_transom_offset: Option<IfcNormalisedRatioMeasure>,
    first_mullion_offset: Option<IfcNormalisedRatioMeasure>,
    second_mullion_offset: Option<IfcNormalisedRatioMeasure>,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcWindowLiningProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcWindowLiningProperties {}
impl IIfcPropertySetDefinition for IfcWindowLiningProperties {}
impl IIfcWindowLiningProperties for IfcWindowLiningProperties {
    fn lining_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.lining_depth
    }
    fn lining_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.lining_thickness
    }
    fn transom_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.transom_thickness
    }
    fn mullion_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.mullion_thickness
    }
    fn first_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.first_transom_offset
    }
    fn second_transom_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.second_transom_offset
    }
    fn first_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.first_mullion_offset
    }
    fn second_mullion_offset(&self) -> &Option<IfcNormalisedRatioMeasure> {
        &self.second_mullion_offset
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcWindowLiningProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowLiningProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.lining_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.lining_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.transom_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.mullion_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.first_transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.second_transom_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.first_mullion_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => {
                    entity.second_mullion_offset = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                12usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowPanelProperties: IIfcPropertySetDefinition {
    fn operation_type(&self) -> &IfcWindowPanelOperationEnum;
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum;
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn shape_aspect_style(&self) -> &Option<EntityRef>;
}
#[derive(Default, Debug)]
pub struct IfcWindowPanelProperties {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    operation_type: IfcWindowPanelOperationEnum,
    panel_position: IfcWindowPanelPositionEnum,
    frame_depth: Option<IfcPositiveLengthMeasure>,
    frame_thickness: Option<IfcPositiveLengthMeasure>,
    shape_aspect_style: Option<EntityRef>,
}
impl IIfcRoot for IfcWindowPanelProperties {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcPropertyDefinition for IfcWindowPanelProperties {}
impl IIfcPropertySetDefinition for IfcWindowPanelProperties {}
impl IIfcWindowPanelProperties for IfcWindowPanelProperties {
    fn operation_type(&self) -> &IfcWindowPanelOperationEnum {
        &self.operation_type
    }
    fn panel_position(&self) -> &IfcWindowPanelPositionEnum {
        &self.panel_position
    }
    fn frame_depth(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_depth
    }
    fn frame_thickness(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.frame_thickness
    }
    fn shape_aspect_style(&self) -> &Option<EntityRef> {
        &self.shape_aspect_style
    }
}
impl IfcWindowPanelProperties {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowPanelProperties::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => entity.operation_type = parameter.into(),
                5usize => entity.panel_position = parameter.into(),
                6usize => {
                    entity.frame_depth = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.frame_thickness = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.shape_aspect_style = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWindowStyle: IIfcTypeProduct {
    fn construction_type(&self) -> &IfcWindowStyleConstructionEnum;
    fn operation_type(&self) -> &IfcWindowStyleOperationEnum;
    fn parameter_takes_precedence(&self) -> bool;
    fn sizeable(&self) -> bool;
}
#[derive(Default, Debug)]
pub struct IfcWindowStyle {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    applicable_occurrence: Option<IfcLabel>,
    has_property_sets: Option<HashSet<EntityRef>>,
    representation_maps: Option<Vec<EntityRef>>,
    tag: Option<IfcLabel>,
    construction_type: IfcWindowStyleConstructionEnum,
    operation_type: IfcWindowStyleOperationEnum,
    parameter_takes_precedence: bool,
    sizeable: bool,
}
impl IIfcRoot for IfcWindowStyle {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWindowStyle {}
impl IIfcTypeObject for IfcWindowStyle {
    fn applicable_occurrence(&self) -> &Option<IfcLabel> {
        &self.applicable_occurrence
    }
    fn has_property_sets(&self) -> &Option<HashSet<EntityRef>> {
        &self.has_property_sets
    }
}
impl IIfcTypeProduct for IfcWindowStyle {
    fn representation_maps(&self) -> &Option<Vec<EntityRef>> {
        &self.representation_maps
    }
    fn tag(&self) -> &Option<IfcLabel> {
        &self.tag
    }
}
impl IIfcWindowStyle for IfcWindowStyle {
    fn construction_type(&self) -> &IfcWindowStyleConstructionEnum {
        &self.construction_type
    }
    fn operation_type(&self) -> &IfcWindowStyleOperationEnum {
        &self.operation_type
    }
    fn parameter_takes_precedence(&self) -> bool {
        self.parameter_takes_precedence
    }
    fn sizeable(&self) -> bool {
        self.sizeable
    }
}
impl IfcWindowStyle {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWindowStyle::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.applicable_occurrence = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => {
                    entity.has_property_sets = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                6usize => {
                    entity.representation_maps = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                7usize => {
                    entity.tag = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => entity.construction_type = parameter.into(),
                9usize => entity.operation_type = parameter.into(),
                10usize => entity.parameter_takes_precedence = parameter.into(),
                11usize => entity.sizeable = parameter.into(),
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWorkControl: IIfcControl {
    fn identifier(&self) -> &IfcIdentifier;
    fn creation_date(&self) -> &EntityRef;
    fn creators(&self) -> &Option<HashSet<EntityRef>>;
    fn purpose(&self) -> &Option<IfcLabel>;
    fn duration(&self) -> &Option<IfcTimeMeasure>;
    fn total_float(&self) -> &Option<IfcTimeMeasure>;
    fn start_time(&self) -> &EntityRef;
    fn finish_time(&self) -> &Option<EntityRef>;
    fn work_control_type(&self) -> &Option<IfcWorkControlTypeEnum>;
    fn user_defined_control_type(&self) -> &Option<IfcLabel>;
}
pub trait IIfcWorkPlan: IIfcWorkControl {}
#[derive(Default, Debug)]
pub struct IfcWorkPlan {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identifier: IfcIdentifier,
    creation_date: EntityRef,
    creators: Option<HashSet<EntityRef>>,
    purpose: Option<IfcLabel>,
    duration: Option<IfcTimeMeasure>,
    total_float: Option<IfcTimeMeasure>,
    start_time: EntityRef,
    finish_time: Option<EntityRef>,
    work_control_type: Option<IfcWorkControlTypeEnum>,
    user_defined_control_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcWorkPlan {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWorkPlan {}
impl IIfcObject for IfcWorkPlan {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcWorkPlan {}
impl IIfcWorkControl for IfcWorkPlan {
    fn identifier(&self) -> &IfcIdentifier {
        &self.identifier
    }
    fn creation_date(&self) -> &EntityRef {
        &self.creation_date
    }
    fn creators(&self) -> &Option<HashSet<EntityRef>> {
        &self.creators
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
    fn duration(&self) -> &Option<IfcTimeMeasure> {
        &self.duration
    }
    fn total_float(&self) -> &Option<IfcTimeMeasure> {
        &self.total_float
    }
    fn start_time(&self) -> &EntityRef {
        &self.start_time
    }
    fn finish_time(&self) -> &Option<EntityRef> {
        &self.finish_time
    }
    fn work_control_type(&self) -> &Option<IfcWorkControlTypeEnum> {
        &self.work_control_type
    }
    fn user_defined_control_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_control_type
    }
}
impl IIfcWorkPlan for IfcWorkPlan {}
impl IfcWorkPlan {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkPlan::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.identifier = parameter.into(),
                6usize => entity.creation_date = parameter.into(),
                7usize => {
                    entity.creators = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.start_time = parameter.into(),
                12usize => {
                    entity.finish_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.work_control_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.user_defined_control_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcWorkSchedule: IIfcWorkControl {}
#[derive(Default, Debug)]
pub struct IfcWorkSchedule {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
    identifier: IfcIdentifier,
    creation_date: EntityRef,
    creators: Option<HashSet<EntityRef>>,
    purpose: Option<IfcLabel>,
    duration: Option<IfcTimeMeasure>,
    total_float: Option<IfcTimeMeasure>,
    start_time: EntityRef,
    finish_time: Option<EntityRef>,
    work_control_type: Option<IfcWorkControlTypeEnum>,
    user_defined_control_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcWorkSchedule {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcWorkSchedule {}
impl IIfcObject for IfcWorkSchedule {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcControl for IfcWorkSchedule {}
impl IIfcWorkControl for IfcWorkSchedule {
    fn identifier(&self) -> &IfcIdentifier {
        &self.identifier
    }
    fn creation_date(&self) -> &EntityRef {
        &self.creation_date
    }
    fn creators(&self) -> &Option<HashSet<EntityRef>> {
        &self.creators
    }
    fn purpose(&self) -> &Option<IfcLabel> {
        &self.purpose
    }
    fn duration(&self) -> &Option<IfcTimeMeasure> {
        &self.duration
    }
    fn total_float(&self) -> &Option<IfcTimeMeasure> {
        &self.total_float
    }
    fn start_time(&self) -> &EntityRef {
        &self.start_time
    }
    fn finish_time(&self) -> &Option<EntityRef> {
        &self.finish_time
    }
    fn work_control_type(&self) -> &Option<IfcWorkControlTypeEnum> {
        &self.work_control_type
    }
    fn user_defined_control_type(&self) -> &Option<IfcLabel> {
        &self.user_defined_control_type
    }
}
impl IIfcWorkSchedule for IfcWorkSchedule {}
impl IfcWorkSchedule {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcWorkSchedule::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                5usize => entity.identifier = parameter.into(),
                6usize => entity.creation_date = parameter.into(),
                7usize => {
                    entity.creators = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.purpose = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                9usize => {
                    entity.duration = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                10usize => {
                    entity.total_float = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                11usize => entity.start_time = parameter.into(),
                12usize => {
                    entity.finish_time = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                13usize => {
                    entity.work_control_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                14usize => {
                    entity.user_defined_control_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcZShapeProfileDef: IIfcParameterizedProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure;
    fn flange_width(&self) -> &IfcPositiveLengthMeasure;
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure;
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
    fn edge_radius(&self) -> &Option<IfcPositiveLengthMeasure>;
}
#[derive(Default, Debug)]
pub struct IfcZShapeProfileDef {
    profile_type: IfcProfileTypeEnum,
    profile_name: Option<IfcLabel>,
    position: EntityRef,
    depth: IfcPositiveLengthMeasure,
    flange_width: IfcPositiveLengthMeasure,
    web_thickness: IfcPositiveLengthMeasure,
    flange_thickness: IfcPositiveLengthMeasure,
    fillet_radius: Option<IfcPositiveLengthMeasure>,
    edge_radius: Option<IfcPositiveLengthMeasure>,
}
impl IIfcProfileDef for IfcZShapeProfileDef {
    fn profile_type(&self) -> &IfcProfileTypeEnum {
        &self.profile_type
    }
    fn profile_name(&self) -> &Option<IfcLabel> {
        &self.profile_name
    }
}
impl IIfcParameterizedProfileDef for IfcZShapeProfileDef {
    fn position(&self) -> &EntityRef {
        &self.position
    }
}
impl IIfcZShapeProfileDef for IfcZShapeProfileDef {
    fn depth(&self) -> &IfcPositiveLengthMeasure {
        &self.depth
    }
    fn flange_width(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_width
    }
    fn web_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.web_thickness
    }
    fn flange_thickness(&self) -> &IfcPositiveLengthMeasure {
        &self.flange_thickness
    }
    fn fillet_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.fillet_radius
    }
    fn edge_radius(&self) -> &Option<IfcPositiveLengthMeasure> {
        &self.edge_radius
    }
}
impl IfcZShapeProfileDef {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcZShapeProfileDef::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.profile_type = parameter.into(),
                1usize => {
                    entity.profile_name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                2usize => entity.position = parameter.into(),
                3usize => entity.depth = parameter.into(),
                4usize => entity.flange_width = parameter.into(),
                5usize => entity.web_thickness = parameter.into(),
                6usize => entity.flange_thickness = parameter.into(),
                7usize => {
                    entity.fillet_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                8usize => {
                    entity.edge_radius = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
pub trait IIfcZone: IIfcGroup {}
#[derive(Default, Debug)]
pub struct IfcZone {
    global_id: IfcGloballyUniqueId,
    owner_history: EntityRef,
    name: Option<IfcLabel>,
    description: Option<IfcText>,
    object_type: Option<IfcLabel>,
}
impl IIfcRoot for IfcZone {
    fn global_id(&self) -> &IfcGloballyUniqueId {
        &self.global_id
    }
    fn owner_history(&self) -> &EntityRef {
        &self.owner_history
    }
    fn name(&self) -> &Option<IfcLabel> {
        &self.name
    }
    fn description(&self) -> &Option<IfcText> {
        &self.description
    }
}
impl IIfcObjectDefinition for IfcZone {}
impl IIfcObject for IfcZone {
    fn object_type(&self) -> &Option<IfcLabel> {
        &self.object_type
    }
}
impl IIfcGroup for IfcZone {}
impl IIfcZone for IfcZone {}
impl IfcZone {
    pub fn form_parameters(parameters: Vec<Parameter>) -> Self {
        let mut entity = IfcZone::default();
        for (index, parameter) in parameters.into_iter().enumerate() {
            match index {
                0usize => entity.global_id = parameter.into(),
                1usize => entity.owner_history = parameter.into(),
                2usize => {
                    entity.name = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                3usize => {
                    entity.description = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                4usize => {
                    entity.object_type = if parameter.is_null() {
                        None
                    } else {
                        Some(parameter.into())
                    }
                }
                _ => {}
            }
        }
        entity
    }
}
use std::any::{Any, TypeId};
use std::collections::{BTreeMap, HashMap};
pub struct Ifc2x3Reader {
    pub entities: BTreeMap<i64, Box<dyn Any>>,
    pub type_ids: HashMap<TypeId, Vec<i64>>,
    pub type_names: HashMap<TypeId, &'static str>,
    empty: Vec<i64>,
}
impl Ifc2x3Reader {
    pub fn new() -> Self {
        Ifc2x3Reader {
            entities: BTreeMap::new(),
            type_ids: HashMap::new(),
            type_names: HashMap::new(),
            empty: Vec::new(),
        }
    }
    pub fn add_entity<T: Any>(&mut self, id: i64, entity: T) {
        let type_id = entity.type_id();
        self.entities.insert(id, Box::new(entity));
        self.type_ids.entry(type_id).or_insert(vec![]).push(id);
        self.type_names.entry(type_id).or_insert(std::any::type_name::<T>());
    }
    pub fn get_entity<T: Any>(&self, entity_ref: EntityRef) -> Option<&T> {
        self.entities
            .get(&entity_ref.0)
            .map(|entity| entity.downcast_ref::<T>())
            .flatten()
    }
    pub fn get_entities<T: Any>(&self) -> impl Iterator<Item = &T> {
        let type_id = TypeId::of::<T>();
        self.type_ids
            .get(&type_id)
            .unwrap_or(&self.empty)
            .iter()
            .map(move |id| self.entities[id].downcast_ref::<T>().unwrap())
    }
    pub fn get_type_name(&self, id: i64) -> &'static str {
        let type_id = (*self.entities[&id]).type_id();
        self.type_names[&type_id]
    }
}
impl StepReader for Ifc2x3Reader {
    fn read_simple_entity(&mut self, id: i64, typed_parameter: TypedParameter) {
        match typed_parameter.type_name.as_str() {
            "IFC2DCOMPOSITECURVE" => {
                let entity = Ifc2DCompositeCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCACTIONREQUEST" => {
                let entity = IfcActionRequest::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCACTOR" => {
                let entity = IfcActor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCACTORROLE" => {
                let entity = IfcActorRole::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCACTUATORTYPE" => {
                let entity = IfcActuatorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAIRTERMINALBOXTYPE" => {
                let entity = IfcAirTerminalBoxType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAIRTERMINALTYPE" => {
                let entity = IfcAirTerminalType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAIRTOAIRHEATRECOVERYTYPE" => {
                let entity = IfcAirToAirHeatRecoveryType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCALARMTYPE" => {
                let entity = IfcAlarmType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANGULARDIMENSION" => {
                let entity = IfcAngularDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATION" => {
                let entity = IfcAnnotation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONCURVEOCCURRENCE" => {
                let entity = IfcAnnotationCurveOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONFILLAREA" => {
                let entity = IfcAnnotationFillArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONFILLAREAOCCURRENCE" => {
                let entity = IfcAnnotationFillAreaOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONSURFACE" => {
                let entity = IfcAnnotationSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONSURFACEOCCURRENCE" => {
                let entity = IfcAnnotationSurfaceOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONSYMBOLOCCURRENCE" => {
                let entity = IfcAnnotationSymbolOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCANNOTATIONTEXTOCCURRENCE" => {
                let entity = IfcAnnotationTextOccurrence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAPPLICATION" => {
                let entity = IfcApplication::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAPPLIEDVALUERELATIONSHIP" => {
                let entity = IfcAppliedValueRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAPPROVAL" => {
                let entity = IfcApproval::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAPPROVALACTORRELATIONSHIP" => {
                let entity = IfcApprovalActorRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAPPROVALPROPERTYRELATIONSHIP" => {
                let entity = IfcApprovalPropertyRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAPPROVALRELATIONSHIP" => {
                let entity = IfcApprovalRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCARBITRARYCLOSEDPROFILEDEF" => {
                let entity = IfcArbitraryClosedProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCARBITRARYOPENPROFILEDEF" => {
                let entity = IfcArbitraryOpenProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCARBITRARYPROFILEDEFWITHVOIDS" => {
                let entity = IfcArbitraryProfileDefWithVoids::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCASSET" => {
                let entity = IfcAsset::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCASYMMETRICISHAPEPROFILEDEF" => {
                let entity = IfcAsymmetricIShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAXIS1PLACEMENT" => {
                let entity = IfcAxis1Placement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAXIS2PLACEMENT2D" => {
                let entity = IfcAxis2Placement2D::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCAXIS2PLACEMENT3D" => {
                let entity = IfcAxis2Placement3D::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBEAM" => {
                let entity = IfcBeam::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBEAMTYPE" => {
                let entity = IfcBeamType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBEZIERCURVE" => {
                let entity = IfcBezierCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBLOBTEXTURE" => {
                let entity = IfcBlobTexture::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBLOCK" => {
                let entity = IfcBlock::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOILERTYPE" => {
                let entity = IfcBoilerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOOLEANCLIPPINGRESULT" => {
                let entity = IfcBooleanClippingResult::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOOLEANRESULT" => {
                let entity = IfcBooleanResult::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOUNDARYEDGECONDITION" => {
                let entity = IfcBoundaryEdgeCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOUNDARYFACECONDITION" => {
                let entity = IfcBoundaryFaceCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOUNDARYNODECONDITION" => {
                let entity = IfcBoundaryNodeCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOUNDARYNODECONDITIONWARPING" => {
                let entity = IfcBoundaryNodeConditionWarping::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOUNDEDSURFACE" => {
                let entity = IfcBoundedSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOUNDINGBOX" => {
                let entity = IfcBoundingBox::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBOXEDHALFSPACE" => {
                let entity = IfcBoxedHalfSpace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBUILDING" => {
                let entity = IfcBuilding::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBUILDINGELEMENTPART" => {
                let entity = IfcBuildingElementPart::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBUILDINGELEMENTPROXY" => {
                let entity = IfcBuildingElementProxy::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBUILDINGELEMENTPROXYTYPE" => {
                let entity = IfcBuildingElementProxyType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCBUILDINGSTOREY" => {
                let entity = IfcBuildingStorey::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCSHAPEPROFILEDEF" => {
                let entity = IfcCShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCABLECARRIERFITTINGTYPE" => {
                let entity = IfcCableCarrierFittingType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCABLECARRIERSEGMENTTYPE" => {
                let entity = IfcCableCarrierSegmentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCABLESEGMENTTYPE" => {
                let entity = IfcCableSegmentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCALENDARDATE" => {
                let entity = IfcCalendarDate::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCARTESIANPOINT" => {
                let entity = IfcCartesianPoint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR2D" => {
                let entity = IfcCartesianTransformationOperator2D::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM" => {
                let entity =
                    IfcCartesianTransformationOperator2DnonUniform::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR3D" => {
                let entity = IfcCartesianTransformationOperator3D::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM" => {
                let entity =
                    IfcCartesianTransformationOperator3DnonUniform::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCENTERLINEPROFILEDEF" => {
                let entity = IfcCenterLineProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCHAMFEREDGEFEATURE" => {
                let entity = IfcChamferEdgeFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCHILLERTYPE" => {
                let entity = IfcChillerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCIRCLE" => {
                let entity = IfcCircle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCIRCLEHOLLOWPROFILEDEF" => {
                let entity = IfcCircleHollowProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCIRCLEPROFILEDEF" => {
                let entity = IfcCircleProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLASSIFICATION" => {
                let entity = IfcClassification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLASSIFICATIONITEM" => {
                let entity = IfcClassificationItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLASSIFICATIONITEMRELATIONSHIP" => {
                let entity = IfcClassificationItemRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLASSIFICATIONNOTATION" => {
                let entity = IfcClassificationNotation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLASSIFICATIONNOTATIONFACET" => {
                let entity = IfcClassificationNotationFacet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLASSIFICATIONREFERENCE" => {
                let entity = IfcClassificationReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCLOSEDSHELL" => {
                let entity = IfcClosedShell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOILTYPE" => {
                let entity = IfcCoilType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOLOURRGB" => {
                let entity = IfcColourRgb::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOLUMN" => {
                let entity = IfcColumn::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOLUMNTYPE" => {
                let entity = IfcColumnType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOMPLEXPROPERTY" => {
                let entity = IfcComplexProperty::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOMPOSITECURVE" => {
                let entity = IfcCompositeCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOMPOSITECURVESEGMENT" => {
                let entity = IfcCompositeCurveSegment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOMPOSITEPROFILEDEF" => {
                let entity = IfcCompositeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOMPRESSORTYPE" => {
                let entity = IfcCompressorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONDENSERTYPE" => {
                let entity = IfcCondenserType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONDITION" => {
                let entity = IfcCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONDITIONCRITERION" => {
                let entity = IfcConditionCriterion::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONNECTEDFACESET" => {
                let entity = IfcConnectedFaceSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONNECTIONCURVEGEOMETRY" => {
                let entity = IfcConnectionCurveGeometry::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONNECTIONPOINTECCENTRICITY" => {
                let entity = IfcConnectionPointEccentricity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONNECTIONPOINTGEOMETRY" => {
                let entity = IfcConnectionPointGeometry::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONNECTIONPORTGEOMETRY" => {
                let entity = IfcConnectionPortGeometry::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONNECTIONSURFACEGEOMETRY" => {
                let entity = IfcConnectionSurfaceGeometry::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONSTRAINTAGGREGATIONRELATIONSHIP" => {
                let entity = IfcConstraintAggregationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP" => {
                let entity = IfcConstraintClassificationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONSTRAINTRELATIONSHIP" => {
                let entity = IfcConstraintRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONSTRUCTIONEQUIPMENTRESOURCE" => {
                let entity = IfcConstructionEquipmentResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONSTRUCTIONMATERIALRESOURCE" => {
                let entity = IfcConstructionMaterialResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONSTRUCTIONPRODUCTRESOURCE" => {
                let entity = IfcConstructionProductResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONTEXTDEPENDENTUNIT" => {
                let entity = IfcContextDependentUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONTROLLERTYPE" => {
                let entity = IfcControllerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCONVERSIONBASEDUNIT" => {
                let entity = IfcConversionBasedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOOLEDBEAMTYPE" => {
                let entity = IfcCooledBeamType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOOLINGTOWERTYPE" => {
                let entity = IfcCoolingTowerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOORDINATEDUNIVERSALTIMEOFFSET" => {
                let entity = IfcCoordinatedUniversalTimeOffset::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOSTITEM" => {
                let entity = IfcCostItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOSTSCHEDULE" => {
                let entity = IfcCostSchedule::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOSTVALUE" => {
                let entity = IfcCostValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOVERING" => {
                let entity = IfcCovering::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCOVERINGTYPE" => {
                let entity = IfcCoveringType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCRANERAILASHAPEPROFILEDEF" => {
                let entity = IfcCraneRailAShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCRANERAILFSHAPEPROFILEDEF" => {
                let entity = IfcCraneRailFShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCREWRESOURCE" => {
                let entity = IfcCrewResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCSGSOLID" => {
                let entity = IfcCsgSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURRENCYRELATIONSHIP" => {
                let entity = IfcCurrencyRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURTAINWALL" => {
                let entity = IfcCurtainWall::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURTAINWALLTYPE" => {
                let entity = IfcCurtainWallType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURVEBOUNDEDPLANE" => {
                let entity = IfcCurveBoundedPlane::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURVESTYLE" => {
                let entity = IfcCurveStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURVESTYLEFONT" => {
                let entity = IfcCurveStyleFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURVESTYLEFONTANDSCALING" => {
                let entity = IfcCurveStyleFontAndScaling::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCCURVESTYLEFONTPATTERN" => {
                let entity = IfcCurveStyleFontPattern::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDAMPERTYPE" => {
                let entity = IfcDamperType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDATEANDTIME" => {
                let entity = IfcDateAndTime::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDEFINEDSYMBOL" => {
                let entity = IfcDefinedSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDERIVEDPROFILEDEF" => {
                let entity = IfcDerivedProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDERIVEDUNIT" => {
                let entity = IfcDerivedUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDERIVEDUNITELEMENT" => {
                let entity = IfcDerivedUnitElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIAMETERDIMENSION" => {
                let entity = IfcDiameterDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIMENSIONCALLOUTRELATIONSHIP" => {
                let entity = IfcDimensionCalloutRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIMENSIONCURVE" => {
                let entity = IfcDimensionCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIMENSIONCURVEDIRECTEDCALLOUT" => {
                let entity = IfcDimensionCurveDirectedCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIMENSIONCURVETERMINATOR" => {
                let entity = IfcDimensionCurveTerminator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIMENSIONPAIR" => {
                let entity = IfcDimensionPair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIMENSIONALEXPONENTS" => {
                let entity = IfcDimensionalExponents::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDIRECTION" => {
                let entity = IfcDirection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISCRETEACCESSORY" => {
                let entity = IfcDiscreteAccessory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISCRETEACCESSORYTYPE" => {
                let entity = IfcDiscreteAccessoryType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONCHAMBERELEMENT" => {
                let entity = IfcDistributionChamberElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONCHAMBERELEMENTTYPE" => {
                let entity = IfcDistributionChamberElementType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONCONTROLELEMENT" => {
                let entity = IfcDistributionControlElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONELEMENT" => {
                let entity = IfcDistributionElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONELEMENTTYPE" => {
                let entity = IfcDistributionElementType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONFLOWELEMENT" => {
                let entity = IfcDistributionFlowElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDISTRIBUTIONPORT" => {
                let entity = IfcDistributionPort::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOCUMENTELECTRONICFORMAT" => {
                let entity = IfcDocumentElectronicFormat::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOCUMENTINFORMATION" => {
                let entity = IfcDocumentInformation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOCUMENTINFORMATIONRELATIONSHIP" => {
                let entity = IfcDocumentInformationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOCUMENTREFERENCE" => {
                let entity = IfcDocumentReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOOR" => {
                let entity = IfcDoor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOORLININGPROPERTIES" => {
                let entity = IfcDoorLiningProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOORPANELPROPERTIES" => {
                let entity = IfcDoorPanelProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDOORSTYLE" => {
                let entity = IfcDoorStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDRAUGHTINGCALLOUT" => {
                let entity = IfcDraughtingCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDRAUGHTINGCALLOUTRELATIONSHIP" => {
                let entity = IfcDraughtingCalloutRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDRAUGHTINGPREDEFINEDCOLOUR" => {
                let entity = IfcDraughtingPreDefinedColour::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDRAUGHTINGPREDEFINEDCURVEFONT" => {
                let entity = IfcDraughtingPreDefinedCurveFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDRAUGHTINGPREDEFINEDTEXTFONT" => {
                let entity = IfcDraughtingPreDefinedTextFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDUCTFITTINGTYPE" => {
                let entity = IfcDuctFittingType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDUCTSEGMENTTYPE" => {
                let entity = IfcDuctSegmentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCDUCTSILENCERTYPE" => {
                let entity = IfcDuctSilencerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEDGE" => {
                let entity = IfcEdge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEDGECURVE" => {
                let entity = IfcEdgeCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEDGELOOP" => {
                let entity = IfcEdgeLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICAPPLIANCETYPE" => {
                let entity = IfcElectricApplianceType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICDISTRIBUTIONPOINT" => {
                let entity = IfcElectricDistributionPoint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICFLOWSTORAGEDEVICETYPE" => {
                let entity = IfcElectricFlowStorageDeviceType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICGENERATORTYPE" => {
                let entity = IfcElectricGeneratorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICHEATERTYPE" => {
                let entity = IfcElectricHeaterType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICMOTORTYPE" => {
                let entity = IfcElectricMotorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICTIMECONTROLTYPE" => {
                let entity = IfcElectricTimeControlType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICALBASEPROPERTIES" => {
                let entity = IfcElectricalBaseProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICALCIRCUIT" => {
                let entity = IfcElectricalCircuit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELECTRICALELEMENT" => {
                let entity = IfcElectricalElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELEMENTASSEMBLY" => {
                let entity = IfcElementAssembly::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELEMENTQUANTITY" => {
                let entity = IfcElementQuantity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELLIPSE" => {
                let entity = IfcEllipse::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCELLIPSEPROFILEDEF" => {
                let entity = IfcEllipseProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCENERGYCONVERSIONDEVICE" => {
                let entity = IfcEnergyConversionDevice::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCENERGYPROPERTIES" => {
                let entity = IfcEnergyProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCENVIRONMENTALIMPACTVALUE" => {
                let entity = IfcEnvironmentalImpactValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEQUIPMENTELEMENT" => {
                let entity = IfcEquipmentElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEQUIPMENTSTANDARD" => {
                let entity = IfcEquipmentStandard::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEVAPORATIVECOOLERTYPE" => {
                let entity = IfcEvaporativeCoolerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEVAPORATORTYPE" => {
                let entity = IfcEvaporatorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEXTENDEDMATERIALPROPERTIES" => {
                let entity = IfcExtendedMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEXTERNALLYDEFINEDHATCHSTYLE" => {
                let entity = IfcExternallyDefinedHatchStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEXTERNALLYDEFINEDSURFACESTYLE" => {
                let entity = IfcExternallyDefinedSurfaceStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEXTERNALLYDEFINEDSYMBOL" => {
                let entity = IfcExternallyDefinedSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEXTERNALLYDEFINEDTEXTFONT" => {
                let entity = IfcExternallyDefinedTextFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCEXTRUDEDAREASOLID" => {
                let entity = IfcExtrudedAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACE" => {
                let entity = IfcFace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACEBASEDSURFACEMODEL" => {
                let entity = IfcFaceBasedSurfaceModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACEBOUND" => {
                let entity = IfcFaceBound::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACEOUTERBOUND" => {
                let entity = IfcFaceOuterBound::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACESURFACE" => {
                let entity = IfcFaceSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACETEDBREP" => {
                let entity = IfcFacetedBrep::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFACETEDBREPWITHVOIDS" => {
                let entity = IfcFacetedBrepWithVoids::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFAILURECONNECTIONCONDITION" => {
                let entity = IfcFailureConnectionCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFANTYPE" => {
                let entity = IfcFanType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFASTENER" => {
                let entity = IfcFastener::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFASTENERTYPE" => {
                let entity = IfcFastenerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFILLAREASTYLE" => {
                let entity = IfcFillAreaStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFILLAREASTYLEHATCHING" => {
                let entity = IfcFillAreaStyleHatching::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFILLAREASTYLETILESYMBOLWITHSTYLE" => {
                let entity = IfcFillAreaStyleTileSymbolWithStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFILLAREASTYLETILES" => {
                let entity = IfcFillAreaStyleTiles::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFILTERTYPE" => {
                let entity = IfcFilterType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFIRESUPPRESSIONTERMINALTYPE" => {
                let entity = IfcFireSuppressionTerminalType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWCONTROLLER" => {
                let entity = IfcFlowController::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWFITTING" => {
                let entity = IfcFlowFitting::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWINSTRUMENTTYPE" => {
                let entity = IfcFlowInstrumentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWMETERTYPE" => {
                let entity = IfcFlowMeterType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWMOVINGDEVICE" => {
                let entity = IfcFlowMovingDevice::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWSEGMENT" => {
                let entity = IfcFlowSegment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWSTORAGEDEVICE" => {
                let entity = IfcFlowStorageDevice::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWTERMINAL" => {
                let entity = IfcFlowTerminal::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLOWTREATMENTDEVICE" => {
                let entity = IfcFlowTreatmentDevice::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFLUIDFLOWPROPERTIES" => {
                let entity = IfcFluidFlowProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFOOTING" => {
                let entity = IfcFooting::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFUELPROPERTIES" => {
                let entity = IfcFuelProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFURNISHINGELEMENT" => {
                let entity = IfcFurnishingElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFURNISHINGELEMENTTYPE" => {
                let entity = IfcFurnishingElementType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFURNITURESTANDARD" => {
                let entity = IfcFurnitureStandard::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCFURNITURETYPE" => {
                let entity = IfcFurnitureType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGASTERMINALTYPE" => {
                let entity = IfcGasTerminalType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGENERALMATERIALPROPERTIES" => {
                let entity = IfcGeneralMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGENERALPROFILEPROPERTIES" => {
                let entity = IfcGeneralProfileProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGEOMETRICCURVESET" => {
                let entity = IfcGeometricCurveSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGEOMETRICREPRESENTATIONCONTEXT" => {
                let entity = IfcGeometricRepresentationContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGEOMETRICREPRESENTATIONSUBCONTEXT" => {
                let entity = IfcGeometricRepresentationSubContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGEOMETRICSET" => {
                let entity = IfcGeometricSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGRID" => {
                let entity = IfcGrid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGRIDAXIS" => {
                let entity = IfcGridAxis::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGRIDPLACEMENT" => {
                let entity = IfcGridPlacement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCGROUP" => {
                let entity = IfcGroup::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCHALFSPACESOLID" => {
                let entity = IfcHalfSpaceSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCHEATEXCHANGERTYPE" => {
                let entity = IfcHeatExchangerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCHUMIDIFIERTYPE" => {
                let entity = IfcHumidifierType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCHYGROSCOPICMATERIALPROPERTIES" => {
                let entity = IfcHygroscopicMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCISHAPEPROFILEDEF" => {
                let entity = IfcIShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCIMAGETEXTURE" => {
                let entity = IfcImageTexture::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCINVENTORY" => {
                let entity = IfcInventory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCIRREGULARTIMESERIES" => {
                let entity = IfcIrregularTimeSeries::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCIRREGULARTIMESERIESVALUE" => {
                let entity = IfcIrregularTimeSeriesValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCJUNCTIONBOXTYPE" => {
                let entity = IfcJunctionBoxType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLSHAPEPROFILEDEF" => {
                let entity = IfcLShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLABORRESOURCE" => {
                let entity = IfcLaborResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLAMPTYPE" => {
                let entity = IfcLampType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIBRARYINFORMATION" => {
                let entity = IfcLibraryInformation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIBRARYREFERENCE" => {
                let entity = IfcLibraryReference::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTDISTRIBUTIONDATA" => {
                let entity = IfcLightDistributionData::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTFIXTURETYPE" => {
                let entity = IfcLightFixtureType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTINTENSITYDISTRIBUTION" => {
                let entity = IfcLightIntensityDistribution::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTSOURCEAMBIENT" => {
                let entity = IfcLightSourceAmbient::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTSOURCEDIRECTIONAL" => {
                let entity = IfcLightSourceDirectional::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTSOURCEGONIOMETRIC" => {
                let entity = IfcLightSourceGoniometric::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTSOURCEPOSITIONAL" => {
                let entity = IfcLightSourcePositional::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLIGHTSOURCESPOT" => {
                let entity = IfcLightSourceSpot::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLINE" => {
                let entity = IfcLine::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLINEARDIMENSION" => {
                let entity = IfcLinearDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLOCALPLACEMENT" => {
                let entity = IfcLocalPlacement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLOCALTIME" => {
                let entity = IfcLocalTime::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCLOOP" => {
                let entity = IfcLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMAPPEDITEM" => {
                let entity = IfcMappedItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIAL" => {
                let entity = IfcMaterial::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIALCLASSIFICATIONRELATIONSHIP" => {
                let entity = IfcMaterialClassificationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIALDEFINITIONREPRESENTATION" => {
                let entity = IfcMaterialDefinitionRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIALLAYER" => {
                let entity = IfcMaterialLayer::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIALLAYERSET" => {
                let entity = IfcMaterialLayerSet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIALLAYERSETUSAGE" => {
                let entity = IfcMaterialLayerSetUsage::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMATERIALLIST" => {
                let entity = IfcMaterialList::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMEASUREWITHUNIT" => {
                let entity = IfcMeasureWithUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMECHANICALCONCRETEMATERIALPROPERTIES" => {
                let entity = IfcMechanicalConcreteMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMECHANICALFASTENER" => {
                let entity = IfcMechanicalFastener::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMECHANICALFASTENERTYPE" => {
                let entity = IfcMechanicalFastenerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMECHANICALMATERIALPROPERTIES" => {
                let entity = IfcMechanicalMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMECHANICALSTEELMATERIALPROPERTIES" => {
                let entity = IfcMechanicalSteelMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMEMBER" => {
                let entity = IfcMember::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMEMBERTYPE" => {
                let entity = IfcMemberType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMETRIC" => {
                let entity = IfcMetric::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMONETARYUNIT" => {
                let entity = IfcMonetaryUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMOTORCONNECTIONTYPE" => {
                let entity = IfcMotorConnectionType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCMOVE" => {
                let entity = IfcMove::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOBJECTIVE" => {
                let entity = IfcObjective::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOCCUPANT" => {
                let entity = IfcOccupant::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOFFSETCURVE2D" => {
                let entity = IfcOffsetCurve2D::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOFFSETCURVE3D" => {
                let entity = IfcOffsetCurve3D::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCONEDIRECTIONREPEATFACTOR" => {
                let entity = IfcOneDirectionRepeatFactor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOPENSHELL" => {
                let entity = IfcOpenShell::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOPENINGELEMENT" => {
                let entity = IfcOpeningElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOPTICALMATERIALPROPERTIES" => {
                let entity = IfcOpticalMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCORDERACTION" => {
                let entity = IfcOrderAction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCORGANIZATION" => {
                let entity = IfcOrganization::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCORGANIZATIONRELATIONSHIP" => {
                let entity = IfcOrganizationRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCORIENTEDEDGE" => {
                let entity = IfcOrientedEdge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOUTLETTYPE" => {
                let entity = IfcOutletType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCOWNERHISTORY" => {
                let entity = IfcOwnerHistory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPATH" => {
                let entity = IfcPath::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPERFORMANCEHISTORY" => {
                let entity = IfcPerformanceHistory::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPERMEABLECOVERINGPROPERTIES" => {
                let entity = IfcPermeableCoveringProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPERMIT" => {
                let entity = IfcPermit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPERSON" => {
                let entity = IfcPerson::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPERSONANDORGANIZATION" => {
                let entity = IfcPersonAndOrganization::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPHYSICALCOMPLEXQUANTITY" => {
                let entity = IfcPhysicalComplexQuantity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPILE" => {
                let entity = IfcPile::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPIPEFITTINGTYPE" => {
                let entity = IfcPipeFittingType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPIPESEGMENTTYPE" => {
                let entity = IfcPipeSegmentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPIXELTEXTURE" => {
                let entity = IfcPixelTexture::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPLANARBOX" => {
                let entity = IfcPlanarBox::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPLANAREXTENT" => {
                let entity = IfcPlanarExtent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPLANE" => {
                let entity = IfcPlane::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPLATE" => {
                let entity = IfcPlate::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPLATETYPE" => {
                let entity = IfcPlateType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPOINTONCURVE" => {
                let entity = IfcPointOnCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPOINTONSURFACE" => {
                let entity = IfcPointOnSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPOLYLOOP" => {
                let entity = IfcPolyLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPOLYGONALBOUNDEDHALFSPACE" => {
                let entity = IfcPolygonalBoundedHalfSpace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPOLYLINE" => {
                let entity = IfcPolyline::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPOSTALADDRESS" => {
                let entity = IfcPostalAddress::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPREDEFINEDDIMENSIONSYMBOL" => {
                let entity = IfcPreDefinedDimensionSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPREDEFINEDPOINTMARKERSYMBOL" => {
                let entity = IfcPreDefinedPointMarkerSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPREDEFINEDTERMINATORSYMBOL" => {
                let entity = IfcPreDefinedTerminatorSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPRESENTATIONLAYERASSIGNMENT" => {
                let entity = IfcPresentationLayerAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPRESENTATIONLAYERWITHSTYLE" => {
                let entity = IfcPresentationLayerWithStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPRESENTATIONSTYLEASSIGNMENT" => {
                let entity = IfcPresentationStyleAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROCEDURE" => {
                let entity = IfcProcedure::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPRODUCTDEFINITIONSHAPE" => {
                let entity = IfcProductDefinitionShape::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPRODUCTREPRESENTATION" => {
                let entity = IfcProductRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPRODUCTSOFCOMBUSTIONPROPERTIES" => {
                let entity = IfcProductsOfCombustionProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROJECT" => {
                let entity = IfcProject::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROJECTORDER" => {
                let entity = IfcProjectOrder::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROJECTORDERRECORD" => {
                let entity = IfcProjectOrderRecord::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROJECTIONCURVE" => {
                let entity = IfcProjectionCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROJECTIONELEMENT" => {
                let entity = IfcProjectionElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYBOUNDEDVALUE" => {
                let entity = IfcPropertyBoundedValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYCONSTRAINTRELATIONSHIP" => {
                let entity = IfcPropertyConstraintRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYDEPENDENCYRELATIONSHIP" => {
                let entity = IfcPropertyDependencyRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYENUMERATEDVALUE" => {
                let entity = IfcPropertyEnumeratedValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYENUMERATION" => {
                let entity = IfcPropertyEnumeration::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYLISTVALUE" => {
                let entity = IfcPropertyListValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYREFERENCEVALUE" => {
                let entity = IfcPropertyReferenceValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYSET" => {
                let entity = IfcPropertySet::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYSINGLEVALUE" => {
                let entity = IfcPropertySingleValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROPERTYTABLEVALUE" => {
                let entity = IfcPropertyTableValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROTECTIVEDEVICETYPE" => {
                let entity = IfcProtectiveDeviceType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPROXY" => {
                let entity = IfcProxy::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCPUMPTYPE" => {
                let entity = IfcPumpType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCQUANTITYAREA" => {
                let entity = IfcQuantityArea::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCQUANTITYCOUNT" => {
                let entity = IfcQuantityCount::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCQUANTITYLENGTH" => {
                let entity = IfcQuantityLength::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCQUANTITYTIME" => {
                let entity = IfcQuantityTime::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCQUANTITYVOLUME" => {
                let entity = IfcQuantityVolume::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCQUANTITYWEIGHT" => {
                let entity = IfcQuantityWeight::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRADIUSDIMENSION" => {
                let entity = IfcRadiusDimension::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRAILING" => {
                let entity = IfcRailing::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRAILINGTYPE" => {
                let entity = IfcRailingType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRAMP" => {
                let entity = IfcRamp::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRAMPFLIGHT" => {
                let entity = IfcRampFlight::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRAMPFLIGHTTYPE" => {
                let entity = IfcRampFlightType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRATIONALBEZIERCURVE" => {
                let entity = IfcRationalBezierCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRECTANGLEHOLLOWPROFILEDEF" => {
                let entity = IfcRectangleHollowProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRECTANGLEPROFILEDEF" => {
                let entity = IfcRectangleProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRECTANGULARPYRAMID" => {
                let entity = IfcRectangularPyramid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRECTANGULARTRIMMEDSURFACE" => {
                let entity = IfcRectangularTrimmedSurface::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREFERENCESVALUEDOCUMENT" => {
                let entity = IfcReferencesValueDocument::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREGULARTIMESERIES" => {
                let entity = IfcRegularTimeSeries::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREINFORCEMENTBARPROPERTIES" => {
                let entity = IfcReinforcementBarProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREINFORCEMENTDEFINITIONPROPERTIES" => {
                let entity = IfcReinforcementDefinitionProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREINFORCINGBAR" => {
                let entity = IfcReinforcingBar::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREINFORCINGMESH" => {
                let entity = IfcReinforcingMesh::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELAGGREGATES" => {
                let entity = IfcRelAggregates::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTASKS" => {
                let entity = IfcRelAssignsTasks::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTOACTOR" => {
                let entity = IfcRelAssignsToActor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTOCONTROL" => {
                let entity = IfcRelAssignsToControl::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTOGROUP" => {
                let entity = IfcRelAssignsToGroup::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTOPROCESS" => {
                let entity = IfcRelAssignsToProcess::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTOPRODUCT" => {
                let entity = IfcRelAssignsToProduct::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTOPROJECTORDER" => {
                let entity = IfcRelAssignsToProjectOrder::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSIGNSTORESOURCE" => {
                let entity = IfcRelAssignsToResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATES" => {
                let entity = IfcRelAssociates::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESAPPLIEDVALUE" => {
                let entity = IfcRelAssociatesAppliedValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESAPPROVAL" => {
                let entity = IfcRelAssociatesApproval::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESCLASSIFICATION" => {
                let entity = IfcRelAssociatesClassification::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESCONSTRAINT" => {
                let entity = IfcRelAssociatesConstraint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESDOCUMENT" => {
                let entity = IfcRelAssociatesDocument::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESLIBRARY" => {
                let entity = IfcRelAssociatesLibrary::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESMATERIAL" => {
                let entity = IfcRelAssociatesMaterial::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELASSOCIATESPROFILEPROPERTIES" => {
                let entity = IfcRelAssociatesProfileProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSELEMENTS" => {
                let entity = IfcRelConnectsElements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSPATHELEMENTS" => {
                let entity = IfcRelConnectsPathElements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSPORTTOELEMENT" => {
                let entity = IfcRelConnectsPortToElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSPORTS" => {
                let entity = IfcRelConnectsPorts::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSSTRUCTURALACTIVITY" => {
                let entity = IfcRelConnectsStructuralActivity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSSTRUCTURALELEMENT" => {
                let entity = IfcRelConnectsStructuralElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSSTRUCTURALMEMBER" => {
                let entity = IfcRelConnectsStructuralMember::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSWITHECCENTRICITY" => {
                let entity = IfcRelConnectsWithEccentricity::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONNECTSWITHREALIZINGELEMENTS" => {
                let entity = IfcRelConnectsWithRealizingElements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCONTAINEDINSPATIALSTRUCTURE" => {
                let entity = IfcRelContainedInSpatialStructure::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCOVERSBLDGELEMENTS" => {
                let entity = IfcRelCoversBldgElements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELCOVERSSPACES" => {
                let entity = IfcRelCoversSpaces::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELDEFINESBYPROPERTIES" => {
                let entity = IfcRelDefinesByProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELDEFINESBYTYPE" => {
                let entity = IfcRelDefinesByType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELFILLSELEMENT" => {
                let entity = IfcRelFillsElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELFLOWCONTROLELEMENTS" => {
                let entity = IfcRelFlowControlElements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELINTERACTIONREQUIREMENTS" => {
                let entity = IfcRelInteractionRequirements::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELNESTS" => {
                let entity = IfcRelNests::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELOCCUPIESSPACES" => {
                let entity = IfcRelOccupiesSpaces::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELOVERRIDESPROPERTIES" => {
                let entity = IfcRelOverridesProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELPROJECTSELEMENT" => {
                let entity = IfcRelProjectsElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELREFERENCEDINSPATIALSTRUCTURE" => {
                let entity = IfcRelReferencedInSpatialStructure::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELSCHEDULESCOSTITEMS" => {
                let entity = IfcRelSchedulesCostItems::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELSEQUENCE" => {
                let entity = IfcRelSequence::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELSERVICESBUILDINGS" => {
                let entity = IfcRelServicesBuildings::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELSPACEBOUNDARY" => {
                let entity = IfcRelSpaceBoundary::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELVOIDSELEMENT" => {
                let entity = IfcRelVoidsElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRELAXATION" => {
                let entity = IfcRelaxation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREPRESENTATION" => {
                let entity = IfcRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREPRESENTATIONCONTEXT" => {
                let entity = IfcRepresentationContext::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREPRESENTATIONMAP" => {
                let entity = IfcRepresentationMap::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCREVOLVEDAREASOLID" => {
                let entity = IfcRevolvedAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRIBPLATEPROFILEPROPERTIES" => {
                let entity = IfcRibPlateProfileProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRIGHTCIRCULARCONE" => {
                let entity = IfcRightCircularCone::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCRIGHTCIRCULARCYLINDER" => {
                let entity = IfcRightCircularCylinder::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCROOF" => {
                let entity = IfcRoof::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCROUNDEDEDGEFEATURE" => {
                let entity = IfcRoundedEdgeFeature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCROUNDEDRECTANGLEPROFILEDEF" => {
                let entity = IfcRoundedRectangleProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSIUNIT" => {
                let entity = IfcSiUnit::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSANITARYTERMINALTYPE" => {
                let entity = IfcSanitaryTerminalType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSCHEDULETIMECONTROL" => {
                let entity = IfcScheduleTimeControl::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSECTIONPROPERTIES" => {
                let entity = IfcSectionProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSECTIONREINFORCEMENTPROPERTIES" => {
                let entity = IfcSectionReinforcementProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSECTIONEDSPINE" => {
                let entity = IfcSectionedSpine::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSENSORTYPE" => {
                let entity = IfcSensorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSERVICELIFE" => {
                let entity = IfcServiceLife::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSERVICELIFEFACTOR" => {
                let entity = IfcServiceLifeFactor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSHAPEASPECT" => {
                let entity = IfcShapeAspect::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSHAPEREPRESENTATION" => {
                let entity = IfcShapeRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSHELLBASEDSURFACEMODEL" => {
                let entity = IfcShellBasedSurfaceModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSITE" => {
                let entity = IfcSite::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSLAB" => {
                let entity = IfcSlab::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSLABTYPE" => {
                let entity = IfcSlabType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSLIPPAGECONNECTIONCONDITION" => {
                let entity = IfcSlippageConnectionCondition::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSOUNDPROPERTIES" => {
                let entity = IfcSoundProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSOUNDVALUE" => {
                let entity = IfcSoundValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSPACE" => {
                let entity = IfcSpace::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSPACEHEATERTYPE" => {
                let entity = IfcSpaceHeaterType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSPACEPROGRAM" => {
                let entity = IfcSpaceProgram::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSPACETHERMALLOADPROPERTIES" => {
                let entity = IfcSpaceThermalLoadProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSPACETYPE" => {
                let entity = IfcSpaceType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSPHERE" => {
                let entity = IfcSphere::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTACKTERMINALTYPE" => {
                let entity = IfcStackTerminalType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTAIR" => {
                let entity = IfcStair::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTAIRFLIGHT" => {
                let entity = IfcStairFlight::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTAIRFLIGHTTYPE" => {
                let entity = IfcStairFlightType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALANALYSISMODEL" => {
                let entity = IfcStructuralAnalysisModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALCURVECONNECTION" => {
                let entity = IfcStructuralCurveConnection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALCURVEMEMBER" => {
                let entity = IfcStructuralCurveMember::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALCURVEMEMBERVARYING" => {
                let entity = IfcStructuralCurveMemberVarying::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLINEARACTION" => {
                let entity = IfcStructuralLinearAction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLINEARACTIONVARYING" => {
                let entity = IfcStructuralLinearActionVarying::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADGROUP" => {
                let entity = IfcStructuralLoadGroup::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADLINEARFORCE" => {
                let entity = IfcStructuralLoadLinearForce::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADPLANARFORCE" => {
                let entity = IfcStructuralLoadPlanarForce::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADSINGLEDISPLACEMENT" => {
                let entity = IfcStructuralLoadSingleDisplacement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION" => {
                let entity = IfcStructuralLoadSingleDisplacementDistortion::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADSINGLEFORCE" => {
                let entity = IfcStructuralLoadSingleForce::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADSINGLEFORCEWARPING" => {
                let entity = IfcStructuralLoadSingleForceWarping::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALLOADTEMPERATURE" => {
                let entity = IfcStructuralLoadTemperature::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALPLANARACTION" => {
                let entity = IfcStructuralPlanarAction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALPLANARACTIONVARYING" => {
                let entity = IfcStructuralPlanarActionVarying::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALPOINTACTION" => {
                let entity = IfcStructuralPointAction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALPOINTCONNECTION" => {
                let entity = IfcStructuralPointConnection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALPOINTREACTION" => {
                let entity = IfcStructuralPointReaction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALPROFILEPROPERTIES" => {
                let entity = IfcStructuralProfileProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALRESULTGROUP" => {
                let entity = IfcStructuralResultGroup::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALSTEELPROFILEPROPERTIES" => {
                let entity = IfcStructuralSteelProfileProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALSURFACECONNECTION" => {
                let entity = IfcStructuralSurfaceConnection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALSURFACEMEMBER" => {
                let entity = IfcStructuralSurfaceMember::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTURALSURFACEMEMBERVARYING" => {
                let entity = IfcStructuralSurfaceMemberVarying::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTRUCTUREDDIMENSIONCALLOUT" => {
                let entity = IfcStructuredDimensionCallout::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTYLEDITEM" => {
                let entity = IfcStyledItem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSTYLEDREPRESENTATION" => {
                let entity = IfcStyledRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSUBCONTRACTRESOURCE" => {
                let entity = IfcSubContractResource::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSUBEDGE" => {
                let entity = IfcSubedge::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACECURVESWEPTAREASOLID" => {
                let entity = IfcSurfaceCurveSweptAreaSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACEOFLINEAREXTRUSION" => {
                let entity = IfcSurfaceOfLinearExtrusion::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACEOFREVOLUTION" => {
                let entity = IfcSurfaceOfRevolution::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACESTYLE" => {
                let entity = IfcSurfaceStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACESTYLELIGHTING" => {
                let entity = IfcSurfaceStyleLighting::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACESTYLEREFRACTION" => {
                let entity = IfcSurfaceStyleRefraction::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACESTYLERENDERING" => {
                let entity = IfcSurfaceStyleRendering::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACESTYLESHADING" => {
                let entity = IfcSurfaceStyleShading::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSURFACESTYLEWITHTEXTURES" => {
                let entity = IfcSurfaceStyleWithTextures::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSWEPTDISKSOLID" => {
                let entity = IfcSweptDiskSolid::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSWITCHINGDEVICETYPE" => {
                let entity = IfcSwitchingDeviceType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSYMBOLSTYLE" => {
                let entity = IfcSymbolStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSYSTEM" => {
                let entity = IfcSystem::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCSYSTEMFURNITUREELEMENTTYPE" => {
                let entity = IfcSystemFurnitureElementType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTSHAPEPROFILEDEF" => {
                let entity = IfcTShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTABLE" => {
                let entity = IfcTable::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTABLEROW" => {
                let entity = IfcTableRow::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTANKTYPE" => {
                let entity = IfcTankType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTASK" => {
                let entity = IfcTask::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTELECOMADDRESS" => {
                let entity = IfcTelecomAddress::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTENDON" => {
                let entity = IfcTendon::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTENDONANCHOR" => {
                let entity = IfcTendonAnchor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTERMINATORSYMBOL" => {
                let entity = IfcTerminatorSymbol::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTLITERAL" => {
                let entity = IfcTextLiteral::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTLITERALWITHEXTENT" => {
                let entity = IfcTextLiteralWithExtent::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTSTYLE" => {
                let entity = IfcTextStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTSTYLEFONTMODEL" => {
                let entity = IfcTextStyleFontModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTSTYLEFORDEFINEDFONT" => {
                let entity = IfcTextStyleForDefinedFont::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTSTYLETEXTMODEL" => {
                let entity = IfcTextStyleTextModel::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTSTYLEWITHBOXCHARACTERISTICS" => {
                let entity = IfcTextStyleWithBoxCharacteristics::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTURECOORDINATEGENERATOR" => {
                let entity = IfcTextureCoordinateGenerator::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTUREMAP" => {
                let entity = IfcTextureMap::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTEXTUREVERTEX" => {
                let entity = IfcTextureVertex::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTHERMALMATERIALPROPERTIES" => {
                let entity = IfcThermalMaterialProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTIMESERIESREFERENCERELATIONSHIP" => {
                let entity = IfcTimeSeriesReferenceRelationship::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTIMESERIESSCHEDULE" => {
                let entity = IfcTimeSeriesSchedule::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTIMESERIESVALUE" => {
                let entity = IfcTimeSeriesValue::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTOPOLOGYREPRESENTATION" => {
                let entity = IfcTopologyRepresentation::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTRANSFORMERTYPE" => {
                let entity = IfcTransformerType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTRANSPORTELEMENT" => {
                let entity = IfcTransportElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTRANSPORTELEMENTTYPE" => {
                let entity = IfcTransportElementType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTRAPEZIUMPROFILEDEF" => {
                let entity = IfcTrapeziumProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTRIMMEDCURVE" => {
                let entity = IfcTrimmedCurve::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTUBEBUNDLETYPE" => {
                let entity = IfcTubeBundleType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTWODIRECTIONREPEATFACTOR" => {
                let entity = IfcTwoDirectionRepeatFactor::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTYPEOBJECT" => {
                let entity = IfcTypeObject::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCTYPEPRODUCT" => {
                let entity = IfcTypeProduct::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCUSHAPEPROFILEDEF" => {
                let entity = IfcUShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCUNITASSIGNMENT" => {
                let entity = IfcUnitAssignment::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCUNITARYEQUIPMENTTYPE" => {
                let entity = IfcUnitaryEquipmentType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVALVETYPE" => {
                let entity = IfcValveType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVECTOR" => {
                let entity = IfcVector::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVERTEX" => {
                let entity = IfcVertex::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVERTEXBASEDTEXTUREMAP" => {
                let entity = IfcVertexBasedTextureMap::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVERTEXLOOP" => {
                let entity = IfcVertexLoop::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVERTEXPOINT" => {
                let entity = IfcVertexPoint::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVIBRATIONISOLATORTYPE" => {
                let entity = IfcVibrationIsolatorType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVIRTUALELEMENT" => {
                let entity = IfcVirtualElement::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCVIRTUALGRIDINTERSECTION" => {
                let entity = IfcVirtualGridIntersection::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWALL" => {
                let entity = IfcWall::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWALLSTANDARDCASE" => {
                let entity = IfcWallStandardCase::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWALLTYPE" => {
                let entity = IfcWallType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWASTETERMINALTYPE" => {
                let entity = IfcWasteTerminalType::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWATERPROPERTIES" => {
                let entity = IfcWaterProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWINDOW" => {
                let entity = IfcWindow::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWINDOWLININGPROPERTIES" => {
                let entity = IfcWindowLiningProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWINDOWPANELPROPERTIES" => {
                let entity = IfcWindowPanelProperties::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWINDOWSTYLE" => {
                let entity = IfcWindowStyle::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWORKPLAN" => {
                let entity = IfcWorkPlan::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCWORKSCHEDULE" => {
                let entity = IfcWorkSchedule::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCZSHAPEPROFILEDEF" => {
                let entity = IfcZShapeProfileDef::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            "IFCZONE" => {
                let entity = IfcZone::form_parameters(typed_parameter.parameters);
                self.add_entity(id, entity);
            }
            _ => println!("{} is not implemented", typed_parameter.type_name),
        }
    }
}
